{"version":3,"file":"ngn.min.js","sources":["../../../src/exception.js","../../../src/core.js","../../../src/emitter/core.js","../../../src/emitter/BrowserEmitter.js","../../../src/utility/Lexer.js","../../../src/utility/Tokenizer.js","../../../src/utility/Set.js","../../../src/net/utility.js","../../../src/net/Request.js","../../../src/net/Network.js","../../../src/net/core.js","../../../src/net/Resource.js","../../../src/data/DiffEngine.js","../../../src/data/Utility.js","../../../src/data/index/BTree.js","../../../src/data/rule/Rule.js","../../../src/data/field/Field.js","../../../src/data/Store.js","../../../src/data/core.js","../../../src/data/TransactionLog.js","../../../src/data/rule/RangeRule.js","../../../src/data/field/VirtualField.js","../../../src/data/field/Relationship.js","../../../src/data/field/FieldMap.js","../../../src/data/Model.js","../../../src/data/index/Index.js","../../../src/data/schema/JSON.js","../../../src/main.js","../../../src/queue/task.js","../../../src/queue/queue.js"],"sourcesContent":["export default class CustomException extends Error { // eslint-disable-line\n  constructor (config) {\n    super()\n\n    Object.defineProperty(this, 'frameFilter', NGN.privateconst((frame) => {\n      return NGN.nodelike\n        ? frame.getFileName() !== __filename && frame.getFileName()\n        : frame.getFileName()\n    }))\n\n    config = config || {}\n    config = typeof config === 'string' ? { message: config } : config\n    config.custom = config.custom || {}\n\n    let me = this\n\n    this.name = config.name || 'NgnError'\n    this.type = config.type || 'TypeError'\n    this.severity = config.severity || 'minor'\n    this.message = config.message || 'Unknown Error'\n    this.category = config.category || 'operational' // Alternative is \"programmer\"\n\n    // Cleanup name\n    this.name = this.name.replace(/[^a-zA-Z0-9_]/gi, '')\n\n    // Add any custom properties\n    for (let attr in config.custom) {\n      if (config.custom.hasOwnProperty(attr)) {\n        this[attr] = config.custom[attr]\n      }\n    }\n\n    this.hasOwnProperty('custom') && delete this.custom\n\n    if (NGN.nodelike || Error.prepareStackTrace) {\n      // Capture the stack trace on a new error so the detail can be saved as a structured trace.\n      Error.prepareStackTrace = function (_, stack) { return stack }\n\n      let _err = new Error()\n\n      Error.captureStackTrace(_err, this)\n\n      this.rawstack = _err.stack\n\n      Error.prepareStackTrace = function (err, stack) { // eslint-disable-line handle-callback-err\n        me.cause && console.warn(me.cause)\n        me.help && console.info(me.help)\n\n        return `${me.name}: ${me.message}\\n` + stack.filter(me.frameFilter).map((el) => {\n          return `    at ${el}`\n        }).join('\\n')\n      }\n\n      // Enable stack trace\n      Error.captureStackTrace(this)\n    }\n  }\n\n  /*\n   * @property {Array} trace\n   * The structured data of the stacktrace. Each array element is a JSON object corresponding to\n   * the full stack trace:\n   *\n   * ```js\n   * {\n   *   filename: String,\n   *   line: Number,\n   *   column: Number,\n   *   functionname: String,\n   *   native: Boolean,\n   *   eval: Boolean,\n   *   type: String\n   * }\n   * ```\n   * @readonly\n   */\n  get trace () {\n    return this.rawstack.filter(this.frameFilter).map((frame) => {\n      return {\n        filename: frame.getFileName(),\n        line: frame.getLineNumber(),\n        column: frame.getColumnNumber(),\n        functionname: frame.getFunctionName(),\n        native: frame.isNative(),\n        eval: frame.isEval(),\n        type: frame.getTypeName()\n      }\n    })\n  }\n}\n","import CustomException from './exception'\n\n/**\n * @namespace NGN\n */\nlet NGN = Object.defineProperties({\n  // Establish a globally recognized namespace for browser or node-like environment.\n  get global () {\n    try { return window } catch (e) { return global }\n  }\n}, {\n  /**\n  * @method define\n  * Create an object definition for a property.\n  * For example:\n  *\n  * ```\n  * Object.defineProperty('attr', NGN.define(true, false, true, 'value'))\n  *\n  * // The snippet above is the same as:\n  * Object.defineProperty(this, 'attr', {\n  *  enumberable: true,\n  *  writable: false,\n  *  configurable: true,\n  *  value: 'value'\n  * })\n  * ```\n  * @param  {boolean} enumerable\n  * Determines if the attribute is considered an accessible part of the object.\n  * Making an attribute enumerable will make it show up as a key in an object,\n  * which can be iterated over (ex: `Object.keys()`). A non-enumerable asset is\n  * treated as a private attribute.\n  * @param  {boolean} writable\n  * Determines whether the value can be changed.\n  * @param  {boolean} configurable\n  * Determines whether the attribute can be removed from the object.\n  * @param  {any} value\n  * The actual value of the attribute.\n  * @private\n  */\n  define: {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: function (enumerable, writable, configurable, value) {\n      return {\n        enumerable,\n        writable,\n        configurable,\n        value\n      }\n    }\n  }\n})\n\nObject.defineProperties(NGN, {\n  /**\n   * @method public\n   * Create a `public` property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.public('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: true,\n   *  writable: true,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  public: NGN.define(false, false, false, function (value) {\n    return NGN.define(true, typeof value !== 'function', false, value)\n  }),\n\n  /**\n   * @method private\n   * Create a `private` property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.private('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  writable: true,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  private: NGN.define(false, false, false, function (value) {\n    return NGN.define(false, typeof value !== 'function', false, value)\n  }),\n\n  /**\n   * @method const\n   * Create a `public` constant property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.const('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: true,\n   *  writable: false,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  const: NGN.define(false, false, false, function (value) {\n    return NGN.define(true, false, false, value)\n  }),\n\n  /**\n   * @method privateconst\n   * Create a `private` constant property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.privateconst('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  writable: false,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  privateconst: NGN.define(false, false, false, function (value) {\n    return NGN.define(false, false, false, value)\n  }),\n\n  /**\n   * @method get\n   * Create a private `getter` property definition for an object.\n   * Public getters are part of the ES2015 class spec.\n   *\n   * Example:\n   *\n   * ```\n   * let myFunction = function () {\n   *  return 'somevalue'\n   * }\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  get: function () {\n   *    return 'somevalue'\n   *  }\n   * })\n   * ```\n   * @param  {function} fn\n   * Any valid async JavaScript function with a `return` value.\n   * @private\n   */\n  get: NGN.define(false, false, false, function (fn) {\n    return {\n      enumerable: false,\n      get: fn\n    }\n  }),\n\n  /**\n   * @method set\n   * Create a private `setter` property definition for an object.\n   * Public setters are part of the ES2015 class spec.\n   *\n   * Example:\n   *\n   * ```\n   * let myFunction = function () {\n   *  return 'somevalue'\n   * }\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  set: function (value) {\n   *    somethingElse = value\n   *  }\n   * })\n   * ```\n   * @param  {function} fn\n   * Any valid JavaScript function that accepts a single argument (value).\n   * @private\n   */\n  set: NGN.define(false, false, false, function (fn) {\n    return {\n      enumerable: false,\n      set: fn\n    }\n  }),\n\n  /**\n   * @method getset\n   * Create a private property defintion containing both a `getter` and `setter`\n   * for the specified attribute.\n   * @param  {function} getFn\n   * Any valid async JavaScript function with a `return` value.\n   * @param  {function} setFn\n   * Any valid JavaScript function that accepts a single argument (value).\n   * @private\n   */\n  getset: NGN.define(false, false, false, (getterFn, setterFn) => {\n    return {\n      enumerable: false,\n      get: getterFn,\n      set: setterFn\n    }\n  }),\n\n  LEDGER_EVENT: NGN.define(false, false, false, (EVENT) => {\n    return function () {\n      NGN.BUS.emit(EVENT, ...arguments)\n    }\n  })\n})\n\nObject.defineProperties(NGN, {\n  /**\n   * @method extend\n   * Extend the NGN core object. Extending NGN is the equivalent of:\n   *\n   * Example:\n   * ```\n   * NGN.extend('greet', NGN.public(function (recipient) {\n   *  return 'Hello, ' + recipient + '!'\n   * }))\n   *\n   * // Equivalent of:\n   *\n   * Object.defineProperty(NGN, 'greet', {\n   *  enumerable: true,\n   *  writable: false,\n   *  configurable: false,\n   *  value: function (recipient) {\n   *    return 'Hello, ' + recipient + '!'\n   *  }\n   * })\n   * ```\n   * The example above produces a public function available from NGN:\n   *\n   * ```\n   * console.log(NGN.greet('world')) // outputs Hello, world!\n   * @param  {string} attribute\n   * Name of the attribute to add to the object.\n   * @param  {Object} descriptor\n   * The object descriptor, i.e.\n   * ```\n   * {\n   *  enumerable: true/false,\n   *  writable: true/false,\n   *  configurable: true/false,\n   *  value: {any}\n   * }\n   *\n   * // OR\n   *\n   * {\n   *  enumerable: true/false,\n   *  get: function () { return ... },\n   *  set: function (value) { some = value ... }\n   * }\n   * ```\n   * @private\n   */\n  extend: NGN.privateconst(function (attribute, descriptor) {\n    // If no descriptor is provided, multiple properties are being defined.\n    if (typeof attribute === 'object') {\n      Object.defineProperties(this, attribute)\n    } else {\n      Object.defineProperty(this, attribute, descriptor)\n    }\n  }),\n\n  /**\n   * @method inherit\n   * Inherit the properties of another object/class.\n   * @param  {object|function} source\n   * The source object (i.e. what gets copied)\n   * @param  {object|function} destination\n   * The object properties get copied to.\n   */\n  inherit: NGN.const(function (source = null, dest = null) {\n    if (source && dest) {\n      source = typeof source === 'function' ? source.prototype : source\n      dest = typeof dest === 'function' ? dest.prototype : dest\n\n      Object.getOwnPropertyNames(source).forEach(function (attr) {\n        const definition = Object.getOwnPropertyDescriptor(source, attr)\n        Object.defineProperty(dest, attr, definition)\n      })\n\n      const prototype = Object.getOwnPropertyNames(Object.getPrototypeOf(source)).filter((attr) => {\n        return attr.trim().toLowerCase() !== 'constructor' && !dest.hasOwnProperty(attr)\n      })\n\n      prototype.forEach((attr) => {\n        const cfg = Object.getOwnPropertyDescriptor(source, attr)\n\n        if (cfg === undefined && typeof source[attr] === 'function') {\n          Object.defineProperty(dest, attr, NGN.public(function () {\n            return source[attr].apply(this, arguments)\n          }))\n        }\n      })\n    }\n  }),\n\n  /**\n   * @method slice\n   * Converts an array-like object to an array.\n   *\n   * Example:\n   * ```\n   * function () {\n   *  return NGN.slice(arguments)\n   * }\n   * ```\n   * @param  {Object} obj\n   * The object to slice into an array.\n   * @return {array}\n   * @private\n   */\n  slice: NGN.private(function (obj) {\n    return Array.prototype.slice.call(obj)\n  }),\n\n  /**\n   * @method splice\n   * Converts an array-like object to a spliced array.\n   *\n   * Example:\n   * ```\n   * function () {\n   *  return NGN.splice(arguments)\n   * }\n   * ```\n   * @param  {Object} obj\n   * The object to splice into an array.\n   * @return {array}\n   * @private\n   */\n  splice: NGN.private(function (obj) {\n    return Array.prototype.splice.call(obj)\n  }),\n\n  /**\n   * @method nullIf\n   * Returns a null value if the two specified expressions are equal.\n   * ```js\n   * if (NGN.nullIf(myvar, 'value') === null) {\n   *   console.log('Variable had a value of \"value\", which is considered null')\n   * }\n   *\n   * // or\n   *\n   * if (NGN.nullIf(myvar) === null) {\n   *   console.log('Empty variable whose trimmed length is 0')\n   * }\n   * ```\n   * @param {any} sourceExpression\n   * The variable or value to check.\n   * @param {any} [comparisonExpression = '']\n   * The variable or value to compare the source expression against.\n   * @return {any}\n   * If the source expression matches the comparison expression, `null` will\n   * be returned. If they do not match, the source expression will be returned.\n   */\n  nullIf: NGN.public(function (sourceExpression, comparisonExpression = '') {\n    try {\n      // If the values aren't equal, make sure it's not due to blank values\n      // or hidden characters.\n      if (sourceExpression !== comparisonExpression) {\n        // Different data types indicate different values.\n        if (typeof sourceExpression !== typeof comparisonExpression) {\n          return sourceExpression\n        }\n\n        if (typeof sourceExpression === 'string') {\n          if (sourceExpression.trim() !== comparisonExpression.trim()) {\n            return sourceExpression\n          }\n        }\n      }\n\n      return null\n    } catch (e) {\n      return null\n    }\n  }),\n\n  // Private alias for nullIf\n  nullif: NGN.public(function () {\n    return this.nullIf(...arguments)\n  }),\n\n  /**\n   * @method converge\n   * Provides a basic coalesce. Expects the first parameter to be a boolean\n   * value. `true` will wrap arguments in a nullIf operator. `false` will not.\n   * @private\n   */\n  converge: NGN.private(function () {\n    if (arguments.length < 2) {\n      return null\n    } else if (arguments.length === 2) {\n      if (arguments[1] === undefined) {\n        return null\n      } else if (arguments[0]) {\n        return NGN.nullIf(arguments[1])\n      } else {\n        return arguments[1]\n      }\n    }\n\n    for (let arg = 1; arg < arguments.length; arg++) {\n      // try {\n      if (arguments[arg] !== undefined &&\n        (\n          arguments[0] ? NGN.nullIf(arguments[arg]) : arguments[arg]\n        ) !== null\n      ) {\n        if (arguments[arg] !== undefined) {\n          return arguments[arg]\n        }\n      }\n      // } catch (e) {}\n    }\n\n    return null\n  }),\n\n  /**\n   * @method coalesce\n   * Finds the first non-null/defined value in a list of arguments.\n   * This can be used with {@link Boolean Boolean} values, since `true`/`false` is a\n   * non-null/defined value.\n   * @param {Mixed} args\n   * Any number of arguments can be passed to this method.\n   * @return {Any}\n   * Returns the first non-null/defined value. If non exist, `null` is retutned.\n   */\n  coalesce: NGN.public(function () {\n    return NGN.converge(false, ...arguments)\n  }),\n\n  /**\n   * @method coalesceb\n   * Provides the same functionality as #coalesce, except **b**lank/empty arguments\n   * are treated as `null` values.\n   * @param {Mixed} args\n   * Any number of arguments can be passed to this method.\n   */\n  coalesceb: NGN.public(function () {\n    return NGN.converge(true, ...arguments)\n  }),\n\n  /**\n   * @property {boolean} nodelike\n   * Indicates NGN is running in a node-like environment supporting\n   * the `require` statement. This will detect node, io.js, Electron,\n   * NW.js, and other environments presumably supporting Node.js.\n   * @private\n   */\n  nodelike: NGN.const(NGN.global.process !== undefined),\n\n  /**\n   * @method dedupe\n   * Deduplicate a simple array.\n   * @param {array} array\n   * The array to deduplicate.\n   * @return {array}\n   * The array with unique records.\n   * @private\n   */\n  dedupe: NGN.const((array) => {\n    let matches = []\n\n    // This is more performant than array.filter in most cases.\n    for (let i = 0; i < array.length; i++) {\n      if (array.indexOf(array[i]) === i) {\n        matches.push(array[i])\n      }\n    }\n\n    array = null\n\n    return matches\n  }),\n\n  /**\n   * @method typeof\n   * A more specific typeof method.\n   * @param  {any} element\n   * The element to determine the type of.\n   * @return {string}\n   * Returns the type (all lower case).\n   */\n  typeof: NGN.const((el) => {\n    if (el === undefined) {\n      return 'undefined'\n    } else if (el === null) {\n      return 'null'\n    }\n\n    let value = Object.prototype.toString.call(el).split(' ')[1].replace(/[^A-Za-z]/gi, '').toLowerCase()\n\n    if (value === 'function') {\n      if (!el.name) {\n        return NGN.coalesceb(el.toString().replace(/\\n/gi, '').replace(/^function\\s|\\(.*$/mgi, '').toLowerCase(), 'function')\n      } else {\n        value = NGN.coalesceb(el.name, 'function')\n      }\n    }\n\n    return value.toLowerCase()\n  }),\n\n  /**\n   * @method forceArray\n   * Forces a value to become an array if it is not already one. For example:\n   *\n   * ```js\n   * let x = 'value'\n   *\n   * x = NGN.forceArray(x)\n   *\n   * console.log(x) // Outputs ['value']\n   * ```\n   * @param {any} expression\n   * The value being forced to be an array.\n   * @private\n   */\n  forceArray: NGN.const((value) => {\n    if (value === null) {\n      return []\n    }\n\n    return NGN.typeof(value) === 'array' ? value : [value]\n  }),\n\n  /**\n   * @method forceBoolean\n   * Forces a value to become a boolean if it is not already one. For example:\n   *\n   * ```js\n   * let x = NGN.forceBoolean('false') // String ==> Boolean\n   * console.log(x) // Outputs false\n   *\n   * let y = NGN.forceBoolean('text') // String ==> Boolean\n   * console.log(y) // Outputs true (any non-blank text results in true, except the word \"false\")\n   *\n   * let z = NGN.forceBoolean(0) // Number ==> Boolean (0 = false, 1 = true)\n   * console.log(z) // Outputs false\n   * ```\n   *\n   * All other types will yield a `true` value, except for `null`. A `null`\n   * value is treated as `false`.\n   * @param {any} expression\n   * The value being forced to be a boolean.\n   * @private\n   */\n  forceBoolean: NGN.const((value) => {\n    switch (NGN.typeof(value)) {\n      case 'boolean':\n        return value\n\n      case 'number':\n        return value === 0 ? false : true // eslint-disable-line no-unneeded-ternary\n\n      case 'string':\n        value = value.trim().toLowerCase()\n\n        if (value === 'false') {\n          return false\n        }\n\n        return true\n\n      default:\n        return NGN.coalesceb(value) !== null\n    }\n  }),\n\n  /**\n   * @method forceNumber\n   * Forces a value to become a number if it is not already one. For example:\n   *\n   * ```js\n   * let x = NGN.forceNumber('10') // String ==> Number\n   * console.log(x === 10) // Outputs true\n   *\n   * let y = NGN.forceNumber(true) // Boolean ==> Number\n   * console.log(y) // Output 1\n   *\n   * let z = NGN.forceNumber(false) // Boolean ==> Number\n   * console.log(y) // Output 0\n   * ```\n   *\n   * All other types will yield a `NaN` value. This has no effect on\n   * @param {any} expression\n   * The value being forced to be a number. If the expression is a date,\n   * the result will be the number of milliseconds passed since the epoch.\n   * See [Date.getTime()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime)\n   * for details.\n   * @param {number} [radix]\n   * An integer between 2 and 36 that represents the radix (the base in\n   * mathematical numeral systems) of the expression.\n   * Specify 10 for the decimal numeral system commonly used by humans.\n   * Always specify this parameter to eliminate reader confusion and to\n   * guarantee predictable behavior. Different implementations produce\n   * different results when a radix is not specified, usually defaulting the\n   * value to 10.\n   *\n   * **If no radix is supplied**, the `parseFloat` will be used to identify\n   * the numeric value. When a radix is supplied, `parseInt` is used.\n   * @private\n   */\n  forceNumber: NGN.const((value, radix = null) => {\n    try {\n      switch (NGN.typeof(value)) {\n        case 'boolean':\n          return value ? 1 : 0\n\n        case 'number':\n          return value\n\n        case 'date':\n          return value.getTime()\n\n        case 'string':\n          return radix !== null ? parseInt(value, radix) : parseFloat(value)\n\n        default:\n          return NaN\n      }\n    } catch (e) {\n      NGN.ERROR(e)\n      return NaN\n    }\n  }),\n\n  /**\n   * @method stack\n   * Retrieve the stack trace from a specific code location without throwing\n   * an exception. Files are always listed from the root. This is the default\n   * order in browsers, but the reverse of the normal stack order in node-like\n   * environments.\n   *\n   * For example, the following stack on node shows `_test.js` as the last item\n   * in the array. In node-like environments, the `_test.js` would normally be\n   * the first item in the stacktrace.\n   *\n   * ```js\n   * [\n   *   { path: 'node.js:348:7', file: 'node.js', line: 348, column: 7 },\n   *   { path: 'module.js:575:10',\n   *     file: 'module.js',\n   *     line: 575,\n   *     column: 10 },\n   *   { path: 'module.js:550:10',\n   *     file: 'module.js',\n   *     line: 550,\n   *     column: 10 },\n   *   { path: 'module.js:541:32',\n   *     file: 'module.js',\n   *     line: 541,\n   *     column: 32 },\n   *   { path: '/_test.js:8:14', file: '/_test.js', line: 8, column: 14 }\n   * ]\n   * ```\n   *\n   * By standardizing the order of the stack trace, it is easier to programmatically\n   * identify sources of problems. This method does not prevent developers from\n   * accessing a normal stacktrace.\n   * @private\n   * @returns {array}\n   * Returns an array of objects. Each object contains the file, line, column,\n   * and path within the stack. For example:\n   *\n   * ```\n   * {\n   *   path: 'path/to/file.js:127:14'\n   *   file: 'path/to/file.js',\n   *   line: 127,\n   *   column: 14\n   * }\n   * ```\n   *\n   * If a stacktrace is unavailable for any reason, the array will contain a\n   * single element like:\n   *\n   * ```js\n   * {\n   *   path: 'unknown',\n   *   file: 'unknown',\n   *   line: 0,\n   *   column: 0\n   * }\n   * ```\n   */\n  processStackItem: NGN.privateconst(function (item, uri) {\n    return item.replace(/at.*\\(|\\)/gi, '')\n      .replace(uri, './')\n      .replace(/\\/{2,100}/gi, '/')\n      .trim().split(':')\n  }),\n\n  stack: NGN.get(function () {\n    const originalStack = (new Error).stack.split('\\n') // eslint-disable-line\n    let stack = (new Error()).stack.split('\\n') || []\n    let fnRegex = /at.*\\(/gi\n\n    stack = stack.filter((item) => {\n      return item.split(':').length > 1\n    }).map((item) => {\n      let operation = fnRegex.exec(item)\n\n      if (operation) {\n        operation = operation[0].replace(/^at\\s{1,100}|\\s{1,100}\\($/gi, '').replace('<anonymous>', 'console')\n      }\n\n      if (this.nodelike) {\n        item = this.processStackItem(item.toString(), process.cwd())\n\n        return {\n          path: item.join(':').replace('./', process.cwd() + '/'),\n          // path: item[0].substr(0, item[0].length) + ':' + item[1] + ':' + item[2],\n          file: item[0].substr(0, item[0].length),\n          line: parseInt(item[1], 10),\n          column: parseInt(item[2], 10),\n          operation: operation\n        }\n      } else {\n        item = this.processStackItem(item.toString(), window.location.origin)\n\n        return {\n          path: item[0].substr(1, item[0].length - 1) + ':' + item[1] + ':' + item[2],\n          file: item[0].substr(1, item[0].length - 1),\n          line: parseInt(item[1], 10),\n          column: parseInt(item[2], 10),\n          operation: operation\n        }\n      }\n    })\n\n    return stack.length !== 0\n      ? (this.nodelike ? stack.reverse() : stack)\n      : [{\n        path: 'unknown',\n        file: 'unknown',\n        line: 0,\n        column: 0\n      }]\n  }),\n\n  /**\n   * @method isFn\n   * A shortcut method for determining if a variable is a function.\n   * This is useful for identifying the existance of callback methods.\n   * @param {any} variable\n   * The variable to identify as a function.\n   * @returns {boolean}\n   * @private\n   */\n  isFn: NGN.privateconst((v) => {\n    return typeof v === 'function'\n  }),\n\n  /**\n   * @method wrap\n   * Executes a **synchronous** method before invoking a standard function.\n   * This is primarily designed for displaying warnings, but can also be\n   * used for other operations like migration layers.\n   * @param {function} preMethod\n   * The **synchronous** function to invoke before the class is instantiated. This\n   * method receives the same arguments passed to the class.\n   * @param {function} method\n   * The function to wrap.\n   * @return {function}\n   * @private\n   */\n  wrap: NGN.privateconst(function (preFn, fn) {\n    return function () {\n      preFn(...arguments)\n      fn(...arguments)\n    }\n  }),\n\n  /**\n   * @method wrapClass\n   * Executes a **synchronous** method before returning an instantiated class.\n   * It runs a function first, then returns the equivalent of\n   * `new MyClass(...)`. This is primarily designed for displaying warnings,\n   * but can also be used for other operations like migration layers.\n   * @param {function} preMethod\n   * The **synchronous** method to invoke before the class is instantiated. This\n   * method receives the same arguments passed to the class.\n   * @param {function} class\n   * The class to wrap.\n   * @return {Class}\n   * @private\n   */\n  wrapClass: NGN.privateconst(function (preFn, ClassFn) {\n    return function () {\n      preFn(...arguments)\n      return new ClassFn(...arguments)\n    }\n  }),\n\n  /**\n   * @method deprecate\n   * Fires an event (if NGN.BUS is available) or logs a warning indicating the\n   * method is deprecated.\n   * @param {function} method\n   * The method to return/execute.\n   * @param {string} [message='The method has been deprecated.']\n   * The warning displayed to the user.\n   * @return {function}\n   * @fires DEPRECATED.METHOD\n   * Fires `DEPRECATED.METHOD` on the NGN.BUS. The message is delivered to\n   * the event handler.\n   */\n  deprecate: NGN.privateconst(function (fn, message = 'The method has been deprecated.') {\n    return this.wrap(() => NGN.WARN('DEPRECATED.METHOD', message), fn)\n  }),\n\n  /**\n   * @method deprecateClass\n   * Logs a warning indicating the class is deprecated. This differs from\n   * #deprecate by extending & preserving the original class (the resulting\n   * class can be used with the `new` operator).\n   * @param {function} class\n   * The class to return/execute.\n   * @param {string} [message='The class has been deprecated.']\n   * The warning displayed to the user.\n   * @fires DEPRECATED.CLASS\n   * Fires `DEPRECATED.CLASS` on the NGN.BUS. The message is delivered to\n   * the event handler.\n   * @return {Class}\n   */\n  deprecateClass: NGN.privateconst(function (classFn, message = 'The class has been deprecated.') {\n    return this.wrapClass(() => NGN.WARN('DEPRECATED.CLASS', message), classFn)\n  }),\n\n  /**\n   * @method needs\n   * A method to check for the existance of required attributes in an object.\n   * This is designed to check for namespace existance.\n   *\n   * ```js\n   * NGN.needs('DOM','BUS', 'NET', 'JUNK') // Throws an error because \"JUNK\" doesn't exist.\n   * ```\n   * @param {Object} namespace\n   * The object to check.\n   * @param {String[]} attributes\n   * A list of attributes to check for.\n   * @throws {MissingNgnDependencyError}\n   * Throws an error if the namespace is missing an attribute dependency.\n   * @private\n   */\n  needs: NGN.private(function () {\n    let missing = NGN.getObjectMissingPropertyNames(NGN, ...arguments)\n\n    if (missing.length === 0) {\n      return\n    }\n\n    // Throw an error if there are any missing attributes.\n    if (missing.length > 0) {\n      throw new MissingNgnDependencyError(`Missing NGN dependencies: ${missing.join(', ')}`.replace(/\\s{2,100}/gi, ' '))\n    }\n  }),\n\n  /**\n   * @method getObjectMissingPropertyNames\n   * Given a list, returns which list items are not present in an\n   * object's enumerable properties.\n   *\n   * ```js\n   * let obj = { a: 1, b: 2 }\n   * let missing = NGN.getObjectMissingPropertyNames(obj, 'a', 'b', 'c')\n   *\n   * console.log(missing) // Outputs ['c']\n   * ```\n   * @param {Object} object\n   * The object to check.\n   * @return {String[]}\n   * @private\n   */\n  getObjectMissingPropertyNames: NGN.private(function () {\n    let missing = []\n    let properties = Object.keys(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      if (properties.indexOf(arguments[i]) < 0) {\n        missing.push(arguments[i])\n      }\n    }\n\n    return missing\n  }),\n\n  /**\n   * @method getObjectExtraneousPropertyNames\n   * Given a list, returns which enumerable object properties\n   * are not in the list.\n   *\n   * ```js\n   * let obj = { a: 1, b: 2, d: 4 }\n   * let extra = NGN.getObjectExtraneousPropertyNames(obj, 'a', 'b', 'c')\n   *\n   * console.log(extra) // Outputs ['d']\n   * ```\n   * @param {Object} object\n   * The object to check.\n   * @return {String[]}\n   * @private\n   */\n  getObjectExtraneousPropertyNames: NGN.private(function () {\n    let properties = Object.keys(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      let index = properties.indexOf(arguments[i])\n\n      if (index >= 0) {\n        properties.splice(index, 1)\n      }\n    }\n\n    return properties\n  }),\n\n  /**\n   * @method objectHasAll\n   * Determines whether the specified object has _all_ of the provided properties.\n   * This only accounts for enumerable properties. It also decorates the Boolean\n   * result with a property called `properties`, which contains any missing property\n   * names.\n   *\n   * **Example**\n   * ```js\n   * let check = NGN.objectHasAll(NGN, 'BUS', 'NET')\n   *\n   * console.log(check) // Outputs: true\n   * ```\n   *\n   * ```js\n   * let check = NGN.objectHasAll(NGN, 'BUS', 'NET', 'JUNK')\n   *\n   * console.log(check) // Outputs: false\n   * console.log(check.properties) // Outputs ['JUNK']\n   * ```js\n   * @param {Object} object\n   * The object to check.\n   * @return {Boolean}\n   */\n  objectHasAll: NGN.const(function () {\n    let properties = Object.keys(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      if (properties.indexOf(arguments[i]) < 0) {\n        return false\n      }\n    }\n\n    return true\n  }),\n\n  /**\n   * @method objectHasAny\n   * Determines whether the specified object has _any_ of the requested properties.\n   * This only accounts for enumerable properties.\n   *\n   * **Example**\n   * ```js\n   * let check = NGN.objectHasAny(NGN, 'BUS', 'NET', 'MORE')\n   *\n   * console.log(check) // Outputs: true\n   * ```\n   *\n   * ```js\n   * let check = NGN.objectHasAny(NGN, 'JUNK1', 'JUNK2', 'JUNK3')\n   *\n   * console.log(check) // Outputs: false\n   * ```js\n   * @param {Object} object\n   * The object to check.\n   * @return {Boolean}\n   */\n  objectHasAny: NGN.const(function () {\n    let properties = Object.keys(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      if (properties.indexOf(arguments[i]) >= 0) {\n        return true\n      }\n    }\n\n    return false\n  }),\n\n  /**\n   * @method objectHasExactly\n   * Determines whether the specified object has _only_ the requested properties.\n   * This only accounts for enumerable properties.\n   *\n   * **Example**\n   * ```js\n   * let obj = { a: 1, b: 2 }\n   * let check = NGN.objectHasExactly(obj, 'a', 'b')\n   *\n   * console.log(check) // Outputs: true\n   * ```\n   *\n   * ```js\n   * let obj = { a: 1, b: 2, d: 4 }\n   * let check = NGN.objectHasExactly(obj, 'a', 'b', 'c')\n   *\n   * console.log(check) // Outputs: false\n   * ```js\n   * @param {Object} object\n   * The object to check.\n   * @return {Boolean}\n   */\n  objectHasExactly: NGN.const(function () {\n    // If there are missing properties, it's not an exact match.\n    if (this.getObjectMissingPropertyNames(arguments[0]).length !== 0) {\n      return false\n    }\n\n    let properties = Object.keys(arguments[0])\n    let args = NGN.slice(arguments)\n\n    args.shift()\n\n    // Check for extra properties on the object\n    for (let i = 0; i < properties.length; i++) {\n      if (args.indexOf(properties[i]) < 0) {\n        return false\n      }\n    }\n\n    // Make sure there are enough properties.\n    for (let i = 0; i < args.length; i++) {\n      if (properties.indexOf(args[i]) < 0) {\n        return false\n      }\n    }\n\n    return true\n  }),\n\n  /**\n   * @method objectRequires\n   * This is the same as #objectHasAll, but will throw an\n   * error if the object is missing any properties.\n   * @throws Error\n   */\n  objectRequires: NGN.const(function () {\n    let check = this.objectHasAll(...arguments)\n\n    if (!check) {\n      throw new Error(`${arguments[0].constructor.name} is missing the following attributes: ${check.missing.join(', ')}`)\n    }\n  }),\n\n  /**\n   * @method createAlias\n   * A helper method to alias a value on an object. This is the equivalent of:\n   * ```js\n   * Object.defineProperty(namespace, name, NGN.get(() => {\n   *   return value\n   * }))\n   * ```\n   * @param  {Object} namespace\n   * The object to apply the alias property to.\n   * @param  {String} name\n   * The alias name.\n   * @param  {Any} value\n   * The value to return.\n   * @private\n   */\n  createAlias: NGN.private(function (namespace, name, value) {\n    Object.defineProperty(namespace, name, NGN.get(() => {\n      return value\n    }))\n  }),\n\n  /**\n   * @method WARN\n   * This method is used to emit special info events.\n   * The NGN.BUS can listen for all events using the NGN.WARN global symbol.\n   *\n   * ```js\n   * NGN.BUS.on(NGN.WARNING_EVENT, function () => {\n   *   console.warn(...arguments)\n   * })\n   * ```\n   *\n   * See NGN.EventEmitter#emit for detailed parameter usage.\n   * @private\n   */\n  WARNING_EVENT: NGN.privateconst(Symbol('NGN.WARN')),\n  WARN: NGN.privateconst(msg => NGN.LEDGER_EVENT(NGN.WARNING_EVENT)(msg)),\n\n  /**\n   * @method INFO\n   * This method is used to emit special warning events.\n   * The NGN.BUS can listen for all events using the NGN.INFO global symbol.\n   *\n   * ```js\n   * NGN.BUS.on(NGN.INFO_EVENT, function () => {\n   *   console.info(...arguments)\n   * })\n   * ```\n   *\n   * See NGN.EventEmitter#emit for detailed parameter usage.\n   * @private\n   */\n  INFO_EVENT: NGN.privateconst(Symbol.for('NGN.INFO')),\n  INFO: NGN.privateconst(msg => NGN.LEDGER_EVENT(NGN.INFO_EVENT)(msg)),\n\n  /**\n   * @method ERROR\n   * This method is used to emit special soft error events. A soft error\n   * is one that does not throw, but does get logged (typically non-critical).\n   * The NGN.BUS can listen for all events using the NGN.ERROR global symbol.\n   *\n   * ```js\n   * NGN.BUS.on(NGN.ERROR_EVENT, function () => {\n   *   console.info(...arguments)\n   * })\n   * ```\n   *\n   * See NGN.EventEmitter#emit for detailed parameter usage.\n   * @private\n   */\n  ERROR_EVENT: NGN.privateconst(Symbol.for('NGN.ERROR')),\n  ERROR: NGN.privateconst(msg => NGN.LEDGER_EVENT(NGN.ERROR_EVENT)(msg)),\n\n  /**\n   * @method createException\n   * Create a custom global exception (custom error).\n   * @param {Object} config\n   * The configuration of the new error.\n   * @param {String} [config.name=NgnError]\n   * The pretty name of the exception. Alphanumeric characters only (underscore is acceptable).\n   * @param {String} [config.type=TypeError]\n   * The type of error. This is commonly `TypeError` or `ReferenceError`, but\n   * it can be any custom value.\n   * @param {String} [config.severity=minor]\n   * A descriptive \"level\" indicating how critical the error is.\n   * @param {String} [config.message=Unknown Error]\n   * The default message to output when none is specified.\n   * @param {Object} [config.custom]\n   * Provide a key/value object of custom attributes for the error.\n   * There are two \"special\" custom attributes: `help` and `cause`.\n   * When provided, these will be written to stdout whenever the error's\n   * stack is viewed.\n   *\n   * For example:\n   *\n   * ```js\n   * NGN.createException({\n   *   name: 'Test Problem',\n   *   message: 'An example error.',\n   *   custom: {\n   *     help: 'Remove the throw statement.',\n   *     cause: 'Testing the error output.'\n   *   }\n   * });\n   *\n   * throw TestProblem()\n   * ```\n   * The code above generates the following console output:\n   *\n   * ```sh\n   * Testing the error output.\n   * Remove the throw statement.\n   * /path/to/test.js:12\n   *    throw TestProblem();\n   *    ^\n   *\n   * TestProblem: An example error.\n   *    at null._onTimeout (/path/to/test.js:12:11)\n   *    at Timer.listOnTimeout (timers.js:92:15)\n   * ```\n   */\n  createException: NGN.const(function (config) {\n    config = config || {}\n    config = typeof config === 'string' ? { message: config } : config\n    config.name = config.name || 'NgnError'\n\n    // Create the error as a function\n    NGN.global[config.name] = function () {\n      if (arguments.length > 0) {\n        config.message = arguments[0]\n      }\n\n      return new CustomException(config)\n    }\n  }),\n\n  /**\n   * @method getType\n   * Returns the primitive object/function of the specified type.\n   * For example:\n   *\n   * ```js\n   * let type = NGN.getType('number') // Returns Number\n   * let type = NGN.getType('string') // Returns String\n   * ```\n   */\n  getType: NGN.const(function (type, defaultType) {\n    switch (type.trim().toLowerCase()) {\n      case 'number':\n        return Number\n\n      case 'regex':\n        NGN.WARN('regex is not a valid JavaScript type. Using regexp instead.')\n\n      case 'regexp': // eslint-disable-line no-fallthrough\n        return RegExp\n\n      case 'boolean':\n        return Boolean\n\n      case 'symbol':\n        return Symbol\n\n      case 'date':\n        return Date\n\n      case 'array':\n        return Array\n\n      case 'object':\n        return Object\n\n      case 'function':\n        return Function\n\n      case 'string':\n        return String\n\n      default:\n        if (defaultType) {\n          return defaultType\n        }\n\n        return undefined\n    }\n  })\n})\n\n// Standard NGN Exceptions\nNGN.createException({\n  name: 'MissingNgnDependencyError',\n  type: 'MissingNgnDependencyError',\n  severity: 'critical',\n  message: 'An NGN dependency is missing or could not be found.',\n  category: 'programmer',\n  custom: {\n    help: 'Include the missing library.',\n    cause: 'A required dependency was not included, or it was not included in the correct sequence.'\n  }\n})\n\nNGN.createException({\n  name: 'ReservedWordError',\n  type: 'ReservedWordError',\n  severity: 'critical',\n  message: 'An attempt to use a reserved word failed.',\n  category: 'programmer',\n  custom: {\n    help: 'Use an alternative word.',\n    cause: 'A word was used to define an attribute, method, field, or other element that already exists.'\n  }\n})\n\nNGN.createException({\n  name: 'InvalidConfigurationError',\n  type: 'InvalidConfigurationError',\n  severity: 'critical',\n  message: 'Invalid configuration.',\n  category: 'programmer',\n  custom: {\n    help: 'See the documentation for the proper configuration.',\n    cause: 'The configuration specified was marked as invalid or caused an error during instantiation.'\n  }\n})\n\n// Self reference to make NGN global in any environment.\nNGN.global.NGN = NGN\n\nexport { NGN as default }\n","// This chunk of awful is courtesy the StandardJS library!\n// We love the lib, except for its failure to allow disabling\n// a parsing error's OUTPUT.\n/* browser-only */\nimport EE from './BrowserEmitter'\n/* end-browser-only */\nlet EEmitter\n/* node-only */\nEEmitter = require('events').EventEmitter\n/* end-node-only */\n/* browser-only */\nEEmitter = EE\n/* end-browser-only */\n\n/**\n * @class NGN.EventEmitter\n * The EventEmitter is an extandable event driver non-DOM objects, such as\n * data models, objects, and other common elements of JavaScript programming.\n *\n * The NGN.EventEmitter is based on and compatible with the [Node.js EventEmitter](https://nodejs.org/dist/latest/docs/api/events.html#events_class_eventemitter).\n * It contains additional event management capabilities, which are available\n * in browser _and_ Node.js environments.\n */\nexport default class EventEmitter extends EEmitter {\n  constructor () {\n    super()\n\n    // const INSTANCE = Symbol('instance')\n\n    Object.defineProperties(this, {\n      // META: NGN.get(() => this[INSTANCE]),\n\n      META: NGN.private({\n        queued: {},\n        collectionQueue: {},\n        thresholdQueue: {},\n        defaultTTL: -1,\n        wildcardEvents: new Set()\n      }),\n\n      /**\n       * @method setTTL\n       * Set a default time-to-live for event handlers (in milliseconds).\n       * After the TTL period elapses, event handlers are removed.\n       * By default, there is no TTL (`-1`).\n       * @param {number} ttl\n       * The number of milliseconds before an event handler is automatically\n       * removed. This value may be `-1` (no TTL/never expires) or a value\n       * greater than `0`.\n       */\n      setTTL: NGN.const((ttl = -1) => {\n        if (ttl === 0) {\n          NGN.WARN('NGN.EventEmitter#TTL cannot be 0.')\n          return\n        }\n\n        this.META.defaultTTL = ttl\n      }),\n\n      /**\n       * @alias off\n       * Remove an event handler. If no handler is specified, all handlers for\n       * the specified event will be removed.\n       * This is a shortcut for #removeListener.\n       * @param {string} eventName\n       * Name of the event to remove.\n       * @param {function} [handlerFn]\n       * The handler function to remove from the event handlers.\n       */\n      off: NGN.public((eventName, handlerFn) => {\n        if (NGN.typeof(eventName) === 'array') {\n          for (let i = 0; i < eventName.length; i++) {\n            this.off(eventName[i], handlerFn)\n          }\n\n          return\n        }\n\n        let l = this.listeners(eventName)\n\n        if (!NGN.isFn(handlerFn)) {\n          return this.clear(eventName)\n        }\n\n        let wrappedHandlerFn = this.wrapEventHandlerWithScope(eventName, handlerFn)\n\n        if (l.indexOf(wrappedHandlerFn) < 0) {\n          for (let i = 0; i < l.length; i++) {\n            if (l[i].toString() === wrappedHandlerFn.toString()) {\n              this.META.wildcardEvents.delete(eventName)\n              // this.removeListener(eventName, handlerFn)\n              this.removeListener(eventName, l[i], false)\n              break\n            }\n          }\n        } else {\n          this.META.wildcardEvents.delete(eventName)\n          this.removeListener(eventName, handlerFn)\n        }\n      }),\n\n      /**\n       * @method deprecate\n       * Provides a deprecation notice for the specified event.\n       * Automatically emits the appropriate \"replacement\" event\n       * if a replacement event is configured. If no replacement\n       * event is configured, the deprecation notice will be written\n       * to the console but no replacement event will be triggered.\n       * @param {string} deprecatedEventName\n       * The name of the deprecated event.\n       * @param {string} [replacementEventName]\n       * The name of the new event.\n       */\n      deprecate: NGN.const((deprecatedEventName, replacementEventName) => {\n        const me = this\n\n        this.on(deprecatedEventName, function () {\n          NGN.WARN(`${deprecatedEventName} is deprecated. ` + (!replacementEventName ? '' : `Use ${replacementEventName} instead.`))\n\n          if (replacementEventName) {\n            let args = NGN.slice(arguments)\n\n            args.shift()\n            args.unshift(replacementEventName)\n\n            me.emit.apply(me, args)\n          }\n        })\n      }),\n\n      /**\n       * @method pool\n       * A helper command to create multiple related subscribers\n       * all at once. This is a convenience function.\n       * @property {string} [prefix]\n       * Supply a prefix to be added to every event. For example,\n       * `myScope.` would turn `someEvent` into `myScope.someEvent`.\n       * @property {Object} subscriberObject\n       * A key:value object where the key is the name of the\n       * unprefixed event and the key is the handler function.\n       * A value can be an object, allowing for nesting events. For example:\n       *\n       * ```js\n       * NGN.BUS.pool('prefix.', {\n       *   deep: {\n       *     nested: {\n       *       eventName: function () {\n       *         console.log('event triggered')\n       *       }\n       *     }\n       *   }\n       * })\n       *\n       * NGN.BUS.emit('prefix.deep.nested.eventName') // <-- Outputs \"event triggered\"\n       * ```\n       * @private\n       */\n      pool: NGN.privateconst(function (prefix, group) {\n        if (typeof prefix !== 'string') {\n          group = prefix\n          prefix = ''\n        }\n\n        let pool = {}\n\n        for (let eventName in group) {\n          let topic = `${NGN.coalesce(prefix, '')}${eventName}`\n\n          if (NGN.isFn(group[eventName])) {\n            this.increaseMaxListeners()\n\n            pool[eventName] = this.on(topic, group[eventName])\n          } else if (typeof group[eventName] === 'object') {\n            this.pool(`${topic}.`, group[eventName])\n          } else {\n            NGN.WARN(`${topic} could not be pooled in the event emitter because it's value is not a function.`)\n          }\n        }\n      }),\n\n      /**\n       * @method attach\n       * Attach a function to a topic. This can be used\n       * to forward events in response to asynchronous functions.\n       *\n       * For example:\n       *\n       * ```js\n       * myAsyncDataFetch(NGN.BUS.attach('topicName'))\n       * ```\n       *\n       * This is the same as:\n       *\n       * ```js\n       * myAsyncCall(function(data){\n       *  NGN.BUS.emit('topicName', data)\n       * })\n       * ```\n       * @param {string} eventName\n       * The name of the event to attach a handler method to.\n       * @param {boolean} [preventDefaultAction=false]\n       * Setting this to `true` will execute a `event.preventDefault()` before\n       * attaching the handler.\n       * @returns {function}\n       * Returns a function that will automatically be associated with an event.\n       */\n      attach: NGN.const(function (eventName, preventDefaultAction) {\n        preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\n\n        return (e) => {\n          if (preventDefaultAction && !NGN.nodelike) {\n            e.preventDefault()\n          }\n\n          this.emit(eventName, ...arguments)\n        }\n      }),\n\n      /**\n       * @method increaseMaxListeners\n       * Increase the number of maximum listeners.\n       * @param {Number} [value = 1]\n       * The number of events the max listener account will be increased by.\n       * @private\n       */\n      increaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() + count)\n      }),\n\n      /**\n       * @method decreaseMaxListeners\n       * Decrease the number of maximum listeners.\n       * @param {Number} [value = 1]\n       * The number of events the max listener account will be decreased by.\n       * @private\n       */\n      decreaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() - count)\n      }),\n\n      /**\n       * @method forward\n       * A special subscriber that fires one or more event in response to\n       * to an event. This is used to bubble events up/down an event chain.\n       *\n       * For example:\n       *\n       * ```js\n       * NGN.BUS.forward('sourceEvent', ['someEvent','anotherEvent'], {payload:true})\n       * ```\n       * When `sourceEvent` is published, the bind method triggers `someEvent` and\n       * `anotherEvent`, passing the payload object to `someEvent` and\n       * `anotherEvent` subscribers simultaneously.\n       *\n       * To forward an event to another EventEmitter, see #relay.\n       * @param {String} sourceEvent\n       * The event to subscribe to.\n       * @param {String|Array} triggeredEvent\n       * An event or array of events to fire in response to the sourceEvent.\n       * @param {any} data\n       * Optional data to pass to each bound event handler.\n       * @returns {Object}\n       * Returns an object with a single `remove()` method.\n       */\n      forward: NGN.const(function (eventName, triggers, payload) {\n        triggers = NGN.forceArray(triggers)\n\n        let me = this\n        let listener = function () {\n          let args = NGN.slice(arguments)\n\n          if (payload) {\n            args.push(payload)\n          }\n\n          me.emit(triggers, ...args)\n        }\n\n        this.increaseMaxListeners()\n        this.on(eventName, listener)\n\n        // Provide handle back for removal of topic\n        return {\n          remove: () => {\n            this.decreaseMaxListeners()\n            this.off(eventName, listener)\n          }\n        }\n      }),\n\n      /**\n       * This relays an entire event to a different event emitter.\n       * For example:\n       *\n       * ```js\n       * let emitterA = new NGN.EventEmitter()\n       * let emitterB = new NGN.EventEmitter()\n       *\n       * emitterA.relay('my.event', emitterB)\n       *\n       * emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n       *\n       * emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n       * ```\n       * @param  {string} eventName\n       * The name of the event to listen for.\n       * @param  {NGN.EventEmitter} targetEmitter\n       * The emitter to relay the event to.\n       * @param {string} [prefix]\n       * An optional prefix to prepend to the eventName.\n       * @param {string} [postfix]\n       * An optional postfix to append to the eventName.\n       */\n      relay: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.on(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      }),\n\n      /**\n       * This relays an entire event to a different event emitter. This is\n       * the same as #relay, but the event handler is removed after the\n       * first invocation of the event.\n       *\n       * For example:\n       *\n       * ```js\n       * let emitterA = new NGN.EventEmitter()\n       * let emitterB = new NGN.EventEmitter()\n       *\n       * emitterA.relayOnce('my.event', emitterB)\n       *\n       * emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n       *\n       * emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n       * emitterA.emit('my.event') // Does nothing\n       * ```\n       * @param  {string} eventName\n       * The name of the event to listen for.\n       * @param  {NGN.EventEmitter} targetEmitter\n       * The emitter to relay the event to.\n       * @param {string} [prefix]\n       * An optional prefix to prepend to the eventName.\n       * @param {string} [postfix]\n       * An optional postfix to append to the eventName.\n       */\n      relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.once(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      }),\n\n      /**\n       * @method delayEmit\n       * This method waits for the specified duration, then publishes an\n       * event once. This will publish the event only once at the end of the\n       * wait period, even if the event is triggered multiple times. This can\n       * be useful when working with many events triggered in rapid succession.\n       *\n       * For example, an NGN.DATA.Model representing a person may be used to\n       * track a user profile. The NGN.DATA.Model fires an event called `field.update`\n       * every time a data field is modified. In many cases, a user may update\n       * multiple fields of their profile using a form with a \"Save\" button.\n       * Instead of generating a new \"save\" (to disk, to memory, to an API, etc)\n       * operation for each field, the publishOnce event can wait until all\n       * changes are made before running the save operation.\n       *\n       * ```js\n       * // Create a data model representing a person.\n       * var Person = new NGN.DATA.Model({....})\n       *\n       * // Create a new person record for a user.\n       * var user = new Person()\n       *\n       * // When the user is modified, save the data.\n       * user.on('field.update', function () {\n       *   // Wait 300 milliseconds to trigger the save event\n       *   NGN.BUS.delayEmit('user.save', 300)\n       * })\n       *\n       * // Save the user using an API\n       * NGN.BUS.on('user.save', function () {\n       *   NGN.NET.put({\n       *     url: 'https://my.api.com/user',\n       *     json: user.data\n       *   })\n       * })\n       *\n       * // Modify the record attributes (which are blank by default)\n       * user.firstname = 'John'\n       * user.lastname = 'Doe'\n       * user.age = 42\n       *\n       * // Make another update 1 second later\n       * setTimeout(function () {\n       *   user.age = 32\n       * }, 1000)\n       * ```\n       *\n       * The code above sets up a model and record. Then it listens to the record\n       * for field updates. Each time it recognizes an update, it queues the \"save\"\n       * event. When the queue matures, it fires the `user.save` event.\n       *\n       * The first `field.update` is triggered when `user.firstname = 'John'` runs.\n       * This initiates a queue for `user.save`, set to mature in 300 millisenconds.\n       * Next, a `field.update` is triggered when `user.lastname = 'Doe'` runs.\n       * This time, since the queue for `user.save` is already initiated, notthing\n       * new happens. Finally, a `field.update` is triggered when `user.age = 42`\n       * runs. Just like the last one, nothing happens since the `user.save` queue\n       * is already active.\n       *\n       * The `user.save` queue \"matures\" after 300 milliseconds. This means after\n       * 300 milliseconds have elapsed, the `user.save` event is triggered. In this\n       * example, it means the `NGN.NET.put()` code will be executed. As a result,\n       * all 3 change (firstname, lastname, and age) will be complete before the\n       * API request is executed. The queue is cleared immediately.\n       *\n       * The final update occurs 1 second later (700 milliseconds after the queue\n       * matures). This triggers a `field.update`, but since the queue is no\n       * longer active, it is re-initiated. 300 milliseconds later, the `user.save`\n       * event is fired again, thus executing the API request again (1.3 seconds\n       * in total).\n       * @param {string} eventName\n       * The event/topic to publish/emit.\n       * @param {Number} [delay=300]\n       * The number of milliseconds to wait before firing the event.\n       * @param {Any} [payload]\n       * An optional payload, such as data to be passed to an event handler.\n       */\n      delayEmit: NGN.const(function (eventName, delay) {\n        if (!this.META.queued.hasOwnProperty(eventName)) {\n          let args = NGN.slice(arguments)\n          args.splice(1, 1)\n\n          this.META.queued[eventName] = setTimeout(() => {\n            delete this.META.queued[eventName]\n            this.emit(...args)\n          }, delay)\n        }\n      }),\n\n      /**\n       * @method getInternalCollectionId\n       * Returns a unique ID for special collections.\n       * @param {object} collection\n       * The collection to generate an ID for.\n       * @private\n       */\n      getInternalCollectionId: NGN.privateconst(function (collection) {\n        return Symbol(collection)\n        // let time = (new Date()).getTime().toString()\n        // let rand = Math.random().toString()\n        // let key = Object.keys(collection).length + 1\n        //\n        // while (collection.hasOwnProperty(`${key.toString()}${time}${rand}`)) {\n        //   key++\n        // }\n        //\n        // return `${key.toString()}${time}${rand}`\n      }),\n\n      /**\n       * @method handleCollectionTrigger\n       * A method to manage #chain event handlers.\n       * @private\n       */\n      handleCollectionTrigger: NGN.privateconst(function (eventName, key) {\n        let me = this\n\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            let cq = me.META.collectionQueue\n\n            if (cq[key]) {\n              cq[key].remainingqueue.delete(eventName)\n\n              if (cq[key].remainingqueue.size === 0) {\n                cq[key].remainingqueue = cq[key].masterqueue\n\n                if (NGN.isFn(cq[key].eventName)) {\n                  cq[key].eventName(cq[key].payload)\n                } else {\n                  me.emit(cq[key].eventName, cq[key].payload)\n                }\n              }\n            }\n          }, 0)\n        }\n      }),\n\n      /**\n       * @method funnel\n       * Emit an event after a collection of unique events have all fired.\n       * This can be useful in situations where multiple asynchronous actions\n       * must complete before another begins. For example, blending 3\n       * remote data sources from different API's into a single resultset\n       * can be achieved with this.\n       *\n       * **Example**\n       * ```js\n       * let collection = NGN.BUS.funnel(['download1done', 'download2done', 'download3done'], 'make.results')\n       *\n       * let allData = []\n       *\n       * // When all of the downloads are done, log them.\n       * NGN.BUS.on('make.results', () => {\n       *   console.log(allData)\n       * })\n       *\n       * // Download the first set of data asynchronously\n       * NGN.NET.json('http:/download1.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download1done')\n       * })\n       *\n       * // Download the second set of data asynchronously\n       * NGN.NET.json('http:/download2.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download2done')\n       * })\n       *\n       * // Download the third set of data asynchronously\n       * NGN.NET.json('http:/download3.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download3done')\n       * })\n       *\n       * // The handler can be removed with the special method:\n       * collection.remove()\n       * ```\n       * @param {array} eventCollection\n       * An array of events. Once _all_ of these events have fired,\n       * the triggerEventName will be fired.\n       * @param {string|function} triggerEventName\n       * The name of the event triggered after the collection has completed.\n       * This can also be a callback function. If a callback function is provided,\n       * it will receive the payload as the only argument when it is triggered.\n       * @param {any} [payload]\n       * An optional payload delivered to the #triggerEventName.\n       * @returns {object} collection\n       * Provides the key/value configuration of the collection.\n       * ```js\n       * {\n       *   masterqueue: ['event1', 'event2', 'etc'], // The original event array (non-editable)\n       *   remainingqueue: [...], // The events the BUS is still waiting for before firing the trigger event.\n       *   eventName: 'triggeredEventName', // Name of the event triggered after the remaining elements are flushed.\n       *   payload: 'anything', // OPTIONAL\n       *   remove: [Function]\n       * }\n       * ```\n       */\n      funnel: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        if (NGN.typeof(eventCollection) !== 'array') {\n          throw new Error(`NGN.BUS.funnel expected an array of events, but received a(n) ${NGN.typeof(eventCollection)}`)\n        }\n\n        let collection = new Set(eventCollection)\n        let key = this.getInternalCollectionId(this.META.collectionQueue)\n\n        this.META.collectionQueue[key] = {}\n\n        Object.defineProperties(this.META.collectionQueue[key], {\n          masterqueue: NGN.const(new Set(eventCollection)),\n          remainingqueue: NGN.private(collection),\n          eventName: NGN.const(triggerEventName),\n          remove: NGN.const(() => {\n            this.META.collectionQueue[key].masterqueue.forEach(event => {\n              this.off(event, this.handleCollectionTrigger(event, key))\n            })\n\n            this.decreaseMaxListeners(this.META.collectionQueue[key].masterqueue.size)\n\n            delete this.META.collectionQueue[key]\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners(collection.size)\n\n        collection.forEach(event => {\n          this.on(event, this.handleCollectionTrigger(event, key))\n        })\n\n        return this.META.collectionQueue[key]\n      }),\n\n      /**\n       * @method funnelOnce\n       * This provides the same functionality as #funnel, but\n       * removes the listener after the resultant event has fired.\n       * See #funnel for detailed usage.\n       * @param {array} eventCollection\n       * An array of events. Once _all_ of these events have fired,\n       * the triggerEventName will be fired.\n       * @param {string} triggerEventName\n       * The name of the event triggered after the collection has completed.\n       * @param {any} [payload]\n       * An optional payload delivered to the #triggerEventName.\n       * @returns {object} collection\n       * Provides the key/value configuration of the collection.\n       */\n      funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\n        // let funnelClosureEvent = Symbol(triggerEventName)\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\n\n        this.increaseMaxListeners()\n        this.once(funnelClosureEvent, () => {\n          collection.remove()\n          collection = null\n          this.emit(triggerEventName, payload)\n        })\n      }),\n\n      /**\n       * @method threshold\n       * After an event is fired a predetermined number of times (the threshold),\n       * trigger another event or function.\n       *\n       * For example:\n       *\n       * ```js\n       * NGN.BUS.threshold('push.my.button', 3, 'annoyed')\n       *\n       * NGN.BUS.on('annoyed', function () {\n       *   console.log('We apologize for the slow response, but excessive clicking will not speed up the process.')\n       * })\n       *\n       * document.getElementById('#myButton').addEventListener('click', NGN.BUS.attach('push.my.button'))\n       * ```\n       *\n       * Once the threshold is exceeded, the final event will be triggered and\n       * the threshold will be reset. Using the example above, this means\n       * clicking 3 times on `#myButton` would trigger the `annoyed` event ONCE,\n       * 6 times triggers `annoyed` TWICE, 9 times triggers `annoyed` THREE times, etc.\n       * @param {string} thresholdEventName\n       * The name of the event to count.\n       * @param {number} limit\n       * The number of occurrances allowed until the final event is triggered.\n       * The event will be triggered at the threshold. For example, if the limit\n       * is `3`, the finalEvent will be triggered the 3rd time thresholdEventName is\n       * fired.\n       * @param {string|function} finalEventName\n       * This can be an event or callback function triggered when the threshold is crossed.\n       * If a callback function is specified, the payload is passed as the only argument.\n       * @param {any} [payload]\n       * An optional payload to send to the finalEvent handler(s).\n       * @returns {object}\n       * Returns an object that can be used to remove the threshold.\n       *\n       */\n      threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        if (typeof thresholdEventName !== 'string') {\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\n        }\n\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\n\n        this.META.thresholdQueue[key] = {}\n\n        Object.defineProperties(this.META.thresholdQueue[key], {\n          key: NGN.const(key),\n          eventName: NGN.const(thresholdEventName),\n          limit: NGN.const(limit),\n          count: NGN.private(0),\n          finalEventName: NGN.const(finalEventName),\n          remove: NGN.const(() => {\n            let event = this.META.thresholdQueue[key].eventName\n\n            delete this.META.thresholdQueue[key]\n\n            this.decreaseMaxListeners()\n            this.off(event, this.handleThresholdTrigger(key))\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners()\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\n\n        return this.META.thresholdQueue[key]\n      }),\n\n      thresholdOnce: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        let thresholdClosureEvent = `::NGNTHRESHOLD::${(new Date()).getTime()}::${finalEventName}`\n        let threshold = this.threshold(thresholdEventName, limit, thresholdClosureEvent, payload)\n\n        this.once(thresholdClosureEvent, () => {\n          threshold.remove()\n          threshold = null\n          this.emit(finalEventName, payload)\n        })\n      }),\n\n      /**\n       * @method handleThresholdTrigger\n       * A method to manage #threshold event handlers.\n       * @private\n       */\n      handleThresholdTrigger: NGN.const(function (key) {\n        let me = this\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            if (me.META.thresholdQueue.hasOwnProperty(key)) {\n              me.META.thresholdQueue[key].count++\n              if (me.META.thresholdQueue[key].count === me.META.thresholdQueue[key].limit) {\n                if (NGN.isFn(me.META.thresholdQueue[key].finalEventName)) {\n                  me.META.thresholdQueue[key].finalEventName(me.META.thresholdQueue[key].payload)\n                } else {\n                  me.emit(me.META.thresholdQueue[key].finalEventName, me.META.thresholdQueue[key].payload)\n                }\n\n                // This if statement is required in case the event is removed\n                // during the reset process.\n                if (me.META.thresholdQueue.hasOwnProperty(key)) {\n                  me.META.thresholdQueue[key].count = 0\n                }\n              }\n            }\n          }, 0)\n        }\n      }),\n\n      /**\n       * An internal method to wrap node-based event handlers\n       * with the proper scope.\n       * @param {string} eventName\n       * The name of the event being handled.\n       * @param {function} handlerFn\n       * The handler function.\n       */\n      wrapEventHandlerWithScope: NGN.privateconst((name, fn) => {\n        if (!NGN.nodelike) {\n          return fn\n        }\n\n        const handlerFn = fn\n\n        return function () {\n          let args = arguments\n\n          if (typeof args[args.length - 1] === 'symbol') {\n            name = args[args.length - 1].toString().replace(/Symbol\\(|\\)/gi, '')\n            args = NGN.slice(args)\n            args.pop()\n          }\n\n          handlerFn.apply({ event: name }, args)\n        }\n      }),\n\n      /**\n       * An internal method to apply scope based on whether the handler\n       * is a Node-like \"once\" emitter or not.\n       * @param {string} eventName\n       * The name of the event being scoped.\n       * @param {function} handlerFn\n       * The handler function.\n       */\n      applyScope: NGN.privateconst((args) => {\n        if (NGN.nodelike && args.length > 1) {\n          if (args[args.length - 1].listener) {\n            args[args.length - 1].listener = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1].listener\n            )\n          } else {\n            args[args.length - 1] = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1]\n            )\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Remove all event handlers from the EventEmitter (both regular and adhoc).\n   * This is a shortcut for #removeAllListeners.\n   */\n  clear () {\n    let events = NGN.slice(arguments)\n\n    if (events.length === 0) {\n      this.META.wildcardEvents.clear()\n\n      let symbolEvents = []\n\n      if (NGN.nodelike) {\n        symbolEvents = Object.getOwnPropertySymbols(this._events)\n      } else {\n        symbolEvents = Object.getOwnPropertySymbols(this.adhoc)\n        symbolEvents = symbolEvents.concat(Object.getOwnPropertySymbols(this.handlers))\n      }\n\n      for (let i = 0; i < symbolEvents.length; i++) {\n        this.removeAllListeners(symbolEvents[i])\n      }\n\n      return this.removeAllListeners()\n    }\n\n    for (let i = 0; i < events.length; i++) {\n      this.META.wildcardEvents.delete(events[i])\n      this.removeAllListeners(events[i])\n    }\n  }\n\n  /**\n   * Internal method used to handle TTL and wildcard management.\n   * @private\n   */\n  eventHandler (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(ttl) === 'boolean') {\n      prepend = ttl\n      ttl = this.META.defaultTTL\n    }\n\n    if (ttl === undefined) {\n      ttl = this.META.defaultTTL\n    }\n\n    if (ttl > 0) {\n      setTimeout(() => this.off(eventName, callback), ttl)\n    }\n\n    if (typeof eventName === 'string' && eventName.indexOf('*') >= 0) {\n      this.META.wildcardEvents.add(eventName)\n    }\n\n    return prepend\n  }\n\n  /**\n   * @method on\n   * Create a new event handler for the specified event.\n   * @param {string|string[]|object} eventName\n   * Name of the event to listen for.\n   * If an object is passed, this method will automatically setup a #pool.\n   * @param {function} handler\n   * The method responsible for responding to the event.\n   * This is ignored if eventName is an object.\n   * @param {number} [TTL]\n   * Time-To-Live is the number of milliseconds before the event handler\n   * is automatically removed. This is useful for automatically cleaning\n   * up limited-life event handlers.\n   * @param {boolean} [prepend=false]\n   * When set to `true`, the event is added to the beginning of\n   * the processing list instead of the end.\n   * This is ignored if eventName is an object.\n   */\n  on (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(eventName) === 'array') {\n      for (let i = 0; i < eventName.length; i++) {\n        this.on(eventName[i], callback, ttl, prepend)\n      }\n\n      return\n    }\n\n    if (this.eventHandler(...arguments)) {\n      this.prependListener(eventName, callback)\n    } else {\n      this.addListener(eventName, callback)\n    }\n  }\n\n  /**\n   * @method once\n   * Create a new event handler for the specified event. The\n   * handler will be removed immediately after it is executed. This\n   * effectively listens for an event to happen once and only once\n   * before the handler is destroyed.\n   * @param  {string} eventName\n   * Name of the event to listen for.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   * @param {boolean} [prepend=false]\n   * When set to `true`, the event is added to the beginning of\n   * the processing list instead of the end.\n   */\n  once (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(eventName) === 'array') {\n      for (let i = 0; i < eventName.length; i++) {\n        this.once(eventName[i], callback, ttl, prepend)\n      }\n\n      return\n    }\n\n    if (this.eventHandler(...arguments)) {\n      this.prependOnceListener(eventName, callback)\n    } else {\n      super.once(eventName, this.wrapEventHandlerWithScope(eventName, callback))\n    }\n  }\n\n  // The following methods override the Node event emitter only when necessary.\n  prependListener () {\n    this.applyScope(arguments)\n    super.prependListener(...arguments)\n  }\n\n  prependOnceListener () {\n    this.applyScope(arguments)\n    super.prependOnceListener(...arguments)\n  }\n\n  addListener () {\n    this.applyScope(arguments)\n    super.addListener(...arguments)\n  }\n\n  removeListener () {\n    if (arguments[arguments.length - 1] !== true) {\n      this.applyScope(arguments)\n    }\n\n    super.removeListener(...arguments)\n  }\n\n  /**\n   * @method emit\n   * Emits an event.\n   * @param {string[]} eventName\n   * The event name can be a string or an array of strings. If an array\n   * of strings is specified, an event will be fired for each event name\n   * within the array.\n   * @param {any} [payload]\n   * An optional payload. This can be any number of additional arguments.\n   */\n  emit () {\n    if (NGN.typeof(arguments[0]) === 'array') {\n      let args = NGN.slice(arguments)\n      let eventNames = args.shift()\n\n      for (let i = 0; i < eventNames.length; i++) {\n        this.emit(eventNames[i], ...args)\n      }\n\n      return\n    }\n\n    // This catches non-string event names. NGN internally uses Symbols\n    // for the NGN.WARN/INFO/ERROR event names to prevent name collisions.\n    // This check provides support for these special events. These types\n    // of events will never have wildcards.\n    if (!NGN.nodelike || !arguments[0] || this.META.wildcardEvents.size === 0) {\n      super.emit(...arguments)\n      return\n    }\n\n    if (NGN.nodelike && typeof arguments[0] === 'symbol') {\n      super.emit(...arguments)\n      return\n    }\n\n    /**\n     * The NGN browser-based event emitter supports wildcards natively, but\n     * Node.js does not. This adds simple wildcard support for Node. The\n     * only wildcard character supported at this time is `*`. This feature\n     * will check the event name for the existance of a wildcard. If a\n     * wilcard character is present, the internally-maintained list of\n     * wildcard events is checked to see if it's a known event. If none\n     * of these checks pass, the standard event emitter is used, otherwise\n     * special wildcard handling is used.\n     */\n    let iterator = this.META.wildcardEvents.values()\n    let currentEvent = null\n    let args = NGN.slice(arguments)\n\n    args.shift()\n\n    while (currentEvent === null || !currentEvent.done) {\n      if (currentEvent !== null && currentEvent.value !== arguments[0]) {\n        let pattern = new RegExp(currentEvent.value.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\n\n        if (pattern.test(arguments[0])) {\n          super.emit(currentEvent.value, ...args, typeof arguments[0] !== 'symbol' ? Symbol(arguments[0]) : arguments[0])\n          break\n        }\n      }\n\n      currentEvent = iterator.next()\n    }\n  }\n}\n","/**\n * @class EventEmitterBase\n * This is an extendable generic class used to apply event management\n * to non-DOM objects, such as data models, logging, and other common\n * elements of JavaScript programming.\n * @protected\n */\nexport default class BrowserEmitter { // eslint-disable-line no-unused-vars\n  /**\n   * @constructor\n   * ```\n   * let EE = new EventEmitter()\n   * ```\n   * This is a protected class. It is most commonly instantiated through\n   * the NGN namespace (i.e. `new NGN.EventEmitter()`). However; it is\n   * designed for use within the NGN library, not directly as an event emitter.\n   * Use with caution.\n   */\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    Object.defineProperties(this, {\n      handlers: NGN.private({}),\n      adhoc: NGN.private({}),\n      maxlisteners: NGN.private(cfg.defaultMaxListeners || 25)\n    })\n  }\n\n  /**\n   * @property {object} subscribers\n   * An array of all subscribers which currently have a registered event handler.\n   * @warning This is a UI-only method.\n   */\n  get subscribers () {\n    let subscriberList = {}\n\n    for (let eventName in this.handlers) {\n      subscriberList[eventName] = {\n        handler: this.handlers[eventName].length,\n        adhoc: 0\n      }\n    }\n\n    for (let eventName in this.adhoc) {\n      subscriberList[eventName] = subscriberList[eventName] || {\n        handler: 0\n      }\n\n      subscriberList[eventName].adhoc = this.adhoc[eventName].length\n    }\n\n    return subscriberList\n  }\n\n  /**\n   * @property defaultMaxListeners\n   * The maximum number of listeners for a single event.\n   */\n  get defaultMaxListeners () {\n    return this.maxlisteners\n  }\n\n  set defaultMaxListeners (value) {\n    this.maxlisteners = value\n  }\n\n  /**\n   * @method {number} listenerCount\n   * The number of listeners for a specific event.\n   * @param {string} eventName\n   * The name of the event to count listeners for.\n   */\n  listenerCount (eventName) {\n    return (this.handlers[eventName] || []).length +\n      (this.adhoc[eventName] || []).length\n  }\n\n  /**\n   * @method getMaxListeners\n   * A node-like reference to the #defaultMaxListeners value.\n   * @return {number}\n   */\n  getMaxListeners () {\n    return this.defaultMaxListeners\n  }\n\n  /**\n   * @method setMaxListeners\n   * A node-like reference to the #defaultMaxListeners value (setter).\n   */\n  setMaxListeners (value) {\n    this.defaultMaxListeners = value\n  }\n\n  /**\n   * @method eventNames\n   * A node-like reference providing an array of recognized event names.\n   * @return {array}\n   */\n  eventNames () {\n    let handlers = Object.keys(this.handlers)\n    let adhoc = Object.keys(this.adhoc)\n    return NGN.dedupe(handlers.concat(adhoc))\n  }\n\n  /**\n   * @method listeners\n   * Returns the raw listener methods for the event.\n   * @param {string} eventName\n   * Name of the event to retrieve listeners for.\n   * @return {array}\n   */\n  listeners (eventName) {\n    let handlers = this.handlers[eventName] || []\n    let adhoc = this.adhoc[eventName] || []\n    return handlers.concat(adhoc)\n  }\n\n  /**\n   * @method addListener\n   * Create a new event handler for the specified event.\n   * @param  {string|object} eventName\n   * Name of the event to listen for.\n   * If an object is passed, this method will automatically setup a #pool.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   * This is ignored if eventName is an object.\n   */\n  addListener (eventName, callback) {\n    if (typeof eventName === 'object') {\n      return this.pool(eventName)\n    }\n\n    this.handlers[eventName] = this.handlers[eventName] || []\n    this.handlers[eventName].unshift(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method prependListener\n   * This is the same as #addListener, except the event handler is added to the end of the queue.\n   * @param  {string|object} eventName\n   * Name of the event to listen for.\n   * If an object is passed, this method will automatically setup a #pool.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   * This is ignored if eventName is an object.\n   */\n  prependListener (eventName, callback) {\n    if (typeof eventName === 'object') {\n      return this.pool(eventName)\n    }\n\n    this.handlers[eventName] = this.handlers[eventName] || []\n    this.handlers[eventName].push(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method onceListener\n   * Create a new event handler for the specified event. The\n   * handler will be removed immediately after it is executed. This\n   * effectively listens for an event to happen once and only once\n   * before the handler is destroyed.\n   * @param  {string} eventName\n   * Name of the event to listen for.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   */\n  once (eventName, callback) {\n    this.adhoc[eventName] = this.adhoc[eventName] || []\n    this.adhoc[eventName].push(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method prependOnceListener\n   * A node-like reference to the #once method, adding events to the\n   * beginning of the event list (processed before others) instead of the end.\n   * @param  {string} eventName\n   * Name of the event to listen for.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   */\n  prependOnceListener (eventName, callback) {\n    this.adhoc[eventName] = this.adhoc[eventName] || []\n    this.adhoc[eventName].unshift(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method removeListener\n   * Remove an event handler. If no handler is specified, all handlers for\n   * the specified event will be removed.\n   * @param {string} eventName\n   * Name of the event to remove.\n   * @param {function} [handlerFn]\n   * The handler function to remove from the event handlers.\n   */\n  removeListener (eventName, handlerFn) {\n    this.deleteEventHandler('handlers', eventName, handlerFn)\n    this.deleteEventHandler('adhoc', eventName, handlerFn)\n  }\n\n  /**\n   * @method deleteEventHandler\n   * Remove a specific event handler.\n   * @param {string} type\n   * Either `handler` (multi-use events) or `adhoc` (one-time events)\n   * @param {string} eventName\n   * Name of the event to remove.\n   * @param {function} handlerFn\n   * The handler function to remove from the event handlers.\n   * @private\n   */\n  deleteEventHandler (type, eventName, handlerFn) {\n    let scope = this[type]\n\n    if (scope[eventName]) {\n      if (!handlerFn) {\n        delete scope[eventName]\n        return\n      }\n\n      let result = []\n      scope[eventName].forEach((handler) => {\n        if (handler.toString() !== handlerFn.toString()) {\n          result.push(handler)\n        }\n      })\n\n      if (result.length === 0) {\n        delete scope[eventName]\n        return\n      }\n\n      scope[eventName] = result\n    }\n  }\n\n  /**\n   * @method removeAllListeners\n   * Remove all event handlers from the EventEmitter (both regular and adhoc).\n   */\n  removeAllListeners (eventName = null) {\n    if (eventName !== null) {\n      delete this.handlers[eventName]\n      delete this.adhoc[eventName]\n    } else {\n      this.handlers = {}\n      this.adhoc = {}\n    }\n  }\n\n  /**\n   * @method emit\n   * Fires an event. This method accepts one or more arguments. The\n   * first argument is always the event name, followed by any number\n   * of payload arguments.\n   *\n   * Example:\n   * ```\n   * const EE = new NGN.EventEmitter()\n   *\n   * EE.emit('someevent', {payload: 1}, {payload: 2})\n   * ```\n   * The example above triggers an event called `someevent` and applies\n   * the remaining two arguments to any event handlers.\n   * @param {string} eventName\n   * The name of the event to trigger.\n   */\n  emit () {\n    let args = NGN.slice(arguments)\n    const eventName = args.shift()\n    const events = this.getAllEvents(eventName)\n\n    if (typeof eventName === 'symbol') {\n      events.push(eventName)\n    }\n\n    let scope = {\n      event: eventName\n    }\n\n    for (let name = 0; name < events.length; name++) {\n      let adhocEvent = this.adhoc[events[name]]\n\n      // Adhoc event handling\n      if (adhocEvent) {\n        delete this.adhoc[events[name]]\n\n        while (adhocEvent.length > 0) {\n          let fn = adhocEvent.pop()\n\n          scope.handler = fn\n\n          fn.apply(scope, args)\n        }\n      }\n\n      // Regular event handling\n      let handler = this.handlers[events[name]]\n\n      if (handler) {\n        for (let fn = 0; fn < handler.length; fn++) {\n          scope.handler = handler[fn]\n          handler[fn].apply(scope, args)\n        }\n      }\n    }\n  }\n\n  /**\n   * @method getAllEvents\n   * Returns all of the events that match an event name. The event name\n   * may contain wildcards (i.e. `*`) or it can be a regular expression.\n   * @param  {string|regexp} eventName\n   * A string or regular expression defining which event names to identify.\n   * A string value containing an asterisk (*) will be converted to a regular\n   * expression for simplistic wildcard event handling purposes.\n   * @return {array}\n   * An array of unique event names with handlers or adhoc handlers.\n   * @private\n   */\n  getAllEvents (eventName) {\n    const regularEvents = Object.keys(this.handlers)\n    const adhocEvents = Object.keys(this.adhoc)\n    let allEvents = NGN.dedupe(regularEvents.concat(adhocEvents))\n\n    allEvents = allEvents.filter(function (event) {\n      // If the event is an exact match, don't filter it out.\n      if (event === eventName) {\n        return true\n      }\n\n      // If the event is a regexp/wildcard, further processing is necessary.\n      if (NGN.typeof(event) === 'regexp' || event.indexOf('*') >= 0) {\n        // Convert wildcard events to a regular expression.\n        if (NGN.typeof(event) !== 'regexp') {\n          event = new RegExp(event.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\n        }\n        // If the event name matches the event, keep it.\n        return event.test(eventName)\n      }\n\n      // None of the criteria were met. Ignore the event.\n      return false\n    })\n\n    return allEvents\n  }\n}\n","/**\n * @class NGN.UTILITY.Lexer\n * This class performs scans static text for tokens, based on a grammar.\n * It is designed to work with NGN.UTILITY.Tokenizer to convert text into\n * a sequence of tokens (strings with an identified \"meaning\").\n *\n * This class was inspired by https://github.com/aaditmshah/lexer (MIT).\n *\n * ```js\n * let lexer = new NGN.UTILITY.Lexer('hello\\nworld\\nand moon')\n *\n * lexer.addRule(/hello/i, function (str) {\n *   return 'hi' // \"hi\" is the name of the token\n * })\n *\n * lexer.addRule(/world/i, function (str) {\n *   return 'planet'\n * })\n *\n * // Create an error if a rule passes. In this case, prevent the word \"moon\".\n * lexer.addRule(/moon/i, function (str) {\n *   this.error()\n * })\n *\n * console.log(lexer.next())\n *\n * // OUTPUT\n * // {\n * //   line: 1,\n * //   column: 1,\n * //   index: 0,\n * //   token: 'hi',\n * //   length: 5,\n * //   input: 'hello'\n * // }\n *\n * lexer.next() // Returns the next token\n * ```\n *\n * The lexer contains two built-in rules to determine the beginning of\n * file/content (token `BOF`) and the end of file content (token `EOF`).\n */\nexport default class NGNLexer { // eslint-disable-line no-unused-vars\n  /**\n   * Create a new lexer instance.\n   * @param  {String} [input='']\n   * Initialize with text input.\n   */\n  constructor (statement = '') {\n    Object.defineProperties(this, {\n      tokens: NGN.private([]),\n      rules: NGN.private([]),\n      remove: NGN.private(0),\n      state: NGN.private(0),\n      index: NGN.private(0),\n      statement: NGN.private(statement),\n      reject: NGN.private(false),\n      lastLineIndex: NGN.private(0),\n      currentLength: NGN.private(0),\n      currentMatch: NGN.private(null),\n      row: NGN.private(1),\n      unrecognizedCharacters: NGN.private(false)\n    })\n\n    // Identify beginning of file/statement\n    this.addRule(/^/, function () {\n      return 'BOF'\n    })\n\n    // Identify end of file/statement\n    this.addRule(/$/, function () {\n      return 'EOF'\n    })\n\n    if (statement && statement.length > 0) {\n      this.input = statement\n    }\n  }\n\n  /**\n   * @property {String} value\n   * The input text to analyze. Changing this automatically resets the lexer.\n   */\n  set input (value) {\n    this.remove = 0\n    this.state = 0\n    this.index = 0\n    this.currentMatch = null\n    this.tokens = []\n    this.row = 1\n    this.statement = value\n  }\n\n  get input () {\n    return this.statement\n  }\n\n  /**\n   * @property {number} lines\n   * The number of lines in the input text.\n   */\n  get lines () {\n    return this.statement.split('\\n').length\n  }\n\n  /**\n   * @property {boolean} unrecognized\n   * Set this to `true` within a rule if a value is unrecognized.\n   * The more common approach is to use the #error method, which\n   * sets this to `true` when a rule should produce an error.\n   */\n  get unrecognized () {\n    return this.unrecognizedCharacters\n  }\n\n  set unrecognized (value) {\n    // TODO: NGN.forceBoolean\n    this.reject = true\n    this.unrecognizedCharacters = NGN.forceBoolean(value)\n  }\n\n  /**\n   * @property {number} currentLine\n   * Retrieves the current line wherever the lexer left off (i.e. last\n   * recognized token).\n   */\n  get currentLine () {\n    return this.row\n  }\n\n  /**\n   * @property {number} currentColumn\n   * Retrieves the current column wherever the lexer left off (i.e. last\n   * recognized token).\n   */\n  get currentColumn () {\n    let col = (this.index - this.lastLineIndex) - this.currentLength\n\n    return col === 0 ? 1 : col\n  }\n\n  /**\n   * Called within a rule to force an error. This is most commonly used\n   * when a block of text contains a value it shouldn't.\n   * @param  {String} [message]\n   * An optional message prefixed to the error message.\n   */\n  error (message) {\n    if (message) {\n      let col = (this.index - this.lastLineIndex) - 1\n\n      throw new Error(`${message} at line ${this.currentLine}, column ${col < 1 ? 1 : col}.`)\n    }\n\n    this.unrecognized = true\n  }\n\n  /**\n   * Add a rule for detecting a token.\n   * @param {RegExp} pattern\n   * The pattern is applied to the text to determine whether the action should\n   * be triggered or not.\n   * @param {Function|String} action\n   * The action method is executed when a pattern match is detected. If the\n   * action is a function, it must return the name of the token. Functions\n   * receive a single argument, which is the text that matched the rule.\n   *\n   * If a string is provided as the action, that string will be returned as\n   * the token value whenever a pattern match occurs. This is a convenient\n   * way to avoid repetitively writing the following type of token handler:\n   *\n   * ```js\n   * function () {\n   *   return 'token'\n   * }\n   * ```\n   * @param {Array} [start=[0]]\n   * An optional array of unsigned integers acting as\n   * [start conditions](http://flex.sourceforge.net/manual/Start-Conditions.html).\n   * By default all rules are active in the initial state (i.e. `0`).\n   */\n  addRule (pattern, action, start = [0]) {\n    if (!pattern.global) {\n      let flags = 'g'\n\n      if (pattern.multiline) {\n        flags += 'm'\n      }\n\n      if (pattern.ignoreCase) {\n        flags += 'i'\n      }\n\n      pattern = new RegExp(pattern.source, flags)\n    }\n\n    let actionFn\n    if (typeof action === 'string') {\n      actionFn = function () {\n        return action\n      }\n    } else {\n      actionFn = action\n    }\n\n    if (!NGN.isFn(actionFn)) {\n      throw new Error(`INVALID LEXER ATTRIBUTES: ${pattern.toString()} rule is missing a valid handler function (action) or token name.`)\n    }\n\n    let actionString = actionFn.toString()\n\n    if (actionString.indexOf('this.error(') >= 0 && /^\\(.*\\)\\s{0,10}=>\\s{0,10}\\{/.test(actionString)) {\n      throw new Error('Cannot use a non-lexical expression (arrow function) as a lexer rule.')\n    }\n\n    this.rules.push({\n      pattern,\n      global: pattern.global,\n      action: actionFn,\n      start\n    })\n  }\n\n  /**\n   * An iterator method.\n   * @return {Object}\n   * Returns the next recognized token as a detailed object:\n   *\n   * ```js\n   * {\n   *   line: 1,\n   *   column: 1,\n   *   index: 0,\n   *   token: 'token name',\n   *   length: 5,\n   *   input: 'original input string'\n   * }\n   */\n  next () {\n    if (this.tokens.length) {\n      return this.tokens.shift()\n    }\n\n    this.reject = true\n\n    while (this.index <= this.statement.length) {\n      // Count any new line & reset column\n      if (/\\n/i.test(this.statement.charAt(this.index))) {\n        this.row++\n        this.lastLineIndex = this.index\n      }\n\n      let matches = this.scan().splice(this.remove)\n      let index = this.index\n\n      while (matches.length) {\n        if (this.reject) {\n          let match = matches.shift()\n          let result = match.result\n          let length = match.length\n\n          this.index += length\n          this.currentLength = length\n          this.reject = false\n          this.remove++\n          let token = match.action.apply(this, result)\n\n          if (this.reject) {\n            this.index = result.index\n          } else if (token !== undefined) {\n            switch (NGN.typeof(token)) {\n              case 'array':\n                this.tokens = token.slice(1)\n                token = token[0]\n\n              default: // eslint-disable-line no-fallthrough\n                if (length) {\n                  this.remove = 0\n                }\n\n                return token\n            }\n          }\n        } else {\n          break\n        }\n      }\n\n      let input = this.statement\n\n      if (index < input.length) {\n        if (this.reject) {\n          this.remove = 0\n\n          let token = this.unexpected(input.substr(this.index++, this.index + input.length))\n\n          if (token !== undefined) {\n            if (NGN.typeof(token) === 'array') {\n              this.tokens = token.slice(1)\n              return token[0]\n            } else {\n              return token\n            }\n          }\n        } else {\n          if (this.index !== index) {\n            this.remove = 0\n          }\n\n          this.reject = true\n        }\n      } else if (matches.length) {\n        this.reject = true\n      } else {\n        break\n      }\n    }\n  }\n\n  /**\n   * Scan the text and apply rules.\n   * @private\n   */\n  scan () {\n    let matches = []\n    let index = 0\n    let state = this.state\n    let lastIndex = this.index\n    let input = this.statement\n\n    for (let i = 0, length = this.rules.length; i < length; i++) {\n      let rule = this.rules[i]\n      let start = rule.start\n      let states = start.length\n\n      if (\n        (!states || start.indexOf(state) >= 0) ||\n          (state % 2 && states === 1 && !start[0])\n      ) {\n        let pattern = rule.pattern\n        pattern.lastIndex = lastIndex\n        let result = pattern.exec(input)\n\n        if (result && result.index === lastIndex) {\n          let j = matches.push({\n            result,\n            action: rule.action,\n            length: result[0].length\n          })\n\n          if (rule.global) {\n            index = j\n          }\n\n          while (--j > index) {\n            let k = j - 1\n\n            if (matches[j].length > matches[k].length) {\n              let temple = matches[j]\n              matches[j] = matches[k]\n              matches[k] = temple\n            }\n          }\n        }\n      }\n    }\n\n    return matches\n  }\n\n  /**\n   * Handles unexpected character sequences.\n   * This may throw an error if the characters are unrecognized.\n   * @param  {String} characters\n   * The characters which triggered the unexpected flag.\n   * @private\n   */\n  unexpected (str) {\n    if (this.unrecognizedCharacters) {\n      let col = (this.index - this.lastLineIndex) - 1\n\n      throw new Error(`Unexpected syntax at line ${this.currentLine}, column ${col < 1 ? 1 : col}\\nat ${str}\\n   ^`)\n    }\n  }\n}\n","/**\n * @class NGN.UTILITY.Tokenizer\n * Given a grammar, a tokenizer will perform lexical analysis of text.\n * In simple terms, it will extract tokens from text. This is accomplished\n * by applying rules with a NGN.UTILITY.Lexer and capturing responses.\n *\n * The NGN.DATA.JQL class is an implementation of a tokenizer. It extracts\n * tokens from JQL queries, splitting them into tokens that can be used in\n * programs.\n */\nexport default class NGNTokenizer { // eslint-disable-line no-unused-vars\n  /**\n   * Create a new tokenizer. This will return an instance of itself,\n   * allowing for methods to be chained like `(new Tokenizker([...])).parse('...')`.\n   * @param  {Array}  [grammar=[]]\n   * A grammar is a collection of rules that are passed to\n   * NGN.UTILITY.Lexer#addRule.\n   *\n   * The following example provides a subset of the NGN.DATA.JQL grammar.\n   *\n   * ```js\n   * new Tokenizer([\n   *   // Disallow irrelevant keywords (SQL)\n   *   [\n   *     /FROM/i,\n   *     function () {\n   *       this.error('FROM is not a valid JQL query descriptor. Found')\n   *     }\n   *   ],\n   *\n   *   // Skip whitespace\n   *   [/\\s+/, function () {}],\n   *\n   *   // Common tokens\n   *   [/SELECT\\s{1,1000}/i, 'SELECT'],\n   *   [/DISTINCT\\s{1,1000}/i, 'DISTINCT'],\n   *   [/WHERE\\s{1,1000}/i, 'WHERE'],\n   *   [/ORDER BY\\s{1,1000}/i, 'ORDERBY']\n   * ])\n   * ```\n   */\n  constructor (grammar = []) {\n    if (grammar.length === 0) {\n      throw new Error('No grammaer rules specified.')\n    }\n\n    Object.defineProperties(this, {\n      statement: NGN.private(null),\n      rules: NGN.privateconst(grammar),\n\n      PROTECTED: NGN.privateconst({\n        lexer: new NGN.UTILITY.Lexer(),\n        activeText: null,\n        orderedList: new Set()\n      })\n    })\n\n    // Add rules\n    for (let i = 0; i < this.rules.length; i++) {\n      this.PROTECTED.lexer.addRule(this.rules[i][0], this.rules[i][1])\n    }\n\n    return this\n  }\n\n  /**\n   * @property {string} text\n   * The text being \"tokenized\".\n   */\n  get text () {\n    return this.PROTECTED.activeText\n  }\n\n  /**\n   * @property {Array} orderedTokenList\n   * An ordered list of tokens as they appear within the text.\n   *\n   * **Example Result:**\n   *\n   * ```js\n   * [{\n   *   column: 1,\n   *   index: 0,\n   *   input: 'original string',\n   *   length: 15,\n   *   line: 4,\n   *   token: 'mytoken'\n   * }, {\n   *   ...\n   * }]\n   * ```\n   */\n  get orderedTokenList () {\n    return Array.from(this.PROTECTED.orderedList).map(item => item.detail)\n  }\n\n  /**\n   * Parses text to generate a token list.\n   * @param  {string} text\n   * The text to parse.\n   * @param  {Boolean} [suppressXOF=true]\n   * By default, `BOF` (Beginning of File) and `EOF` (End of File) tokens are\n   * suppressed. Set this to `false` to enable them.\n   * @return {Array}\n   * Returns an array of tokens.\n   *\n   * **Example Result:**\n   *\n   * ```js\n   * [{\n   *   column: 1,\n   *   index: 0,\n   *   input: 'original string',\n   *   length: 15,\n   *   line: 4,\n   *   token: 'mytoken'\n   * }, {\n   *   ...\n   * }]\n   * ```\n   */\n  parse (text, ignoreXOF = true) {\n    if (!NGN.coalesce(text) || typeof text !== 'string') {\n      throw new Error('Cannot parse empty string or non-string.')\n    }\n\n    this.PROTECTED.activeText = text\n\n    let tokens = {}\n    let token\n\n    this.PROTECTED.lexer.input = text\n    this.PROTECTED.orderedList.clear()\n\n    while (token = this.PROTECTED.lexer.next()) { // eslint-disable-line no-cond-assign\n      if (!ignoreXOF || (token !== 'BOF' && token !== 'EOF')) {\n        tokens[token] = NGN.coalesce(tokens[token], [])\n\n        tokens[token].push({\n          line: this.PROTECTED.lexer.currentLine,\n          column: this.PROTECTED.lexer.currentColumn,\n          length: this.PROTECTED.lexer.currentLength,\n          index: this.PROTECTED.lexer.index - this.PROTECTED.lexer.currentLength,\n          input: this.PROTECTED.lexer.statement.substr(this.PROTECTED.lexer.index - this.PROTECTED.lexer.currentLength, this.PROTECTED.lexer.currentLength)\n        })\n\n        const index = tokens[token].length - 1\n\n        this.PROTECTED.orderedList.add({\n          index: index,\n          token: token,\n          get detail () {\n            return Object.assign(tokens[this.token][this.index], {token: this.token})\n          }\n        })\n      }\n    }\n\n    return tokens\n  }\n}\n","/**\n * @class NGN.UTILITY.Set\n * Provides advanced features for [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\n * objects.\n */\nexport default class NGNSet { // eslint-disable-line\n  /**\n   * Indicates the subset is wholly contained within the main set.\n   * @param  {Set}  mainset\n   * @param  {Set}  subset\n   * @return {Boolean}\n   */\n  static isSuperSet (mainset, subset) {\n    if (subset.size > mainset.size || subset.size === 0) {\n      return false\n    }\n\n    let elements = mainset.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      if (!mainset.has(element.value)) {\n        return false\n      }\n\n      element = elements.next()\n    }\n\n    return true\n  }\n\n  /**\n   * Join any number of sets together into a single aggregate set.\n   * Only unique values will be added.\n   * Accepts any number of Set arguments.\n   * @return {Set}\n   */\n  static concat () {\n    let aggregate = new Set(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      let elements = arguments[i].values()\n      let element = elements.next()\n\n      while (!element.done) {\n        aggregate.add(element.value)\n        element = elements.next()\n      }\n    }\n\n    return aggregate\n  }\n\n  /**\n   * Identify the intersection/overlap between two sets.\n   * @param  {Set} setA\n   * @param  {Set} setB\n   * @return {Set}\n   * Returns a Set containing the common elements of setA and setB.\n   */\n  static intersection (setA, setB) {\n    let intersection = new Set()\n    let a = setA.size < setB.size ? setA : setB\n    let b = setA.size < setB.size ? setB : setA\n    let elements = a.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      if (b.has(element.value)) {\n        intersection.add(element.value)\n      }\n\n      element = elements.next()\n    }\n\n    return intersection\n  }\n\n  /**\n   * Identify the elements that are NOT part of both sets.\n   * @param  {Set} setA\n   * @param  {Set} setB\n   * @return {Set}\n   * Returns a set containing elements that are NOT common between setA and setB.\n   */\n  static difference (setA, setB) {\n    let diff = new Set(setA)\n    let elements = setB.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      diff.delete(element.value)\n      element = elements.next()\n    }\n\n    return diff\n  }\n\n  /**\n   * Determines whether two sets contain the same values.\n   * @param  {Set} setA\n   * @param  {Set} setB\n   * @return {Boolean}\n   */\n  static equal (setA, setB) {\n    return NGN.UTILITY.Set.difference(setA, setB).size === 0\n  }\n\n  static equals () {\n    NGN.WARN('NGN.UTILITY.Set.equals() should be equal() (no s at the end).')\n    NGN.UTILITY.Set.equal(...arguments)\n  }\n\n  /**\n   * A convenience method for appending the Set prototype with all\n   * of the methods in this utility, where the first argument of\n   * each method automatically refers to the Set.\n   * @private\n   */\n  static applyAll () {\n    Set.prototype.isSuperSet = function (subset) { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.isSuperSet(this, subset)\n    }\n\n    Set.prototype.concat = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.concat(this, ...arguments)\n    }\n\n    Set.prototype.intersection = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.intersection(this, ...arguments)\n    }\n\n    Set.prototype.difference = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.difference(this, ...arguments)\n    }\n\n    Set.prototype.equals = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.equal(this, ...arguments)\n    }\n  }\n}\n","let hostname\n/* node-only */\nhostname = require('os').hostname() // eslint-disable-line comma-style\n/* end-node-only */\n/* browser-only */\nhostname = window.location.host // eslint-disable-line comma-style\n/* end-browser-only */\n\n// CONSTANTS USED INTERNALLY\n// Normalize URL syntax\nconst normalizeUrl = function (url) { // eslint-disable-line no-unused-vars\n  let uri = []\n\n  url = url.split('/')\n\n  for (let i = 0; i < url.length; i++) {\n    if (url[i] === '..') {\n      uri.pop()\n    } else if (url[i] !== '.') {\n      uri.push(url[i])\n    }\n  }\n\n  uri = uri.join('/').replace(/:\\/{3,50}/gi, '://')\n\n  // Handle query parameter normalization\n  let match = /(.*:\\/\\/.*)[?](.*)/.exec(uri)\n  let path = match === null ? uri : match[1]\n  let queryString = match !== null ? match[2] : ''\n\n  uri = path\n\n  if (queryString.trim().length > 0) {\n    let params = {}\n\n    queryString.split('&').forEach(attr => {\n      let keypair = attr.split('=')\n      params[keypair[0]] = keypair.length > 1 ? keypair[1] : null\n    })\n\n    queryString = []\n    Object.keys(params).forEach((param, i) => {\n      queryString.push(`${param}${params[param] !== null ? '=' + encodeURIComponent(params[param]) : ''}`)\n    })\n\n    uri = `${uri}?${queryString.join('&')}`\n  }\n\n  return uri\n}\n\nlet networkInterfaces = [\n  '127.0.0.1'\n  , 'localhost' // eslint-disable-line comma-style\n  /* node-only */\n  , require('os').hostname() // eslint-disable-line comma-style\n  /* end-node-only */\n  /* browser-only */\n  , window.location.host // eslint-disable-line comma-style\n  /* end-browser-only */\n]\n\n/* node-only */\n// Retreive local IP's and hostnames\nlet data = require('os').networkInterfaces()\nlet interfaces = Object.keys(data)\n\nfor (let i = 0; i < interfaces.length; i++) {\n  let iface = data[interfaces[i]]\n\n  for (let x = 0; x < iface.length; x++) {\n    if (iface[x].family === 'IPv4') {\n      networkInterfaces.push(iface[x].address)\n    }\n  }\n}\n/* end-node-only */\n\nnetworkInterfaces = NGN.dedupe(networkInterfaces)\n\nconst HttpMethods = [ // eslint-disable-line no-unused-vars\n  'OPTIONS',\n  'HEAD',\n  'GET',\n  'POST',\n  'PUT',\n  'DELETE',\n  'TRACE',\n  'CONNECT'\n]\n\nexport { hostname, normalizeUrl, networkInterfaces, HttpMethods }\n","import { hostname, normalizeUrl, HttpMethods, networkInterfaces } from './utility'\n\n/**\n * @class NGN.NET.Request\n * Represents a network request. This class can be used\n * to create and manipulate HTTP requests, but it does not\n * actually transmit them. To send the request, use NGN.NET#request\n * or one of the many common helper methods.\n * @private\n */\nexport default class Request { // eslint-disable-line no-unused-vars\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    // Require URL and HTTP method\n    NGN.objectRequires(cfg, 'url')\n\n    if (NGN.objectHasAny(cfg, 'form', 'json')) {\n      NGN.WARN('NET.Request', '\"form\" and \"json\" configuration properties are not valid. Use \"body\" instead.')\n    }\n\n    Object.defineProperties(this, {\n      UrlPattern: NGN.privateconst(new RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?')),\n\n      /**\n       * @cfgproperty {string} url (required)\n       * The complete URL for the request, including query parameters.\n       */\n      uri: NGN.private(null),\n\n      /**\n       * @cfg {string} [method=GET]\n       * The HTTP method to invoke when the request is sent. The standard\n       * RFC 2616 HTTP methods include:\n       *\n       * - OPTIONS\n       * - HEAD\n       * - GET\n       * - POST\n       * - PUT\n       * - DELETE\n       * - TRACE\n       * - CONNECT\n       *\n       * There are many additional non-standard methods some remote hosts\n       * will accept, including `PATCH`, `COPY`, `LINK`, `UNLINK`, `PURGE`,\n       * `LOCK`, `UNLOCK`, `VIEW`, and many others. If the remote host\n       * supports these methods, they may be used in an NGN.NET.Request.\n       * Non-standard methods will not be prevented, but NGN will trigger\n       * a warning event if a non-standard request is created.\n       */\n      httpmethod: NGN.private(null),\n\n      /**\n       * @cfg {boolean} [enforceMethodSafety=true]\n       * According to [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html),\n       * some HTTP methods are considered idempotent (safe). These methods\n       * should have no significance to data (i.e. read-only). For example,\n       * `OPTIONS`, `HEAD`, and `GET` are all idempotent. By default, NGN.NET\n       * loosely enforces idempotence by ignoring the #body when making a\n       * request. While it is not advised, nor officially supported, NGN.NET can\n       * technically ignore method safety, allowing a request body to be\n       * sent to a remote server. Set this configuration to `false` to\n       * prevent NGN.NET from enforcing idempotence/safety.\n       */\n      enforceMethodSafety: NGN.private(NGN.coalesce(cfg.enforceMethodSafety, cfg.enforcemethodsafety, true)),\n\n      /**\n       * @cfg {object} [headers]\n       * Optionally supply custom headers for the request. Most standard\n       * headers will be applied automatically (when appropriate), such\n       * as `Content-Type`, `Content-Length`, and `Authorization`.\n       * In Node-like environments, a `User-Agent` will be applied containing\n       * the `hostname` of the system making the request. Any custom headers\n       * supplied will override headers managed by NGN.NET.\n       */\n      headers: NGN.public(NGN.coalesceb(cfg.headers)),\n\n      /**\n       * @cfg {object|string|binary} [body]\n       * The body configuration supports text, an object, or a data URL or\n       * binary content. **For multi-part form data (file uploads), use\n       * the #files configuration _instead_ of this attribute.**\n       *\n       * It is also possible to construct a simple form submission\n       * (x-www-form-urlencoded) from a specially formatted key/value object\n       * conforming to the following syntax:\n       *\n       * ```json\n       * {\n       *   form: {\n       *     form_field_1: \"value\",\n       *     form_field_2: \"value\",\n       *     form_field_3: \"value\",\n       *   }\n       * }\n       * ```\n       * The object above will be automatically converted & url-encoded as:\n       *\n       * ```js\n       * form_field_1=value&form_field_2=value&form_field_3=value\n       * ```\n       *\n       * The appropriate request headers are automatically applied.\n       */\n      requestbody: NGN.public(NGN.coalesce(cfg.body)),\n\n      /**\n       * @cfgproperty {string} username\n       * A username to authenticate the request with (basic auth).\n       */\n      user: NGN.private(NGN.coalesceb(cfg.username)),\n\n      /**\n       * @cfgproperty {string} password\n       * A password to authenticate the request with (basic auth).\n       * @readonly\n       */\n      secret: NGN.private(NGN.coalesceb(cfg.password)),\n\n      /**\n       * @cfgproperty {string} accessToken\n       * An access token to authenticate the request with (Bearer auth).\n       * If this is configured, it will override any basic auth settings.\n       */\n      bearerAccessToken: NGN.private(NGN.coalesceb(cfg.accessToken)),\n\n      /**\n       * @cfgproperty {boolean} [withCredentials=false]\n       * Indicates whether or not cross-site `Access-Control` requests should\n       * be made using credentials such as cookies, authorization headers or\n       * TLS client certificates. Setting `withCredentials` has no effect on\n       * same-site requests.\n       *\n       * In addition, this flag is also used to indicate when cookies are to\n       * be ignored in the response. The default is `false`. XMLHttpRequest\n       * from a different domain cannot set cookie values for their own\n       * domain unless `withCredentials` is set to true before making the\n       * request. The third-party cookies obtained by setting `withCredentials`\n       * to true will still honor same-origin policy and hence can not be\n       * accessed by the requesting script through\n       * [document.cookie](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie)\n       * or from response headers.\n       */\n      withCredentials: NGN.private(NGN.coalesce(cfg.withCredentials, false)),\n\n      /**\n       * @cfgproperty {Number} [timeout=30000]\n       * The number of milliseconds to wait before considering the request to\n       * have timed out. Defaults to `30000` (30 seconds).\n       */\n      timeout: NGN.public(NGN.coalesce(cfg.timeout, 30000)),\n\n      /**\n       * @method timer\n       * A placeholder for a timeout monitor.\n       * @private\n       */\n      timer: NGN.private(null),\n\n      /**\n       * @method isCrossOrigin\n       * Determine if accessing a URL is considered a cross origin request.\n       * @param {string} url\n       * The URL to identify as a COR.\n       * @returns {boolean}\n       * @private\n       */\n      isCrossOrigin: NGN.privateconst(function (url) {\n        /* node-only */\n        if (networkInterfaces.indexOf(this.host) < 0) {\n          return true\n        }\n        /* end-node-only */\n\n        return this.host !== hostname // eslint-disable-line no-undef\n      }),\n\n      /**\n       * @method applyAuthorizationHeader\n       * Generates and applies the authorization header for the request,\n       * based on the presence of #username, #password, or #accessToken.\n       * @private\n       */\n      applyAuthorizationHeader: NGN.privateconst(() => {\n        if (NGN.coalesceb(this.bearerAccessToken) !== null) {\n          this.setHeader('Authorization', `Bearer ${this.bearerAccessToken}`, true)\n        } else if (NGN.coalesceb(this.user) && NGN.coalesceb(this.secret)) {\n          this.setHeader('Authorization', this.basicAuthToken(this.user, this.secret), true)\n        }\n      }),\n\n      /**\n       * @method basicAuthToken\n       * Generates a basic authentication token from a username and password.\n       * @return {[type]} [description]\n       * @private\n       */\n      basicAuthToken: NGN.privateconst((user, secret) => {\n        // Binary to base64-ascii conversions\n        /* node-only */\n        return 'Basic ' + Buffer.from(`${user}:${secret}`, 'binary').toString('base64')\n        /* end-node-only */\n        /* browser-only */\n        return 'Basic ' + NGN.global.btoa(`${user}:${secret}`) // eslint-disable-line no-unreachable\n        /* end-browser-only */\n      }),\n\n      /**\n       * @method parseUri\n       * Parses the URI into composable parts.\n       * @param {string} URL\n       * The URI/URL to parse.\n       * @return {Object}\n       * Returns a key/value object:\n       *\n       * ```js\n       * {\n       *   protocol: 'http',\n       *   hostname: 'domain.com',\n       *   path: '/path/to/file.html',\n       *   query: 'a=1&b=2',\n       *   hash: null\n       * }\n       * ```\n       * @private\n       */\n      parseUri: NGN.privateconst(uri => {\n        let part = uri.match(this.UrlPattern)\n        let protocol\n        /* node-only */\n        protocol = 'http'\n        /* end-node-only */\n        /* browser-only */\n        protocol = window.location.protocol.replace(':', '').toLowerCase()\n        /* end-browser-only */\n        let url = {\n          protocol: NGN.coalesce(part[2], protocol),\n          hostname: NGN.coalesce(part[4], hostname),\n          path: NGN.coalesceb(part[5], '/'),\n          query: NGN.coalesceb(part[7]),\n          hash: NGN.coalesceb(part[9])\n        }\n\n        // URL contains a username/password.\n        if (url.hostname.indexOf('@') > 0) {\n          let credentials = uri.match(/^.*\\/{1,2}(.*):(.*)@/i)\n\n          url.hostname = url.hostname.split('@').pop()\n\n          this.user = credentials[1]\n          this.secret = credentials[2]\n          this.applyAuthorizationHeader()\n        }\n\n        url.port = NGN.coalesce(url.hostname.match(/:([0-9]{1,6})/), url.protocol === 'https' ? 443 : 80)\n\n        if (url.hostname.indexOf(':') > 0) {\n          url.hostname = url.hostname.split(':')[0]\n        }\n\n        if (url.path.charAt(0) !== '/') {\n          url.path = `/${url.path}`\n        }\n\n        return url\n      }),\n\n      uriParts: NGN.private(null),\n\n      /**\n       * @cfgproperty {Number} [maxRedirects=10]\n       * Set the maximum number of redirects. There is a hard-cap of 25\n       * redirects to prevent cyclic requests (endless loop).\n       */\n      maximumRedirects: NGN.private(10),\n      redirectAttempts: NGN.private(0),\n\n      prepareBody: NGN.private(() => {\n        // Request body management\n        if (this.requestbody !== null) {\n          if (this.headers === null) {\n            this.headers = {}\n          }\n\n          let contentType = NGN.coalesceb(this.headers['Content-Type'], this.headers['content-type'], this.headers['Content-type'])\n\n          if (typeof this.requestbody === 'object') {\n            if (NGN.objectHasExactly(this.requestbody, 'form')) {\n              let form = this.requestbody.form\n              let keys = Object.keys(form)\n              let dataString = []\n\n              for (let i = 0; i < keys.length; i++) {\n                if (NGN.isFn(form[keys[i]])) {\n                  throw new Error('Invalid form data. Form data cannot be a complex data format such as an object or function.')\n                } else if (typeof form[keys[i]] === 'object') {\n                  dataString.push(`${keys[i]}=${encodeURIComponent(JSON.stringify(form[keys[i]]))}`)\n                } else {\n                  dataString.push(`${keys[i]}:${encodeURIComponent(form[keys[i]])}`)\n                }\n              }\n\n              this.requestbody = dataString.join('&')\n            } else {\n              this.requestbody = JSON.stringify(this.requestbody).trim()\n              this.setHeader('Content-Length', this.requestbody.length, false)\n              this.setHeader('Content-Type', NGN.coalesceb(contentType, 'application/json'), false)\n            }\n          }\n\n          if (typeof this.requestbody === 'string') {\n            if (contentType !== null) {\n              // Check for form data\n              let match = /([^=]+)=([^&]+)/.exec(this.requestbody)\n\n              if (match !== null && this.requestbody.trim().substr(0, 5).toLowerCase() !== 'data:' && this.requestbody.trim().substr(0, 1).toLowerCase() !== '<') {\n                this.setHeader('Content-Type', 'application/x-www-form-urlencoded', false)\n              } else {\n                this.setHeader('Content-Type', 'text/plain')\n\n                if (this.requestbody.trim().substr(0, 5).toLowerCase() === 'data:') {\n                  // Crude Data URL mimetype detection\n                  match = /^data:(.*);/gi.exec(this.requestbody.trim())\n\n                  if (match !== null) {\n                    this.setHeader('Content-Type', match[1])\n                  }\n                } else if (/^<\\?xml.*/gi.test(this.requestbody.trim())) {\n                  // Crude XML Detection\n                  this.setHeader('Content-Type', 'application/xml')\n                } else if (/^<html.*/gi.test(this.requestbody.trim())) {\n                  // Crude HTML Detection\n                  this.setHeader('Content-Type', 'text/html')\n                }\n              }\n            }\n\n            this.setHeader('Content-Type', this.requestbody.length, false)\n          } else {\n            NGN.WARN('NET.Request.body', `The request body must cannot be ${typeof this.requestbody}. Please provide a string, object, or binary value for the body.`)\n          }\n        }\n      })\n    })\n\n    if (cfg.maxRedirects) {\n      this.maxRedirects = cfg.maxRedirects\n    }\n\n    this.url = cfg.url\n    this.method = NGN.coalesceb(cfg.method, 'GET')\n\n    this.prepareBody()\n\n    // Apply authorization if applicable\n    if (NGN.coalesce(this.user, this.secret, this.bearerAccessToken) !== null) {\n      this.applyAuthorizationHeader()\n    }\n  }\n\n  get maxRedirects () {\n    return this.maximumRedirects\n  }\n\n  set maxRedirects (value) {\n    if (value > 25) {\n      value = 25\n    }\n\n    if (value < 0) {\n      value = 0\n    }\n\n    this.maximumRedirects = value\n  }\n\n  /**\n   * @property {string} protocol\n   * The protocol used to make the request.\n   * @readonly\n   */\n  get protocol () {\n    return NGN.coalesce(this.uriParts.protocol, 'http')\n  }\n\n  /**\n   * @property {string} host\n   * The hostname/domain of the request.\n   */\n  get host () {\n    return NGN.coalesce(this.uriParts.hostname)\n  }\n\n  get hostname () {\n    return this.host\n  }\n\n  /**\n   * @property {number} port\n   * The port of the remote host.\n   */\n  get port () {\n    return this.uriParts.port\n  }\n\n  /**\n   * @property {string} path\n   * The pathname of the URL.\n   */\n  get path () {\n    return NGN.coalesce(this.uriParts.path, '/')\n  }\n\n  /**\n   * @property {string} query\n   * The raw query string of the URI. To retrieve a key/value list,\n   * use #queryParameters instead.\n   */\n  get query () {\n    return NGN.coalesce(this.uriParts.query, '')\n  }\n\n  /**\n   * @property {object} queryParameters\n   * Returns a key/value object containing the URL query parameters of the\n   * request, as defined in the #url. The paramter values (represented as keys\n   * in this object) may be modified, but not removed (use removeQueryParameter\n   * to delete a query parameter). No new query parameters can be added (use\n   * setQueryParameter instead).\n   * @readonly\n   */\n  get queryParameters () {\n    let params = this.query.split('&')\n    let resultSet = {}\n\n    for (let i = 0; i < params.length; i++) {\n      let keypair = params[i].split('=')\n      let attr = `__qp__${keypair[0]}__qp__`\n\n      Object.defineProperty(resultSet, attr, {\n        enumerable: false,\n        configurable: false,\n        writable: true,\n        value: NGN.coalesceb(keypair[1])\n      })\n\n      Object.defineProperty(resultSet, keypair[0], {\n        enumerable: true,\n        configurable: false,\n        get: () => { return resultSet[attr] },\n        set: (value) => {\n          resultSet[attr] = value\n          this.setQueryParameter(keypair[0], value, true)\n        }\n      })\n    }\n\n    return resultSet\n  }\n\n  /**\n   * @property hash\n   * The hash part of the URL (i.e. everything after the trailing `#`).\n   */\n  get hash () {\n    return NGN.coalesce(this.uriParts.hash, '')\n  }\n\n  /**\n   * @property {string} url\n   * The URL where the request will be sent.\n   */\n  get url () {\n    return this.uri\n  }\n\n  set url (value) {\n    if (NGN.coalesceb(value) === null) {\n      NGN.WARN('NET.Request.url', 'A blank URL was identified for a request.')\n    }\n\n    this.uri = normalizeUrl(value.trim())\n    this.uriParts = this.parseUri(this.uri)\n  }\n\n  get method () {\n    return this.httpmethod\n  }\n\n  set method (value) {\n    if (this.httpmethod === value) {\n      return\n    }\n\n    if (NGN.coalesceb(value) === null) {\n      NGN.WARN('NET.Request.method', 'No HTTP method specified.')\n    }\n\n    value = value.trim().toUpperCase()\n\n    if (HttpMethods.indexOf(value) < 0) {\n      NGN.WARN('NET.Request.method', `A non-standard HTTP method was recognized in a request: ${value}.`)\n    }\n\n    this.httpmethod = value\n  }\n\n  get body () {\n    return this.requestbody\n  }\n\n  set body (value) {\n    this.requestbody = value\n    this.prepareBody()\n  }\n\n  /**\n   * @property {boolean} crossOriginRequest\n   * Indicates the request will be made to a domain outside of the\n   * one hosting the request.\n   */\n  get crossOriginRequest () {\n    return this.isCrossOrigin(this.uri)\n  }\n\n  /**\n   * @property {string} username\n   * The username that will be used in any basic authentication operations.\n   */\n  get username () {\n    return NGN.coalesce(this.user)\n  }\n\n  set username (user) {\n    user = NGN.coalesceb(user)\n\n    if (this.user !== user) {\n      this.user = user\n\n      if (NGN.coalesceb(this.secret) !== null) {\n        this.applyAuthorizationHeader()\n      }\n    }\n  }\n\n  /**\n   * @property {string} password\n   * It is possible to set a password for any basic authentication operations,\n   * but it is not possible to read a password.\n   * @writeonly\n   */\n  set password (secret) {\n    secret = NGN.coalesceb(secret)\n\n    if (this.secret !== secret) {\n      this.secret = secret\n\n      if (NGN.coalesceb(this.user) !== null) {\n        this.applyAuthorizationHeader()\n      }\n    }\n  }\n\n  /**\n   * @property {string} accessToken\n   * Supply a bearer access token for basic authenticaiton operations.\n   * @writeonly\n   */\n  set accessToken (token) {\n    token = NGN.coalesceb(token)\n\n    if (this.bearerAccessToken !== token) {\n      this.bearerAccessToken = token\n      this.applyAuthorizationHeader()\n    }\n  }\n\n  /**\n   * @method setHeader\n   * Add a header to the request.\n   * @param {string} header\n   * The name of the header.\n   * @param {string} value\n   * Value of the header.\n   * @param {Boolean} [overwriteExisting=true]\n   * If the header already exists, setting this to `false` will prevent\n   * the original header from being overwritten.\n   */\n  setHeader (key, value, overwriteExisting = true) {\n    key = key.replace(/'|\"/gi, '').toLowerCase()\n\n    if (this.headers === null || this.headers[key] === undefined || overwriteExisting) {\n      if (this.headers === null) {\n        this.headers = {}\n      }\n\n      this.headers[key] = value\n    }\n  }\n\n  /**\n   * @method getHeader\n   * @param  {string} header\n   * The name of the header to retrieve.\n   * @return {string}\n   * Returns the current value of the specified header.\n   */\n  getHeader (key) {\n    if (this.headers === null) {\n      return undefined\n    }\n\n    if (!this.headers.hasOwnProperty(key.toLowerCase())) {\n      return undefined\n    }\n\n    return this.headers[key.toLowerCase()]\n  }\n\n  /**\n   * @method removeHeader\n   * Removes a header from the request. Nothing happens if the header does\n   * not exist.\n   * @param  {string} header\n   * The header to remove.\n   */\n  removeHeader (key) {\n    if (this.headers !== null) {\n      delete this.headers[key.toLowerCase()]\n      delete this.headers[key]\n    }\n  }\n\n  /**\n   * @method setQueryParameter\n   * Add a query parameter to the request.\n   * @param {string} parameter\n   * The name of the parameter.\n   * @param {string} value\n   * Value of the parameter. The value is automatically URL encoded. If the\n   * value is null, only the key will be added to the URL (ex: `http://domain.com/page.html?key`)\n   * @param {Boolean} [overwriteExisting=true]\n   * If the parameter already exists, setting this to `false` will prevent\n   * the original parameter from being overwritten.\n   */\n  setQueryParameter (key, value, overwriteExisting = true) {\n    let re = new RegExp(\"^.*(\\\\?|&)(\" + key + \".*)(&.*)$|^.*(\\\\?|&)(\" + key + \".*)$\", 'i') // eslint-disable-line quotes\n    let exists = (re.exec(this.uri) !== null)\n    let match\n\n    if (exists) {\n      if (!overwriteExisting) {\n        return\n      }\n\n      match = re.exec(this.uri)\n\n      if (match !== null) {\n        this.url = this.uri.replace(`${NGN.coalesceb(match[5], match[2])}`, `${key}${value !== null ? '=' + encodeURIComponent(value) : ''}`)\n      }\n    } else {\n      this.url = `${this.uri}${this.query.length === 0 ? '?' : '&'}${key}${value !== null ? '=' + encodeURIComponent(value) : ''}`\n    }\n  }\n\n  /**\n   * @method removeQueryParameter\n   * Remove a query parameter from the request URI.\n   * @param {string} key\n   */\n  removeQueryParameter (key) {\n    this.url = this.uri.replace(new RegExp(`${key}=(.[^&]+)|\\\\?${key}|&${key}`, 'gi'), '')\n  }\n\n  startMonitor () {\n    if (this.timer === null) {\n      this.timer = setTimeout(() => {\n        throw new Error('Timed out retrieving ' + this.url)\n      }, this.timeout)\n    }\n  }\n\n  stopMonitor () {\n    clearTimeout(this.timer)\n    this.timer = null\n  }\n\n  /**\n   * @method send\n   * Send the request.\n   * @param {Function} callback\n   * The callback is executed when the request is complete.\n   * @param {Object} callback.response\n   * The response object returned by the server.\n   */\n  send (callback) {\n    let body = this.body\n\n    // Disable body when safe methods are enforced.\n    if (NGN.coalesce(body)) {\n      if (this.enforceMethodSafety && 'OPTIONS|HEAD|GET'.indexOf(this.method) >= 0) {\n        body = null\n      }\n    }\n\n    /* node-only */\n    // Run request in Node-like environments\n    // Support local file system retrieval in node-like environments.\n    // This short-circuits the request and reads the file system instead.\n    if (this.protocol === 'file') {\n      if (!NGN.isFn(callback)) {\n        throw new Error('A callback is required when retrieving system files in a node-like environment.')\n      }\n\n      let response = {\n        status: require('fs').existsSync(this.uri.replace('file://', '')) ? 200 : 400\n      }\n\n      response.responseText = response.status === 200 ? require('fs').readFileSync(this.uri.replace('file://', '')).toString() : 'File does not exist or could not be found.'\n\n      return callback(response)\n    }\n\n    const http = this.protocol === 'https' ? require('https') : require('http')\n\n    let params = NGN.coalesceb(this.query)\n    let reqOptions = {\n      hostname: this.hostname,\n      port: this.port,\n      method: this.method,\n      headers: this.headers,\n      path: this.path\n    }\n\n    if (params !== null) {\n      reqOptions.path = `${this.path}?${params}`\n    }\n\n    const req = http.request(reqOptions, (response) => {\n      response.setEncoding('utf8')\n\n      let body = ''\n      response.on('data', (chunk) => {\n        body += chunk\n      })\n\n      response.on('end', () => {\n        switch (response.statusCode) {\n          case 301:\n          case 302:\n          case 307:\n          case 308:\n            if (this.redirectAttempts > this.maxRedirects) {\n              this.redirectAttempts = 0\n\n              this.stopMonitor()\n\n              return callback({ // eslint-disable-line standard/no-callback-literal\n                status: 500,\n                statusText: 'Too many redirects',\n                responseText: 'Too many redirects',\n                responseXML: 'Too many redirects',\n                readyState: 4\n              })\n            }\n\n            if (response.headers.location === undefined) {\n              this.stopMonitor()\n\n              return callback({ // eslint-disable-line standard/no-callback-literal\n                status: 502,\n                statusText: 'Bad Gateway',\n                responseText: 'Bad Gateway',\n                responseXML: 'Bad Gateway',\n                readyState: 4\n              })\n            }\n\n            this.redirectAttempts++\n            this.url = response.headers.location\n\n            return this.send(callback)\n\n          default:\n            this.stopMonitor()\n\n            return callback({ // eslint-disable-line standard/no-callback-literal\n              status: response.statusCode,\n              statusText: NGN.coalesce(response.statusText),\n              responseText: body,\n              responseXML: body,\n              readyState: 4\n            })\n        }\n      })\n    })\n\n    req.on('error', (err) => {\n      this.stopMonitor()\n\n      if (NGN.isFn(callback)) {\n        callback({ // eslint-disable-line standard/no-callback-literal\n          status: 400,\n          statusText: err.message,\n          responseText: err.message,\n          responseXML: err.message,\n          readyState: 0\n        })\n      } else {\n        throw err\n      }\n    })\n\n    this.startMonitor()\n\n    if (this.body) {\n      req.write(this.body)\n    }\n\n    req.end()\n    /* end-node-only */\n    /* browser-only */\n    let xhr = new XMLHttpRequest()\n    let responded = false\n    let me = this\n\n    // Apply readystate change handler\n    xhr.onreadystatechange = function () {\n      if (responded) {\n        return\n      }\n\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        responded = true\n\n        if (xhr.status === 0) {\n          NGN.WARN(`Request Error: ${me.method} ${me.url} (likely a CORS issue).`)\n        }\n\n        if (NGN.isFn(callback)) {\n          callback(xhr)\n        }\n      }\n    }\n\n    // Apply error handler\n    xhr.onerror = function (e) {\n      NGN.WARN('NET.error', e)\n\n      if (!responded && NGN.isFn(callback)) {\n        callback(xhr)\n      }\n\n      responded = true\n    }\n\n    xhr.ontimeout = function (e) {\n      responded = true\n      callback(xhr)\n    }\n\n    xhr.timeout = this.timeout\n\n    // Open the request\n    xhr.open(this.method, this.url, true)\n\n    // Apply withCredentials\n    xhr.withCredentials = this.withCredentials\n\n    // Apply Request Headers\n    if (this.headers !== null) {\n      let headers = Object.keys(this.headers)\n      for (let i = 0; i < headers.length; i++) {\n        xhr.setRequestHeader(headers[i], this.headers[headers[i]])\n      }\n    }\n\n    // Write the body (which may be null) & send the request\n    xhr.send(body)\n    /* end-browser-only */\n  }\n}\n","import { hostname } from './utility'\nimport Request from './Request'\n\nexport default class Network { // eslint-disable-line\n  constructor () {\n    Object.defineProperties(this, {\n      /**\n       * @method parseRequestConfiguration\n       * Prepare common configuration attributes for a request.\n       * @return {NGN.NET.Request}\n       * @private\n       */\n      parseRequestConfiguration: NGN.private((cfg, method = 'GET') => {\n        if (typeof cfg === 'string') {\n          cfg = {\n            url: cfg\n          }\n        }\n\n        cfg = cfg || {}\n        cfg.method = method\n        cfg.url = NGN.coalesceb(cfg.url, hostname) // eslint-disable-line no-undef\n\n        return new NGN.NET.Request(cfg)\n      }),\n\n      // Returns a scoped method for sending the request, after preparing it.\n      makeRequest: NGN.private((method) => {\n        const me = this\n\n        return function () {\n          let args = NGN.slice(arguments)\n          let callback\n\n          if (NGN.isFn(args[args.length - 1])) {\n            callback = args.pop()\n          }\n\n          args.push(method)\n\n          let request = me.parseRequestConfiguration(...args)\n\n          // Send the request\n          me.send(request, callback)\n        }\n      }),\n\n      // Helper aliases (undocumented)\n      OPTIONS: NGN.privateconst(this.options.bind(this)),\n      HEAD: NGN.privateconst(this.head.bind(this)),\n      GET: NGN.privateconst(this.get.bind(this)),\n      POST: NGN.privateconst(this.post.bind(this)),\n      PUT: NGN.privateconst(this.put.bind(this)),\n      DELETE: NGN.privateconst(this.delete.bind(this)),\n      TRACE: NGN.privateconst(this.trace.bind(this)),\n      JSON: NGN.privateconst(this.json.bind(this)),\n      JSONP: NGN.privateconst(this.jsonp.bind(this))\n    })\n  }\n\n  get Request () {\n    return Request\n  }\n\n  /**\n   * @method request\n   * Send a request. In most cases, it is easier to use one of the built-in\n   * request functions (#get, #post, #put, #delete, #json, etc). This method\n   * is available for creating custom requests.\n   * @param  {Object} configuration\n   * Provide a #NGN.NET.Request configuration.\n   * @param  {Function} callback\n   * The callback to execute when the request is complete.\n   */\n  request (cfg, callback) {\n    cfg = cfg || {}\n    cfg.method = NGN.coalesceb(cfg.method, 'GET')\n\n    if (NGN.isFn(this[cfg.method])) {\n      this.makeRequest(cfg.method)(...arguments)\n    } else {\n      this.send(new NGN.NET.Request(cfg), callback)\n    }\n  }\n\n  /**\n   * @method options\n   * Issue a `OPTIONS` request.\n   * @param {string|object} url\n   * The URL to issue the request to, or a configuration object.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  options () {\n    this.makeRequest('OPTIONS').apply(this, arguments)\n  }\n\n  /**\n   * @method head\n   * Issue a `HEAD` request.\n   * @param {string|object} url\n   * The URL to issue the request to, or a configuration object.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  head () {\n    this.makeRequest('HEAD').apply(this, arguments)\n  }\n\n  /**\n   * @method get\n   * Issue a `GET` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  get () {\n    this.makeRequest('GET').apply(this, arguments)\n  }\n\n  /**\n   * @method post\n   * Issue a `POST` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  post () {\n    this.makeRequest('POST').apply(this, arguments)\n  }\n\n  /**\n   * @method put\n   * Issue a `PUT` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  put () {\n    this.makeRequest('PUT').apply(this, arguments)\n  }\n\n  /**\n   * @method delete\n   * Issue a `DELETE` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  delete () {\n    this.makeRequest('DELETE').apply(this, arguments)\n  }\n\n  /**\n   * @method trace\n   * Issue a `TRACE` request. This is a debugging method, which\n   * echoes input back to the user. It is a standard HTTP method,\n   * but considered a security risk by many practioners and may\n   * not be supported by remote hosts.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  trace () {\n    NGN.WARN('NGN.NET.Request.method', 'An HTTP TRACE request was made.')\n    this.makeRequest('TRACE').apply(this, arguments)\n  }\n\n  /**\n   * @method json\n   * This is a shortcut method for creating a `GET` request and\n   * auto-processing the response body into a JSON object.\n   * @param  {string} url\n   * The URL to issue the request to.\n   * @param  {Function} callback\n   * This receives a JSON response object from the server.\n   * @param {Error} callback.error\n   * If the request cannot be completed for any reason, this argument will be\n   * populated with the error. If the request is successful, this will be `null`.\n   * @param {Object} callback.data\n   * The JSON response from the remote URL.\n   */\n  json (url, callback) {\n    if (!NGN.isFn(callback)) {\n      throw new Error('NGN.NET.json requires a callback method.')\n    }\n\n    // Request method is \"GET\"\n    let request = this.parseRequestConfiguration({url})\n\n    this.preflight(request)\n\n    request.send((response) => {\n      try {\n        let responseData = JSON.parse(response.responseText)\n        callback(null, responseData)\n      } catch (e) {\n        e.response = NGN.coalesce(response.responseText)\n        callback(e, null)\n      }\n    })\n  }\n\n  /**\n   * @method jsonp\n   * Execute a request via JSONP. JSONP is only available in browser\n   * environments, since it's operation is dependent on the existance of\n   * the DOM. However; this may work with some headless browsers.\n   * @param {string} url\n   * The URL of the JSONP endpoint.\n   * @param {function} callback\n   * Handles the response.\n   * @param {Error} callback.error\n   * If an error occurred, this will be populated. If no error occurred, this will\n   * be null.\n   * @param {object|array} callback.response\n   * The response.\n   * @environment browser\n   */\n  jsonp (url, callback) {\n    /* node-only */\n    NGN.WARN('NET.Request', 'An unsupported JSONP request was made.')\n    callback(new Error('JSONP unsupported in Node-like environments.'))\n    /* end-node-only */\n    /* browser-only */\n    const fn = 'jsonp_callback_' + Math.round(100000 * Math.random())\n\n    window[fn] = (data) => {\n      delete window[fn]\n\n      document.body.removeChild(script)\n\n      return callback(null, data)\n    }\n\n    let script = document.createElement('script')\n\n    script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + fn\n\n    script.addEventListener('error', (e) => {\n      delete window[fn]\n\n      return callback(new Error('The JSONP request was blocked. This may be the result of an invalid URL, cross origin restrictions, or the remote server may not be online.'))\n    })\n\n    document.body.appendChild(script)\n    /* end-browser-only */\n  }\n\n  // Apply a preflight request option to the network request.\n  send (request, callback) {\n    this.preflight(request)\n    request.send(callback)\n  }\n\n  /**\n   * @method preflight\n   * This is a no-op method that runs before a request is sent.\n   * This exists specicially to be overridden by class extensions.\n   */\n  preflight (request) {}\n}\n","import Request from './Request'\nimport Network from './Network'\nimport Resource from './Resource'\nimport * as Utility from './utility'\n\n/**\n * @namespace NGN.NET\n * A library to issue HTTP/S requests.\n * This acts as an AJAX library.\n * @author Corey Butler\n * @singleton\n */\n\n// [INCLUDE: ./Request.js]\n// [INCLUDE: ./Network.js]\n// [INCLUDE: ./Resource.js]\n\n// NGN.extend('NET', NGN.const(new Network()))\n// NGN.NET.normalizeUrl = normalizeUrl\n\nNetwork.prototype.Resource = Resource\n\nconst normalizeUrl = Utility.normalizeUrl\nconst networkInterfaces = Utility.networkInterfaces\nconst Library = new Network()\n\nexport { Library, normalizeUrl, networkInterfaces, Request, Resource }\n\n// Network = null // eslint-disable-line\n// NetworkResource = null // eslint-disable-line\n","import Network from './Network'\nimport { hostname, normalizeUrl } from './utility'\n\n/**\n * @class NGN.NET.Resource\n * Represents a remote web resource, such as a backend web server or\n * an API server. This class inherits everything from NGN.NET, extending\n * it with customizable options for working with specific remote resources.\n *\n * This class was designed for use in applications where multiple requests\n * are made to multiple backends. For example, a common single page application\n * may make multiple requests for resources (media, templates, CSS, etc)\n * as well as multiple requests to an API server.\n *\n * For example:\n *\n * ```js\n * let server = new NGN.NET.Resource({\n *   credentials: {\n *     username: 'username',\n *     password: 'password'\n *   },\n *   headers: {\n *     'x-source': 'mydomain.com'\n *   }\n * })\n *\n * let API = new NGN.NET.Resource({\n *   credentials: {\n *     token: 'secret_token'\n *   },\n *   headers: {\n *     'user-agent': 'mobile'\n *   },\n *   baseUrl: 'https://api.mydomain.com'\n * })\n *\n * server.get('./templates/home.html', (response) => { ... })\n * API.json('/user', (data) => { ... })\n * ```\n *\n * Both `server` and `API` in the example above are instances of\n * NGN.NET. They each use different credentials to access the\n * remote endpoint, using different global headers and\n * a different base URL.\n *\n * This can be incredibly useful anytime a migration is required,\n * such as running code in dev ==> staging ==> production or\n * switching servers. It is also useful for creating connections\n * to different remote services, creating custom API clients,\n * and generally organizing/standardizing how an application connects\n * to remote resources.\n * @extends NGN.NET\n */\nexport default class NetworkResource extends Network {\n  constructor (cfg) {\n    super()\n\n    cfg = cfg || {}\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {object} headers\n       * Contains headers (key/value) that are applied to all requests.\n       */\n      globalHeaders: NGN.private(NGN.coalesceb(cfg.headers, {})),\n\n      /**\n       * @cfg {object} credentials\n       * Contains credentials that are applied to all requests.\n       * @private\n       */\n      globalCredentials: NGN.private(NGN.coalesceb(cfg.credentials, {})),\n\n      /**\n       * @cfg {string} username\n       * Use this to set a username (instead of using #credentials).\n       */\n      user: NGN.private(NGN.coalesceb(cfg.username)),\n\n      /**\n       * @cfg {string} password\n       * Use this to set a password (instead of using #credentials).\n       */\n      secret: NGN.private(NGN.coalesceb(cfg.password)),\n\n      /**\n       * @cfg {string} accessToken\n       * Use this to set an access token (instead of using #credentials).\n       */\n      accesstoken: NGN.private(NGN.coalesceb(cfg.token, cfg.accessToken)),\n\n      /**\n       * @cfg {object} query\n       * Contains query parameters to be applied to all requests. All values\n       * are automatically url-encoded.\n       */\n      globalQuery: NGN.private(NGN.coalesceb(cfg.query, {})),\n\n      /**\n       * @cfg {string} [baseUrl=window.loction.origin]\n       * The root domain/base URL to apply to all requests to relative URL's.\n       * This was designed for uses where a backend API may be served on\n       * another domain (such as api.mydomain.com instead of www.mydomain.com).\n       * The root will only be applied to relative paths that do not begin\n       * with a protocol. For example, `./path/to/endpoint` **will** have\n       * the root applied (`{root}/path/to/endpoint`) whereas `https://domain.com/endpoint`\n       * will **not** have the root applied.\n       */\n      baseUrl: NGN.private(NGN.coalesce(cfg.baseUrl, cfg.baseurl, `http://${hostname}/`)),\n\n      /**\n       * @cfg {boolean} [nocache=false]\n       * Set this to `true` to add a unique cache-busting URL parameter to all requests.\n       */\n      nocache: NGN.private(NGN.coalesce(cfg.nocache, false)),\n\n      /**\n       * @cfg {boolean} [sslonly=false]\n       * Set this to true to rewrite all URL's to use HTTPS.\n       */\n      sslonly: NGN.public(NGN.coalesce(cfg.sslonly, false))\n    })\n\n    if (this.baseUrl.indexOf('://') < 0 || this.baseUrl.indexOf('://') > 10) {\n      this.baseUrl = `http${this.sslonly ? 's' : ''}://${this.baseUrl}`\n    } else if (this.sslonly) {\n      this.baseUrl = this.baseUrl.replace('http://', 'https://')\n    }\n\n    if (this.accesstoken !== null) {\n      this.credentials = {\n        accessToken: this.accesstoken\n      }\n    } else if (this.user !== null && this.ssecret !== null) {\n      this.credentials = {\n        username: this.user,\n        password: this.secret\n      }\n    }\n  }\n\n  get username () {\n    return this.user\n  }\n\n  set username (value) {\n    if (this.user !== value) {\n      this.user = value\n\n      if (this.secret !== null) {\n        this.credentials = {\n          username: this.user,\n          password: this.secret\n        }\n      }\n    }\n  }\n\n  set password (value) {\n    if (this.secret !== value) {\n      this.secret = value\n\n      if (this.user !== null) {\n        this.credentials = {\n          username: this.user,\n          password: this.secret\n        }\n      }\n    }\n  }\n\n  /**\n   * @property {object} headers\n   * Represents the current global headers.\n   *\n   * This is commonly used when a remote resource requires a specific\n   * header on every call.\n   *\n   * **Example**\n   *\n   * ```js\n   * let resource = new NGN.NET.Resource(...)\n   *\n   * resource.headers = {\n   *   'user-agent': 'my custom agent name'\n   * }\n   * ```\n   */\n  get headers () {\n    return this.globalHeaders\n  }\n\n  set headers (value) {\n    this.globalHeaders = value\n  }\n\n  /**\n   * @property credentials\n   * Configure credentials that are applied to every request.\n   * This is commonly used when communicating with a RESTful API.\n   * This can accept a username and password or an access token.\n   *\n   * **Examples**\n   *\n   * ```js\n   *  let resource = new NGN.NET.Resource(...)\n   *\n   *  resource.credentials = {\n   *    username: 'user',\n   *    password: 'pass'\n   *  }\n   * ```\n   *\n   * ```js\n   * resource.credentials = {\n   *   accessToken: 'token'\n   * }\n   * ```\n   */\n  set credentials (credentials) {\n    if (credentials.hasOwnProperty('accesstoken') || credentials.hasOwnProperty('accessToken') || credentials.hasOwnProperty('token')) {\n      credentials.accessToken = NGN.coalesce(credentials.accessToken, credentials.accesstoken, credentials.token)\n\n      if (credentials.hasOwnProperty('username')) {\n        delete credentials.username\n      }\n\n      if (credentials.hasOwnProperty('password')) {\n        delete credentials.password\n      }\n    } else if (!(credentials.hasOwnProperty('username') && credentials.hasOwnProperty('password')) && !credentials.hasOwnProperty('accessToken')) {\n      throw new Error('Invalid credentials. Must contain an access token OR the combination of a username AND password.')\n    }\n\n    this.globalCredentials = credentials\n\n    if (credentials.username) {\n      this.username = credentials.username\n    }\n\n    if (credentials.password) {\n      this.password = credentials.password\n    }\n  }\n\n  // Explicitly deny credential reading.\n  get credentials () {\n    NGN.WARN('Credentials are write-only. An attempt to read credentials was denied.')\n    return {\n      username: null,\n      secret: null,\n      password: null,\n      accessToken: null\n    }\n  }\n\n  /**\n   * @property {object} query\n   * Represents the current global query paramaters.\n   *\n   * This is commonly used when a remote resource requires a specific\n   * query paramater on every call.\n   *\n   * **Example**\n   *\n   * ```js\n   * let resource = new NGN.NET.Resource(...)\n   *\n   * resource.query = {\n   *   'user_id': '12345'\n   * }\n   * ```\n   *\n   * All parameter values are automatically URL-encoded.\n   */\n  get query () {\n    return this.globalQuery\n  }\n\n  set query (value) {\n    this.globalQuery = value\n  }\n\n  /**\n   * @method prepareUrl\n   * Prepare a URL by applying the base URL (only when appropriate).\n   * @param  {string} uri\n   * The universal resource indicator (URI/URL) to prepare.\n   * @return {string}\n   * Returns a fully qualified URL.\n   * @private\n   */\n  prepareUrl (uri) {\n    if (uri.indexOf('://') < 0) {\n      uri = normalizeUrl(`${this.baseUrl}/${uri}`)\n    }\n\n    return uri.replace(/\\/{2,5}/gi, '/').replace(/:\\/{1}/i, '://')\n  }\n\n  /**\n   * @method preflight\n   * Prepares a request before it is sent.\n   * @param {NGN.NET.Request} request\n   * The request object.\n   * @private\n   */\n  preflight (request) {\n    // Apply the base URL\n    request.url = this.prepareUrl(request.url)\n\n    // If global query parameters have been defined, apply them.\n    let qp = Object.keys(this.globalQuery)\n    if (qp.length > 0) {\n      let queryString = []\n      for (let i = 0; i < qp.length; i++) {\n        queryString.push(`${qp[i]}=${encodeURIComponent(this.globalQuery[qp[i]])}`)\n      }\n\n      if (request.query === '') {\n        request.url = `${request.url}?${queryString.join('&')}`\n      } else {\n        request.url = `${request.url}&${queryString.join('&')}`\n      }\n    }\n\n    // If global credentials are available, apply them.\n    let gHeaders = Object.keys(this.globalHeaders)\n    for (let i = 0; i < gHeaders.length; i++) {\n      request.setHeader(gHeaders[i], this.globalHeaders[gHeaders[i]])\n    }\n\n    // If global headers/credentials are available, apply them.\n    if (this.globalCredentials.accessToken) {\n      request.accessToken = this.globalCredentials.accessToken\n    } else if (this.globalCredentials.username) {\n      request.username = this.globalCredentials.username\n      request.password = this.globalCredentials.password\n    }\n\n    // Add a cache buster\n    if (this.nocache) {\n      request.setQueryParameter('nocache' + (new Date()).getTime().toString() + Math.random().toString().replace('.', ''), null)\n    }\n  }\n}\n","/**\n * @ignore\n * Addition: ['+', path, value]\n * Deletion: ['-', path, oldValue]\n * Modified: ['m', path, oldValue, newValue]\n */\nexport default class ObjectDiff {\n  static compare (lhs, rhs, path = []) {\n    let differences = []\n    let ltype = NGN.typeof(lhs)\n    let rtype = NGN.typeof(rhs)\n\n    // If the comparators aren't the same type, then\n    // it is a replacement. This is identified as\n    // removal of one object and creation of the other.\n    if (ltype !== rtype) {\n      return [\n        ['m', path, lhs, rhs]\n      ]\n    }\nconsole.log('Diffing:', ltype, lhs, rhs, 'PATH', path.join('.'))\n    switch (ltype) {\n      // case 'function':\n      //   if (lhs.toString() !== rhs.toString()) {\n      //     return ['m', path, lhs, rhs]\n      //   }\n      //\n      //   return []\n\n      case 'object':\n        let keys = Object.keys(lhs)\n        // let relativePath\n\n        // Compare left to right for modifications and removals\n        for (let i = 0; i < keys.length; i++) {\n          // Reset the relative path\n          let relativePath = Object.assign([], path)\n\n          relativePath.push(keys[i])\n\n          if (!rhs.hasOwnProperty(keys[i])) {\n            // If no right hand argument exists, it was removed.\n            differences.push(['-', relativePath, lhs[keys[i]]])\n          } else if (NGN.typeof(lhs[keys[i]]) === 'object') {\n            // Recursively compare objects\n            differences = differences.concat(this.compare(lhs[keys[i]], rhs[keys[i]], relativePath))\n          } else if (lhs[keys[i]] !== rhs[keys[i]]) {\n            if (NGN.typeof(lhs[keys[i]]) === 'array' && NGN.typeof(rhs[keys[i]]) === 'array') {\n              // If the keys contain arrays, re-run the comparison.\n              differences = differences.concat(this.compare(lhs[keys[i]], rhs[keys[i]], relativePath))\n            } else {\n              // If the comparators exist but are different, a\n              // modification ocurred.\n              differences.push(['m', relativePath, lhs[keys[i]], rhs[keys[i]]])\n            }\n          }\n        }\n\n        // Compare right to left for additions\n        keys = Object.keys(lhs)\n        keys.unshift(rhs)\n        keys = NGN.getObjectExtraneousPropertyNames.apply(this, keys)\n\n        for (let i = 0; i < keys.length; i++) {\n          // Reset the relative path\n          let relativePath = Object.assign([], path)\n          relativePath.push(keys[i])\n\n          differences.push(['+', relativePath, rhs[keys[i]]])\n        }\n\n        break\n\n      case 'array':\n        differences = this.compareArray(lhs, rhs)\n\n        break\n\n      case 'string':\n        console.log('TO DO: Add String Diff') // eslint-disable-line no-fallthrough\n\n      default:\n        if (lhs !== rhs) {\n          if (NGN.typeof(lhs) !== 'undefined' && NGN.typeof(rhs) === 'undefined') {\n            differences.push(['-', path, lhs])\n          } else if (NGN.typeof(lhs) === 'undefined' && NGN.typeof(rhs) !== 'undefined') {\n            differences.push(['+', path, rhs])\n          } else {\n            differences.push(['m', path, lhs, rhs])\n          }\n        }\n    }\n\n    return differences\n  }\n\n  compareArray (lhs, rhs) {\n    // if (lhs === rhs) {\n      return []\n    // }\n    //\n    // for (let i = 0; i < lhs.length; i++) {\n    //   if (false) {}\n    // }\n  }\n\n  static arraysHaveMatchByRef (array1, array2, len1, len2) {\n    for (let index1 = 0; index1 < len1; index1++) {\n      let val1 = array1[index1]\n\n      for (let index2 = 0; index2 < len2; index2++) {\n        let val2 = array2[index2]\n\n        if (index1 !== index2 && val1 === val2) {\n          return true\n        }\n      }\n    }\n  }\n\n  static matchItems (array1, array2, index1, index2, context) {\n    let value1 = array1[index1]\n    let value2 = array2[index2]\n\n    if (value1 === value2) {\n      return true\n    }\n\n    if (typeof value1 !== 'object' || typeof value2 !== 'object') {\n      return false\n    }\n\n    let objectHash = context.objectHash\n\n    if (!objectHash) {\n      // no way to match objects was provided, try match by position\n      return context.matchByPosition && index1 === index2\n    }\n\n    let hash1\n    let hash2\n\n    if (typeof index1 === 'number') {\n      context.hashCache1 = NGN.forceArray(context.hashCache1)\n      hash1 = context.hashCache1[index1]\n\n      if (typeof hash1 === 'undefined') {\n        context.hashCache1[index1] = hash1 = objectHash(value1, index1)\n      }\n    } else {\n      hash1 = objectHash(value1)\n    }\n\n    if (typeof hash1 === 'undefined') {\n      return false\n    }\n\n    if (typeof index2 === 'number') {\n      context.hashCache2 = NGN.forceArray(context.hashCache2)\n      hash2 = context.hashCache2[index2]\n\n      if (typeof hash2 === 'undefined') {\n        context.hashCache2[index2] = hash2 = objectHash(value2, index2)\n      }\n    } else {\n      hash2 = objectHash(value2)\n    }\n\n    if (typeof hash2 === 'undefined') {\n      return false\n    }\n\n    return hash1 === hash2\n  }\n\n  /*\n   * LCS implementation that supports arrays or strings\n   * reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n   * This code abstracted from Benjamn Eidelman's JSONDiffPatch (MIT).\n   */\n  static lcsDefaultMatch (array1, array2, index1, index2) {\n    return array1[index1] === array2[index2]\n  }\n\n  static lcsLengthMatrix (array1, array2, match, context) {\n    let len1 = array1.length\n    let len2 = array2.length\n    let x\n    let y\n\n    // initialize empty matrix of len1+1 x len2+1\n    let matrix = [len1 + 1]\n\n    for (x = 0; x < len1 + 1; x++) {\n      matrix[x] = [len2 + 1]\n\n      for (y = 0; y < len2 + 1; y++) {\n        matrix[x][y] = 0\n      }\n    }\n\n    matrix.match = match\n\n    // save sequence lengths for each coordinate\n    for (x = 1; x < len1 + 1; x++) {\n      for (y = 1; y < len2 + 1; y++) {\n        if (match(array1, array2, x - 1, y - 1, context)) {\n          matrix[x][y] = matrix[x - 1][y - 1] + 1\n        } else {\n          matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1])\n        }\n      }\n    }\n\n    return matrix\n  };\n\n  static lcsBacktrack (matrix, array1, array2, index1, index2, context) {\n    if (index1 === 0 || index2 === 0) {\n      return {\n        sequence: [],\n        indices1: [],\n        indices2: []\n      }\n    }\n\n    if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {\n      let subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context)\n\n      subsequence.sequence.push(array1[index1 - 1])\n      subsequence.indices1.push(index1 - 1)\n      subsequence.indices2.push(index2 - 1)\n\n      return subsequence\n    }\n\n    if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {\n      return backtrack(matrix, array1, array2, index1, index2 - 1, context)\n    } else {\n      return backtrack(matrix, array1, array2, index1 - 1, index2, context)\n    }\n  };\n\n  static lcsGet (array1, array2, match, context) {\n    context = context || {}\n\n    let matrix = lengthMatrix(array1, array2, match || defaultMatch, context)\n    let result = backtrack(matrix, array1, array2, array1.length, array2.length, context)\n\n    if (typeof array1 === 'string' && typeof array2 === 'string') {\n      result.sequence = result.sequence.join('')\n    }\n\n    return result\n  }\n}\n\n\n// class LCS {\n//\n// }\n","// Difference Utilities\nimport ObjectDiff from './DiffEngine'\n\n// CRC table for checksum (cached)\nlet crcTable = null\n\n/**\n * Generate the CRC table for checksums. This is a fairly complex\n * operation that should only be executed once and cached for\n * repeat use.\n */\nconst makeCRCTable = function () {\n  let c\n  let crcTable = []\n\n  for (let n = 0; n < 256; n++) {\n    c = n\n\n    for (let k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1))\n    }\n\n    crcTable[n] = c\n  }\n\n  return crcTable\n}\n\n/**\n * @class NGN.DATA.UTILITY\n * A utility library of functions relevant to data management.\n */\nexport default class Utility { // eslint-disable-line\n  static diff () {\n    return ObjectDiff.compare(...arguments) // eslint-disable-line no-undef\n  }\n\n  /**\n   * @method checksum\n   * Create the checksum of the specified string.\n   * @param  {string} content\n   * The content to generate a checksum for.\n   * @return {string}\n   * Generates a checksum value.\n   */\n  static checksum (str) {\n    if (typeof str === 'object') {\n      str = JSON.stringify(this.serialize(str))\n    }\n\n    if (!crcTable) {\n      crcTable = makeCRCTable()\n    }\n\n    let crc = 0 ^ (-1)\n\n    for (let i = 0; i < str.length; i++) {\n      crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF]\n    }\n\n    return (crc ^ (-1)) >>> 0\n  }\n\n  /**\n   * @method UUID\n   * Generate a universally unique identifier (v4).\n   *\n   * This is a \"fast\" UUID generator, designed to work in the browser.\n   * This will generate a UUID in less than 20ms on Chrome, as of Nov 6, 2017.\n   * Code courtesy of @broofa on StackOverflow.\n   *\n   * While this method cannot absolutely guarantee there will be no collisions\n   * (duplicates), the chances are 1:5.3x10^^36 (1 in over 100 quadrillion).\n   * You are over 30 _octillion_ times more likely to win the Powerball than to\n   * generate two identical \"random\" UUIDs using the version 4 scheme.\n   * @return {string}\n   * Returns a [V4 GUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29).\n   */\n  static UUID () {\n    /* node-only */\n    return this.GUID()\n    /* end-node-only */\n    /* browser-only */\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => // eslint-disable-line\n      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16) // eslint-disable-line\n    )\n    /* end-browser-only */\n  }\n\n  /**\n   * @method GUID\n   * Generate a globally unique identifier. A GUID is the Microsoft\n   * implementation of a UUIDv4.\n   *\n   * The likelihood of an ID collision, according to the original author (Jeff\n   * Ward) is 1:3.26x10^15 (1 in 3.26 quadrillion). Results are generated between\n   * approximately 105ms (Desktop) and 726ms (Android) as of May 2016.\n   * @return {string} [description]\n   */\n  static GUID () {\n    let lut = []\n\n    for (let i = 0; i < 256; i++) {\n      lut[i] = (i < 16 ? '0' : '') + (i).toString(16)\n    }\n\n    const d0 = Math.random() * 0xffffffff | 0\n    const d1 = Math.random() * 0xffffffff | 0\n    const d2 = Math.random() * 0xffffffff | 0\n    const d3 = Math.random() * 0xffffffff | 0\n\n    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] +\n      '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] +\n      lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' +\n      lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] +\n      lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff]\n  }\n\n  /**\n   * @method serialize\n   * Creates a JSON data object with no functions. Only uses enumerable\n   * attributes of the object.\n   *\n   * Functions & Setters are always ignored. Getters are evaluated recursively\n   * until a simple object type is found or there are no further nested\n   * attributes.\n   * @param {object|array} object\n   * Supports an object or array.\n   */\n  static serialize (data) {\n    if (typeof data !== 'object') {\n      throw new Error(`Cannot serialize ${NGN.typeof(data)} value. Must be an object.`)\n    }\n\n    // Force an object for parsing\n    let SERIALIZED_ARRAY_DATA = Symbol('array.data')\n\n    if (NGN.typeof(data) === 'array') {\n      data = {\n        [SERIALIZED_ARRAY_DATA]: data\n      }\n    }\n\n    let result = {}\n    let attribute = Object.keys(data)\n\n    for (let i = 0; i < attribute.length; i++) {\n      if (data[attribute[i]] !== undefined) {\n        switch (NGN.typeof(data[attribute[i]])) {\n          case 'object':\n            Object.defineProperty(\n              result,\n              attribute[i],\n              NGN.public(NGN.DATA.UTIL.serialize(data[attribute[i]]))\n            )\n\n            break\n\n          case 'array':\n            result[attribute[i]] = []\n\n            for (let a = 0; a < data[attribute[i]].length; a++) {\n              result[attribute[i]].push(NGN.DATA.UTIL.serialize(data[attribute[i]]))\n            }\n\n            break\n\n          case 'date':\n            Object.defineProperty(result, attribute[i], NGN.public(data[attribute[i]].toISOString()))\n\n            break\n\n          case 'symbol':\n            if (SERIALIZED_ARRAY_DATA !== attribute[i]) {\n              result[attribute[i]] = data[attribute[i]].toString()\n            }\n\n            break\n\n          case 'regexp':\n            Object.defineProperty(result, attribute[i], NGN.public(data[attribute[i]].toString()))\n\n            break\n\n          case 'weakmap':\n          case 'map':\n            let mapResult = {}\n\n            data[attribute[i]].forEach((value, key) => {\n              mapResult[key.toString()] = this.serialize(value)\n            })\n\n            result[attribute[i]] = mapResult\n\n            break\n\n          case 'weakset':\n          case 'set':\n            if (data[attribute[i]].size === 0) {\n              result[attribute[i]] = []\n              break\n            }\n\n            result[attribute[i]] = this.serialize(Array.from(data[attribute[i]].values()))\n\n            break\n\n          case 'function':\n            break\n\n          default:\n            result[attribute[i]] = data[attribute[i]]\n        }\n      }\n    }\n\n    return result[SERIALIZED_ARRAY_DATA] !== undefined ? result[SERIALIZED_ARRAY_DATA] : result\n  }\n\n  // /**\n  //  * @method objectByteSize\n  //  * Calculates the _estimated_ size (in bytes) of primitive key/value objects,\n  //  * meaning those that do not contain functions, accessors (getters/setters),\n  //  * or other attributes other than `String`, `Number`, or `Boolean` values.\n  //  * NGN treats dates as `String` values.\n  //  *\n  //  * JavaScript engines differ in how they manage memory, but most do not\n  //  * calculate the size of functions. If a value of type `function` is found in\n  //  * the object, NGN will calculate the size of it's `String` representation.\n  //  * This is a weak measure of function size since most JavaScript engines\n  //  * do not expose enough realtime heap data to know calculate with accuracy at\n  //  * any given point in time.\n  //  *\n  //  * This method attempts to implement similar principles to C's `sizeOf` method.\n  //  *\n  //  * Consider this method to provide a **best guess based on the available data**.\n  //  *\n  //  * @param {Object} object\n  //  * The primitive key/value object upon which the bytesize estimation will be made.\n  //  * @param {Boolean} [ignoreFunctionEstimate=false]\n  //  * By default, NGN will calculate the `String` representation of any functions\n  //  * it encounters in the key/value object. Setting this to `true` will prevent\n  //  * this behavior, effectively using a `0` to calculate function size.\n  //  */\n  // static objectByteSize (obj, ignore=false) {\n  //   switch (typeof obj) {\n  //     case null:\n  //       return 4\n  //\n  //     case 'string':\n  //       return obj.length * 2\n  //\n  //     case 'boolean':\n  //       return 4\n  //\n  //     case 'number':\n  //       return 8\n  //\n  //     case 'function':\n  //       if (!ignore) {\n  //         return obj.toString().length * 2\n  //       }\n  //\n  //       return 0\n  //   }\n  //\n  //   let list = []\n  //   let stack = [obj]\n  //   let bytes = 0\n  //\n  //   while (stack.length) {\n  //     let value = stack.pop()\n  //\n  //     if (typeof value === 'object') {\n  //       if (list.indexOf(value) < 0) {\n  //         list.push(value)\n  //\n  //         // If the object is not an array, add key sizes\n  //         const isArray = !Array.isArray(value)\n  //\n  //         for (let key in value) {\n  //           if (!isArray) {\n  //             bytes += (2 * key.length) + NGN.DATA.util(value[key])\n  //             stack.push(value[key])\n  //           } else {\n  //\n  //           }\n  //         }\n  //       }\n  //     } else {\n  //       bytes += NGN.DATA.UTILITY.objectByteSize(value)\n  //     }\n  //   }\n  //\n  //   return bytes\n  // }\n}\n\nexport { makeCRCTable }\n","import EventEmitter from '../../emitter/core'\n\n/**\n * Inspired by btree.js (c) 2013 Daniel Wirtz <dcode@dcode.io>\n * Released under the Apache License, Version 2.0\n * see: http://github.com/dcodeIO/btree.js for details.\n *\n * Converted to ECMASCript 2016 class syntax & modified to use\n * NGN conventions. Separated code into multiple classes.\n * Copyright (c) 2018, Ecor Ventures LLC.\n * @hidden\n */\nclass TreeNode {\n  constructor (parent = null, leafs = [], nodes = [null]) {\n    Object.defineProperties(this, {\n      parent: NGN.private(parent),\n      leafs: NGN.private(leafs),\n      nodes: NGN.private(nodes),\n\n      METADATA: NGN.private({\n        order: null,\n        minOrder: null,\n\n        /**\n        * Compare two numbers\n        * @param  {number} firstNumber\n        * @param  {number} secondNumber\n        * @return {number}\n        * - Returns `-1` if first number is less than second.\n        * - Returns `0` if numbers are equal.\n        * - Returns `1` if first number is greater than second.\n        */\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })\n    })\n\n    // Associate leafs with parent\n    for (let i = 0; i < this.leafs.length; i++) {\n      this.leafs[i].parent = this\n      // Object.defineProperty(this.leafs[i], 'parent', NGN.get(() => this))\n    }\n\n    // Associate nodes with parent\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (this.nodes[i] !== null) {\n        this.nodes[i].parent = this\n        // Object.defineProperty(this.nodes[i], 'parent', NGN.get(() => this))\n      }\n    }\n  }\n\n  /**\n  * Search for the node that contains the specified key\n  * @param  {any} key\n  * @return {TreeLeaf|TreeNode}\n  */\n  search (key) {\n    if (this.leafs.length > 0) {\n      let a = this.leafs[0]\n\n      if (this.METADATA.compare(a.key, key) === 0) {\n        return {\n          leaf: a,\n          index: 0\n        }\n      }\n\n      if (this.METADATA.compare(key, a.key) < 0) {\n        if (this.nodes[0] !== null) {\n          return this.nodes[0].search(key) // Left\n        }\n\n        return { node: this, index: 0 }\n      }\n\n      let i\n      for (i = 1; i < this.leafs.length; i++) {\n        let b = this.leafs[i]\n\n        if (this.METADATA.compare(b.key, key) === 0) {\n          return {\n            leaf: b,\n            index: i\n          }\n        }\n\n        if (this.METADATA.compare(key, b.key) < 0) {\n          if (this.nodes[i] !== null) {\n            return this.nodes[i].search(key) // Inner\n          }\n\n          return { node: this, index: i }\n        }\n\n        a = b\n      }\n\n      if (this.nodes[i] !== null) {\n        return this.nodes[i].search(key) // Right\n      }\n\n      return { node: this, index: i }\n    }\n\n    return { node: this, index: 0 }\n  }\n\n  /**\n  * Retrieve the value of a key.\n  * @param {number} key\n  * @returns {NGNTreeLeaf}\n  * Returns `undefined` if no leaf is found.\n  */\n  get (key) {\n    let result = this.search(key)\n    return result.leaf ? result.leaf.value : undefined\n  }\n\n  /**\n  * Insert a key/value pair into the node.\n  * @param {number} key\n  * @param {any} value\n  * @param {boolean} [overwrite=true]\n  * Overwrite existing values.\n  */\n  put (key, value, overwrite = true) {\n    let result = this.search(key)\n\n    // Key already exists\n    if (result.leaf) {\n      if (!overwrite) {\n        return\n      }\n\n      result.leaf.value = value\n      return\n    }\n\n    let node = result.node\n    let index = result.index\n\n    node.leafs.splice(index, 0, new TreeLeaf(node, key, value))\n    node.nodes.splice(index + 1, 0, null)\n\n    if (node.leafs.length > this.METADATA.order) {\n      node.split()\n    }\n  }\n\n  /**\n  * Delete key.\n  * @param {number} key\n  */\n  delete (key) {\n    var result = this.search(key)\n\n    if (!result.leaf) {\n      return\n    }\n\n    let leaf = result.leaf\n    let node = leaf.parent\n    let index = result.index\n    let left = node.nodes[index]\n\n    if (left === null) {\n      node.leafs.splice(index, 1)\n      node.nodes.splice(index, 1)\n      node.balance()\n    } else {\n      let max = left.leafs[left.leafs.length - 1]\n\n      left.delete(max.key)\n\n      max.parent = node\n\n      node.leafs.splice(index, 1, max)\n    }\n\n    return true\n  }\n\n  /**\n  * Balance the tree.\n  * @private\n  */\n  balance () {\n    if (this.parent instanceof Tree) {\n      // Root has a single child and no leafs\n      if (this.leafs.length === 0 && this.nodes[0] !== null) {\n        this.parent.root = this.nodes[0]\n        this.parent.root.parent = this.parent\n      }\n\n      return\n    }\n\n    if (this.leafs.length >= this.METADATA.minOrder) {\n      return\n    }\n\n    let index = this.parent.nodes.indexOf(this)\n    let left = index > 0 ? this.parent.nodes[index - 1] : null\n    let right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null\n    let sep\n    let leaf\n    let rest\n\n    if (right !== null && right.leafs.length > this.METADATA.minOrder) {\n      // Append the parent separator\n      sep = this.parent.leafs[index]\n      sep.parent = this\n\n      this.leafs.push(sep)\n\n      // Replace blank with the first right leaf\n      leaf = right.leafs.shift()\n      leaf.parent = this.parent\n\n      this.parent.leafs[index] = leaf\n\n      // Append the right rest\n      rest = right.nodes.shift()\n\n      if (rest !== null) {\n        rest.parent = this\n      }\n\n      this.nodes.push(rest)\n    } else if (left !== null && left.leafs.length > this.METADATA.minOrder) {\n      // Prepend the parent seperator\n      sep = this.parent.leafs[index - 1]\n      sep.parent = this\n\n      this.leafs.unshift(sep)\n\n      // Replace the blank with the last left leaf\n      leaf = left.leafs.pop()\n      leaf.parent = this.parent\n\n      this.parent.leafs[index - 1] = leaf\n\n      // Prepend the left rest to this\n      rest = left.nodes.pop()\n\n      if (rest !== null) {\n        rest.parent = this\n      }\n\n      this.nodes.unshift(rest)\n    } else {\n      let subst\n\n      if (right !== null) {\n        // Combine this + seperator from the parent + right\n        sep = this.parent.leafs[index]\n        subst = new TreeNode(this.parent, this.leafs.concat([sep], right.leafs), this.nodes.concat(right.nodes))\n        subst.METADATA.order = this.METADATA.order\n        subst.METADATA.minOrder = this.METADATA.minOrder\n\n        // Remove the seperator from the parent\n        this.parent.leafs.splice(index, 1)\n\n        // And replace the nodes it seperated with subst\n        this.parent.nodes.splice(index, 2, subst)\n      } else if (left !== null) {\n        // Combine left + seperator from parent + this\n        sep = this.parent.leafs[index - 1]\n        subst = new TreeNode(\n          this.parent,\n          left.leafs.concat([sep], this.leafs),\n          left.nodes.concat(this.nodes)\n        )\n\n        subst.METADATA.minOrder = this.METADATA.minOrder\n        subst.METADATA.order = this.METADATA.order\n\n        // Remove the seperator from the parent\n        this.parent.leafs.splice(index - 1, 1)\n\n        // Replace seperated nodes with subst\n        this.parent.nodes.splice(index - 1, 2, subst)\n      } else {\n        throw new Error(`Internal error: ${this.toString(true)} has neither a left nor a right sibling`)\n      }\n\n      this.parent.balance()\n    }\n  }\n\n  /**\n  * Split the node.\n  */\n  split () {\n    let index = Math.floor(this.leafs.length / 2)\n\n    if (this.parent instanceof Tree) {\n      this.nodes = [\n        new TreeNode(this, this.leafs.slice(0, index), this.nodes.slice(0, index + 1)),\n        new TreeNode(this, this.leafs.slice(index + 1), this.nodes.slice(index + 1))\n      ]\n\n      this.leafs = [this.leafs[index]]\n    } else {\n      let leaf = this.leafs[index]\n      let rest = new TreeNode(\n        this.parent,\n        this.leafs.slice(index + 1),\n        this.nodes.slice(index + 1)\n      )\n\n      this.leafs = this.leafs.slice(0, index)\n      this.nodes = this.nodes.slice(0, index + 1)\n\n      this.parent.unsplit(leaf, rest)\n    }\n  }\n\n  /**\n  * Unsplits a child.\n  * @param {NGNTreeLeaf} leaf\n  * @param {NGNTreeNode} rest\n  * @param {number} [order=52]\n  * @private\n  */\n  unsplit (leaf, rest) {\n    leaf.parent = this\n    rest.parent = this\n\n    let a = this.leafs[0]\n\n    if (this.METADATA.compare(leaf.key, a.key) < 0) {\n      this.leafs.unshift(leaf)\n      this.nodes.splice(1, 0, rest)\n    } else {\n      let i\n      for (i = 1; i < this.leafs.length; i++) {\n        let b = this.leafs[i]\n\n        if (this.METADATA.compare(leaf.key, b.key) < 0) {\n          this.leafs.splice(i, 0, leaf)\n          this.nodes.splice(i + 1, 0, rest)\n          break\n        }\n      }\n\n      if (i === this.leafs.length) {\n        this.leafs.push(leaf)\n        this.nodes.push(rest)\n      }\n    }\n\n    if (this.leafs.length > this.METADATA.order) {\n      this.split()\n    }\n  }\n\n  /**\n  * A string representation of the node.\n  * @param {boolean} [includeNodes=false]\n  * Include sub-nodes\n  * @returns {string}\n  * @private\n  */\n  toString (includeNodes = false) {\n    let value = []\n    let i\n\n    for (i = 0; i < this.leafs.length; i++) {\n      value.push(this.leafs[i].key)\n    }\n\n    let s = `[${value.toString()}]${(this.parent instanceof Tree ? ':*' : ':')}${this.parent}`\n\n    if (includeNodes) {\n      for (i = 0; i < this.nodes.length; i++) {\n        s += ` -> ${this.nodes[i]}`\n      }\n    }\n\n    return s\n  }\n}\n\n/**\n * @hidden\n */\nclass TreeLeaf {\n  /**\n   * Constructs a new Leaf containing a value.\n   * @param {NGNTreeNode} parent\n   * @param {number} key\n   * @param {any} value\n   */\n  constructor (parent, key, value) {\n    Object.defineProperties(this, {\n      parent: NGN.private(parent),\n      key: NGN.private(key),\n      value: NGN.private(value)\n    })\n  }\n\n  toString () {\n    return this.key.toString()\n  }\n}\n\n/**\n * @class NGN.DATA.BTree\n * A O(n) B-tree data type.\n * @private\n */\nexport default class Tree extends EventEmitter {\n  constructor (order = 52) {\n    super()\n\n    // Sanitize input\n    order = order < 1 ? 1 : order\n\n    Object.defineProperties(this, {\n      root: NGN.private(new TreeNode(this)),\n\n      BTREE: NGN.private({}),\n\n      METADATA: NGN.private({\n        order: order,\n\n        minOrder: order > 1 ? Math.floor(order / 2) : 1,\n\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })\n    })\n\n    this.root.METADATA.minOrder = this.METADATA.minOrder\n    this.root.METADATA.order = this.METADATA.order\n  }\n\n  /**\n   * Validates a node and prints debugging info if something went wrong.\n   * @param {!TreeNode|!Tree} node\n   * @private\n   */\n  validate (node) {\n    if (node instanceof Tree) {\n      return\n    }\n\n    if (node.leafs.length + 1 !== node.nodes.length) {\n      NGN.ERROR(`Illegal leaf/node count in ${node}: ${node.leafs.length}/${node.nodes.length}`)\n    }\n\n    let i\n\n    for (i = 0; i < node.leafs.length; i++) {\n      if (!node.leafs[i]) {\n        NGN.ERROR(`Illegal leaf in ${node} at ${i}: ${node.leafs[i]}`)\n      }\n    }\n\n    for (i = 0; i < node.nodes.length; i++) {\n      if (NGN.typeof(node.nodes[i]) === 'undefined') {\n        NGN.ERROR(`Illegal node in ${node} at ${i}: undefined`)\n      }\n    }\n  }\n\n  /**\n   * Insert a key/value pair into the tree.\n   * @param {number} key\n   * @param {any} value\n   * @param {boolean} [overwrite=true]\n   * Overwrite existing values\n   */\n  put (key, value, overwrite = true) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    if (value === undefined) {\n      throw new Error(`Illegal value: ${value}`)\n    }\n\n    return this.root.put(key, value, overwrite)\n  }\n\n  /**\n   * Retrieve the value for the specified key.\n   * @param {number} key\n   * @returns {any}\n   * If there is no such key, `undefined` is returned.\n   */\n  get (key) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    return this.root.get(key)\n  }\n\n  /**\n   * Delete a key from the tree.\n   * @param {number} key\n   */\n  delete (key) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    return this.root.delete(key)\n  }\n\n  /**\n   * Walk through all keys in ascending order.\n   * @param {number} minKey\n   * If omitted or NULL, starts at the beginning\n   * @param {number} maxKey\n   * If omitted or NULL, walks till the end\n   * @param {function} callback\n   * @param {number} callback.key\n   * The key\n   * @param {any} callback.value\n   * The value.\n   */\n  walk (minKey, maxKey, callback) {\n    if (this.root.leafs.length === 0) {\n      return\n    }\n\n    if (NGN.isFn(minKey)) {\n      callback = minKey\n      minKey = maxKey = null\n    } else if (NGN.isFn(maxKey)) {\n      callback = maxKey\n      maxKey = null\n    }\n\n    minKey = NGN.coalesce(minKey)\n    maxKey = NGN.coalesce(maxKey)\n\n    let ptr\n    let index\n\n    if (minKey === null) {\n      // No minimum limit\n      ptr = this.root\n\n      while (ptr.nodes[0] !== null) {\n        ptr = ptr.nodes[0]\n      }\n\n      index = 0\n    } else {\n      // lookup\n      let result = this.root.search(minKey)\n\n      if (result.leaf) {\n        // Minimum key itself exists\n        ptr = result.leaf.parent\n        index = ptr.leafs.indexOf(result.leaf)\n      } else {\n        // Key does not exist\n        ptr = result.node\n        index = result.index\n\n        if (index >= ptr.leafs.length) {\n          // begin at parent separator in overrun\n          if (ptr.parent instanceof Tree || ptr.parent.nodes.indexOf(ptr) >= ptr.parent.leafs.length) {\n            return\n          }\n\n          ptr = ptr.parent\n        }\n      }\n    }\n\n    // ptr/index points to first result\n    while (true) {\n      if (maxKey !== null && this.METADATA.compare(ptr.leafs[index].key, maxKey) > 0) {\n        break\n      }\n      if (ptr.leafs.length === 0) {\n        break\n      }\n\n      if (callback(ptr.leafs[index].key, ptr.leafs[index].value)) {\n        break\n      }\n\n      if (ptr.nodes[index + 1] !== null) {\n        // Descend Tree\n        ptr = ptr.nodes[index + 1]\n        index = 0\n\n        while (ptr.nodes[0] !== null) {\n          ptr = ptr.nodes[0]\n        }\n      } else if (ptr.leafs.length > index + 1) {\n        // Next\n        index++\n      } else {\n        // Ascend Tree\n        do {\n          if ((ptr.parent instanceof Tree)) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr)\n          ptr = ptr.parent\n        } while (index >= ptr.leafs.length)\n      }\n    }\n  }\n\n  /**\n   * Walks through all keys in descending order.\n   * @param {number} minKey\n   * If omitted or NULL, starts at the beginning\n   * @param {number} maxKey\n   * If omitted or NULL, walks till the end\n   * @param {function} callback\n   * @param {number} callback.key\n   * The key\n   * @param {any} callback.value\n   * The value.\n   */\n  walkDesc (minKey, maxKey, callback) {\n    if (NGN.isFn(minKey)) {\n      callback = minKey\n      minKey = maxKey = null\n    } else if (NGN.isFn(maxKey)) {\n      callback = maxKey\n      maxKey = null\n    }\n\n    minKey = NGN.coalesce(minKey)\n    maxKey = NGN.coalesce(maxKey)\n\n    let ptr\n    let index\n    if (maxKey === null) {\n      // No maximum\n      ptr = this.root\n\n      while (ptr.nodes[ptr.nodes.length - 1] !== null) {\n        ptr = ptr.nodes[ptr.nodes.length - 1]\n      }\n\n      index = ptr.leafs.length - 1\n    } else {\n      // Lookup\n      let result = this.root.search(maxKey)\n\n      if (result.leaf) {\n        // Maximum key exists\n        ptr = result.leaf.parent\n        index = ptr.leafs.indexOf(result.leaf)\n      } else {\n        // Key does not exist\n        ptr = result.node\n        index = result.index - 1\n\n        while (index < 0) {\n          // Begin at parent separator on underrun\n          if (ptr.parent instanceof Tree) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr) - 1\n\n          if (index < 0) {\n            return\n          }\n\n          ptr = ptr.parent\n        }\n      }\n    }\n\n    // ptr/index points to first result\n    while (true) {\n      if (minKey !== null && this.METADATA.compare(ptr.leafs[index].key, minKey) < 0) {\n        break\n      }\n\n      if (callback(ptr.leafs[index].key, ptr.leafs[index].value)) {\n        break\n      }\n\n      if (ptr.nodes[index] !== null) {\n        // Descend Tree\n        ptr = ptr.nodes[index]\n\n        while (ptr.nodes[ptr.nodes.length - 1] !== null) {\n          ptr = ptr.nodes[ptr.nodes.length - 1]\n        }\n\n        index = ptr.leafs.length - 1\n      } else if (index > 0) {\n        // Next\n        index--\n      } else {\n        // Ascend Tree\n        do {\n          if ((ptr.parent instanceof Tree)) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr) - 1\n\n          ptr = ptr.parent\n        } while (index < 0)\n      }\n    }\n  }\n\n  /**\n   * The number of keys between minKey and maxKey (both inclusive).\n   * @param {number} minKey\n   * If omitted, counts from the start\n   * @param {number} maxKey\n   * If omitted, counts till the end\n   * @returns {number}\n   */\n  count (minKey, maxKey) {\n    let n = 0\n\n    this.walk(\n      minKey !== undefined ? minKey : null,\n      maxKey !== undefined ? maxKey : null,\n      (key, value) => { n++ }\n    )\n\n    return n\n  };\n\n  /**\n   * A string representation of the tree.\n   * @returns {string}\n   */\n  toString () {\n    return `Tree(${this.METADATA.order}) ${this.root.toString()}`\n  }\n\n  get length () {\n    return this.count()\n  }\n}\n","/**\n  * @class NGN.DATA.Rule\n  * A data validation rule.\n  * @fires validator.add\n  */\nexport default class NGNDataValidationRule { // eslint-disable-line\n  /**\n   * Create a new data rule.\n   * @param {Function/String[]/Number[]/Date[]/RegExp/Array} rule\n   * * When rule is a _function_, the value is passed to it as an argument.\n   * * When rule is a _String_, the value is compared for an exact match (case sensitive)\n   * * When rule is a _Number_, the value is compared for equality.\n   * * When rule is a _Date_, the value is compared for exact equality.\n   * * When rule is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n   * * When rule is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n   * * When rule is _an array of dates_, the value is compared to each date for equality.\n   * @param {string} [name]\n   * An optional name for the rule. This can be useful when debugging data issues.\n   * @param {object} [scope]\n   * Apply a custom scope to the validation functions (applicable to custom methods only).\n   */\n  constructor (validation, name = null, scope = null) {\n    const type = NGN.typeof(validation)\n\n    Object.defineProperties(this, {\n      RULE: NGN.private({\n        type: type,\n        validator: validation,\n        name: NGN.coalesce(name, `Untitled ${type.toUpperCase()} Validation`),\n        scope: NGN.coalesce(scope, this)\n      })\n    })\n  }\n\n  get name () {\n    return this.RULE.name\n  }\n\n  get type () {\n    return this.RULE.type\n  }\n\n  /**\n   * @method test\n   * Test a value against the validation rule.\n   * @param {any} value\n   * The value to test.\n   * @returns {boolean}\n   * Returns `true` when the value meets the rule expectations and `false` when it does not.\n   */\n  test (value) {\n    if (NGN.isFn(this.RULE.validator)) {\n      // Custom enforcement function\n      return this.RULE.validator.apply(this.RULE.scope, [value])\n    } else {\n      switch (this.type) {\n        // Enumeration\n        case 'array':\n          return this.RULE.validator.indexOf(value) !== -1\n\n        // Pattern Matching\n        case 'regexp':\n          return this.RULE.validator.test(value)\n\n        default:\n          return this.RULE.validator === value\n      }\n    }\n  }\n}\n","import EventEmitter from '../../emitter/core'\n\n/**\n * @class NGN.DATA.Field\n * Represents a data field to be used in a model/record.\n * @fires hidden\n * Triggered when the field changes from unhidden to hidden.\n * @fires unhidden\n * Triggered when the field changes from hidden to unhidden.\n * @fires update {object}\n * Triggered when the field value is updated. The payload contains\n * an object with old and new values:\n *\n * ```js\n * {\n *   old: 'old value',\n *   new: 'new value'\n * }\n * ```\n * @fires invalid\n * Triggered when a previously valid value becomes invalid.\n * @fires valid\n * Triggered when a previously invalid value becomes valid.\n * @fires rule.add {NGN.DATA.Rule}\n * Triggered when a new validation rule is added. The rule is emitted\n * to event handlers.\n * @fires rule.remove {NGN.DATA.Rule}\n * Triggered when a validation rule is removed. The rule is emitted\n * to event handlers.\n * @fires keystatus.changed {boolean}\n * Triggered when the key (identifier) status changes. The boolean\n * payload indicates whether the field is considered an identifier.\n */\nexport default class NGNDataField extends EventEmitter { // eslint-disable-line\n  /**\n   * @param {string|object} configuration\n   * Accepts an object with all configuration objects, or a string representing\n   * the name of the field.\n   */\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    if (typeof cfg === 'string') {\n      cfg = {\n        name: cfg\n      }\n    }\n\n    // Validate field configuration values\n    if (cfg.hasOwnProperty('pattern') && NGN.typeof(cfg.pattern) !== 'regexp') {\n      throw new Error('Invalid data field configuration. Pattern must be a valid JavaScript regular expression (RegExp).')\n    }\n\n    if (cfg.type === undefined) {\n      if (cfg.default) {\n        cfg.type = NGN.getType(NGN.typeof(cfg.default), String)\n      }\n    }\n\n    super(cfg)\n\n    const EMPTYDATA = Symbol('empty')\n\n    Object.defineProperties(this, {\n      METADATA: NGN.privateconst({\n        /**\n         * @cfg {boolean} [required=false]\n         * Indicates the value is required.\n         */\n        required: NGN.coalesce(cfg.required, false),\n\n        /**\n         * @cfgproperty {boolean} [hidden=false]\n         * Indicates the field is hidden (metadata).\n         */\n        hidden: NGN.coalesce(cfg.hidden, false),\n\n        // Identifies the property as a standard data attribute.\n        // Alternative options include `data`, `key`, `join`, `virtual`.\n        fieldType: NGN.coalesce(cfg.identifier, false) ? 'key' : 'data',\n\n        isIdentifier: NGN.coalesce(cfg.identifier, false),\n\n        /**\n         * @cfg {boolean} [autocorrectInput=true]\n         * Attempt to automatically correct data type values. For example,\n         * a numeric field receiving a value of `'10'` will automatically\n         * convert the input to `10`. Only arrays, numbers, and booleans are\n         * supported. See NGN#forceArray, NGN#forceBoolean, and NGN#forceNumber\n         * for details.\n         */\n        autocorrectInput: NGN.coalesce(cfg.autocorrectInput, false),\n\n        /**\n         * @cfg {RegExp} [pattern]\n         * A pattern, as defined by a standard RegExp, that the data must match.\n         */\n        pattern: NGN.coalesceb(cfg.pattern),\n\n        /**\n         * @cfgproperty {string} name\n         * The field name.\n         */\n        name: NGN.coalesce(cfg.name),\n\n        /**\n         * @cfgproperty {string} description\n         * This is a metadata field, primarily used for documentation\n         * or schema generation purposes.\n         */\n        description: NGN.coalesce(cfg.description, `${NGN.typeof(cfg.type)} field`),\n\n        /**\n         * @cfgproperty {string} [sourceName]\n         * A source name represents the physical name of an attribute as it\n         * would be recognized in a system of record. For example, a field\n         * named `firstname` may need to be written to disk/memory as `gn`\n         * (commonly used as shorthand for givenName in LDAP environments\n         * and relational databases).\n         *\n         * By specifying `firstname` as the field name and `gn` as the source\n         * name, the field will automatically map values from the source\n         * to model name and vice versa.\n         *\n         * For instance, a JSON input may look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"John\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         *\n         * When this data is applied to the field (or loaded in a\n         * NGN.DATA.Model), the field #value for `firstname` would be `John`.\n         * If the field #value is changed to `Jill` (i.e.\n         * `firstname.value = 'Jill'`), the resulting data set would look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"Jill\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         */\n        sourceName: NGN.coalesce(cfg.sourceName),\n\n        /**\n         * @cfg {any} default\n         * The default value of the field when no value is specified.\n         */\n        default: NGN.coalesce(cfg.default),\n\n        lastValue: Symbol('no.value'),\n\n        /**\n         * @cfg {Primitive} [type=String]\n         * The JS primitive representing the type of data represented\n         * by the field.\n         */\n        dataType: NGN.coalesce(cfg.type, String),\n\n        /**\n         * @cfg {function} [rule[]]\n         * A function, or an array of functions, which determine whether the\n         * field value is valid or not. These functions receive a single argument\n         * (the data value) and must return a Boolean value.\n         */\n        rules: NGN.coalesce(cfg.rule, cfg.rules, cfg.validators, []),\n        violatedRule: null,\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * If this is set to `false`, invalid values will throw an error.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {function} transformer\n         * A synchronous transformation function will be applied each time\n         * the field value is set. This can be used to modify data _before_ it\n         * is stored as a field value. The returned value from the function\n         * will be the new value of the field.\n         *\n         * The transformation function will receive the input as it's only\n         * aregument. For example:\n         *\n         * ```js\n         * let field = new NGN.DATA.Field({\n         *   name: 'testfield',\n         *   transformer: function (input) {\n         *     return input + '_test'\n         *   }\n         * })\n         *\n         * field.value = 'a'\n         *\n         * console.log(field.value) // Outputs \"a_test\"\n         * ```\n         *\n         * **Transformations can affect performance.** In small data sets,\n         * transformations are typically negligible, only adding a few\n         * milliseconds to processing time. This may affect large data sets,\n         * particularly data stores using defauly bulk recod loading.\n         */\n        TRANSFORM: NGN.coalesce(cfg.transformer),\n\n        RAWDATAPLACEHOLDER: EMPTYDATA,\n        RAW: EMPTYDATA,\n        ENUMERABLE_VALUES: null,\n        REVERSE_ENUMERABLE_VALUES: null,\n        IS_NEW: true,\n\n        EVENTS: new Set([\n          'hidden',\n          'unhidden',\n          'update',\n          'invalid',\n          'valid',\n          'rule.add',\n          'rule.remove'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n\n        /**\n         * @cfg {Number} [auditMaxEntries=20]\n         * The maximum number of historical records to maintain for the field.\n         * See NGN.DATA.TransactionLog#constructor for details.\n         */\n        AUDITLOG: NGN.coalesce(cfg.audit, false)\n          ? new NGN.DATA.TransactionLog(NGN.coalesce(cfg.auditMaxEntries, 10))\n          : null,\n\n        /**\n         * @cfg {NGN.DATA.Model} [model]\n         * Optionally specify the parent model.\n         */\n        model: null,\n\n        // Set the value using a configuration.\n        setValue: (value, suppressEvents = false, ignoreAudit = false) => {\n          // Preprocessing (transform input)\n          if (this.METADATA.TRANSFORM !== null && NGN.isFn(this.METADATA.TRANSFORM)) {\n            value = this.METADATA.TRANSFORM.call(this, value)\n          }\n\n          // Attempt to auto-correct input when possible.\n          if (this.METADATA.autocorrectInput && this.type !== NGN.typeof(value)) {\n            value = this.autoCorrectValue(value)\n          }\n\n          // Ignore changes when the value hasn't been modified.\n          if (value === this.value) {\n            return\n          }\n\n          let change = {\n            field: this,\n            old: typeof this.METADATA.RAW === 'symbol' ? undefined : this.METADATA.RAW,\n            new: value\n          }\n\n          let priorValueIsValid = this.valid\n\n          this.METADATA.RAW = value\n\n          // Notify when an invalid value is detected.\n          if (!this.valid) {\n            // If invalid values are explicitly prohibited, throw an error.\n            // The value is rolled back before throwing the error so developers may\n            // catch the error and continue processing.\n            if (!this.METADATA.allowInvalid) {\n              this.METADATA.RAW = change.old\n              throw new Error(`\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`)\n            } else {\n              change.reason = `\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`\n              NGN.WARN(change.reason)\n            }\n\n            this.emit('invalid', change)\n          } else if (!suppressEvents && priorValueIsValid !== null && priorValueIsValid) {\n            // If the field BECAME valid (compared to prior value),\n            // emit an event.\n            this.emit('valid', change)\n          }\n\n          if (typeof this.METADATA.lastValue === 'symbol') {\n            this.METADATA.lastValue = value\n          }\n\n          // If auditing is enabled and not explicitly ignored by an internal\n          // operation, commit the change.\n          if (!ignoreAudit && !this.virtual && this.METADATA.AUDITABLE) {\n            change.cursor = this.METADATA.AUDITLOG.commit(this.METADATA.RAW)\n          }\n\n          // Notify when the update is complete.\n          if (!suppressEvents) {\n            this.emit('update', change)\n          }\n\n          // Mark unnecessary code for garbage collection.\n          priorValueIsValid = null\n          change = null\n        },\n\n        // Submit the payload to the parent model (if applicable).\n        commitPayload: (payload) => {\n          if (this.METADATA.model) {\n            payload.action = 'update'\n            payload.join = true\n\n            this.increaseMaxListeners(3)\n            this.METADATA.model.emit(\n              [\n                'update',\n                `${payload.field}.update`,\n                `update.${payload.field}`\n              ],\n              payload\n            )\n\n            payload = null // Mark for garbage collection\n          }\n        }\n      })\n    })\n\n    // Apply common rules\n    if (NGN.typeof(this.METADATA.rules) !== 'array') {\n      this.METADATA.rules = NGN.forceArray(this.METADATA.rules)\n    }\n\n    if (this.METADATA.rules.length > 0) {\n      for (let i = 0; i < this.METADATA.rules.length; i++) {\n        if (NGN.isFn(this.METADATA.rules[i]) && !(this.METADATA.rules[i] instanceof NGN.DATA.Rule)) {\n          this.METADATA.rules[i] = new NGN.DATA.Rule(this.METADATA.rules[i], `Custom Rule #${i + 1}`)\n        }\n      }\n    }\n\n    // Apply pattern validation if specified.\n    if (this.METADATA.dataType === String) {\n      if (this.METADATA.pattern !== null) {\n        this.METADATA.rules.unshift(new NGN.DATA.Rule(cfg.pattern, `Pattern Match (${cfg.pattern.toString()})`))\n      }\n\n      /**\n       * @cfg {Boolean} [nonempty]\n       * @info This validation attribute applies to #String fields only.\n       * Validates a value is not blank, `null`, or `undefined`.\n       */\n      if (cfg.nonempty) {\n        this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n          return value.trim().length > 0\n        }, `No Blanks (${cfg.pattern.toString()})`))\n      }\n    }\n\n    /**\n     * @cfg {Number} [min]\n     * @info This validation attribute applies to #Array, #String, and #Number fields only.\n     * Specify a minimum value:\n     *\n     * - For string values, this is a minimum number of characters.\n     * - For numeric values, this is a minimum inclusive value (i.e. value must be greater than\n     * or equal to the minimum).\n     * - For arrays, this is a minimum number of items that must exist in the array.\n     */\n    /**\n     * @cfg {Number} [max]\n     * @info This validation attribute applies to #Array, #String, and #Number fields only.\n     * Specify a maximum value:\n     *\n     * - For string values, this is a maximum number of characters.\n     * - For numeric values, this is a maximum inclusive value (i.e. value must be less than\n     * or equal to the maximum).\n     * - For arrays, this is a maximum number of items that may exist in the array.\n     */\n\n    // Apply number-specific validations.\n    if (this.METADATA.dataType === Number || this.METADATA.dataType === Date || this.METADATA.dataType === String) {\n      // Support minimum/maximum range\n      if (NGN.objectHasAny(cfg, 'min', 'minimum', 'max', 'maximum')) {\n        cfg.range = NGN.forceArray(NGN.coalesce(cfg.range))\n        cfg.range.push([NGN.coalesce(cfg.min, cfg.minimum), NGN.coalesce(cfg.max, cfg.maximum)])\n      }\n\n      /**\n       * @cfg {Number} [range]\n       * @info This validation attribute applies to #String and #Number fields only.\n       * Specify a range of acceptable values:\n       *\n       * - For numbers, this implies inclusive ranges. For example, `1-10` means \"between 1 and 10, where both 1 and 10 are valid.\"\n       * - For strings, this implies inclusive ranges just like numbers, where the number is the character count.\n       */\n      if (cfg.hasOwnProperty('range')) {\n        this.METADATA.rules.unshift(new NGN.DATA.RangeRule('Numeric Range', cfg.range))\n      }\n\n      if (this.METADATA.dataType === Number) {\n        // Support numeric patterns (i.e. support for integers)\n        if (NGN.coalesce(cfg.pattern)) {\n          this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n            return cfg.pattern.test(value.toString())\n          }, `Numeric Pattern (${cfg.pattern.toString().substr(0, 15) + (cfg.pattern.toString().length > 15 ? '...' : '')})`))\n        }\n\n        /**\n         * @cfg {Number} [multipleOf]\n         * @info This validation attribute applies to #Number fields only.\n         * Insures the field value is a multiple of this number. For example,\n         * if the multiple is `10` and the value is `100`, it is valid.\n         * If the multiple is `10` and the value is `101`, it is invalid.\n         */\n        if (NGN.typeof(cfg.multipleOf) === 'number') {\n          this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n            return Math.abs(value % cfg.multipleOf) === 0\n          }, `Numeric Multiple of ${cfg.multipleOf}`))\n        }\n      }\n    }\n\n    // Apply array-specific native validations\n    if (this.METADATA.dataType === Array) {\n      // Enforce minimum number of array items\n      if (NGN.objectHasAny(cfg, 'min', 'minimum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => value.length >= NGN.coalesce(cfg.min, cfg.minimum), `${NGN.coalesce(cfg.min, cfg.minimum)} count minimum`))\n      }\n\n      // Enforce maximum number of array items\n      if (NGN.objectHasAny(cfg, 'max', 'maximum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => value.length <= NGN.coalesce(cfg.max, cfg.maximum), `${NGN.coalesce(cfg.max, cfg.maximum)} count maximum`))\n      }\n\n      /**\n       * @cfg {Array} [unique]\n       * @info This validation attribute applies to #Array fields only.\n       * @warning This is a computationally expensive validation when used in NGN Data Stores.\n       * Validates that all items are unique.\n       */\n      if (NGN.coalesce(cfg.unique, false)) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => NGN.dedupe(value).length === value.length, 'Unique value constraint'))\n      }\n\n      /**\n       * @cfg {any} [listType]\n       * @info This validation attribute applies to #Array fields only.\n       * Require each element of the array to conform to the specified data\n       * type. For example, setting `listType: Number` will validate that\n       * each element of the array is a number.\n       *\n       * ```js\n       * [1, 2, 3, 4, 5] // Valid\n       * [1, 2, 'three', 4, 5] // Invalid\n       * ```\n       */\n      if (cfg.hasOwnProperty('listType')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          for (let i = 0; i < value.length; i++) {\n            if (NGN.typeof(value[i]) !== NGN.typeof(cfg.listType)) {\n              return false\n            }\n          }\n\n          return true\n        }, `${NGN.typeof(cfg.listType).toUpperCase()} list type constraint`))\n      }\n\n      // Support enumerations in array values\n      if (cfg.hasOwnProperty('enum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          return cfg.enum.indexOf(value) >= 0\n        }))\n      }\n\n      /**\n       * @cfg {Array} [tuples]\n       * @info This validation attribute applies to #Array fields only.\n       * @warning This is a computationally expensive validation when used in NGN Data Stores.\n       * Validate each item of an array according to a unique schema.\n       * Each item is a key value object, which supports only the `type` and\n       * `enum` validations.\n       *\n       * For example:\n       *\n       * ```js\n       * {\n       *   tuples: [{\n       *     type: Number\n       *   }, {\n       *     type: String,\n       *     enum: ['a', 'b', 'c']\n       *   }, {\n       *     enum: ['d', 1]\n       *   }]\n       * }\n       * ```\n       * The configuration above will make sure the first array item is a number,\n       * while the second is either `a`, `b`, or `c`, and the third is either\n       * the letter `d` or the number `1`. Only the first three items of the\n       * array will be checked, but there must be at least 3 items.\n       */\n      if (cfg.hasOwnProperty('tuples')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          if (value.length < cfg.tuples.length) {\n            return false\n          }\n\n          for (let i = 0; i < cfg.tuples.length; i++) {\n            if (cfg.tuples[i].hasOwnProperty('type')) {\n              if (NGN.typeof(value[i]) !== NGN.typeof(cfg.tuples[i].type)) {\n                return false\n              }\n            }\n\n            if (cfg.tuples[i].hasOwnProperty('enum')) {\n              if (cfg.tuples[i].enum.indexOf(value[i]) < 0) {\n                return false\n              }\n            }\n          }\n\n          return true\n        }, 'Tuple constraint'))\n      }\n    }\n\n    /**\n     * @cfg {Array} [enum]\n     * An enumeration of available values this field is allowed to have.\n     */\n    if (NGN.objectHasAny(cfg, 'enum', 'enumeration')) {\n      this.METADATA.ENUMERABLE_VALUES = new Set(NGN.forceArray(NGN.coalesce(cfg.enum, cfg.enumeration)))\n      this.METADATA.rules.push(new NGN.DATA.Rule((value) => this.METADATA.ENUMERABLE_VALUES.has(value), 'Enumerable Values'))\n    }\n\n    /**\n     * @cfg {Array} [not]\n     * A \"reverse\" enumeration, i.e. a list of values this field is **not** allowed to be.\n     */\n    if (NGN.objectHasAny(cfg, 'not', 'notin')) {\n      this.METADATA.REVERSE_ENUMERABLE_VALUES = new Set(NGN.forceArray(NGN.coalesce(cfg.not, cfg.notin)))\n      this.METADATA.rules.push(new NGN.DATA.Rule((value) => !this.METADATA.REVERSE_ENUMERABLE_VALUES.has(value), 'Rejected Values'))\n    }\n\n    // Check if the field type is an array, which indicates multiple\n    // data types are considered valid.\n    if (cfg.type instanceof Array) {\n      // If the array has no values, assume the user meant to create an \"Array\" data type.\n      // Warn them, in case this was not the intention.\n      if (cfg.type.length === 0) {\n        NGN.WARN(`No data type specified for ${this.name} field. Autoconverted to an array.`)\n        cfg.type = Array\n      } else if (cfg.type.length === 1) {\n        // If there is only one data type, the array is extraneous and standard\n        // datatype validation can be used.\n        cfg.type = cfg.type[0]\n      }\n    }\n\n    /**\n     * @cfg {Primitive|Array} [type=String]\n     * The type should be a JavaScript primitive, class, or constructor.\n     * For example, `String`, `Number`, `Boolean`, `RegExp`, `Array`, or `Date`.\n     * This can also be an array of primitive values. For example, `[String, Number]`\n     * indicates the field could be a string or a numeric value.\n     */\n    if (cfg.type instanceof Array) {\n      let typeList = cfg.type.map(type => NGN.typeof(type))\n\n      this.METADATA.rules.unshift(\n        new NGN.DATA.Rule(\n          (value) => typeList.indexOf(NGN.typeof(value)) >= 0,\n          `${this.type.toUpperCase()} Multitype Check`\n        )\n      )\n    } else {\n      this.METADATA.rules.unshift(\n        new NGN.DATA.Rule(\n          (value) => NGN.typeof(value) === NGN.typeof(this.METADATA.dataType),\n          `${this.type.toUpperCase()} Type Check`\n        )\n      )\n    }\n\n    // Associate a model if one is defined.\n    if (NGN.coalesce(cfg.model) !== null) {\n      this.model = cfg.model\n    }\n  }\n\n  get sourceName () {\n    return this.METADATA.sourceName\n  }\n\n  get auditable () {\n    return this.METADATA.AUDITABLE\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n      this.METADATA.AUDITLOG.relay('*', this, 'transaction.')\n    }\n  }\n\n  /**\n   * @property {NGN.DATA.Model} model\n   * Represents the model/record the field is associated to.\n   * The model may be configured once, after which this property\n   * becomes read-only. This will also be read-only if #model is set\n   * to a valid value.\n   */\n  get model () {\n    return this.METADATA.model\n  }\n\n  set model (value) {\n    if (this.METADATA.model === null) {\n      if (value instanceof NGN.DATA.Entity) {\n        this.METADATA.model = value\n\n        // let events = Array.from(this.METADATA.EVENTS.values())\n        // events.splice(events.indexOf('update'), 1)\n        //\n        this.on('update', (payload) => this.METADATA.commitPayload(payload))\n        //\n        // for (let i = 0; i < events.length; i++) {\n        //   this.on(events[i], () => this.METADATA.model.emit(`field.${events[i]}`, ...arguments))\n        // }\n      } else {\n        NGN.WARN('Invalid model.')\n      }\n    } else {\n      NGN.WARN('Cannot set model multiple times.')\n    }\n  }\n\n  /**\n   * @property {string} fieldType\n   * The type of field.\n   */\n  get fieldType () {\n    return this.METADATA.fieldType\n  }\n\n  /**\n   * @property {boolean} required\n   * Indicates the field must have a non-null value.\n   */\n  get required () {\n    return this.METADATA.required\n  }\n\n  set required (value) {\n    this.METADATA.required = NGN.forceBoolean(value)\n  }\n\n  /**\n   * @property {string} type\n   * The type of data in string format.\n   */\n  get type () {\n    return NGN.typeof(this.METADATA.dataType)\n  }\n\n  /**\n   * @property {boolean} hidden\n   * Indicates the field should be considered hidden.\n   */\n  get hidden () {\n    return this.METADATA.hidden\n  }\n\n  set hidden (value) {\n    let originallyHidden = this.hidden\n    let currentlyHidden = NGN.forceBoolean(value)\n\n    if (originallyHidden !== currentlyHidden) {\n      this.METADATA.hidden = currentlyHidden\n      this.emit(originallyHidden ? 'unhidden' : 'hidden')\n    }\n  }\n\n  /**\n   * @property {boolean} virtual\n   * Indicates the field should be considered virtual.\n   */\n  get virtual () {\n    return this.METADATA.fieldType === 'virtual'\n  }\n\n  /**\n   * @property {boolean} identifier\n   * Indicates the field is considered an identifier.\n   */\n  get identifier () {\n    return this.METADATA.isIdentifier\n  }\n\n  set identifier (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.isIdentifier) {\n      this.METADATA.isIdentifier = value\n      this.emit('keystatus.changed', this)\n    }\n  }\n\n  get name () {\n    return this.METADATA.name\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates the model is new or does not exist according to the persistence store.\n   * @private\n   * @readonly\n   */\n  get isNew () {\n    return this.METADATA.IS_NEW\n  }\n\n  /**\n   * @property {Any} default\n   * The default field value.\n   */\n  get default () {\n    if (this.isIdentifier) {\n      return NGN.coalesce(this.METADATA.autoid, this.METADATA.default)\n    }\n\n    if (NGN.isFn(this.METADATA.default) && this.type !== 'function') {\n      return this.METADATA.default.apply(this)\n    }\n\n    return this.METADATA.default\n  }\n\n  /**\n   * @property {Any} value\n   * The value of the field.\n   */\n  get value () {\n    if (typeof this.METADATA.RAW !== 'symbol') {\n      return this.METADATA.RAW\n    }\n\n    return this.METADATA.default\n  }\n\n  set value (value) {\n    this.METADATA.setValue(value)\n  }\n\n  /**\n   * @property silentValue\n   * A write-only attribute to set the value without triggering an update event.\n   * This is designed primarily for use with live update proxies to prevent\n   * endless event loops.\n   * @param {any} value\n   * The new value of the field.\n   * @private\n   * @writeonly\n   */\n  set silentValue (value) {\n    this.METADATA.setValue(value, true)\n  }\n\n  get modified () {\n    if (typeof this.META.lastValue === 'symbol') {\n      return false\n    }\n\n    return this.METADATA.lastValue !== this.value\n  }\n\n  /**\n   * @property {boolean} valid\n   * Indicates the field value is valid.\n   */\n  get valid () {\n    if (this.required && NGN.coalesce(this.METADATA.RAW) === null) {\n      this.METADATA.violatedRule = 'Data Required'\n      NGN.WARN(`${this.METADATA.name} is a required field.`)\n      return false\n    }\n\n    if (this.METADATA.rules.length > 0) {\n      for (let rule = 0; rule < this.METADATA.rules.length; rule++) {\n        if (!this.METADATA.rules[rule].test(this.METADATA.RAW)) {\n          this.METADATA.violatedRule = this.METADATA.rules[rule].name\n          return false\n        }\n      }\n    }\n\n    this.METADATA.violatedRule = null\n\n    return true\n  }\n\n  /**\n   * @property {String}\n   * Name of the rule which was violated.\n   */\n  get violatedRule () {\n    return NGN.coalesce(this.METADATA.violatedRule, 'None')\n  }\n\n  /**\n   * @property {Array} changelog\n   * The changelog returns the underlying NGN.DATA.TransactionLog#log if\n   * auditing is available. The array will be empty if auditing is disabled.\n   */\n  get changelog () {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The changelog for the ${this.name} field is empty because auditing is disabled.`)\n      return []\n    }\n\n    return this.METADATA.AUDITLOG.log\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog (transaction log). To \"undo\" an \"undo\", use #redo.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  undo (count = 1, suppressEvents = false) {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The undo operation failed on the ${this.name} field because auditing is disabled.`)\n      return\n    }\n\n    let id = this.METADATA.AUDITLOG.rollback(count)\n\n    // Silently set the value to an older value.\n    this.METADATA.setValue(this.METADATA.AUDITLOG.getCommit(id).value, suppressEvents, true)\n  }\n\n  /**\n   * @method redo\n   * A function to reapply known changes. This operation affects\n   * the changelog (transaction log).\n   *\n   * The redo operation only works after an undo operation, but before a new\n   * value is committed to the transaction log. In other words, `undo -> redo`\n   * will work, but `undo -> update -> redo` will not. For details, see how\n   * the NGN.DATA.TransactionLog cursor system works.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  redo (count = 1, suppressEvents = false) {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The redo operation failed on the ${this.name} field because auditing is disabled.`)\n      return\n    }\n\n    let id = this.METADATA.AUDITLOG.advance(count)\n\n    // Silently set the value to a newer value.\n    this.METADATA.setValue(this.METADATA.AUDITLOG.getCommit(id).value, suppressEvents, true)\n  }\n\n  /**\n   * Hide the field.\n   */\n  hide () {\n    this.hidden = true\n  }\n\n  /**\n   * Unhide the field.\n   */\n  unhide () {\n    this.hidden = false\n  }\n\n  /**\n   * Do not throw errors whan a value is marked as invalid.\n   */\n  allowInvalid () {\n    this.METADATA.allowInvalid = true\n  }\n\n  /**\n   * Throw errors whan a value is marked as invalid.\n   */\n  disallowInvalid () {\n    this.METADATA.allowInvalid = false\n  }\n\n  /**\n   * Attempt to automatically correct a value according to the\n   * field's data type.\n   * @param  {Any} value\n   * The value to attempt to autocorrect.\n   * @return {Any}\n   * Returns the value after attempting to autocorrect the value.\n   */\n  autoCorrectValue (value) {\n    try {\n      switch (this.type) {\n        case 'number':\n          value = NGN.forceNumber(value)\n          break\n\n        case 'boolean':\n          value = NGN.forceBoolean(value)\n          break\n\n        case 'array':\n          value = NGN.forceArray(value)\n          break\n\n        case 'string':\n          value = value.toString()\n          break\n\n        case 'date':\n          let valueType = NGN.typeof(value)\n\n          if (valueType !== 'date') {\n            if (valueType === 'number') {\n              let dt = new Date()\n              dt.setTime(value)\n\n              value = dt\n            } else {\n              value = new Date(Date.parse(value))\n            }\n          }\n\n          break\n      }\n    } finally {\n      return value // eslint-disable-line no-unsafe-finally\n    }\n  }\n}\n","import EventEmitter from '../emitter/core'\n\nNGN.createException({\n  name: 'NGNDuplicateRecordError',\n  message: 'A duplicate record exists within the unique data set.'\n})\n\n/**\n * @class NGN.DATA.Store\n * Represents a collection of data.\n * @fires record.create\n * Fired when a new record is created. The new\n * record is provided as an argument to the event\n * handler.\n * @fires record.delete\n * Fired when a record(s) is removed. The old record\n * is provided as an argument to the event handler.\n * @fires record.update\n * Fired when a record(s) is modified. A change object\n * is provided as an argument to event handlers. The object\n * contains a reference to the store, the old record, and\n * the new record.\n *\n * ```\n * {\n *   store: <current data store>,\n *   new: <NGN.DATA.Model>,\n *   old: <NGN.DATA.Model>\n * }\n * ```\n */\nexport default class NGNDataStore extends EventEmitter { // eslint-disable-line\n  constructor (cfg = {}) {\n    if (NGN.typeof(cfg) === 'model') {\n      cfg = { model: cfg }\n    } else if (!cfg.model || NGN.typeof(cfg.model) !== 'model') {\n      throw new InvalidConfigurationError('Missing or invalid \"model\" configuration property.')\n    }\n\n    super()\n\n    const me = this\n\n    Object.defineProperties(this, {\n      /**\n       * @cfgproperty {string} [name]\n       * A descriptive name for the store. This is typically used for\n       * debugging, logging, and (somtimes) data proxies.\n       */\n      name: NGN.const(NGN.coalesce(cfg.name, 'Untitled Data Store')),\n\n      METADATA: NGN.private({\n        // Holds the models/records\n        records: [],\n\n        /**\n         * @cfgproperty {NGN.DATA.Model} model\n         * An NGN Data Model to which data records conform.\n         */\n        Model: NGN.coalesce(cfg.model),\n\n        /**\n         * @cfg {boolean} [allowDuplicates=true]\n         * Set to `false` to prevent duplicate records from being added.\n         * If a duplicate record is added, it will be ignored and an\n         * error will be thrown.\n         *\n         * **Identifying duplicates _may_ be slow** on data sets with 200+ records.\n         * Uniqueness is determined by a checksum of the current NGN.DATA.Model#data\n         * of a record. The amount of time required to generate a checksum can range\n         * from 3ms to 150ms per record depending on data complexity.\n         *\n         * In most scenarios, the performance impact will be negligible/indistinguishable\n         * to the naked eye. However; if an application experiences slow data\n         * load or processing times, setting this to `false` may help.\n         */\n        allowDuplicates: NGN.coalesce(cfg.allowDuplicates, true),\n\n        /**\n         * @cfg {boolean} [errorOnDuplicate=false]\n         * Set to `true` to throw an error when a duplicate record is detected.\n         * If this is not set, it will default to the value of #allowDuplicates.\n         * If #allowDuplicates is not defined either, this will be `true`\n         */\n        errorOnDuplicate: NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, false),\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * Allow invalid records to be added to the store.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {boolean} [errorOnInvalid=false]\n         * Set to `true` to throw an error when an attempt is made to add an\n         * invalid record.\n         */\n        errorOnInvalid: NGN.coalesce(cfg.errorOnInvalid, cfg.allowInvalid, false),\n\n        /**\n         * @cfgproperty {boolean} [autoRemoveExpiredRecords=true]\n         * When set to `true`, the store will automatically delete expired records.\n         */\n        autoRemoveExpiredRecords: NGN.coalesce(cfg.autoRemoveExpiredRecords, true),\n\n        /**\n         * @cfg {boolean} [softDelete=false]\n         * When set to `true`, the store makes a copy of a record before removing\n         * it from the store. The store will still emit a `record.delete` event,\n         * and it will still behanve as though the record has been completely\n         * removed. However; the record copy can be retrieved using the #restore\n         * method.\n         *\n         * Since it is not always desirable to store a copy of every deleted\n         * record indefinitely, it is possible to expire and permanently remove\n         * records by setting the #softDeleteTtl.\n         *\n         * ```js\n         * var People = new NGN.DATA.Store({\n         *   model: Person,\n         *   softDelete: true,\n         *   softDeleteTtl: 10000\n         * })\n         *\n         * People.add(somePerson)\n         *\n         * var removedRecordId\n         * People.once('record.delete', function (record) {\n         *   removedRecordId = record.id\n         * })\n         *\n         * People.remove(somePerson)\n         *\n         * setTimeout(function () {\n         *   People.restore(removedRecordId)\n         * }, 5000)\n         *\n         * ```\n         *\n         * The code above creates a new store and adds a person to it.\n         * Then a placeholder variable (`removedRecordId`) is created.\n         * Next, a one-time event listener is added to the store, specifically\n         * for handling the removal of a record. Then the record is removed,\n         * which triggers the `record.delete` event, which populates\n         * `removedRecordId` with the ID of the record that was deleted.\n         * Finally, the code waits for 5 seconds, then restores the record. If\n         * the #restore method _wasn't_ called, the record would be purged\n         * from memory after 10 seconds (because `softDeleteTtl` is set to 10000\n         * milliseconds).\n         */\n        softDelete: NGN.coalesce(cfg.softDelete, false),\n\n        /**\n         * @cfg {number} [softDeleteTtl=-1]\n         * This is the number of milliseconds the store waits before purging a\n         * soft-deleted record from memory. `-1` = Infinite (no TTL).\n         */\n        softDeleteTtl: NGN.coalesce(cfg.softDeleteTtl, -1),\n\n        // ARCHIVE contains soft deleted records\n\n        /**\n         * @cfg {Number} [FIFO=-1]\n         * Configures the store to use \"**F**irst **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the oldest record (i.e. the 1st). This guarantees the\n         * store will never have more than 10 records at any given time and it\n         * will always maintain the latest records.\n         *\n         * FIFO and LIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. FIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        fifo: NGN.coalesce(cfg.FIFO, -1),\n\n        /**\n         * @cfg {Number} [LIFO=-1]\n         * Configures the store to use \"**L**ast **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * This methos acts in the opposite manner as #FIFO. However; for\n         * all intents and purposes, this merely replaces the last record in\n         * the store when a new record is added.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the latest record (i.e. the 10th). This guarantees the\n         * store will never have more than 10 records at any given time. Every\n         * time a new record is added (assuming the store already has the maximum\n         * allowable records), it replaces the last record (10th) with the new\n         * record.\n         *\n         * LIFO and FIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. LIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        lifo: NGN.coalesce(cfg.LIFO, -1),\n\n        /**\n         * @cfg {Number} [maxRecords=-1]\n         * Setting this will prevent new records from being added past this limit.\n         * Attempting to add a record to the store beyond it's maximum will throw\n         * an error.\n         */\n        maxRecords: NGN.coalesce(cfg.maxRecords, -1),\n\n        /**\n         * @cfg {Number} [minRecords=0]\n         * Setting this will prevent removal of records if the removal would\n         * decrease the count below this limit.\n         * Attempting to remove a record below the store's minimum will throw\n         * an error.\n         */\n        minRecords: NGN.coalesce(cfg.minRecords, 0),\n\n        /**\n         * @cfg {Number} [autocompact=50000]\n         * Identify the number of deletions that should occur before\n         * the store is compacted. See #compact. Set this to any value\n         * below `100` (the minimum) to disable autocompact.\n         */\n        autocompact: NGN.coalesce(cfg.autocompact, 50000),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        MAP: NGN.coalesce(cfg.fieldmap),\n\n        EVENTS: new Set([\n          'record.duplicate',\n          'record.create',\n          'record.update',\n          'record.delete',\n          'record.restored',\n          'record.purged',\n          'record.move',\n          'record.invalid',\n          'record.valid',\n          'clear',\n          'filter.create',\n          'filter.delete',\n          'index.create',\n          'index.delete',\n          'compact.start',\n          'compact.complete'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: (change) => {\n          if (change.hasOwnProperty('cursor')) {\n            this.METADATA.AUDITLOG.commit(this.METADATA.getAuditMap())\n          }\n        },\n\n        // The first and last indexes are maintained to determine which active\n        // record is considered first/last. Sometimes data is filtered out,\n        // so the first/last active record is not guaranteed to represent the\n        // first/last actual record. These indexes are maintained to prevent\n        // unnecessary iteration in large data sets.\n        FIRSTRECORDINDEX: 0,\n        LASTRECORDINDEX: 0,\n\n        /**\n         * @cfg {array} [index]\n         * An array of #model fields that will be indexed.\n         * See NGN.DATA.Index for details.\n         */\n        INDEX: null\n      }),\n\n      // Internal attributes that should not be extended.\n      PRIVATE: NGN.privateconst({\n        STUB: Symbol('record.stub'),\n\n        // A private indexing method\n        INDEX: function (record, delta) {\n          if (typeof this.event === 'symbol') {\n            switch (this.event) {\n              case me.PRIVATE.EVENT.CREATE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(record[field], record.OID))\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].remove(record.OID, record[field]))\n                break\n\n              case me.PRIVATE.EVENT.LOAD_RECORDS:\n                for (let i = 0; i < me.METADATA.records.length; i++) {\n                  me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(me.METADATA.records[i][field], me.METADATA.records[i].OID))\n                }\n\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD_FIELD:\n                if (me.METADATA.INDEXFIELDS.has(record.field.name)) {\n                  me.METADATA.INDEX[record.field.name].remove(record.record.OID, record.field.value)\n                }\n\n                break\n            }\n          } else {\n            switch (this.event) {\n              case 'record.update':\n                if (me.METADATA.INDEXFIELDS.has(delta.field.name)) {\n                  me.METADATA.INDEX[delta.field.name].update(record.OID, delta.old, delta.new)\n                }\n                break\n\n              case 'clear':\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].reset())\n                break\n            }\n          }\n        },\n\n        // Contains a map of all records\n        RECORDMAP: new Map(),\n\n        // A reference to active records\n        ACTIVERECORDMAP: null,\n\n        // A reference to filtered records (non-active/non-deleted)\n        FILTEREDRECORDMAP: null,\n\n        // Internal events\n        EVENT: {\n          CREATE_RECORD: Symbol('record.create'),\n          DELETE_RECORD: Symbol('record.delete'),\n          DELETE_RECORD_FIELD: Symbol('records.field.delete'),\n          LOAD_RECORDS: Symbol('records.load')\n        },\n\n        // Makes sure the model configuration specifies a valid and indexable field.\n        checkModelIndexField: (field) => {\n          let metaconfig = this.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields && metaconfig.fields.hasOwnProperty(field)) {\n            if (metaconfig.fields[field] !== null) {\n              if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(metaconfig.fields[field])) >= 0) {\n                throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n              } else if (NGN.typeof(metaconfig.fields[field]) === 'object') {\n                if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(NGN.coalesce(metaconfig.fields[field].type))) >= 0) {\n                  throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n                }\n              }\n            }\n          } else {\n            throw new Error(`Cannot create index for unrecognized field \"${field}\".`)\n          }\n        },\n\n        // Get the type of field from the model definition\n        getModelFieldType: (field) => {\n          let metaconfig = this.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields[field] === null) {\n            return NGN.typeof(metaconfig.fields[field])\n          }\n\n          if (metaconfig.fields[field].type) {\n            return NGN.typeof(metaconfig.fields[field].type)\n          }\n\n          if (metaconfig.fields[field].default) {\n            return NGN.typeof(metaconfig.fields[field].default)\n          }\n\n          return NGN.typeof(NGN.coalesce(metaconfig.fields[field]))\n        },\n\n        // Add a record\n        addRecord: (data, suppressEvents = false) => {\n          const record = new me.METADATA.Model(data)\n\n          if (!(record instanceof NGN.DATA.Entity)) {\n            throw new Error(`Only a NGN.DATA.Model or JSON object may be used in NGN.DATA.Store#add. Received a \"${NGN.typeof(data)}\" value.`)\n          }\n\n          // Prevent invalid record addition (if configured)\n          if (!me.METADATA.allowInvalid && !record.valid) {\n            NGN.WARN(`An attempt to add invalid data to the \"${this.name}\" store was prevented. The following fields are invalid: ${Array.from(record.METADATA.invalidFieldNames.keys()).join(', ')}`)\n\n            if (!suppressEvents) {\n              this.emit('record.invalid', record)\n            }\n\n            if (this.METADATA.errorOnInvalid) {\n              throw new Error(`Invalid data cannot be added to the \"${this.name}\" store.`)\n            }\n          }\n\n          // If duplicates are prevented, check the new data.\n          if (!me.METADATA.allowDuplicates) {\n            for (let i = 0; i < this.METADATA.records.length; i++) {\n              if (this.METADATA.records[i].checksum === record.checksum) {\n                NGN.WARN(`An attempt to add a duplicate record to the \"${this.name}\" store was prevented.`)\n\n                if (!suppressEvents) {\n                  this.emit('record.duplicate', record)\n                }\n\n                if (this.METADATA.errorOnDuplicate) {\n                  throw new Error(`Duplicate records are not allowed in the \"${this.name}\" data store.`)\n                }\n\n                break\n              }\n            }\n          }\n\n          // Handle special record count processing (LIFO/FIFO support)\n          if (me.METADATA.lifo > 0 && me.METADATA.records.length + 1 > me.METADATA.lifo) {\n            me.remove(me.METADATA.records.length - 1, suppressEvents)\n          } else if (this.METADATA.fifo > 0 && me.METADATA.records.length + 1 > me.METADATA.fifo) {\n            me.remove(0, suppressEvents)\n          }\n\n          // Relay model events to this store.\n          // record.relay('*', this, 'record.')\n          record.on('*', function () {\n            switch (this.event) {\n              // case 'field.update':\n              // case 'field.delete':\n              //   // TODO: Update indices\n              //   return\n\n              case 'field.invalid':\n              case 'field.valid':\n                return me.emit(this.event.replace('field.', 'record.'), record)\n\n              case 'expired':\n                // TODO: Handle expiration\n            }\n          })\n\n          delete record.METADATA.store\n          Object.defineProperty(record.METADATA, 'store', NGN.get(() => me))\n\n          // Indexing is handled in an internal event handler\n          me.METADATA.records.push(record)\n\n          // Add the record to the map for efficient retrievel by OID\n          me.PRIVATE.RECORDMAP.set(record.OID, me.METADATA.records.length - 1)\n\n          return record\n        },\n\n        convertStubToRecord: (index, record) => {\n          if (record.hasOwnProperty(this.PRIVATE.STUB)) {\n            let newRecord = this.PRIVATE.addRecord(record.metadata, false)\n            newRecord.OID = record.OID\n\n            this.METADATA.records[index] = newRecord\n\n            return newRecord\n          } else {\n            return record\n          }\n        }\n      }),\n\n      // Create a convenience alias for the remove method.\n      delete: NGN.const(NGN.deprecate(this.remove, 'Store.delete is deprecated. Use Store.remove instead.'))\n    })\n\n    // Create a smart reference to record lists\n    Object.defineProperties(this.PRIVATE, {\n      ACTIVERECORDS: NGN.get(() => {\n        if (this.PRIVATE.ACTIVERECORDMAP === null) {\n          return this.PRIVATE.RECORDMAP\n        }\n\n        return this.PRIVATE.ACTIVERECORDMAP\n      }),\n\n      FILTEREDRECORDS: NGN.get(() => {\n        if (this.PRIVATE.FILTEREDRECORDMAP === null) {\n          return this.PRIVATE.RECORDMAP\n        }\n\n        return this.PRIVATE.FILTEREDRECORDMAP\n      })\n    })\n\n    // Disallow modification of internal events\n    Object.freeze(this.PRIVATE.EVENT)\n\n    // Support LIFO (Last In First Out) & FIFO(First In First Out)\n    if (this.METADATA.lifo > 0 && this.METADATA.fifo > 0) {\n      throw new InvalidConfigurationError('NGN.DATA.Store can be configured to use FIFO or LIFO, but not both simultaneously.')\n    }\n\n    // If LIFO/FIFO is used, disable alternative record count limitations.\n    if (this.METADATA.lifo > 0 || this.METADATA.fifo > 0) {\n      this.METADATA.minRecords = 0\n      this.METADATA.maxRecords = -1\n    } else {\n      this.METADATA.minRecords = this.METADATA.minRecords < 0 ? 0 : this.METADATA.minRecords\n    }\n\n    // Bubble events to the BUS\n    // this.relay('*', NGN.BUS, 'store.')\n\n    // Configure Indices\n    if (NGN.coalesce(cfg.index) && NGN.typeof(this.METADATA.Model.prototype.CONFIGURATION.fields) === 'object') {\n      this.createIndex(cfg.index)\n    }\n\n    // Setup auto-compact\n    if (this.METADATA.autocompact < 100) {\n      this.METADATA.DELETECOUNT = 0\n      this.on(this.PRIVATE.EVENTS.DELETE_RECORD, () => {\n        this.METADATA.DELETECOUNT++\n\n        if (this.METADATA >= this.METADATA.autocompact) {\n          this.METADATA.DELETECOUNT = 0\n          this.compact()\n        }\n      })\n    }\n  }\n\n  /**\n   * @property {array} snapshots\n   * Contains the data snapshot of the entire store.\n   * @readonly\n   * @private\n   */\n  get snapshots () {\n    return NGN.coalesce(this.snapshotarchive, [])\n  }\n\n  // Deprecation notice\n  get history () {\n    NGN.WARN('history is deprecated. Use NGN.DATA.Store#changelog instead.')\n    return this.changelog\n  }\n\n  // Deprecation notice\n  get recordCount () {\n    NGN.WARN('recordCount is deprecated. Use NGN.DATA.Store#size instead.')\n    return this.size\n  }\n\n  /**\n   * @property {number} count\n   * The total number of **active** records contained in the store.\n   * Active records are any records that aren't filtered out.\n   */\n  get size () {\n    return this.PRIVATE.ACTIVERECORDS.size\n  }\n\n  /**\n   * @property {number} length\n   * The total number of records contained in the store.\n   * This value does not include any soft-deleted/volatile records.\n   */\n  get length () {\n    return this.METADATA.records.length\n  }\n\n  /**\n   * @property {NGN.DATA.Model} first\n   * Return the first active record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get first () {\n    let record = NGN.coalesce(this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n\n    return this.PRIVATE.convertStubToRecord(this.METADATA.FIRSTRECORDINDEX, record)\n    // return NGN.coalesce(this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n  }\n\n  /**\n   * @property {NGN.DATA.Model} last\n   * Return the last active record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get last () {\n    let record = NGN.coalesce(this.METADATA.records[this.METADATA.LASTRECORDINDEX])\n\n    return this.PRIVATE.convertStubToRecord(this.METADATA.LASTRECORDINDEX, record)\n  }\n\n  /**\n   * @property {object} data\n   * A serialized version of the data represented by the store. This\n   * only includes non-virtual fields. See #representation to use\n   * a representation of data containing virtual fields.\n   */\n  get data () {\n    const recordList = this.PRIVATE.ACTIVERECORDS\n\n    // If no records exist, skip\n    if (recordList.size === 0) {\n      return []\n    }\n\n    let rec = this.PRIVATE.convertStubToRecord(this.METADATA.FIRSTRECORDINDEX, this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n\n    if (this.METADATA.MAP === null) {\n      this.METADATA.MAP = NGN.coalesce(rec.MAP)\n    }\n\n    let defaults = null\n\n    if (rec instanceof NGN.DATA.Entity) {\n      let fieldDefinitions = rec.fieldDefinitions\n      let fields = Object.keys(fieldDefinitions)\n\n      defaults = {}\n\n      fields.forEach(field => {\n        if (!fieldDefinitions[field].hidden && !fieldDefinitions[field].virtual) {\n          defaults[field] = fieldDefinitions[field].default\n        }\n      })\n    }\n\n    const result = []\n    // const fields = defaults !== null ? Object.keys(defaults) : []\n\n    // Iterate through set\n    recordList.forEach(index => {\n      if (this.METADATA.records[index] !== null) {\n        // If the value is a stub, map it.\n        if (this.METADATA.records[index].hasOwnProperty(this.PRIVATE.STUB)) {\n          let applicableData = Object.assign({}, defaults)\n          let data = Object.assign(applicableData, this.METADATA.records[index].metadata)\n\n          if (this.METADATA.MAP !== null) {\n            result.push(this.METADATA.MAP.applyInverseMap(data))\n          } else {\n            result.push(data)\n          }\n        } else {\n          result.push(this.METADATA.records[index].data)\n        }\n      }\n    })\n\n    return result\n  }\n\n  /**\n   * @property {array} representation\n   * The complete and unfiltered underlying representation dataset\n   * (data + virtuals of each model).\n   */\n  get representation () {\n    const result = []\n    const recordList = this.PRIVATE.ACTIVERECORDS\n\n    recordList.forEach(index => {\n      if (this.METADATA.records[index] !== null) {\n        result.push(this.METADATA.records[index].representation)\n      }\n    })\n\n    return result\n  }\n\n  get auditable () {\n    return this.METADATA.AUDITABLE\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n    }\n  }\n\n  get model () {\n    return this.METADATA.Model\n  }\n\n  // set model (value) {\n  //   if (value !== this.METADATA.Model) {\n  //     if (NGN.typeof(value) !== 'model') {\n  //       throw new InvalidConfigurationError(`\"${this.name}\" model could not be set because the value is a ${NGN.typeof(value)} type (requires NGN.DATA.Model).`)\n  //     }\n  //\n  //     this.METADATA.Model = value\n  //   }\n  // }\n\n  get map () {\n    return this.METADATA.MAP\n  }\n\n  /**\n   * @property {array} indexedFieldNames\n   * An array of the field names for which the store maintains indexes.\n   */\n  get indexedFieldNames () {\n    if (this.METADATA.INDEXFIELDS) {\n      return Array.from(this.METADATA.INDEXFIELDS)\n    } else {\n      return []\n    }\n  }\n\n  /**\n   * @method add\n   * Append a data record to the store. This adds the record to the end of the list.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in #model.\n   * @param {boolean} [suppressEvents=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  add (data, suppressEvents = false) {\n    // Support array input\n    if (NGN.typeof(data) === 'array') {\n      let result = new Array(data.length)\n\n      for (let i = 0; i < data.length; i++) {\n        result[i] = this.add(data[i], suppressEvents)\n      }\n\n      return result\n    }\n\n    // Prevent creation if it will exceed maximum record count.\n    if (this.METADATA.maxRecords > 0 && this.METADATA.records.length + 1 > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    if (!(data instanceof this.METADATA.Model)) {\n      // Force a data model\n      if (NGN.typeof(data) === 'string') {\n        data = JSON.parse(data)\n      }\n\n      if (typeof data !== 'object') {\n        throw new Error(`${NGN.typeof(data)} is an invalid data type (must be an object conforming to the ${this.METADATA.Model.name} field configuration).`)\n      }\n    } else {\n      data = data.data\n    }\n\n    const record = this.PRIVATE.addRecord(data)\n\n    // TODO: Apply filters to new record before identifying the last record.\n    this.METADATA.LASTRECORDINDEX = this.METADATA.records.length - 1\n\n    this.emit(this.PRIVATE.EVENT.CREATE_RECORD, record)\n\n    if (!suppressEvents) {\n      this.emit('record.create', record)\n    }\n\n    return record\n  }\n\n  /**\n   * @method remove\n   * Remove a record.\n   * @param {NGN.DATA.Model|number|Symbol} record\n   * Accepts an existing NGN Data Model or index number.\n   * Using a model is slower than using an index number.\n   * This may also be the NGN.DATA.Model#OID value (for\n   * advanced use cases).\n   * @fires record.delete\n   * The record delete event sends 2 arguments to handler methods:\n   * `record` and `index`. The record refers to the model that was\n   * removed. The `index` refers to the position of the record within\n   * the store's data list. **NOTICE** the `index` refers to where\n   * the record _used to be_.\n   * @returns {NGN.DATA.Model}\n   * Returns the data model that was just removed. If a model\n   * is unavailable (i.e. remove didn't find the specified record),\n   * this will return `null`.\n   */\n  remove (record, suppressEvents = false) {\n    // Short-circuit processing if there are no records.\n    if (this.METADATA.records.length === 0) {\n      NGN.INFO(`\"${this.name}\" store called remove(), but the store contains no records.`)\n      return\n    }\n\n    // Support removal of simultaneously removing multiple records\n    if (NGN.typeof(record) === 'array') {\n      let result = new Array(record.length)\n\n      for (let i = 0; i < record.length; i++) {\n        result[i] = this.remove(record[i])\n      }\n\n      return result\n    }\n\n    // Prevent removal if it will exceed minimum record count.\n    if (this.minRecords > 0 && this.METADATA.records.length - 1 < this.minRecords) {\n      throw new Error('Removing this record would violate the minimum record count.')\n    }\n\n    // Identify which record will be removed.\n    let index\n\n    switch (NGN.typeof(record)) {\n      case 'number':\n        if (record < 0 || !this.METADATA.records[record]) {\n          NGN.ERROR(`Record removal failed (record not found at index ${(record || 'undefined').toString()}).`)\n          return null\n        }\n\n        index = record\n\n        break\n\n      // The default case comes before the symbol case specifically\n      // so the record can be converted to an OID value (for use with\n      // the RECORDMAP lookup).\n      default:\n        if (!(record instanceof NGN.DATA.Entity)) {\n          NGN.ERROR('Invalid record value passed to Store.remove() method.')\n          return null\n        }\n\n        record = record.OID\n\n      case 'symbol': // eslint-disable-line no-fallthrough\n        index = this.PRIVATE.ACTIVERECORDS.get(record)\n\n        if (index < 0) {\n          NGN.ERROR(`Record removal failed. Record OID not found (\"${record.toString()}\").`)\n          return null\n        }\n\n        break\n    }\n\n    // If nothing has been deleted yet, create an active record map.\n    // The active record map contains Model OID values with a reference\n    // to the actual record index.\n    if (this.PRIVATE.ACTIVERECORDMAP === null) {\n      // Copy the record map to initialize the active records\n      this.PRIVATE.ACTIVERECORDMAP = new Map(this.PRIVATE.RECORDMAP)\n    }\n\n    // Identify the record to be removed.\n    const removedRecord = this.METADATA.records[index]\n\n    // If the record isn't among the active records, do not remove it.\n    if (removedRecord === null) {\n      NGN.WARN('Specified record does not exist.')\n      return null\n    }\n\n    let activeIndex = this.PRIVATE.ACTIVERECORDS.get(removedRecord.OID)\n\n    if (isNaN(activeIndex)) {\n      NGN.WARN(`Record not found for \"${removedRecord.OID.toString()}\".`)\n      return null\n    }\n\n    this.PRIVATE.ACTIVERECORDS.delete(removedRecord.OID)\n\n    // If the store is configured to soft-delete,\n    // don't actually remove it until it expires.\n    if (this.METADATA.softDelete) {\n      if (this.METADATA.softDeleteTtl >= 0) {\n        removedRecord.once('expired', () => {\n          this.METADATA.records[this.PRIVATE.RECORDMAP.get(removedRecord.OID)] = null\n          this.PRIVATE.RECORDMAP.delete(removedRecord.OID)\n\n          if (!suppressEvents) {\n            this.emit('record.purge', removedRecord)\n          }\n        })\n\n        removedRecord.expires = this.METADATA.softDeleteTtl\n      }\n    } else {\n      this.METADATA.records[this.PRIVATE.RECORDMAP.get(removedRecord.OID)] = null\n      this.PRIVATE.RECORDMAP.delete(removedRecord.OID)\n    }\n\n    // Update cursor indexes (to quickly reference first and last active records)\n    if (this.METADATA.LASTRECORDINDEX === activeIndex) {\n      if (this.PRIVATE.ACTIVERECORDS.size <= 1) {\n        this.METADATA.LASTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.values().next().value\n        this.METADATA.FIRSTRECORDINDEX = this.METADATA.LASTRECORDINDEX\n      } else if (activeIndex !== 0) {\n        for (let i = (activeIndex - 1); i >= 0; i--) {\n          if (i === 0) {\n            this.METADATA.LASTRECORDINDEX = 0\n            break\n          }\n\n          const examinedRecord = this.METADATA.records[i]\n\n          if (examinedRecord !== null) {\n            if (this.PRIVATE.ACTIVERECORDS.has(examinedRecord.OID)) {\n              this.METADATA.LASTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.get(examinedRecord.OID)\n              break\n            }\n          }\n        }\n      }\n    } else if (this.METADATA.FIRSTRECORDINDEX === activeIndex) {\n      let totalSize = this.PRIVATE.ACTIVERECORDS.size\n\n      for (let i = (activeIndex + 1); i < totalSize; i++) {\n        const examinedRecord = this.METADATA.records[i]\n\n        if (examinedRecord !== null) {\n          if (this.PRIVATE.ACTIVERECORDS.has(examinedRecord.OID)) {\n            this.METADATA.FIRSTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.get(examinedRecord.OID)\n            break\n          }\n        }\n      }\n    }\n\n    this.emit(this.PRIVATE.EVENT.DELETE_RECORD, removedRecord)\n\n    if (!suppressEvents) {\n      this.emit('record.delete', removedRecord)\n    }\n\n    return removedRecord\n  }\n\n  /**\n   * Create a new index on the store.\n   * @param  {string} field\n   * The name of the field to index.\n   * @fires index.create\n   * Triggered when an index is created. The name of field is passed\n   * as the only argument.\n   */\n  createIndex (field) {\n    // Support multiple indexes\n    if (NGN.typeof(field) === 'array') {\n      for (let i = 0; i < field.length; i++) {\n        this.createIndex(field[i])\n      }\n\n      return\n    }\n\n    // Make sure index fields are known to the store\n    if (!this.METADATA.INDEXFIELDS) {\n      this.METADATA.INDEXFIELDS = new Set()\n\n      // this.on('record.*', this.PRIVATE.INDEX)\n      this.on([\n        this.PRIVATE.EVENT.CREATE_RECORD,\n        this.PRIVATE.EVENT.DELETE_RECORD,\n        this.PRIVATE.EVENT.LOAD_RECORDS,\n        this.PRIVATE.EVENT.DELETE_RECORD_FIELD,\n        'clear'\n      ], this.PRIVATE.INDEX)\n    }\n\n    // In an index already exists, ignore it.\n    if (this.METADATA.INDEXFIELDS.has(field)) {\n      return\n    }\n\n    // Guarantee the existance of the index list\n    this.METADATA.INDEX = NGN.coalesce(this.METADATA.INDEX, {})\n\n    this.PRIVATE.checkModelIndexField(field)\n\n    this.METADATA.INDEXFIELDS.add(field)\n\n    // Identify BTree\n    let btree = ['number', 'date'].indexOf(this.PRIVATE.getModelFieldType(field)) >= 0\n\n    this.METADATA.INDEX[field] = new NGN.DATA.Index(btree, `${field.toUpperCase()} ${btree ? 'BTREE ' : ''}INDEX`)\n\n    // Apply to any existing records\n    if (this.METADATA.records.length > 0) {\n      this.PRIVATE.INDEX.apply({ event: this.PRIVATE.EVENT.LOAD_RECORDS })\n    }\n\n    this.emit('index.created', field)\n  }\n\n  /**\n   * Remove an existing index from the store.\n   * @param  {string} [field=null]\n   * The name of the indexed field. Set this to `null` (or leave blank) to\n   * remove all existing indexes.\n   * @fires index.delete\n   * Triggered when an index is removed. The name of field is passed\n   * as the only argument.\n   */\n  removeIndex (field = null) {\n    if (!this.METADATA.INDEXFIELDS) {\n      return\n    }\n\n    if (NGN.coalesce(field) === null) {\n      field = this.indexedFieldNames\n    }\n\n    // Support multiple indexes\n    if (NGN.typeof(field) === 'array') {\n      for (let i = 0; i < field.length; i++) {\n        this.removeIndex(field[i])\n      }\n\n      return\n    }\n\n    // Remove the specific index.\n    this.METADATA.INDEXFIELDS.delete(field)\n    delete this.METADATA.INDEX[field]\n    this.emit('index.delete', field)\n\n    // When there are no more indexes, clear out event\n    // listeners and fields.\n    if (this.METADATA.INDEXFIELDS.size === 0) {\n      this.METADATA.INDEX = null\n      delete this.METADATA.INDEXFIELDS\n\n      this.off([\n        this.PRIVATE.EVENT.CREATE_RECORD,\n        this.PRIVATE.EVENT.DELETE_RECORD,\n        this.PRIVATE.EVENT.LOAD_RECORDS,\n        this.PRIVATE.EVENT.DELETE_RECORD_FIELD\n      ], this.PRIVATE.INDEX)\n    }\n  }\n\n  /**\n   * Retrieve a record based on it's relative position to another\n   * record. This method is used by NGN.DATA.Model#next and NGN.DATA.Model#previous\n   * to support \"doubly linked list\" approach to record iteration.\n   * @param  {[type]}  currentRecord [description]\n   * @param  {Number}  [count=1]     [description]\n   * @param  {Boolean} [cycle=false] [description]\n   * @return {[type]}                [description]\n   */\n  getRecordSibling (currentRecord, count = 1, cycle = false) {\n    let size = this.size\n\n    if (size === 0) {\n      NGN.WARN('Attempted to execute getRecordSibling with no active records.')\n      return null\n    }\n\n    // Make sure the iterator fits within the range\n    if (Math.abs(count) > size) {\n      count = count % size\n    }\n\n    if (size === 1 || count === 0) {\n      return currentRecord\n    }\n\n    let ActiveRecords = Array.from(this.PRIVATE.ACTIVERECORDS)\n    let currentIndex = ActiveRecords.findIndex(item => currentRecord.OID === item[0])\n\n    if (currentIndex < 0) {\n      throw new Error('Record not found.')\n    }\n\n    currentIndex += count\n\n    // Support cycling through records.\n    if ((currentIndex >= ActiveRecords.length || currentIndex < 0) && cycle) {\n      // Cycle forwards\n      if (count > 0) {\n        currentIndex = currentIndex % ActiveRecords.length\n      } else {\n        // Cycle Backwards\n        currentIndex = ActiveRecords.length - Math.abs(currentIndex)\n      }\n    }\n\n    if (currentIndex < 0 || currentIndex >= ActiveRecords.length) {\n      return null\n    }\n\n    return this.METADATA.records[ActiveRecords[currentIndex][1]]\n  }\n\n  /**\n   * Returns the index number of the model. If the same\n   * model exists more than once (duplicate records), only\n   * the first index is returned.\n   * @param  {NGN.DATA.Model} model\n   * The model/record to retrieve an index number for.\n   * @return {number}\n   * The zero-based index number of the model.\n   */\n  indexOf (record) {\n    return this.PRIVATE.RECORDMAP.get(record.OID)\n  }\n\n  /**\n   * Determine whether the store contains a record.\n   * This only checks the active record set (ignores filtered records).\n   * @param  {NGN.DATA.Model} record\n   * The record to test for inclusion.\n   * @return {boolean}\n   */\n  contains (record) {\n    return this.PRIVATE.ACTIVERECORDS.has(record.OID)\n  }\n\n  /**\n   * Get the list of records for the given value.\n   * @param {string} fieldName\n   * The name of the indexed field.\n   * @param  {any} fieldValue\n   * The value of the index field. This is used to lookup\n   * the list of records/models whose field is equal to\n   * the specified value.\n   * @return {NGN.DATA.Model[]}\n   * Returns an array of models/records within the index for\n   * the given value.\n   */\n  getIndexRecords (field, value) {\n    if (this.METADATA.INDEX && this.METADATA.INDEX.hasOwnProperty(field)) {\n      let oid = this.METADATA.INDEX[field].recordsFor(value)\n      let result = new Array(oid.length)\n\n      for (let i = 0; i < oid.length; i++) {\n        result[i] = this.METADATA.records[this.PRIVATE.RECORDMAP.get(oid[i])]\n      }\n\n      return result\n    }\n\n    return []\n  }\n\n  /**\n   * Retrieve an active record by index number (0-based, similar to an array).\n   * @param  {number} [index=0]\n   * The index of the record to retrieve.\n   */\n  getRecord (index = 0) {\n    if (typeof index === 'symbol') {\n      index = this.PRIVATE.ACTIVERECORDS.get(index)\n    }\n\n    if (index < 0) {\n      NGN.WARN('Cannot retrieve a record for a negative index.')\n      return null\n    }\n\n    if (index >= this.PRIVATE.ACTIVERECORDS.size) {\n      NGN.WARN('Cannot retrieve a record for an out-of-scope index (index greater than total record count.)')\n      return null\n    }\n\n    return this.METADATA.records[Array.from(this.PRIVATE.ACTIVERECORDS)[index][1]]\n  }\n\n  /**\n   * @method clear\n   * Removes all data. If auditing is enabled, the transaction log is reset.\n   * @param {boolean} [purgeSoftDelete=true]\n   * Purge soft deleted records from memory.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from triggering when this method is run.\n   * @fires clear\n   * Fired when all data is removed\n   */\n  clear (purge = true, suppressEvents = false) {\n    if (this.METADATA.ARCHIVE) {\n      if (!purge) {\n        this.METADATA.ARCHIVE = this.records\n      } else {\n        delete this.METADATA.ARCHIVE\n      }\n    }\n\n    this.METADATA.records = []\n    this.PRIVATE.RECORDMAP = new Map()\n    this.PRIVATE.ACTIVERECORDMAP = null\n    this.PRIVATE.FILTEREDRECORDMAP = null\n    this.METADATA.LASTRECORDINDEX = 0\n    this.METADATA.FIRSTRECORDINDEX = 0\n\n    if (this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITLOG.reset()\n    }\n\n    // Indexes updated automatically (listening for 'clear' event)\n\n    if (!suppressEvents) {\n      this.emit('clear')\n    }\n  }\n\n  /**\n   * A special method to clear events from the underlying event emitter.\n   * This exists because #clear has a special meaning in a data store (removing\n   * all data records vs removing all events).\n   * @private\n   */\n  clearEvents () {\n    super.clear(...arguments)\n  }\n\n  /**\n   * Replace a model.\n   * @deprecated 2.0.0\n   * @param  {NGN.DATA.Model} newModel\n   * The new model.\n   */\n  replaceModel (newModel) {\n    NGN.deprecate(\n      () => { this.model = newModel },\n      'replaceModel has been deprected. Set the model directly instead.'\n    )\n  }\n\n  /**\n   * @method snapshot\n   * Add a snapshot of the current store to the #snapshot archive.\n   * This can potentially be a computationally/memory-expensive operation.\n   * The method creates a copy of all data in the store along with checksums\n   * of each element and holds the snapshot in RAM. Large stores may consume\n   * large amounts of RAM until the snapshots are released/cleared.\n   * Snapshots are most commonly used with data proxies to calculate\n   * differences in a data set before persisting them to a database.\n   * @fires snapshot\n   * Triggered when a new snapshot is created. The snapshot dataset is\n   * passed as the only argument to event handlers.\n   * @returns {object}\n   * Returns an object containing the following fields:\n   *\n   * ```js\n   * {\n   *   timestamp: 'ex: 2018-01-19T16:43:03.279Z',\n   *   checksum: 'snapshotchecksum',\n   *   modelChecksums: [\n   *     'record1_checksum',\n   *     'record2_checksum'\n   *   ],\n   *   data: { ... } // Actual data at the time of the snapshot\n   * }\n   * ```\n   */\n  snapshot () {\n    this.METADATA.snapshotarchive = NGN.coalesce(this.METADATA.snapshotarchive, [])\n\n    let data = this.data\n    let dataset = {\n      id: NGN.DATA.UTILITY.GUID(),\n      timestamp: (new Date()).toISOString(),\n      checksum: NGN.DATA.UTILITY.checksum(JSON.stringify(data)).toString(),\n      modelChecksums: this.data.map((item) => {\n        return NGN.DATA.UTILITY.checksum(JSON.stringify(item)).toString()\n      }),\n      data: data\n    }\n\n    this.METADATA.snapshotarchive.unshift(dataset)\n    this.emit('snapshot', dataset)\n\n    return dataset\n  }\n\n  /**\n   * @method clearSnapshots\n   * Remove all archived snapshots.\n   */\n  clearSnapshots () {\n    this.snapshotarchive = null\n  }\n\n  load (data) {\n    console.time('load')\n    let insertableData\n\n    // Guarantee unique records amongst only the new records\n    if (!this.METADATA.allowDuplicates) {\n      let uniqueValues = new Set()\n\n      insertableData = []\n\n      for (let i = 0; i < data.length; i++) {\n        if (!uniqueValues.has(JSON.stringify(data[i]))) {\n          uniqueValues.add(JSON.stringify(data[i]))\n          insertableData.push(data[i])\n        } else if (this.METADATA.errorOnDuplicate) {\n          throw new NGNDuplicateRecordError()\n        }\n      }\n    } else {\n      insertableData = data\n    }\n\n    let newRecordCount = insertableData.length + this.METADATA.records.length\n\n    // Don't exceed the maximum record count if it exists.\n    if (this.METADATA.maxRecords > 0 && newRecordCount > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    if (newRecordCount > 4000000) {\n      throw new Error('Maximum load size exceeded. A store may contain a maximum of 4M records.')\n    }\n\n    for (let i = 0; i < insertableData.length; i++) {\n      let oid = Symbol('model.id')\n      this.METADATA.records.push({\n        [this.PRIVATE.STUB]: true,\n        OID: oid,\n        metadata: insertableData[i]\n      })\n\n      // Add the record to the map for efficient retrievel by OID\n      this.PRIVATE.RECORDMAP.set(oid, this.METADATA.records.length - 1)\n    }\n\n    // TODO: Apply filters to new record before identifying the last record.\n    this.METADATA.LASTRECORDINDEX = this.METADATA.records.length - 1\n\n    // this.emit(this.PRIVATE.EVENT.LOAD_RECORDS)\n  }\n\n  /**\n   * This rebuilds the local index of records, removing any dead records.\n   * While deleted records are destroyed (in accordance to #softDeleteTtl),\n   * the active record table contains a `null` or `undefined` value for each\n   * deleted/dead record. This method removes such records, akin in nature to\n   * the common JavaScript garbage collection process.\n   *\n   * This method almost never needs to be run, since stores\n   * attempt to manage this process for themselves automatically. However; if\n   * large volume deletions occur rapidly (50K+), it's possible (though not assured)\n   * performance could be negatively impacted. Compacting the store can\n   * improve performance in these cases. However; running this too often or\n   * excessively may degrade performance since it is essentially rewriting\n   * the store data each time.\n   *\n   * When in doubt, *don't* use this method.\n   * @info This method will not run when fewer than 100 cumulative records have\n   * existed in the store, due to the inefficient nature at such low volume.\n   * @fires compact.start\n   * Triggered when the compact process begins.\n   * @fires compact.complete\n   * Triggered when the compact process completes.\n   */\n  compact () {\n    this.emit('compact.start')\n\n    if (this.METADATA.records.length < 100) {\n      this.emit('compact.complete')\n\n      if (this.METADATA.records.length !== 0) {\n        NGN.WARN(`compact() called on ${this.name} with fewer than 100 elements.`)\n      }\n\n      return\n    }\n\n    let ranges = []\n    let currentRange = []\n    let empty = 0\n\n    // Identify null ranges (dead records)\n    for (let i = 0; i < this.METADATA.records.length; i++) {\n      if (this.METADATA.records[i] === null) {\n        empty++\n\n        if (currentRange.length === 0) {\n          currentRange.push(i)\n        }\n      } else {\n        // Identify new index values for remaining records\n        if (empty > 0) {\n          this.PRIVATE.RECORDMAP.set(this.METADATA.records[i].OID, i - empty)\n\n          if (this.METADATA.FIRSTRECORDINDEX === i) {\n            this.METADATA.FIRSTRECORDINDEX = i - empty\n          }\n\n          if (this.METADATA.LASTRECORDINDEX === i) {\n            this.METADATA.LASTRECORDINDEX = i - empty\n          }\n        }\n\n        if (currentRange.length === 1) {\n          currentRange.push(i - 1)\n          ranges.push(currentRange)\n          currentRange = []\n        }\n      }\n    }\n\n    // Clear null ranges\n    empty = 0\n    while (ranges.length > 0) {\n      this.METADATA.records.splice(ranges[0][0] - empty, ranges[0][1] - ranges[0][0] + 1)\n      empty += ranges[0][1] - ranges[0][0] + 1\n      ranges.shift()\n    }\n\n    // Reset the active record map\n    this.PRIVATE.ACTIVERECORDMAP = null\n\n    this.emit('compact.complete')\n  }\n\n  /**\n   * Performs executes the callback method on each active record\n   * within the store. For example:\n   *\n   * ```js\n   * Store.forEach(function (record) {\n   *   // Do Something\n   * })\n   * ```\n   * @param  {Function} callback\n   * The callback method is applied to each record.\n   */\n  forEach (fn) {\n    if (!NGN.isFn(fn)) {\n      throw new Error(`A ${NGN.typeof(fn)} was applied to ${this.name}'s each() method when a function was expected.`)\n    }\n\n    this.PRIVATE.ACTIVERECORDS.forEach((value, key, map) => {\n      fn(this.METADATA.records[value])\n    })\n  }\n}\n","import UTILITY from './Utility'\nimport BTree from './index/BTree'\nimport JSONSchema from './schema/JSON'\nimport TransactionLog from './TransactionLog'\nimport Rule from './rule/Rule'\nimport RangeRule from './rule/RangeRule'\nimport Field from './field/Field'\nimport VirtualField from './field/VirtualField'\nimport Relationship from './field/Relationship'\nimport FieldMap from './field/FieldMap'\nimport Entity from './Model'\nimport Index from './index/Index'\nimport Store from './Store'\n\nconst Model = function (cfg) {\n  if (NGN.typeof(cfg) !== 'object') {\n    throw new Error('Model must be configured.')\n  }\n\n  let Model = function (data, suppressEvents = false) {\n    let Entity = new NGN.DATA.Entity(cfg)\n\n    if (data) {\n      Entity.load(data, suppressEvents)\n    }\n\n    return Entity\n  }\n\n  Object.defineProperty(Model.prototype, 'CONFIGURATION', NGN.const(cfg))\n\n  return Model\n}\n\nconst util = NGN.deprecate(UTILITY, 'NGN.DATA.util is now NGN.DATA.UTILITY')\n\nexport {\n  UTILITY,\n  util,\n  TransactionLog,\n  Rule,\n  RangeRule,\n  Field,\n  VirtualField,\n  Relationship,\n  FieldMap,\n  Model,\n  Entity,\n  Index,\n  Store,\n  BTree,\n  JSONSchema\n}\n","import EventEmitter from '../emitter/core'\n\n/**\n * @class NGN.DATA.TransactionLog\n * The transaction log is a history/changelog. It can be used to revert values\n * to a prior state or (in limited cases) restore values.\n *\n * The transaction log is based on a commit log and cursor. The commit log\n * is an ordered list of values. The cursor is a position within the log.\n *\n * **How it Works:**\n *\n * The most common purpose of a transaction log is to revert changes (undo).\n * This is accomplished with the #rollback method.\n *\n * The #rollback method does not remove records, nor does the #advance.\n * The methods repositions the log cursor. Only #commit activities actually\n * modify the log.\n *\n * For example, a log containing 5 committed records will have the cursor set to\n * the latest entry by default:\n *\n * ```\n * [1, 2, 3, 4, 5]\n *              ^\n * ```\n *\n * Executing rollback(2) moves the cursor \"back\" two positions, from `5` to\n * `3`.\n *\n * ```\n * [1, 2, 3, 4, 5]\n *        ^\n * ```\n *\n * At this point, no records have been removed. It would still be\n * possible to #advance the cursor forward to `4` or `5`. However; once a\n * #commit is executed, all logs _after_ the cursor are removed before the new\n * transaction is committed to the log.\n *\n * ```\n * [1, 2, 3] // Commit removes [4, 5]\n *        ^\n *\n * [1, 2, 3, 6] // Commit commits new entry and advances cursor.\n *           ^\n * ```\n *\n * It is also possible to immediately #flush the log without requiring a new\n * #commit. This will immediately remove all log entries after the\n * current cursor position.\n */\nexport default class NGNTransactionLog extends EventEmitter { // eslint-disable-line\n  /**\n   * Create a new transaction log.\n   * @param  {number} [maxEntryCount=10]\n   * The maximum number of entries to keep in the log. Set this to `-1` to keep\n   * an unlimited number of logs.\n   */\n  constructor (maxEntryCount) {\n    super()\n\n    Object.defineProperties(this, {\n      METADATA: NGN.private({\n        transaction: {},\n        changeOrder: [],\n        cursor: null,\n        max: NGN.coalesce(maxEntryCount, 10)\n      })\n    })\n  }\n\n  get length () {\n    return this.METADATA.changeOrder.length\n  }\n\n  /**\n   * @property {Symbol} cursor\n   * The active cursor of the log.\n   */\n  get cursor () {\n    return this.METADATA.cursor\n  }\n\n  set cursor (value) {\n    if (value !== null && !this.METADATA.transaction.hasOwnProperty(value)) {\n      throw new Error('Cannot set cursor for transaction log (does not exist).')\n    }\n\n    this.METADATA.cursor = value\n  }\n\n  /**\n   * @property {any} currentValue\n   * Returns the value at the current cursor position.\n   */\n  get currentValue () {\n    if (this.METADATA.cursor === null) {\n      return undefined\n    }\n\n    return this.getCommit(this.METADATA.cursor).value\n  }\n\n  /**\n   * @property {Number}\n   * The index of the log entry at the current cursor position.\n   */\n  get cursorIndex () {\n    if (this.METADATA.cursor === null) {\n      return undefined\n    }\n\n    return this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n  }\n\n  /**\n   * Add a new value to the transaction log.\n   * @param {Any} value\n   * The value to assign to the log (record).\n   * @return {Number}\n   * Returns the transaction number\n   * @fires log {Symbol}\n   * Fires a log event with the transaction ID (symbol) for reference.\n   */\n  commit (value) {\n    let id = typeof value === 'symbol' ? Symbol(String(value)) : Symbol(NGN.coalesce(value, NGN.typeof(value)).toString())\n\n    this.METADATA.transaction[id] = [\n      new Date(),\n      value\n    ]\n\n    this.flush()\n\n    this.METADATA.changeOrder.push(id)\n    this.METADATA.cursor = id\n\n    if (this.METADATA.max > 0 && this.METADATA.changeOrder.length > this.METADATA.max) {\n      let removedId = this.METADATA.changeOrder.shift()\n      delete this.METADATA.transaction[removedId]\n    }\n\n    this.emit('commit', id, null)\n\n    return id\n  }\n\n  /**\n   * Return the entry for the specified commit ID.\n   * @param  {Symbol} id\n   * The transaction ID.\n   * @return {Object}\n   * Returns an object with `timestamp` and `value` keys.\n   */\n  getCommit (id = null) {\n    if (!this.METADATA.transaction.hasOwnProperty(id)) {\n      return undefined\n    }\n\n    return {\n      timestamp: this.METADATA.transaction[id][0],\n      value: this.METADATA.transaction[id][1]\n    }\n  }\n\n  /**\n   * Remove all transaction log entries from the current cursor onward.\n   */\n  flush () {\n    if (this.METADATA.cursor === null) {\n      return\n    }\n\n    let position = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n\n    // If the whole log is cleared, reset it silently.\n    if (position === 0) {\n      return\n    }\n\n    let removedEntries = this.METADATA.changeOrder.splice(position + 1)\n\n    for (let i = 0; i < removedEntries.length; i++) {\n      delete this.METADATA.transaction[removedEntries[i]]\n    }\n\n    this.METADATA.cursor = this.METADATA.changeOrder[this.METADATA.changeOrder.length - 1]\n  }\n\n  /**\n   * Rollback the log to the specified index/cursor.\n   * @param  {Number|Symbol} [index=1]\n   * The index may be a number or a commit ID (symbol).\n   *\n   * **Specifying a number** will rollback the log by the specified number of\n   * commits. By default, the index is `1`, which is the equivalent of a simple\n   * \"undo\" operation. Specifying `2` would \"undo\" two operations. Values less\n   * than or equal to zero are ignored. Values greater than the total number of\n   * committed transactions trigger a reset.\n   *\n   * **Specifying a symbol** will rollback the log to the specified commit log\n   * (the symbol is the commit log ID).\n   * @fires rollback {Object}\n   * This fires a `rollback` event containing the active cursor.\n   * @return {Symbol}\n   * Returns the active cursor upon completion of rollback.\n   */\n  rollback (index = 1) {\n    // If the log is empty, ignore the rollback\n    if (this.METADATA.changeOrder.length === 0) {\n      return null\n    }\n\n    if (typeof index === 'symbol') {\n      this.cursor = index\n      return index\n    }\n\n    if (index >= this.METADATA.changeOrder.length) {\n      this.METADATA.cursor = this.METADATA.changeOrder[0]\n    } else {\n      // Make sure the index is a symbol\n      if (typeof index === 'number') {\n        if (index <= 0) {\n          return this.METADATA.cursor\n        }\n\n        let currentPosition = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n        currentPosition -= index\n\n        if (currentPosition <= 0) {\n          currentPosition = 0\n        }\n\n        index = this.METADATA.changeOrder[currentPosition]\n      }\n\n      this.METADATA.cursor = index\n    }\n\n    this.emit('rollback', this.METADATA.cursor, null)\n\n    return this.METADATA.cursor\n  }\n\n  /**\n   * Advance the log to the specified index/cursor.\n   * @param  {Number|Symbol} [index=1]\n   * The index may be a number or a commit ID (symbol).\n   *\n   * **Specifying a number** will advance the log by the specified number of\n   * commits. By default, the index is `1`, which is the equivalent of a simple\n   * \"redo\" operation. Specifying `2` would \"redo\" two operations. Values less\n   * than or equal to zero are ignored. Values greater than the total number of\n   * committed transactions will advance the cursor to the last entry.\n   *\n   * **Specifying a symbol** will advance the log to the specified commit log\n   * record (the symbol is the commit log ID).\n   * @fires advance {Object}\n   * This fires a `advance` event containing the active cursor.\n   * @return {Symbol}\n   * Returns the active cursor upon completion of rollback.\n   */\n  advance (index = 1) {\n    // If the log is empty, ignore the rollback\n    if (this.METADATA.changeOrder.length === 0) {\n      return null\n    }\n\n    // Make sure the index is a symbol\n    if (typeof index === 'number') {\n      if (index <= 0) {\n        return this.METADATA.cursor\n      }\n\n      let currentPosition = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n      currentPosition += index\n\n      if (currentPosition >= this.METADATA.changeOrder.length) {\n        currentPosition = this.METADATA.changeOrder.length - 1\n      }\n\n      index = this.METADATA.changeOrder[currentPosition]\n    }\n\n    this.METADATA.cursor = index\n\n    this.emit('advance', this.METADATA.cursor, null)\n\n    return this.METADATA.cursor\n  }\n\n  /**\n   * Clear the transaction log.\n   */\n  reset (suppressEvents = false) {\n    this.METADATA.transaction = {}\n    this.METADATA.changeOrder = []\n    this.METADATA.cursor = null\n\n    if (!suppressEvents) {\n      this.emit('reset')\n    }\n  }\n\n  /**\n   * @property {Array} log\n   * Returns the entire log, in ascending historical order (oldest first).\n   * This may be a time-consuming operation if the log is large.\n   *\n   * **Example:**\n   *\n   * ```js\n   * [{\n   *   timestamp: Date,\n   *   value: 'some value'\n   * },{\n   *   timestamp: Date,\n   *   value: 'some other value'\n   * }]\n   */\n  get log () {\n    return this.METADATA.changeOrder.map(entry => {\n      return {\n        timestamp: this.METADATA.transaction[entry][0],\n        value: this.METADATA.transaction[entry][1],\n        activeCursor: this.METADATA.cursor === entry\n      }\n    })\n  }\n}\n","import Rule from './Rule'\n\n/**\n * @class NGN.DATA.RangeRule\n * A special rule to validate values within one or more ranges.\n * Supports numeric ranges, date ranges, and simple string-based\n * ranges (string length).\n */\nexport default class NGNDataRangeValidationRule extends Rule { // eslint-disable-line\n  /**\n   * Create a new range rule.\n   * @param {string} [name]\n   * An optional name for the rule. This can be useful when debugging data issues.\n   * @param {object} [scope=null]\n   * Apply a custom scope to the validation functions (applicable to custom methods only).\n   * @param {Array} [range]\n   * An enumeration of acceptable numeric ranges. For example, if\n   * the value must be between 5-10 or from 25-50, the configuration\n   * would look like:\n   *\n   * ```js\n   * range: [\n   *   [5, 10],\n   *   ['25-50']\n   * ]\n   * ```\n   *\n   * To accept anything below a certain number or anything over a certain\n   * number while also specifying one or more ranges, use a `null` value.\n   *\n   * For example:\n   *\n   * ```js\n   * range: [\n   *   [null, 0],\n   *   [5, 10],\n   *   ['25-50'],\n   *   [100, null]\n   * ]\n   * ```\n   *\n   * The aforementioned example would accept a value less than `zero`,\n   * between `5` and `10`, between `25` and `50`, or over `100`. Therefore,\n   * acceptable values could be `-7`, `7`, `25`, `42`,  `10000`, or anything\n   * else within the ranges. However, the values `3`, `19`, and `62` would\n   * all fail because they're outside the ranges.\n   */\n  constructor (name, scope, range = []) {\n    if (NGN.typeof(scope) === 'array') {\n      range = scope\n      scope = null\n    }\n\n    super(null, name, scope)\n\n    this.RULE.prepareRange = function (value) {\n      // If a simple range is specified (single array), format it for the rule processor.\n      value = NGN.forceArray(value)\n\n      if (NGN.typeof(value[0]) !== 'array') {\n        value = [value]\n      }\n\n      for (let i = 0; i < value.length; i++) {\n        if (value[i].length !== 2) {\n          if (NGN.typeof(value[i][0]) !== 'string') {\n            throw new Error(`Invalid range: \"${value[i].toString()}\"`)\n          }\n\n          value[i] = value[i][0].replace(/[^0-9->]/gi, '').split(/->{1,100}/)\n        }\n\n        if (NGN.typeof(value[i][0]) !== 'number') {\n          value[i][0] = NGN.coalesce(value[i][0], '').replace(/null|none|any/gi, '')\n        }\n\n        if (NGN.typeof(value[i][1]) !== 'number') {\n          value[i][1] = NGN.coalesce(value[i][1], '').replace(/null|none|any/gi, '')\n        }\n      }\n\n      return value\n    }\n\n    // Initialize the range\n    this.RULE.range = new Set()\n    this.range = range\n\n    // Create the validation function.\n    this.RULE.validator = (value) => {\n      let isString = NGN.typeof(value) === 'string'\n      let range = this.range\n\n      for (let i = 0; i < range.length; i++) {\n        let min = NGN.coalesceb(range[i][0], isString ? value.length : value)\n        let max = NGN.coalesceb(range[i][1], isString ? value.length : value)\n\n        if (\n          (isString && value.length >= min && value.length <= max) ||\n          (!isString && value >= min && value <= max)\n        ) {\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n\n  get range () {\n    return Array.from(this.RULE.range.values())\n  }\n\n  set range (value) {\n    this.RULE.range = new Set()\n    this.addRange(value)\n  }\n\n  /**\n   * Add a range to the rule.\n   * @param {array} value\n   * A range can be a single array, such as `[min, max]`. An array of arrays is\n   * also acceptable, such as `[[min1, max1], [min2, max2]]`.\n   */\n  addRange (value) {\n    value = this.RULE.prepareRange(value)\n\n    for (let i = 0; i < value.length; i++) {\n      if (NGN.coalesceb(value[i][0]) !== null && NGN.coalesceb(value[i][1]) !== null && value[i][1] < value[i][0]) {\n        throw new Error(`Invalid value \"${value[i][0].toString()} -> ${value[i][1].toString()}\". Minimum value cannot exceed maximum.`)\n      }\n\n      this.RULE.range.add(value[i])\n    }\n  }\n\n  /**\n   * Remove an existing range from the rule.\n   * @param {array} value\n   * A range can be a single array, such as `[min, max]`. An array of arrays is\n   * also acceptable, such as `[[min1, max1], [min2, max2]]`.\n   */\n  removeRange (value) {\n    let range = this.range\n    value = this.RULE.prepareRange(value)\n\n    for (let i = 0; i < value.length; i++) {\n      for (let x = 0; x < range.length; x++) {\n        if (value[i].toString() === range[x].toString()) {\n          this.RULE.range.delete(range[x])\n        }\n      }\n    }\n  }\n}\n","import DataField from './Field'\n\n/**\n * @class NGN.DATA.VirtualField\n * A virtual field is a read-only ephemeral representation of data,\n * generated dynamically.\n * In other words, it's a made up data field that isn't part of what gets stored.\n * The value can be changed at any time, without warning or events. This is most\n * commonly used as an _internal class_ to support virtual fields within data\n * models. Consider the following:\n *\n * **Example:**\n *\n * ```js\n * let Person = new NGN.DATA.Model({\n *   fields: {\n *     dateOfBirth: Date\n *     age: function () {\n *       return YearsApart(new Date(), this.dateOfBirth)\n *     }\n *   }\n * })\n * ```\n *\n * The `age` example above (shorthand syntax) compares the `dateOfBirth` field\n * to the current date, expecting a numeric response. This particular virtual\n * field is useful for calculating a common value on the fly, and it is reusable\n * for any number of instances of the model.\n *\n * This functionality is available by implementing the NGN.DATA.VirtualField.\n * For example, the `age` virtual field would be created as:\n *\n * ```js\n * let age = new NGN.DATA.VirtualField(model, function () {\n *   return YearsApart(new Date(), this.dateOfBirth)\n * })\n * ```\n * @fires cache.clear {NGN.DATA.VirtualField}\n * Fired whenever the cache is cleared. The field is passed as the only argument\n * to event handler functions.\n */\nexport default class NGNVirtualDataField extends DataField { // eslint-disable-line\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    if (!(cfg.model instanceof NGN.DATA.Entity)) {\n      NGN.WARN('No model specified for the virtual field to reference.')\n    }\n\n    // Remove unnecessary config values\n    delete cfg.required\n    delete cfg.default\n    delete cfg.min\n    delete cfg.minimum\n    delete cfg.max\n    delete cfg.maximum\n    delete cfg.range\n    delete cfg.rule\n    delete cfg.rules\n    delete cfg.validators\n    delete cfg.pattern\n\n    super(cfg)\n\n    this.METADATA.AUDITABLE = false\n    this.METADATA.fieldType = 'virtual'\n\n    /**\n     * @cfg {boolean} [cache=true]\n     * By default, virtual fields _associated with a model_ will cache results\n     * to prevent unnecessary function calls. The cache is cleared whenever a\n     * local data field is modified.\n     *\n     * Caching can substantially reduce processing time in large data sets\n     * by calling methods less often. In most use cases, it will provide a\n     * substantial performance gain. However; since virtual fields can also\n     * leverage variables and methods that are not a part of the data model,\n     * caching may prevent the value from updating as expected. While this case\n     * may occur less often, it can occur. If you suspect caching is interfering\n     * with a virtual field value, it can be disabled by setting this to `false`.\n     */\n    this.METADATA.caching = NGN.coalesce(cfg.cache, true)\n\n    /**\n     * @cfg {NGN.DATA.Model|NGN.DATA.Store|Object} scope\n     * The model, store, or object that will be referenceable within the\n     * virtual field #method. The model will be available in the `this` scope.\n     */\n    this.METADATA.scope = NGN.coalesce(cfg.scope, cfg.model, this)\n\n    /**\n     * @cfg {Function} method\n     * The method used to generate a value.\n     * This is an asynchronous method the returns a value (of any type).\n     */\n    const me = this\n    const handlerFn = cfg.method\n\n    this.METADATA.virtualMethod = function () {\n      return handlerFn.apply(me.METADATA.scope, ...arguments)\n    }\n\n    // Add smart-cache support\n    this.METADATA.CACHEKEY = Symbol('no.cache')\n    this.METADATA.cachedValue = this.METADATA.CACHEKEY\n\n    // Only add caching support if a model is associated\n    if (this.METADATA.caching && this.model) {\n      // Create a method for identifying which local data fields\n      // need to be monitored (for caching)\n      const localFieldPattern = /this(\\.(.[^\\W]+)|\\[['\"]{1}(.*)+['\"]{1}\\])/g\n\n      // Returns a Set of fieldnames used in the virtual function.\n      let monitoredFields = new Set()\n      let content = handlerFn.toString()\n      let iterator = localFieldPattern.exec(content)\n\n      while (iterator !== null) {\n        let field = NGN.coalesce(iterator[2], iterator[3])\n\n        if (this.model.METADATA.knownFieldNames.has(field)) {\n          monitoredFields.add(field)\n        }\n\n        content = content.replace(localFieldPattern, '')\n        iterator = localFieldPattern.exec(content)\n      }\n\n      this.METADATA.model.pool('field.', {\n        update: (change) => {\n          if (change.field && monitoredFields.has(change.field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n          }\n        },\n\n        remove: (field) => {\n          if (monitoredFields.has(field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n            NGN.ERROR(`The ${this.name} virtual field uses the ${field.name} field, which was removed. This virtual field may no longer work.`)\n          }\n        },\n\n        create: (field) => {\n          if (monitoredFields.has(field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n            NGN.INFO(`The ${this.name} virtual field uses the ${field.name} field, which was added.`)\n          }\n        }\n      })\n    }\n  }\n\n  get auditable () {\n    NGN.WARN('Virtual fields do not support the auditable property.')\n    return false\n  }\n\n  set auditable (value) {\n    NGN.WARN('Virtual fields do not support the auditable property.')\n  }\n\n  /**\n   * @property {any} value\n   * This will always return the value of the virtual field, but it may only\n   * be _set_ to a synchronous function that returns a value.\n   */\n  get value () {\n    if (this.METADATA.caching) {\n      if (this.METADATA.cachedValue !== this.METADATA.CACHEKEY) {\n        return this.METADATA.cachedValue\n      } else {\n        this.METADATA.cachedValue = this.METADATA.virtualMethod()\n        return this.METADATA.cachedValue\n      }\n    }\n\n    return this.METADATA.virtualMethod()\n  }\n\n  set value (value) {\n    NGN.WARN('Cannot set the value of a virtual field (read only).')\n  }\n\n  get required () {\n    NGN.WARN('Virtual fields do not support the required property.')\n    return false\n  }\n\n  set required (value) {\n    NGN.WARN('Virtual fields do not support the required property.')\n  }\n\n  get isNew () {\n    NGN.WARN('Virtual fields do not support the isNew property.')\n    return false\n  }\n\n  get default () {\n    NGN.WARN('Virtual fields do not have default values.')\n    return undefined\n  }\n\n  set default (value) {\n    NGN.WARN('Virtual fields do not have default values.')\n    return undefined\n  }\n\n  get violatedRule () {\n    return 'None'\n  }\n\n  get valid () {\n    NGN.WARN('Virtual fields are always valid.')\n    return true\n  }\n\n  get modified () {\n    NGN.WARN('modified attribute does nothing on virtual fields.')\n    return false\n  }\n\n  allowInvalid () {\n    NGN.WARN('allowInvalid() unavailable for virtual fields.')\n  }\n\n  disallowInvalid () {\n    NGN.WARN('disallowInvalid() unavailable for virtual fields.')\n  }\n\n  autocorrectInput () {\n    NGN.WARN('autocorrectInput() unavailable for virtual fields.')\n  }\n}\n","import DataField from './Field'\n\n/**\n * @class NGN.DATA.Relationship\n * Represents a data field linked to another NGN.DATA.Model or\n * NGN.DATA.Store. This is used for nesting models/stores within a field,\n * supporting creation of complex data structures that are still easy\n * to work with.\n *\n * While there is no limit to how deeply nested fields can be, it is considered\n * a best practice to avoid circular relationships, which can lead to infinite\n * loops when serializing data.\n *\n * Nested models (i.e. records) each have their own data\n * NGN.DATA.Model#validators, so relationship fields defer all validation to\n * the individual record/model.\n *\n * Relationships using NGN.DATA.Stores behave a little differently, since they\n * represent a collection of data instead of a single record/model. NGN manages\n * [referential integrity](https://en.wikipedia.org/wiki/Referential_integrity)\n * using simplistic\n * [cardinality](https://en.wikipedia.org/wiki/Cardinality_(data_modeling)).\n *\n * Referential integrity & cardinality rules are data modeling principles\n * designed to enforce data quality standards. The nature of JavaScript objects\n * naturally enforces rudimentary data linking/nesting. NGN data relationships\n * build upon this, using proven data modeling principles.\n *\n * This is done, very simply, by using the @cfg#min and @cfg#max configuration\n * options. However; these options don't always need to be enforced, depending\n * on what type of cardniality needs to be achieved.\n *\n * For more information, see the Data Modeling Guide.\n *\n * **Note to self, use this next part in the guide:**\n *\n * There are five (5) common types of cardinality.\n *\n * - **1 => 1**: One-to-One\n * - **0 => 1**: Zero-or-One\n * - **0 => N**: Zero-to-Many\n * - **1 => N**: One-to-Many\n * - **N => N**: Many-to-Many\n *\n * There are also more granular types of cardinality, which are less common in\n * web applications, but often used in data and ETL operations.\n *\n * - **0,1 => 0,N**: Zero-or-One to Zero-or-More\n * - **0,1 => 1,N**: Zero-or-One to One-or-More\n * - ... write the rest in the guide...\n */\nexport default class NGNRelationshipField extends DataField { // eslint-disable-line\n  constructor (cfg = {}) {\n    let type = NGN.typeof(cfg.join)\n\n    // Assure valid configuration\n    if (!cfg.join) {\n      throw new InvalidConfigurationError('Missing \"join\" configuration property.')\n    } else if (\n      ['model', 'store'].indexOf(type) < 0 &&\n      (\n        type !== 'array' ||\n        NGN.typeof(cfg.join[0]) !== 'model'\n      )\n    ) {\n      throw new InvalidConfigurationError(`The join specified is not a valid NGN.DATA.Model, NGN.DATA.Store, or collection. It is a ${NGN.typeof(cfg.join)}\"`)\n    }\n\n    // Create optional cardinality validations\n\n    // Initialize\n    cfg.identifier = false\n    super(cfg)\n\n    this.METADATA.fieldType = 'join'\n    this.METADATA.join = Symbol('relationship')\n\n    // Apply event monitoring to the #record.\n    this.METADATA.applyMonitor = () => {\n      if (this.METADATA.manner === 'model') {\n        // Model Event Relay\n        this.METADATA.join.pool('field.', {\n          create: this.METADATA.commonModelEventHandler('field.create'),\n          update: this.METADATA.commonModelEventHandler('field.update'),\n          remove: this.METADATA.commonModelEventHandler('field.remove'),\n          invalid: (data) => {\n            this.emit(['invalid', `invalid.${this.METADATA.name}.${data.field}`])\n          },\n          valid: (data) => {\n            this.emit(['valid', `valid.${this.METADATA.name}.${data.field}`])\n          }\n        })\n      //   this.METADATA.join.pool('field.', {\n      //     create: this.METADATA.commonModelEventHandler('field.create'),\n      //     update: this.METADATA.commonModelEventHandler('field.update'),\n      //     remove: this.METADATA.commonModelEventHandler('field.remove'),\n      //     invalid: (data) => {\n      //       this.emit(['invalid', `invalid.${this.name}.${data.field}`])\n      //     },\n      //     valid: (data) => {\n      //       this.emit(['valid', `valid.${this.name}.${data.field}`])\n      //     }\n      //   })\n      // } else {\n      //   // Store Event Relay\n      //   this.METADATA.join.pool('record.', {\n      //     create: this.METADATA.commonStoreEventHandler('record.create'),\n      //     update: this.METADATA.commonStoreEventHandler('record.update'),\n      //     remove: this.METADATA.commonStoreEventHandler('record.remove'),\n      //     invalid: (data) => {\n      //       this.emit('invalid', `invalid.${this.name}.${data.field}`)\n      //     },\n      //     valid: (data) => {\n      //       this.emit('valid', `valid.${this.name}.${data.field}`)\n      //     }\n      //   })\n      }\n    }\n\n    // Event handling for nested models.\n    this.METADATA.commonModelEventHandler = (type) => {\n      const me = this\n\n      return function (change) {\n        me.METADATA.commitPayload({\n          field: `${me.name}.${change.field}`,\n          old: NGN.coalesce(change.old),\n          new: NGN.coalesce(change.new),\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: me.METADATA.record\n          }\n        })\n      }\n    }\n\n    // Event handling for nested stores.\n    this.METADATA.commonStoreEventHandler = (type) => {\n      const me = this\n\n      return function (record, change) {\n        let old = change ? NGN.coalesce(change.old) : me.data\n\n        if (this.event === 'record.create') {\n          old.pop()\n        } else if (this.event === 'record.delete') {\n          old.push(record.data)\n        }\n\n        me.METADATA.commitPayload({\n          field: me.name + (change ? `.${change.field}` : ''),\n          old: change ? NGN.coalesce(change.old) : old,\n          new: change ? NGN.coalesce(change.new) : me.data,\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: record\n          }\n        })\n      }\n    }\n\n    // const commitPayload = this.METADATA.commitPayload\n    //\n    // this.METADATA.commitPayload = (payload) => {\n    //   console.log('HERE')\n    //   commitPayload(...arguments)\n    // }\n\n    /**\n     * @cfg join {NGN.DATA.Store|NGN.DATA.Model[]}\n     * A relationship to another model/store is defined by a join.\n     * The join may be a data store or data model. It is also possible\n     * to specify a collection.\n     *\n     * For example, a join may be defined as:\n     *\n     * ```js\n     * // Use of a model\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: new NGN.DATA.Model(...)\n     * })\n     *\n     * // Use of a model collection\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: [new NGN.DATA.Model(...)]\n     * })\n     *\n     * // Use of a store\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: new NGN.DATA.Store(...)\n     * })\n     * ```\n     *\n     * A store and a model collection are both a group of models,\n     * Internally, model collections are converted to data stores.\n     *\n     * By supporting all three formats, it is possible to create complex\n     * data models, such as:\n     *\n     * ```js\n     * let Pet = new NGN.DATA.Model(...)\n     * let Kid = new NGN.DATA.Model(...)\n     * let Kids = new NGN.DATA.Store({\n     *   model: Kid\n     * })\n     *\n     * let Person = new NGN.DATA.Model({\n     *   fields: {\n     *     dateOfBirth: Date,\n     *     spouse: Person,  // <== Join a Model\n     *     kids: Kids,      // <== Join a Store\n     *     pets: [Pet]      // <== Join a Collection\n     *   }\n     * })\n     * ```\n     *\n     * The `pets` field contains a \"collection\". This shorthand notation is used\n     * to help understand real data relationships. In this case, it is easy to\n     * infer that a person may have zero or more pets.\n     */\n    this.value = NGN.coalesce(cfg.join)\n    this.METADATA.AUDITABLE = false\n    this.auditable = NGN.coalesce(cfg.audit, false)\n  }\n\n  /**\n   * @property {string} manner\n   * The manner of relationship. This can be one of 3 values: `store`\n   * (NGN.DATA.Store), `model` (NGN.DATA.Model), or `collection`. A collection\n   * is a special configuration shortcut used to represent a new store of models.\n   *\n   * For example, a model may be defined as:\n   *\n   * ```js\n   * let Pet = new NGN.DATA.Model({\n   *   fields: {\n   *     name: String,\n   *     animalType: String\n   *   }\n   * })\n   *\n   * let Person = new NGN.DATA.Model({\n   *   fields: {\n   *     dateOfBirth: Date\n   *   },\n   *   relationships: {\n   *     pets: [Pet]        // <== Collection\n   *   }\n   * })\n   * ```\n   */\n  get manner () {\n    return NGN.coalesce(this.METADATA.manner, 'unknown')\n  }\n\n  get value () {\n    return this.METADATA.join\n  }\n\n  // Override the default value setter\n  set value (value) {\n    // Short-circuit if the value hasn't changed.\n    let currentValue = this.METADATA.join\n\n    if (currentValue === value) {\n      return\n    }\n\n    let type = NGN.typeof(value)\n\n    if (type === 'array') {\n      if (value.length !== 1) {\n        throw new Error(`${this.METADATA.name} cannot refer to an empty data store/model collection. A record must be provided.`)\n      }\n\n      this.METADATA.manner = 'store'\n      value = new NGN.DATA.Store({\n        model: value[0]\n      })\n    } else if (['model', 'store'].indexOf(type) >= 0) {\n      this.METADATA.manner = type\n    } else {\n      NGN.ERROR(`The \"${this.METADATA.name}\" relationship has an invalid record type. Only instances of NGN.DATA.Store, NGN.DATA.Model, or [NGN.DATA.Model] are supported.\" .`)\n      throw new InvalidConfigurationError(`Invalid record configuration for \"${this.METADATA.name}\" field.`)\n    }\n\n    if (this.manner === 'unknown') {\n      throw new Error('Cannot set a relationship field to anything other than an NGN.DATA.Store, NGN.DATA.Model, or an array of NGN.DATA.Model collections. (Unknown manner of relationship)')\n    }\n\n    this.METADATA.join = type === 'model' ? new value() : value // eslint-disable-line new-cap\n    this.auditable = this.METADATA.AUDITABLE\n    this.METADATA.applyMonitor()\n\n    // Notify listeners of change\n    if (typeof currentValue !== 'symbol') {\n      this.emit('update', {\n        old: currentValue,\n        new: value\n      })\n    }\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.join.auditable = value\n    }\n  }\n\n  // Override the default undo\n  undo () {\n    if (this.METADATA.manner === 'model') {\n      this.METADATA.join.undo(...arguments)\n    }\n  }\n\n  redo () {\n    if (this.METADATA.manner === 'model') {\n      this.METADATA.join.redo(...arguments)\n    }\n  }\n}\n","/**\n * @class NGN.DATA.FieldMap\n * A field map is a special data transformer that maps field names (keys)\n * to a different format. Consider the following field map:\n *\n * ```js\n * let fieldMap = new NGN.DATA.FieldMap({\n *   father: 'pa',\n *   mother: 'ma',\n *   brother: 'bro',\n *   sister: 'sis'\n * })\n * ```\n *\n * The map above reads as \"the `father` field is also known as `pa`\",\n * \"the `mother` field is also known as `ma`\", etc.\n *\n * The following transformation is possible:\n *\n * ```js\n * let result = fieldMap.apply({\n *   pa: 'John',\n *   ma: 'Jill',\n *   bro: 'Joe',\n *   sis: 'Jane'\n * })\n *\n * console.log(result)\n * ```\n *\n * _yields:_\n *\n * ```sh\n * {\n *   father: 'John'\n *   mother: 'Jill',\n *   brother: 'Joe',\n *   sister: 'Jane'\n * }\n * ```\n *\n * It is also possible to reverse field names:\n *\n * ```js\n * let result = fieldMap.applyReverse({\n *   father: 'John'\n *   mother: 'Jill',\n *   brother: 'Joe',\n *   sister: 'Jane'\n * })\n *\n * console.log(result)\n * ```\n *\n * _yields:_\n *\n * ```sh\n * {\n *   pa: 'John',\n *   ma: 'Jill',\n *   bro: 'Joe',\n *   sis: 'Jane'\n * }\n * ```\n *\n * This class is designed to assist with reading and writing data\n * to NGN.DATA.Model and NGN.DATA.Store instances.\n * @private\n */\nexport default class NGNDataFieldMap { // eslint-disable-line\n  constructor (cfg = {}) {\n    Object.defineProperties(this, {\n      originalSource: NGN.privateconst(cfg),\n      sourceMap: NGN.private(null),\n      reverseMap: NGN.private(null),\n      applyData: NGN.privateconst((map = 'map', data) => {\n        if (NGN.typeof(data) !== 'object') {\n          return data\n        }\n\n        let keys = Object.keys(data)\n        map = map === 'map' ? this.inverse : this.map\n\n        for (let i = 0; i < keys.length; i++) {\n          if (map.hasOwnProperty(keys[i])) {\n            data[map[keys[i]]] = data[keys[i]]\n            delete data[keys[i]]\n          }\n        }\n\n        return data\n      })\n    })\n  }\n\n  /**\n   * @property {object} map\n   * A reference to the data mapping object.\n   */\n  get map () {\n    if (this.sourceMap === null) {\n      let keys = Object.keys(this.originalSource)\n\n      this.sourceMap = {}\n\n      for (let i = 0; i < keys.length; i++) {\n        if (NGN.typeof(keys[i]) === 'string' && NGN.typeof(this.originalSource[keys[i]]) === 'string') {\n          this.sourceMap[keys[i]] = this.originalSource[keys[i]]\n        }\n      }\n    }\n\n    return this.sourceMap\n  }\n\n  /**\n   * @property {object} inverse\n   * A reference to the inversed data map.\n   */\n  get inverse () {\n    if (this.reverseMap === null) {\n      let keys = Object.keys(this.originalSource)\n\n      this.reverseMap = {}\n\n      for (let i = 0; i < keys.length; i++) {\n        if (NGN.typeof(keys[i]) === 'string' && NGN.typeof(this.originalSource[keys[i]]) === 'string') {\n          this.reverseMap[this.originalSource[keys[i]]] = keys[i]\n        }\n      }\n    }\n\n    return this.reverseMap\n  }\n\n  /**\n   * Apply the map to an object.\n   * @param  {object} data\n   * @return {object}\n   */\n  applyMap (data) {\n    return this.applyData('map', data)\n  }\n\n  /**\n   * Apply the inversed map to an object.\n   * @param  {object} data\n   * @return {object}\n   */\n  applyInverseMap (data) {\n    return this.applyData('reverse', data)\n  }\n}\n","import EventEmitter from '../emitter/core'\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.EventEmitter\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create {NGN.DATA.Field}\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\nexport default class NGNDataEntity extends EventEmitter { // eslint-disable-line\n  constructor (cfg) {\n    cfg = NGN.coalesce(cfg, {})\n\n    super()\n\n    if (cfg.dataMap) {\n      cfg.fieldmap = cfg.dataMap\n      NGN.WARN('\"dataMap\" is deprecated. Use \"map\" instead.')\n    }\n\n    if (cfg.idAttribute) {\n      cfg.IdentificationField = cfg.idAttribute\n      NGN.WARN('\"idAttribute\" is deprecated. Use \"IdentificationField\" instead.')\n    }\n\n    const me = this\n\n    // Create private attributes & data placeholders\n    Object.defineProperties(this, {\n      /**\n       * @property {Symbol} OID\n       * A unique object ID assigned to the model. This is an\n       * internal readon-only reference.\n       * @private\n       */\n      OID: NGN.private(Symbol('model.id')),\n\n      METADATA: NGN.privateconst({\n        /**\n         * @cfg {string} [name]\n         * A descriptive name for the model. This is typically used for\n         * debugging, logging, schema defintions, and (sometimes) data proxies.\n         */\n        name: NGN.coalesce(cfg.name, 'Untitled Model'),\n\n        /**\n         * @cfg {string} [description]\n         * A description of the model. This is typically used for\n         * debugging, logging, schema definitions, and (sometimes) data proxies.\n         */\n        description: NGN.coalesce(cfg.description, cfg.name, 'Generic Data Model'),\n\n        /**\n         * @cfg {object} fields\n         * A private object containing the data fields of the model.\n         * Each key contains the field name, while each value can be one of\n         * the following:\n         *\n         * - Primitive (String, Number, RegExp, Boolean)\n         * - Standard Type (Array, Object, Date)\n         * - Custom Class\n         * - NGN.DATA.Field\n         * - An NGN.DATA.Field configuration\n         * - `null` (Defaults to String primitive)\n         *\n         * ```js\n         * fields: {\n         *   a: String,\n         *   b: Date,\n         *   c: MyCustomClass,\n         *   d: new NGN.DATA.Field({\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   }),\n         *   e: {\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   },\n         *   f: null // Uses default field config (String)\n         * }\n         * ```\n         *\n         * Extensions of the NGN.DATA.Field are also supported,\n         * such as NGN.DATA.VirtualField and NGN.DATA.Relationship.\n         */\n        fields: Object.assign({}, NGN.coalesce(cfg.fields, {})),\n        knownFieldNames: new Set(),\n        invalidFieldNames: new Set(),\n        auditFieldNames: NGN.coalesce(cfg.audit, false) ? new Set() : null,\n\n        /**\n         * @property {[NGN.DATA.Rule]|Object}\n         * Custom validation rules used to verify the integrity of the entire\n         * model. This only applies to the full model. Individual data fields\n         * may have their own validators.\n         *\n         * If an object is specified, it should contain simple key/value pairs,\n         * where the key is the descriptive name of the rule and the value is\n         * a synchronous callback function that returns a `true`/`false` value.\n         * For instance, assume the fields called `price`, `items`, and `tax` exist\n         * in the example model below. :\n         *\n         * ```js\n         * {\n         *   'Positive Sale': function () {\n         *      return (this.price * this.items) > 0\n         *   },\n         *   'Taxes Applied': function () {\n         *      return this.tax > 0\n         *   }\n         * }\n         * ```\n         *\n         * Alternatively, an array of NGN.DATA.Rule instances may be provided.\n         */\n        validators: NGN.coalesce(cfg.rules, cfg.rule, cfg.validators),\n\n        /**\n         * @cfgproperty {boolean} [validation=true]\n         * Toggle data validation using this.\n         */\n        validation: NGN.coalesce(cfg.validation, true),\n\n        /**\n         * @cfg {boolean} [autoid=false]\n         * If the NGN.DATA.Model#IdentificationField/id is not provided for a record,\n         * a unique ID will be automatically generated for it.\n         *\n         * An NGN.DATA.Store using a model with this set to `true` will never\n         * have a duplicate record, since the #id or #IdentificationField will always\n         * be unique.\n         */\n        autoid: NGN.coalesce(cfg.autoid, false),\n\n        /**\n         * @cfg {String} [IdentificationField='id']\n         * Setting this allows an attribute of the object to be used as the ID.\n         * For example, if an email is the ID of a user, this would be set to\n         * `email`.\n         */\n        IdentificationField: NGN.coalesce(cfg.IdentificationField, cfg.idField, 'id'),\n\n        /**\n         * @cfgproperty {Date|Number} [expires]\n         * When this is set to a date/time, the model record will be marked\n         * as expired at the specified time/date. If a number is specified\n         * (milliseconds), the record will be marked as expired after the\n         * specified time period has elapsed. When a record/model is marked as\n         * \"expired\", it triggers the `expired` event. By default, expired\n         * records/models within an NGN.DATA.Store will be removed from the store.\n         *\n         * Setting this to any value less than `0` disables expiration.\n         * @fires expired\n         * Triggered when the model/record expires.\n         */\n        expiration: null,\n\n        // Holds a setTimeout method for expiration events.\n        expirationTimeout: null,\n\n        created: Date.now(),\n        store: null,\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: false,\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: function (change) {\n          if (change.hasOwnProperty('cursor')) {\n            me.METADATA.AUDITLOG.commit(me.METADATA.getAuditMap())\n          }\n        },\n\n        EVENTS: new Set([\n          'field.update',\n          'field.create',\n          'field.remove',\n          'field.invalid',\n          'field.valid',\n          'field.hidden',\n          'field.unhidden',\n          'field.rule.add',\n          'field.rule.remove',\n          'rule.add',\n          'rule.remove',\n          'relationship.create',\n          'relationship.remove',\n          'expired',\n          'deleted',\n          'reset',\n          'load'\n        ]),\n\n        /**\n         * An internal method used to apply field definitions to the model.\n         * @param  {string} fieldname\n         * Name of the field (as applied to the model).\n         * @param  {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\n         * The configuration to apply. See #addField for details.\n         * @param  {Boolean} [suppressEvents=false]\n         * Optionally suppress the `field.create` event.\n         * @private\n         */\n        applyField: (field, fieldcfg = null, suppressEvents = false) => {\n          // Prevent duplicate fields\n          if (this.METADATA.knownFieldNames.has(field)) {\n            return NGN.WARN(`Duplicate field \"${field}\" detected.`)\n          }\n\n          // Prevent reserved words\n          if (this.hasOwnProperty(field) && field.toLowerCase() !== 'id') {\n            throw new ReservedWordError(`\"${field}\" cannot be used as a field name (reserved word).`)\n          }\n\n          // If the field config isn't already an NGN.DATA.Field, create it.\n          if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            if (fieldcfg instanceof NGN.DATA.Store || fieldcfg instanceof NGN.DATA.Model) {\n              if (this.METADATA.IdentificationField === field) {\n                throw new InvalidConfigurationError(`\"${field}\" cannot be an ID. Relationship fields cannot be an identification field/attribute.`)\n              }\n\n              this.METADATA.fields[field] = new NGN.DATA.Relationship({\n                name: field,\n                record: fieldcfg,\n                model: this\n              })\n            } else {\n              switch (NGN.typeof(fieldcfg)) {\n                // Custom config\n                case 'object':\n                  fieldcfg.model = this\n                  fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n                  fieldcfg.name = field\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field(fieldcfg)\n\n                  break\n\n                // Collection of models\n                case 'array':\n                  return this.applyField(field, fieldcfg[0], suppressEvents)\n\n                // Type-based cfg.\n                default:\n                  if (NGN.isFn(fieldcfg) || fieldcfg === null) {\n                    if (NGN.isFn(fieldcfg) && ['string', 'number', 'boolean', 'number', 'symbol', 'regexp', 'date', 'array', 'object'].indexOf(NGN.typeof(fieldcfg)) < 0) {\n                      this.METADATA.fields[field] = new NGN.DATA.VirtualField({\n                        name: field,\n                        identifier: this.METADATA.IdentificationField === field,\n                        model: this,\n                        method: fieldcfg\n                      })\n\n                      break\n                    }\n\n                    this.METADATA.fields[field] = new NGN.DATA.Field({\n                      name: field,\n                      type: fieldcfg,\n                      identifier: this.METADATA.IdentificationField === field,\n                      model: this\n                    })\n\n                    break\n                  }\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field({\n                    name: field,\n                    type: NGN.isFn(fieldcfg) ? fieldcfg : String,\n                    identifier: NGN.isFn(fieldcfg)\n                      ? false\n                      : NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field),\n                    model: this\n                  })\n\n                  break\n              }\n            }\n          } else if (fieldcfg.model === null) {\n            fieldcfg.name = field\n            fieldcfg.identifier = fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n            this.METADATA.fields[field].model = this\n          } else if (fieldcfg.model === this) {\n            fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n          } else if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            return NGN.WARN(`The \"${fieldcfg.name}\" field cannot be applied because model is already specified.`)\n          }\n\n          // Add a direct reference to the model.\n          Object.defineProperty(this, field, {\n            enumerable: true,\n            configurable: true,\n            get: () => this.get(field),\n            set: (value) => this.set(field, value)\n          })\n\n          // Enable auditing if necessary.\n          if (this.METADATA.AUDITABLE) {\n            if (this.METADATA.fields[field].fieldType !== 'virtual') {\n              this.METADATA.fields[field].auditable = true\n              this.METADATA.auditFieldNames.add(field)\n            }\n          }\n\n          // Add the field to the list\n          this.METADATA.knownFieldNames.add(field)\n\n          this.METADATA.fields[field].relay('*', this, 'field.')\n\n          if (!suppressEvents) {\n            this.emit('field.create', this.METADATA.fields[field])\n          }\n\n          return this.METADATA.fields[field]\n        },\n\n        /**\n         * An internal helper method for applying changes to the model.\n         * @param  {String} [type='undo']\n         * This can be `undo` or `redo`.\n         * @param  {Number} [count=1]\n         * The number of cursor indexes to shift\n         * @param  {Boolean} [suppressEvents=false]\n         * Indicates events should be suppressed.\n         * @private\n         */\n        applyChange: (type = 'undo', count = 1, suppressEvents = false) => {\n          if (!this.METADATA.AUDITABLE) {\n            NGN.WARN(`The ${type} operation failed on the ${this.name} model because auditing is disabled.`)\n            return\n          }\n\n          this.METADATA.AUDITLOG[type === 'undo' ? 'rollback' : 'advance'](count)\n\n          let data = this.METADATA.AUDITLOG.currentValue\n\n          if (data) {\n            this.METADATA.auditFieldNames.forEach(fieldname => {\n              let field = this.METADATA.fields[fieldname]\n              let log = field.METADATA.AUDITLOG\n\n              if (log.cursor !== data[fieldname]) {\n                if (typeof data[fieldname] === 'symbol') {\n                  log.cursor = data[fieldname]\n                } else {\n                  log.cursor = null\n                }\n\n                field.METADATA.setValue(NGN.coalesce(log.currentValue, field.default), suppressEvents, true)\n              }\n            })\n          }\n        },\n\n        /**\n         * Generates a key/value representation of the model where\n         * each key represents an auditable field and each value is the\n         * transaction cursor ID.\n         * @return {Object}\n         * @private\n         */\n        getAuditMap: () => {\n          let map = {}\n\n          this.METADATA.auditFieldNames.forEach(field => {\n            map[field] = this.METADATA.fields[field].METADATA.AUDITLOG.cursor\n          })\n\n          return map\n        },\n\n        /**\n         * Restore the model to a specific audit map (i.e. historical state\n         * of multiple fields).\n         * @param {Object} map\n         * The audit map to restore.\n         */\n        // restore: (map) => {\n        //   let keys = Object.keys(map)\n        //\n        //   for (let i = 0; i < keys.length; i++) {\n        //     if (this.METADATA.knownFieldNames.has(keys[i]) && typeof map[keys[i]] === 'symbol') {\n        //       console.log('Has', keys[i])\n        //\n        //     }\n        //   }\n        // },\n\n        // Deprecations\n        setSilent: NGN.deprecate(this.setSilentFieldValue, 'setSilent has been deprecated. Use setSilentFieldValue instead.'),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        DATAMAP: null\n      }),\n\n      MAP: NGN.get(() => {\n        return NGN.coalesce(\n          this.METADATA.DATAMAP,\n          this.METADATA.store instanceof NGN.DATA.Store\n            ? this.METADATA.store.map\n            : null\n        )\n      })\n    })\n\n    if (cfg.fieldmap instanceof NGN.DATA.FieldMap) {\n      this.METADATA.DATAMAP = cfg.fieldmap\n    } else if (NGN.typeof(cfg.fieldmap) === 'object') {\n      this.METADATA.DATAMAP = new NGN.DATA.FieldMap(cfg.fieldmap)\n    }\n\n    // Bubble events to the BUS\n    // this.relay('*', NGN.BUS, 'record.')\n\n    // Add data fields.\n    let fields = Object.keys(this.METADATA.fields)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i]\n\n      if (this.METADATA.knownFieldNames.has(name)) {\n        NGN.WARN(`Duplicate field \"${name}\" detected.`)\n      } else {\n        // Configure a data field for each configuration.\n        this.METADATA.applyField(name, this.METADATA.fields[name], true)\n      }\n    }\n\n    // Apply automatic ID's when applicable\n    if (this.METADATA.autoid) {\n      let autoIdValue = null\n\n      Object.defineProperty(this.METADATA, 'IdentificationValue', NGN.get(() => {\n        if (autoIdValue === null) {\n          autoIdValue = NGN.DATA.UTILITY.UUID()\n        }\n\n        return autoIdValue\n      }))\n    }\n\n    // Apply auditing if configured\n    this.auditable = NGN.coalesce(cfg.audit, false)\n\n    // Clear any cached checksums when the model changes.\n    this.on(['field.update', 'field.create', 'field.delete', 'field.hidden', 'field.unhidden'], () => {\n      if (this.METADATA.checksum) {\n        this.METADATA.checksum = null\n      }\n    })\n\n    // Configure TTL/Expiration\n    if (cfg.expires) {\n      this.expires = cfg.expires\n    }\n\n    // Configure model-level validation rules\n    if (this.METADATA.validators !== null) {\n      switch (NGN.typeof(this.METADATA.validators)) {\n        // Support key/value objects where the key is the name and value is a function.\n        case 'object':\n          let keys = Object.keys(this.METADATA.validators)\n          let rules = []\n\n          for (let i = 0; i < keys.length; i++) {\n            rules.push(new NGN.DATA.Rule(this.METADATA.validators[keys[i]], keys[i], this))\n          }\n\n          break\n\n        // Support an array of existing data rules.\n        case 'array':\n          for (let i = 0; i < this.METADATA.validators.length; i++) {\n            if (this.METADATA.validators[i].hasOwnProperty('RULE')) {\n              this.METADATA.validators[i].RULE.scope = this\n            } else {\n              throw new Error(`Invalid data rule configuration for ${this.name} model. Rule #${i} is not a valid NGN.DATA.Rule instance.`)\n            }\n          }\n\n          break\n\n        // Diasllow any other kinds of rules.\n        default:\n          throw new Error(`Invalid data rule configuration for ${this.name} model. Expected an object or array of NGN.DATA.Rule instances. Received \"${NGN.typeof(this.METADATA.validators)}\"`)\n      }\n    }\n  }\n\n  get name () {\n    return this.METADATA.name\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n      this.METADATA.auditFieldNames = value ? new Set() : null\n\n      // Set each field to an auditable state (or not).\n      this.METADATA.knownFieldNames.forEach(fieldname => {\n        if (!this.METADATA.fields[fieldname].virtual) {\n          this.METADATA.fields[fieldname].auditable = value\n\n          if (value) {\n            this.METADATA.auditFieldNames.add(fieldname)\n          }\n        }\n      })\n\n      if (value) {\n        // Track Changes (if auditing enabled)\n        this.on('field.transaction.*', (id) => {\n          this.METADATA.AUDIT_HANDLER({ cursor: id })\n        })\n      } else {\n        this.METADATA.auditFieldNames.clear()\n\n        this.off('field.transaction.*')\n      }\n    }\n  }\n\n  /**\n   * The unique ID assigned to the model.\n   * @return {string}\n   */\n  get id () {\n    return this.get(this.METADATA.IdentificationField)\n  }\n\n  set id (value) {\n    this.set('id', value)\n  }\n\n  /**\n   * @property ID\n   * An alias for #id.\n   */\n  get ID () {\n    return this.id\n  }\n\n  set ID (value) {\n    this.set('id', value)\n  }\n\n  /**\n   * @property {Array} changelog\n   * The changelog returns the underlying NGN.DATA.TransactionLog#log if\n   * auditing is available. The array will be empty if auditing is disabled.\n   */\n  get changelog () {\n    return this.METADATA.AUDITLOG.log.map(entry => {\n      let result = {\n        timestamp: entry.timestamp,\n        activeCursor: entry.activeCursor,\n        value: {}\n      }\n\n      let data = entry.value\n      let field = Object.keys(data)\n\n      for (let i = 0; i < field.length; i++) {\n        if (typeof data[field[i]] === 'symbol') {\n          result.value[field[i]] = NGN.coalesce(\n            this.METADATA.fields[field[i]].METADATA.AUDITLOG.getCommit(data[field[i]]).value,\n            this.METADATA.fields[field[i]].default\n          )\n        } else {\n          result.value[field[i]] = NGN.coalesce(this.METADATA.fields[field[i]].default)\n        }\n      }\n\n      return result\n    })\n  }\n\n  /**\n   * @property {Number} createDate\n   * The date/time when the model is created.\n   */\n  get createDate () {\n    return this.METADATA.created\n  }\n\n  /**\n   * @property {object} data\n   * A serialized version of the data represented by the model. This\n   * only includes non-virtual fields. See #representation to use\n   * a representation of data containing virtual fields.\n   */\n  get data () {\n    if (this.MAP) {\n      return this.MAP.applyInverseMap(this.serializeFields())\n    }\n\n    return this.serializeFields()\n  }\n\n  /**\n   * @property {object} unmappedData\n   * Returns #data _without applying_ the data #map.\n   */\n  get unmappedData () {\n    return this.serializeFields()\n  }\n\n  /**\n   * @property {object} representation\n   * A serialized version of the data represented by the model. This\n   * includes virtual fields. See #data to use just the raw values.\n   */\n  get representation () {\n    if (this.MAP) {\n      return this.MAP.applyInverseMap(this.serializeFields(false, false))\n    }\n\n    return this.serializeFields(false, false)\n  }\n\n  /**\n   * @property {object} unmappedRepresentation\n   * Returns #representation _without applying_ the data #map.\n   */\n  get unmappedRepresentation () {\n    return this.serializeFields(false, false)\n  }\n\n  /**\n   * @property {string} checksum\n   * The checksum is a unique \"fingerprint\" of the data stored in the model.\n   * Please note that generating a checksum for an individual record is\n   * usually a quick operation, but generating large quantities of checksums\n   * simultaneously/sequentially can be computationally expensive. On average,\n   * a checksum takes 3-125ms to generate.\n   */\n  get checksum () {\n    this.METADATA.checksum = NGN.coalesce(this.METADATA.checksum, NGN.DATA.UTILITY.checksum(JSON.stringify(this.data)))\n\n    return this.METADATA.checksum\n  }\n\n  /**\n   * @property {Date} expires\n   * The date/time when the record expires. This may be set to\n   * a future date, or a numeric value. Numeric values\n   * represent the number of milliseconds from the current time\n   * before the record expires. For example, set this to `3000`\n   * to force the record to expire 3 seconds from now.\n   *\n   * Set this to `0` to immediately expire the record. Set this to\n   * `-1` or `null` to prevent the record from expiring.\n   */\n  get expires () {\n    return this.METADATA.expiration\n  }\n\n  set expires (value) {\n    if (value === null) {\n      clearTimeout(this.METADATA.expirationTimeout)\n      this.METADATA.expiration = null\n      return\n    }\n\n    let now = new Date()\n\n    if (!isNaN(value) && !(value instanceof Date)) {\n      // Handle numeric (millisecond) expiration\n      if (value < 0) {\n        this.METADATA.expiration = null\n\n        return\n      }\n\n      if (value === 0) {\n        this.METADATA.expiration = now\n        this.emit('expire')\n\n        return\n      }\n\n      this.METADATA.expiration = new Date()\n      this.METADATA.expiration.setTime(now.getTime() + value)\n    } else if (!(value instanceof Date) || value <= now) {\n      throw new Error(`${this.name} expiration (TTL) value must be a positive number (milliseconds) or future date.`)\n    } else {\n      // Handle date-based expiration\n      this.METADATA.expiration = value\n    }\n\n    clearTimeout(this.METADATA.expirationTimeout)\n\n    this.METADATA.expirationTimeout = setTimeout(() => this.emit('expire'), this.METADATA.expiration.getTime() - now.getTime())\n  }\n\n  get expired () {\n    if (this.METADATA.expiration === null) {\n      return false\n    }\n\n    return this.METADATA.expiration <= (new Date())\n  }\n\n  get fieldDefinitions () {\n    return this.METADATA.fields\n    // if (this.METADATA.knownFieldNames.size === 0) {\n    //   return {}\n    // }\n    //\n    // let fields = this.METADATA.knownFieldNames.keys()\n    // let result = {}\n    // let fieldname = fields.next()\n    //\n    // while (!fieldname.done) {\n    //   let field = this.METADATA.fields[fieldname.value]\n    //\n    //   if ((\n    //     field.value === undefined ||\n    //     (ignoreID && fieldname.value === this.IdentificationField) ||\n    //     (!field.virtual || (!ignoreVirtualFields && field.virtual))\n    //   )) {\n    //     // Do not serialize hidden values or virtuals\n    //     if (!field.hidden) {\n    //       switch (NGN.typeof(field.value)) {\n    //         case 'array':\n    //         case 'object':\n    //           result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\n    //           break\n    //\n    //         default:\n    //           result[fieldname.value] = field.value\n    //       }\n    //     }\n    //   }\n    // }\n  }\n\n  serializeFields (ignoreID = false, ignoreVirtualFields = true) {\n    if (this.METADATA.knownFieldNames.size === 0) {\n      return {}\n    }\n\n    let fields = this.METADATA.knownFieldNames.keys()\n    let result = {}\n    let fieldname = fields.next()\n\n    while (!fieldname.done) {\n      let field = this.METADATA.fields[fieldname.value]\n\n      // Ignore unserializable fields\n      if ((\n        field.value === undefined ||\n        (ignoreID && fieldname.value === this.IdentificationField) ||\n        (!field.virtual || (!ignoreVirtualFields && field.virtual))\n      )) {\n        // Do not serialize hidden values or virtuals\n        if (!field.hidden) {\n          switch (NGN.typeof(field.value)) {\n            case 'array':\n            case 'object':\n              result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\n              break\n\n            default:\n              result[fieldname.value] = field.value\n          }\n        }\n      }\n\n      fieldname = fields.next()\n    }\n\n    return result\n  }\n\n  serialize () {\n    return NGN.deprecate(this.serializeFields, 'serialize is now serializeFields. Use NGN.DATA.UTILITY.serialize for generic object serialization.')\n  }\n\n  /**\n   * Determines whether a field exists in the model or not.\n   * @param  {string} field\n   * Name of the field to check for.\n   * @return {boolean}\n   */\n  fieldExists (field) {\n    return this.METADATA.knownFieldNames.has(field)\n  }\n\n  /**\n   * Retrieve the value of the specified field.\n   * @param  {string} field\n   * Name of the field whose value should be returned.\n   * @return {any}\n   * Returns the value of the field.\n   */\n  get (field) {\n    if (field === 'id' || field === 'ID' || field === this.METADATA.IdentificationField) {\n      field = this.METADATA.IdentificationField\n\n      if (this.METADATA.autoid) {\n        if (!this.METADATA.knownFieldNames.has(field)) {\n          return this.METADATA.IdentificationValue\n        } else {\n          return NGN.coalesce(this.METADATA.fields[field].value, this.METADATA.IdentificationValue)\n        }\n      }\n    }\n\n    if (this.METADATA.knownFieldNames.has(field)) {\n      return this.METADATA.fields[field].value\n    } else {\n      NGN.WARN(`Cannot get \"${field}\". The field is not part of the model.`)\n      return undefined\n    }\n  }\n\n  /**\n   * Set a new value for the specified field.\n   * @param {string} field\n   * Name of the field whose value will be changed.\n   * @param {any} value\n   * The new value of the field.\n   */\n  set (field, value) {\n    if (field === 'id' || field === 'ID') {\n      field = this.METADATA.IdentificationField\n    }\n\n    if (this.METADATA.knownFieldNames.has(field)) {\n      this.METADATA.fields[field].value = value\n    } else {\n      NGN.WARN(`Cannot set \"${field}\". Unrecognized field name.`)\n    }\n  }\n\n  /**\n   * Add a data field after the initial model definition.\n   * @param {string} fieldname\n   * The name of the field.\n   * @param {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\n   * The field configuration (see cfg#fields for syntax).\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addField (name, fieldConfiguration = null, suppressEvents = false) {\n    if (name instanceof NGN.DATA.Field) {\n      fieldConfiguration = name\n      name = fieldConfiguration.name\n    } else if (typeof name !== 'string') {\n      throw new Error('Cannot add a non-string based field.')\n    }\n\n    this.METADATA.applyField(name, fieldConfiguration, suppressEvents)\n  }\n\n  /**\n   * @method removeField\n   * Remove a field from the data model.\n   * @param {string} name\n   * Name of the field to remove.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is removed.\n   */\n  removeField (name, suppressEvents = false) {\n    if (this.METADATA.knownFieldNames.has(name)) {\n      this.METADATA.knownFieldNames.delete(name)\n      this.METADATA.invalidFieldNames.delete(name)\n\n      const field = this.METADATA.fields[name]\n\n      delete this[name]\n      delete this.METADATA.fields[name] // eslint-disable-line no-undef\n\n      // let change = {\n      //   action: 'delete',\n      //   field: field.name,\n      //   value: field,\n      //   join: field instanceof NGN.DATA.Relationship\n      // }\n\n      if (!suppressEvents) {\n        this.emit('field.remove', field)\n      }\n\n      if (this.METADATA.store !== null) {\n        this.METADATA.store.emit(this.METADATA.store.PRIVATE.EVENT.DELETE_RECORD_FIELD, {\n          record: this,\n          field\n        })\n      }\n    }\n  }\n\n  /**\n   * Returns the NGN.DATA.Field object for the specified field.\n   * @param  {string} fieldName\n   * Name of the field to retrieve.\n   * @return {NGN.DATA.Field}\n   * The raw field.\n   */\n  getField (name) {\n    if (name.toLowerCase() === 'id' && !this.METADATA.fields.hasOwnProperty(name) && this.METADATA.fields.hasOwnProperty(this.METADATA.IdentificationField)) {\n      return this.METADATA.fields[this.METADATA.IdentificationField]\n    }\n\n    return this.METADATA.fields[name]\n  }\n\n  /**\n   * @method setSilent\n   * A method to set a field value without triggering an update event.\n   * This is designed primarily for use with live update proxies to prevent\n   * endless event loops.\n   * @param {string} fieldname\n   * The name of the #field to update.\n   * @param {any} value\n   * The new value of the field.\n   * @private\n   */\n  setSilentFieldValue (field, value) {\n    this.METADATA.fields[field].silentValue = value\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog (transaction log). To \"undo\" an \"undo\", use #redo.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  undo (count = 1, suppressEvents = false) {\n    this.METADATA.applyChange('undo', ...arguments)\n  }\n\n  /**\n   * @method redo\n   * A function to reapply known changes. This operation affects\n   * the changelog (transaction log).\n   *\n   * The redo operation only works after an undo operation, but before a new\n   * value is committed to the transaction log. In other words, `undo -> redo`\n   * will work, but `undo -> update -> redo` will not. For details, see how\n   * the NGN.DATA.TransactionLog cursor system works.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  redo (count = 1, suppressEvents = false) {\n    this.METADATA.applyChange('redo', ...arguments)\n  }\n\n  /**\n   * @method load\n   * Load a data record.\n   * @param {object} data\n   * The data to apply to the model.\n   * @param {boolean} [suppressEvents=false]\n   * Do not emit a change event when the data is loaded.\n   */\n  load (data, suppressEvents = false) {\n    if (this.MAP) {\n      data = this.MAP.applyMap(data)\n    }\n\n    let keys = Object.keys(data)\n\n    for (let i = 0; i < keys.length; i++) {\n      if (this.METADATA.knownFieldNames.has(keys[i])) {\n        this.METADATA.fields[keys[i]].METADATA.setValue(data[keys[i]], suppressEvents)\n      } else {\n        NGN.WARN(`Failed to load ${keys[i]} field of ${this.name} model. \"${keys[i]}\" is not a recognized field.`)\n      }\n    }\n\n    if (!suppressEvents) {\n      this.emit('load')\n    }\n\n    return this\n  }\n\n  /**\n   * @info This method only works on records within a store. If this method is\n   * called on a model that is not part of a store, the model itself will be\n   * returned.\n   *\n   * Retrieve the next record (after this one) from the store.\n   * This can be used to iterate through a store by calling `model.next()`.\n   * This is operation acts as a linked list iterator.\n   * @param  {Number}  [count=1]\n   * The number of records to retrieve. For example, `1` retrieves the next record.\n   * `2` retrieves the second record after this one. A negative number will\n   * automatically use the #previous method to retrieve prior records. Setting this\n   * to `0` will return the current record (i.e. no change).\n   * @param  {Boolean}  [cycle=false] [description]\n   * If this `next` is called on the last record, it will fail. Setting `cycle` to\n   * `true` will automatically restart the iteration, returning the first record in\n   * the store.\n   * @return {NGN.DATA.Model}\n   * Returns the next model in the store (after this one.)\n   */\n  next (count = 1, cycle = false) {\n    if (count === 0) {\n      return this\n    }\n\n    if (this.METADATA.store) {\n      if (typeof count === 'boolean') {\n        cycle = count\n        count = 1\n      }\n\n      return this.METADATA.store.getRecordSibling(this, count, cycle)\n    } else {\n      NGN.WARN('Attempted to call next() on a model that does not belong to a store.')\n      return this\n    }\n  }\n\n  /**\n   * Retrieve the previous record (before this one) from the store.\n   * This can be used to iterate through a store in reverse by calling\n   * `model.previous()`. This is operation acts as a doubly linked list iterator.\n   *\n   * @info This method only works on records within a store. If this method is\n   * called on a model that is not part of a store, the model itself will be\n   * returned.\n   * @param  {Number}  [count=1]\n   * The number of records to retrieve. For example, `1` retrieves the prior record.\n   * `2` retrieves the second record before this one. A negative number will\n   * automatically use the #next method to retrieve forward records. Setting this\n   * to `0` will return the current record (i.e. no change).\n   * @param  {Boolean}  [cycle=false]\n   * If this `next` is called on the first record, it will fail. Setting `cycle` to\n   * `true` will automatically restart the iteration, returning the last record in\n   * the store.\n   * @return {NGN.DATA.Model}\n   * Returns the previous model in the store (before this one.)\n   */\n  previous (count = 1, cycle = false) {\n    if (count === 0) {\n      return this\n    }\n\n    if (this.METADATA.store) {\n      if (typeof count === 'boolean') {\n        cycle = count\n        count = 1\n      }\n\n      return this.METADATA.store.getRecordSibling(this, 0 - count, cycle)\n    } else {\n      NGN.WARN('Attempted to call previous() on a model that does not belong to a store.')\n      return this\n    }\n  }\n\n  /**\n   * Remove this model from the NGN.DATA.Store it is a part of.\n   *\n   * @info This method only works on records within a store. If this method is\n   * called on a model that is not part of a store, nothing will happen.\n   */\n  destroy () {\n    if (this.METADATA.store) {\n      this.METADATA.store.remove(this.OID)\n    } else {\n      NGN.WARN('Attempted to call remove() on a model that does not belong to a store.')\n    }\n  }\n}\n","import EventEmitter from '../../emitter/core'\n\n/**\n * @class NGN.DATA.Index\n * Data indexes are a data structure that improves the speed\n * of data retrieval from an NGN.DATA.Store, at the cost of\n * additional memory usage. Even though memory usage is increased\n * for each index applied to a store, it tends to be a very small\n * fraction of the memory required for storing data.\n *\n * Indexes help locate data within a store without having to read\n * every record. They will, in the overwhelming majority of cases,\n * speed up queries. However; if overused or misused, they may\n * marginally _increase_ query processing time.\n *\n * NGN data indexes were designed to be used the same way relational\n * data indexes and graph data vertices are used.\n * @fires create {Symbol}\n * Triggered when a new record is indexed. The payload (Symbol)\n * represents the NGN.DATA.Model#oid.\n * @fires delete {Symbol}\n * Triggered when a record is de-indexed. The payload (Symbol)\n * represents the NGN.DATA.Model#oid.\n * @fires update {Symbol}\n * Triggered when a record is re-indexed (updated). The payload (Symbol)\n * represents the NGN.DATA.Model#oid.\n * @fires reset\n * Triggered when the index is completely cleared/reset to it's original state.\n * @private\n */\nexport default class NGNDataIndex extends EventEmitter { // eslint-disable-line\n  /**\n   * Create a new data index.\n   * @param {Boolean} [BTree=false]\n   * Use a B-Tree index. This is only available for numeric values and dates.\n   * @param {String} [name='Untitled Index']\n   * Optional name for index. This is useful for debugging when multiple\n   * indexes exist.\n   */\n  constructor (btree = false, name = 'Untitled Index') {\n    super()\n\n    Object.defineProperties(this, {\n      // Private constants\n      CREATE_EVENT: NGN.privateconst(Symbol('create')),\n      REMOVE_EVENT: NGN.privateconst(Symbol('delete')),\n      UPDATE_EVENT: NGN.privateconst(Symbol('update')),\n\n      // Private data attributes\n      uniqueValues: NGN.privateconst(new Set()),\n      knownRecords: NGN.privateconst([]), // Linked list of Sets\n      name: NGN.const(name),\n      isBTree: NGN.privateconst(btree)\n    })\n\n    // Bubble up private events when applicable\n    const me = this\n    this.on([\n      this.CREATE_EVENT,\n      this.REMOVE_EVENT,\n      this.UPDATE_EVENT\n    ], function (oid, value, suppressEvent = false) {\n      if (!suppressEvent) {\n        me.emit(this.event.toString().replace(/^Symbol\\(|\\)$/g, ''), oid)\n      }\n    })\n\n    // When all known records for a given value are removed,\n    // clear the unique value index.\n    this.on(this.REMOVE_EVENT, (oid, value) => {\n      if (this.recordsFor(value).length === 0) {\n        let index = this.indexOf(value)\n\n        if (index >= 0) {\n          this.knownRecords.splice(index, 1)\n          this.uniqueValues.delete(value)\n        }\n      }\n    })\n\n    // Support BTree Indexing\n    if (this.isBTree) {\n      Object.defineProperty(this, 'BTREE', NGN.privateconst(new NGN.DATA.BTree(2, name)))\n    }\n  }\n\n  get keys () {\n    if (this.uniqueValues.size === 0) {\n      return []\n    }\n\n    return Array.from(this.uniqueValues.values())\n  }\n\n  /**\n   * Add a field/value to the index.\n   * @param {any} value\n   * The value of the model/record indexed field.\n   * @param {Symbol} oid\n   * The record's object ID (NGN.DATA.Model#OID)\n   */\n  add (value, oid, suppressEvent = false) {\n    let valueIndex = -1\n\n    // Create or identify the index of the unique value\n    if (!this.uniqueValues.has(value)) {\n      this.uniqueValues.add(value)\n      this.knownRecords.push(new Set())\n      valueIndex += this.uniqueValues.size\n    } else {\n      valueIndex = this.indexOf(value)\n    }\n\n    this.knownRecords[valueIndex].add(oid)\n\n    // Add BTree indexing\n    if (this.isBTree) {\n      let btreeValue = value instanceof Date ? value.getTime() : value\n\n      if (this.BTREE.get(btreeValue) === undefined) {\n        this.BTREE.put(btreeValue, valueIndex)\n      }\n    }\n\n    this.emit(this.CREATE_EVENT, oid, value, suppressEvent)\n  }\n\n  /**\n   * Remove a record from the index.\n   * @param  {Symbol} oid\n   * The record's object ID (NGN.DATA.Model#OID)\n   * @param  {any} [value=undefined]\n   * When specified, the field value will be used to identify\n   * the index value. Specifying this value will make the remove\n   * operation faster (uses introspection).\n   */\n  remove (oid, value, suppressEvent = false) {\n    // If a value is specified, attempt to lookup the OID by value.\n    if (value !== undefined) {\n      let index = this.recordsOf(value)\n\n      // If a value index is found, remove the OID\n      if (index) {\n        if (index.delete(oid)) { // Returns false if nothing is actually deleted.\n          if (this.isBTree && (!index || index.size === 0)) {\n            this.BTREE.delete(value instanceof Date ? value.getTime() : value)\n          }\n\n          this.emit(this.REMOVE_EVENT, oid, value, suppressEvent)\n\n          return\n        }\n      }\n\n      NGN.WARN(`Index value \"${value}\" not found in index.`)\n    }\n\n    // Iterate through all index values to remove the OID (slow)\n    let removed = false\n    for (let i = 0; i < this.knownRecords.length; i++) {\n      if (this.knownRecords[i].delete(oid) && !removed) {\n        removed = true\n        value = Array.from(this.uniqueValues.values())[i]\n\n        if (this.isBTree) {\n          this.BTREE.delete(value instanceof Date ? value.getTime() : value)\n        }\n\n        break\n      }\n    }\n\n    if (removed) {\n      this.emit(this.REMOVE_EVENT, oid, value, suppressEvent)\n    }\n  }\n\n  /**\n   * Update an index to reflect an updated value.\n   * @param  {[type]} oid      [description]\n   * @param  {[type]} oldvalue [description]\n   * @param  {[type]} newvalue [description]\n   * @return {[type]}          [description]\n   */\n  update (oid, oldValue, newValue, suppressEvent = false) {\n    if (oldValue !== newValue) {\n      this.remove(oid, oldValue, true)\n      this.add(newValue, oid, true)\n      this.emit(this.UPDATE_EVENT, oid, null, suppressEvent)\n    }\n  }\n\n  /**\n   * Forcibly reset the index (clears everything).\n   */\n  reset () {\n    this.uniqueValues.clear()\n    this.knownRecords.splice(0)\n\n    if (this.isBTree) {\n      this.BTREE.reset()\n    }\n\n    this.emit('reset')\n  }\n\n  /**\n   * Retrieve the index number of known records for the\n   * specified value.\n   * @private\n   * @param  {any} value\n   * The unique value for which records are known.\n   * @return {[numeric]}\n   * The 0-based index of known records. Returns `-1` if no\n   * index exists.\n   */\n  indexOf (value) {\n    return Array.from(this.uniqueValues.keys()).indexOf(value)\n  }\n\n  /**\n   * The records of a particular value.\n   * @private\n   * @param  {any} value\n   * The index field value to use as a lookup.\n   * @return {Set}\n   * An set of object ID's or `null` if none exist.\n   */\n  recordsOf (value) {\n    let valueIndex = this.indexOf(value)\n\n    return valueIndex < 0 ? null : this.knownRecords[valueIndex]\n  }\n\n  /**\n   * Get the list of records for the given value.\n   * @param  {any} value\n   * The value of the index to lookup.\n   * @return {array}\n   * The array contains OID reference values (records).\n   */\n  recordsFor (value) {\n    let index = this.recordsOf(value)\n\n    if (index === null || index.size === 0) {\n      return []\n    }\n\n    return Array.from(index.values())\n  }\n}\n","import EventEmitter from '../../emitter/core'\n\n/**\n * @class NGN.DATA.JSONSchema\n * Represents a JSON Schema.\n * @fires parsed\n * Triggered when the schema is parsed.\n */\nexport default class NGNJSONSchema extends EventEmitter { // eslint-disable-line no-unused-vars\n  /**\n   * Create a new JSON schema reference.\n   * @param  {Object|String} [schema={}]\n   * The schema to parse. This can be the JSON schema object itself or the URL\n   * of a remote JSON schema.\n   * @param  {NGN.NET.Resource} [NetworkResource]\n   * Specify a custom network resource to make the request for a remote schema.\n   */\n  constructor (schema = {}, NetworkResource = null) {\n    super()\n\n    Object.defineProperties(this, {\n      METADATA: NGN.private({\n        schema,\n        ID: null,\n        name: null\n      }),\n\n      PRIVATE: NGN.privateconst({\n        MODELS: null,\n        NET: NGN.coalesce(NetworkResource, NGN.NET),\n\n        parsed: false,\n\n        /**\n         * @method PRIVATE.extractCommonPropertyAttributes\n         * @param  {object} property\n         * Schema metadata object.\n         * @param {array} [models=[]]\n         * The list of known models. This is passed in because nested objects\n         * may exist within a property. NGN identifies these as nested models,\n         * even though the JSON schema does not force these to be separate\n         * schemas.\n         * @return {Object}\n         * Returns a clean \"NGN-ready\" field object of common properties.\n         */\n        extractCommonPropertyAttributes: (property, models = []) => {\n          let field = {}\n\n          // Add pattern\n          if (property.pattern) {\n            field.pattern = property.pattern\n          }\n\n          // Add description\n          if (property.description) {\n            field.description = property.description\n          }\n\n          // Add default\n          if (property.default) {\n            field.default = property.default\n          }\n\n          if (!property.$ref) {\n            if (!property.type) {\n              field.type = String\n            } else {\n              let type = NGN.typeof(property.type) === 'array' ? 'array' : property.type.trim().toLowerCase()\n\n              switch (type) {\n                case 'string':\n                  let format = NGN.coalesce(property.format, 'unknown').trim().toLowerCase()\n\n                  field.type = String\n\n                  switch (format) {\n                    case 'date':\n                    case 'date-time':\n                    case 'datetime':\n                    case 'format-time':\n                      field.type = Date\n                      break\n\n                    case 'ipv4':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\n                      )\n\n                      break\n\n                    case 'ipv6':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\n                      )\n\n                      break\n\n                    case 'email':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\\b$/\n                      )\n\n                      break\n\n                    case 'hostname':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)+(\\.([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*))*$/ // eslint-disable-line no-irregular-whitespace\n                      )\n\n                      break\n\n                    case 'uri':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]\\.[^\\s]{2,})/\n                      )\n\n                      break\n                  }\n\n                  break\n\n                case 'integer':\n                  field.type = Number\n                  field.pattern = /^\\d+$/\n                  break\n\n                case 'number':\n                  field.type = Number\n                  break\n\n                case 'object':\n                  if (property.properties) {\n                    let subschema = new NGN.DATA.JSONSchema(property)\n\n                    subschema.name = `${NGN.coalesce(this.name, 'untitled')}_${NGN.coalesce(subschema.name, 'submodel')}${models.length + 1}`\n\n                    subschema.getModelDefinitions(definitions => {\n                      definitions[definitions.length - 1].name = subschema.name\n                      models = definitions.concat(models)\n                    })\n\n                    field = {\n                      $model: subschema.name\n                    }\n                  } else {\n                    field.type = Object\n                  }\n\n                  break\n\n                default:\n                  field.type = String\n                  break\n              }\n            }\n          }\n\n          // String validation options\n          if (field.type === String || field.type === Number) {\n            if (NGN.coalesce(property.minLength, property.minimum)) {\n              field.min = NGN.coalesce(property.minLength, property.minimum)\n            }\n\n            if (NGN.coalesce(property.maxLength, property.maximum)) {\n              field.max = NGN.coalesce(property.maxLength, property.maximum)\n            }\n\n            // Numeric-specific validations\n            if (property.type === Number) {\n              if (property.multipleOf) {\n                field.multipleOf = property.multipleOf\n              }\n\n              if (property.exclusiveMinimum) {\n                field.min = (property.exclusiveMinimum + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\n              }\n\n              if (property.exclusiveMaximum) {\n                field.max = (property.exclusiveMaximum - 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\n              }\n            }\n          }\n\n          // Array validation options\n          if (field.type === Array) {\n            // Support minimum array length\n            if (property.hasOwnProperty('minItems')) {\n              field.min = property.minItems\n            }\n\n            // Support maximum array length\n            if (property.hasOwnProperty('maxItems')) {\n              field.max = property.maxItems\n            }\n\n            if (property.hasOwnProperty('items')) {\n              if (NGN.typeof(property.items) === 'array') {\n                // Apply tuple validation\n                field.tuples = property.items\n              } else {\n                // Apply list validation\n                if (property.items.hasOwnProperty('type')) {\n                  field.listType = NGN.getType(property.items.type)\n                }\n\n                if (property.items.hasOwnProperty('enum')) {\n                  field.enum = property.items.enum\n                }\n              }\n            }\n          }\n\n          return field\n        },\n\n        /**\n         * @method PRIVATE.extractModelDefinitions\n         * Retrieve all of the NGN.DATA.Model defitions that can be interpreted\n         * from this schema.\n         * @protected\n         * @private\n         * @param  {Object} data\n         * The schema object.\n         * @param  {Array} [models=[]]\n         * An array of known models. This method is used recursively, so this\n         * argument exists primarily for internal use.\n         * @param  {Function} callback\n         * Executed when all models have been detected.\n         */\n        extractModelDefinitions: (data, models = [], callback) => {\n          if (NGN.isFn(models)) {\n            callback = models\n            models = []\n          }\n\n          if (data.type === 'object') {\n            let name = NGN.coalesce(data.name, this.name, 'Untitled')\n\n            if (data.hasOwnProperty('$schema') && name === null && this.METADATA.URL) {\n              name = this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', '')\n            }\n\n            // Configure the basic model\n            let model = {\n              name,\n              description: NGN.coalesce(data.description, 'No description.'),\n              fields: {}\n            }\n\n            // Flag the ID for the schema\n            if (data.hasOwnProperty('$schema')) {\n              this.METADATA.ID = NGN.coalesce(data.$id, data.$schema)\n            }\n\n            // Queue the tasks since several are async but sequential\n            let tasks = new NGN.Tasks()\n\n            // If the allOf attribute exists, the schema is extending another.\n            // Extract the subschema before continuing.\n            if (data.hasOwnProperty('allOf')) {\n              for (let i = 0; i < data.allOf.length; i++) {\n                tasks.add(`Identify base schema: ${data.allOf}`, cont => {\n                  let URI = NGN.coalesce(data.allOf[i].$ref, data.allOf[i].$schema)\n\n                  if (URI !== null) {\n                    // When a URI is specified, retrieve the remote schema\n                    let baseSchema = new NGN.DATA.JSONSchema(URI)\n\n                    baseSchema.getModelDefinitions(definitions => {\n                      let coreModel = definitions.pop()\n\n                      Object.assign(model.fields, coreModel.fields)\n\n                      // If the nested schema has additional models, apply them.\n                      if (definitions.length > 0) {\n                        models = definitions.concat(models)\n                      }\n\n                      this.METADATA.name = NGN.coalesce(this.METADATA.name, coreModel.name)\n\n                      cont()\n                    })\n                  } else if (data.allOf[i].hasOwnProperty('properties')) {\n                    // Handle additional properties\n                    let additionalProperties = Object.keys(data.allOf[i].properties)\n\n                    for (let prop = 0; prop < additionalProperties.length; prop++) {\n                      model.fields[additionalProperties[prop]] = this.extractCommonPropertyAttributes(data.allOf[i].properties[additionalProperties[prop]])\n                    }\n\n                    cont()\n                  }\n                })\n              }\n            }\n\n            tasks.add('Identify attributes', cont => {\n              // If the schema specifies dependencies, it is specifying a set of\n              // rules requiring the existance and non-empty value of additional\n              // fields. Create NGN.DATA.Rule sets to support this.\n              if (data.hasOwnProperty('dependencies')) {\n                Object.keys(data.dependencies).forEach(dependency => {\n                  let requiredFields = null\n                  let dep = data.dependencies[dependency]\n\n                  if (NGN.typeof(dep) === 'array') {\n                    // Simple property dependencies\n                    requiredFields = dep\n                  } else if (dep.hasOwnProperty('required')) {\n                    // Schema dependencies\n                    requiredFields = dep.required\n                  }\n\n                  // Add all valid dependencies as rules\n                  if (requiredFields !== null) {\n                    model.rules[`${dependency} dependency on \"${requiredFields.join(', ')}\"`] = function () {\n                      if (NGN.coalesce(this[dependency]) !== null) {\n                        for (let i = 0; i < requiredFields.length; i++) {\n                          if (NGN.coalesce(this[requiredFields[i]]) === null) {\n                            return false\n                          }\n                        }\n                      }\n\n                      return true\n                    }\n                  }\n                })\n              }\n\n              // Identify the fields\n              let properties = Object.keys(data.properties)\n              let subtasks = new NGN.Tasks()\n\n              if (properties.length > 0) {\n                for (let i = 0; i < properties.length; i++) {\n                  let propertyName = properties[i]\n                  let property = data.properties[propertyName]\n\n                  model.fields[propertyName] = this.PRIVATE.extractCommonPropertyAttributes(property, models)\n\n                  // If this is a subschema, retrieve it.\n                  if (property.$ref) {\n                    subtasks.add(next => {\n                      let nestedModel = new NGN.DATA.JSONSchema(property.$ref)\n\n                      nestedModel.getModelDefinitions(definitions => {\n                        models = definitions.concat(models)\n\n                        model.fields[propertyName] = {\n                          $model: definitions[definitions.length - 1].name\n                        }\n\n                        next()\n                      })\n                    })\n                  }\n\n                  model.fields[propertyName].required = NGN.coalesce(data.required, '').indexOf(propertyName) >= 0\n                }\n              }\n\n              subtasks.on('complete', () => {\n                models.push(model)\n                cont()\n              })\n\n              subtasks.run(true)\n            })\n\n            tasks.on('complete', () => callback(models))\n            tasks.run(true)\n          } else {\n            callback(models)\n          }\n        }\n      })\n    })\n\n    this.once('parsed', () => {\n      this.PRIVATE.parsed = true\n      this.METADATA.ID = NGN.coalesce(this.METADATA.schema.id, this.METADATA.schema.$schema)\n    })\n\n    // Initialize\n    switch (NGN.typeof(schema)) {\n      case 'string':\n        // If schema is actually a URL, retrieve it.\n        this.METADATA.URL = schema\n        this.PRIVATE.NET.json(schema, (err, schema) => {\n          if (err) {\n            throw err\n          }\n\n          this.METADATA.schema = schema\n          this.METADATA.name = NGN.coalesce(schema.name, this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', ''))\n\n          this.emit('parsed')\n        })\n\n        break\n\n      case 'object':\n        this.METADATA.name = NGN.coalesce(schema.name, 'Untitled')\n        this.emit('parsed')\n        break\n\n      default:\n        throw new Error('Invalid schema definition.')\n    }\n  }\n\n  get id () {\n    if (this.METADATA.ID) {\n      return this.METADATA.ID\n    }\n\n    let id = NGN.coalesce(this.METADATA.URL)\n\n    if (id !== null) {\n      return id\n    }\n\n    let root\n    /* node-only */\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, `http://${require('os').hostname()}`)\n    /* end-node-only */\n    /* browser-only */\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, window.location.origin)\n    /* end-browser-only */\n\n    this.METADATA.ID = this.PRIVATE.NET.normalizeUrl(`${root}/${NGN.coalesce(this.name, 'untitled').toLowerCase()}.json`)\n\n    return this.METADATA.ID\n  }\n\n  get name () {\n    return this.METADATA.name\n  }\n\n  set name (value) {\n    this.METADATA.name = NGN.coalesce(value, 'Untitled')\n  }\n\n  getModelDefinitions (callback) {\n    if (!this.PRIVATE.parsed) {\n      this.once('parsed', () => {\n        this.getModelDefinitions(callback)\n      })\n    } else if (!this.PRIVATE.MODELS) {\n      this.PRIVATE.extractModelDefinitions(this.METADATA.schema, [], definitions => {\n        this.PRIVATE.MODELS = definitions\n        callback(definitions)\n      })\n    } else {\n      callback(this.PRIVATE.MODELS)\n    }\n  }\n}\n","import NGN from './core'\nimport EventEmitter from './emitter/core'\nimport * as Queue from './queue/core'\nimport * as Utility from './utility/core'\nimport * as Network from './net/core'\nimport * as Data from './data/core'\n\n// Add Event Emitter Class & Global Event Bus\nNGN.extend('EventEmitter', NGN.public(EventEmitter))\nNGN.extend('BUS', NGN.const(new NGN.EventEmitter()))\n\n// Add Queuing System\nNGN.extend('Task', NGN.const(Queue.Task))\nNGN.extend('Queue', NGN.const(Queue.Queue))\nNGN.extend('Tasks', NGN.deprecate(NGN.Queue, 'NGN.Tasks is now NGN.Queue'))\n\n// Add Networking\nNGN.extend('NET', NGN.const(Network.Library))\n\n// Add Utilities\nNGN.extend('UTILITY', NGN.const(Utility))\n\n// Add Data Library\nNGN.extend('DATA', NGN.const(Data))\n","import EventEmitter from '../emitter/core'\n\n/**\n * @class NGN.Task\n * Represents a unit of work as a function. A task \"executes\"\n * when it's callback method is executed.\n * @fires start\n * Triggered when task execution begins. The task itself is provided\n * as an argument to the event handler.\n * @fires complete\n * Triggered when task execution finishes. The task itself is provided\n * as an argument to the event handler.\n * @fires skip\n * Triggered when task is skipped. The task itself is provided\n * as an argument to the event handler.\n * @fires timeout\n * Triggered when task execution time exceeds the specified timeout\n * limit. The task itself is provided as an argument to the event handler.\n */\nexport default class QueueItem extends EventEmitter {\n  constructor (config) {\n    config = config || {}\n\n    super(config)\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {string} name\n       * Descriptive name of the worker.\n       */\n      name: NGN.const(NGN.coalesce(config.name, 'Unknown')),\n\n      /**\n       * @cfg {function} callback\n       * The method to execute when the queue is ready.\n       */\n      callback: NGN.privateconst(config.callback),\n\n      /**\n       * @cfg {number} number\n       * The queue item number. This is used primarily as an ID.\n       */\n      number: NGN.const(parseInt(config.number, 10)),\n\n      timer: NGN.private(null),\n      _status: NGN.private(null),\n      bus: NGN.private(config.buz),\n      _skip: NGN.private(false)\n    })\n\n    this.on('timeout', () => {\n      this._status = 'timedout'\n    })\n\n    this.on('skip', () => {\n      this._status = 'skipped'\n    })\n  }\n\n  /**\n   * @property {string} status\n   * May be `running`, `complete`, or `null` (not run yet)\n   */\n  get status () {\n    return this._status\n  }\n\n  /**\n   * @property {boolean} skipped\n   * `true` to skip the step, `false` to execute it.\n   */\n  get skipped () {\n    return this._skip\n  }\n\n  /**\n   * @method run\n   * Execute the callback function.\n   * @param {string} mode\n   * `dev` or `prod`. When in \"dev\" mode, verbose output is written\n   * to the console.\n   */\n  run (mode) {\n    if (this.skipped) {\n      this.emit('skip', this)\n\n      if (mode && mode === 'dev') {\n        NGN.WARN('SKIPPED ' + this.name)\n      }\n\n      return\n    }\n\n    this.emit('start', this)\n\n    if (mode && mode === 'dev') {\n      NGN.INFO('Executing ' + this.name + ':')\n    }\n\n    this._status = 'running'\n\n    const me = this\n    const scope = {\n      name: this.name,\n      number: this.number,\n      timeout: function (milliseconds) {\n        me.timer = setTimeout(function () {\n          me.emit('timeout', me)\n        }, milliseconds)\n      }\n    }\n\n    this.callback.apply(scope, [function () {\n      me._status = 'complete'\n      me.emit('complete', me)\n    }])\n\n    if (this.callback.length === 0) {\n      me._status = 'complete'\n      me.emit('complete', me)\n    }\n  }\n\n  /**\n   * @method skip\n   * Skip this item\n   */\n  skip () {\n    if (this._status === 'running') {\n      NGN.WARN(`Cannot skip step: ${this.name} is currently running.`)\n    } else if (this._status === 'timedout') {\n      NGN.WARN(`Cannot skip step: ${this.name} timed out.`)\n    } else if (this._status === 'complete') {\n      NGN.WARN(`Cannot skip step: ${this.name} already completed.`)\n    }\n\n    this._skip = true\n  }\n}\n","import EventEmitter from '../emitter/core'\n\n/**\n * @class NGN.Queue\n * A job runner/collection capable of parallel and sequential task processing.\n * @fires complete\n * Triggered when the entire collection of tasks has completed\n * processing/running.\n * @fires aborted\n * Triggered when processing is aborted before completion.\n * @fires aborting\n * Triggered when the abort sequence begins.\n * @fires timeout\n * Triggered when processing times out.\n * @fires taskstart\n * Triggered whenever a new task is started. The NGN.Task is\n * the only argument delivered to event handlers.\n * @fires taskcomplete\n * Triggered whenever a task completes processing. The NGN.Task is\n * the only argument delivered to event handlers.\n * @fires taskcreate\n * Triggered when a new NGN.Task is added to the queue. The NGN.Task is\n * the only argument delivered to event handlers.\n * @fires taskremove\n * Triggered when a NGN.Task is removed from the queue. The NGN.Task is\n * the only argument delivered to event handlers.\n * @fires tasktimeout\n * Triggered when an NGN.Task times out during processing. The NGN.Task is\n * the only argument delivered to event handlers.\n */\nexport default class Queue extends EventEmitter {\n  /**\n   * @constructor\n   * @param {string} [mode=production]\n   * Set this to `dev` for verbose console output.\n   */\n  constructor (mode = 'production') {\n    super()\n\n    Object.defineProperties(this, {\n      steps: NGN.private([]),\n      completed: NGN.private(0),\n      timeout: NGN.private(null),\n      _mode: NGN.private(mode),\n      _cancel: NGN.private(false),\n      processing: NGN.private(false),\n      timer: NGN.private(null),\n      sequential: NGN.private(false)\n    })\n\n    this.on('taskcomplete', (step) => {\n      // Disallow duplicates\n      if (this.sequential || step.status === 'completed') {\n        return\n      }\n\n      step._status = 'complete'\n\n      // When the step is done, tally it\n      this.completed++\n\n      if (this.mode === 'dev') {\n        NGN.INFO(step.name + ' completed.')\n      }\n\n      // If all of the queries have been tallied, we're done.\n      if (this.completed === this.steps.length) {\n        this.processing = false\n\n        Object.keys(this.steps).forEach((step) => {\n          clearTimeout(this.steps[step].timer)\n        })\n\n        this.emit('complete')\n      }\n    })\n\n    this.on('aborting', () => {\n      this._cancel = true\n    })\n  }\n\n  /**\n   * @property {Array} list\n   * A list of tasks within the collection. This is an array of\n   * objects, where each object contains the `id`, `name`, and\n   * `status` of the task.\n   *\n   * ```js\n   * {\n   *   id: <Number>,\n   *   name: <String>,\n   *   status: <String>\n   * }\n   * ```\n   */\n  get list () {\n    return this.steps.map(function (s) {\n      return {\n        id: s.number,\n        name: s.name,\n        status: s.status\n      }\n    })\n  }\n\n  /**\n   * @property {string} mode\n   * The type of processing (dev, production, etc). Setting this to\n   * `dev` enables verbose logging.\n   */\n  get mode () {\n    return this._mode\n  }\n\n  set mode (value) {\n    if (value.toLowerCase().substr(0, 3) === 'dev') {\n      this._mode = 'dev'\n    } else {\n      this._mode = 'production'\n    }\n  }\n\n  get cancelled () {\n    return this._cancel\n  }\n\n  onTimeout () {\n    let log = []\n\n    if (this.steps.length > 0) {\n      this.steps.forEach((s) => {\n        log.push(s.name, s.status === null ? 'NOT STARTED' : s.status)\n      })\n    }\n\n    this.emit('timeout', {\n      process: log\n    })\n\n    log = null\n  }\n\n  /**\n   * @method add\n   * Add a task to the list.\n   * @param {string} [name]\n   * A descriptive name for the queued process/task.\n   * @param {function} callback\n   * The function to queue.\n   * @param {function} callback.next\n   * This argument allows users to explicitly use asynchronous\n   * methods. Example:\n   *\n   * ```\n   * let tasks = new NGN.Tasks()\n   *\n   * tasks.add('Descriptive Title', function (next) {\n   *   myAsyncMethod(function () {\n   *     console.log('Ran something async.')\n   *     next()\n   *   })\n   * })\n   * @returns {NGN.Task}\n   * Returns the task object added to the queue.\n   */\n  add (name, fn) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    if (typeof name === 'function') {\n      fn = name\n      name = 'Step ' + (parseInt(this.steps.length) + 1)\n    }\n\n    if (typeof fn !== 'function') {\n      throw new Error('No processing method defined for step ' + (parseInt(this.steps.length) + 1) + '.')\n    }\n\n    const queue = new NGN.Task({\n      name: name,\n      callback: fn,\n      number: (this.steps.length > 0 ? this.steps[this.steps.length - 1].number : 0) + 1\n    })\n\n    queue.on('complete', (step) => this.emit('taskcomplete', step))\n\n    queue.on('timeout', (step) => {\n      if (step.status === 'running' || step.status === 'timedout') {\n        this.emit('tasktimeout', step)\n      }\n    })\n\n    this.steps.push(queue)\n    this.emit('taskcreate', queue)\n\n    return queue\n  }\n\n  /**\n   * @method getAt\n   * @param  {number} index\n   * Retrieve a queue item by it's index/queue number.\n   * @return {Queue}\n   */\n  getAt (index) {\n    return this.steps[index]\n  }\n\n  /**\n   * @method get\n   * Retrieve a specific queue item.\n   * @param  {string} requestedStepTitle\n   * The descriptie name of the queue item to retrieve.\n   * @return {Queue}\n   */\n  get (requestedStep) {\n    // Get by Name\n    let element = this.steps.filter((step) => {\n      return step.name === requestedStep\n    })\n\n    if (element.length === 1) {\n      return element[0]\n    }\n\n    // Get by index\n    element = this.steps.filter((step) => {\n      return step.number === requestedStep\n    })\n\n    if (element.length === 1) {\n      return element[0]\n    }\n  }\n\n  /**\n   * @method remove\n   * Remove a queue item by name or number.\n   * @param  {string} requestedStepTitle\n   * The descriptive name of the queue item to retrieve.\n   * @return {Queue}\n   * Returns the item that was removed.\n   */\n  remove (requestedStep) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    // Remove by name\n    let element = this.steps.filter((step) => {\n      return step.name === requestedStep\n    })\n\n    if (element.length === 1) {\n      this.steps = this.steps.filter((step) => {\n        return step.name !== requestedStep\n      })\n\n      this.emit('taskremove', element[0])\n      return element[0]\n    }\n\n    // Remove by ID\n    element = this.steps.filter((step) => {\n      return step.number === requestedStep\n    })\n\n    if (element.length === 1) {\n      this.steps = this.steps.filter((step) => {\n        return step.number !== requestedStep\n      })\n\n      this.emit('taskremove', element[0])\n      return element[0]\n    }\n  }\n\n  /**\n   * @method removeAt\n   * Removes a queue item from the specific index.\n   * @param  {number} requestedStepIndex\n   * The queue index/number.\n   * @return {Queue}\n   * Returns the item that was removed.\n   */\n  removeAt (requestedStep) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    // Remove by index\n    if (typeof requestedStep !== 'number') {\n      return console.error('Failed to remove step: ' + requestedStep)\n    }\n\n    if (requestedStep < 0 || requestedStep >= this.steps.length) {\n      return console.error('Step index ' + requestedStep + ' could not be found or does not exist.')\n    }\n\n    return this.steps.splice(requestedStep, 1)[0]\n  }\n\n  /**\n   * @method reset\n   * Resets all cancelled/skipped steps, essentially resetting the queue\n   * to it's pre-aborted state.\n   */\n  reset () {\n    if (this.processing) {\n      return NGN.WARN('Cannot reset a running queue. Abort or wait for the process to complete before resetting.')\n    }\n\n    // Refresh cancelled steps\n    this.steps.forEach((step) => {\n      step._skip = false\n    })\n  }\n\n  /**\n   * @method process\n   * Run the queued processes in order.\n   * @param {boolean} [sequential=false]\n   * Set to `true` to run the queue items in a synchronous-like manner.\n   * This will execute each method one after the other. Each method must\n   * complete before the next is started.\n   */\n  process (sequential = false) {\n    if (this.processing) {\n      return NGN.WARN('Cannot start processing (already running). Please wait for this process to complete before calling process() again.')\n    }\n\n    if (this.steps.length === 0) {\n      return this.emit('complete')\n    }\n\n    this.processing = true\n    this._cancel = false\n\n    if (this.timeout !== null) {\n      this.timer = setTimeout(() => this.onTimeout(), this.timeout)\n    }\n\n    this.sequential = typeof sequential === 'boolean' ? sequential : false\n    if (!this.sequential) {\n      for (let i = 0; i < this.steps.length; i++) {\n        this.steps[i].run(this.mode)\n      }\n    } else {\n      let queue = this.steps\n      let listener = new NGN.EventEmitter()\n\n      listener.on('taskcomplete', () => {\n        if (queue.length > 0) {\n          const currentTask = queue.shift()\n\n          if (currentTask.skipped) {\n            return listener.emit('taskcomplete')\n          }\n\n          currentTask.on('complete', () => listener.emit('taskcomplete'))\n          currentTask.on('start', () => this.emit('taskstart', currentTask))\n\n          currentTask.run(this.mode)\n        } else {\n          this.emit('complete')\n        }\n      })\n\n      let currentStep = queue.shift()\n\n      currentStep.on('complete', () => listener.emit('taskcomplete'))\n      currentStep.on('start', () => this.emit('taskstart', currentStep))\n\n      currentStep.run(this.mode)\n    }\n  }\n\n  // Alias for process\n  run () {\n    this.process(...arguments)\n  }\n\n  /**\n   * @method abort\n   * Abort/cancel processing. This prevents further steps from processing.\n   */\n  abort () {\n    this.emit('aborting')\n\n    // Make sure the steps are skipped.\n    this.each((step) => {\n      if (['completed', 'running', 'timedout'].indexOf(step.status) < 0 && !step.skipped) {\n        step.skip()\n      }\n    })\n\n    this.once('complete', () => this.emit('aborted'))\n  }\n\n  /**\n   * @method each\n   * Apply a method to each step.\n   * @param {function} method\n   * @private\n   */\n  each (fn) {\n    for (let i = 0; i < this.steps.length; i++) {\n      fn(this.steps[i])\n    }\n  }\n\n  // Alias for abort\n  cancel () {\n    this.abort(...arguments)\n  }\n}\n"],"names":["CustomException","Error","[object Object]","config","super","Object","defineProperty","this","NGN","privateconst","frame","nodelike","getFileName","__filename","message","custom","me","name","type","severity","category","replace","attr","hasOwnProperty","prepareStackTrace","_","stack","_err","captureStackTrace","rawstack","err","cause","console","warn","help","info","filter","frameFilter","map","el","join","trace","filename","line","getLineNumber","column","getColumnNumber","functionname","getFunctionName","native","isNative","eval","isEval","getTypeName","EEmitter","defineProperties","global","window","e","define","enumerable","writable","configurable","value","public","private","const","get","fn","set","getset","getterFn","setterFn","LEDGER_EVENT","EVENT","BUS","emit","arguments","extend","attribute","descriptor","inherit","source","dest","prototype","getOwnPropertyNames","forEach","definition","getOwnPropertyDescriptor","getPrototypeOf","trim","toLowerCase","undefined","apply","slice","obj","Array","call","splice","nullIf","sourceExpression","comparisonExpression","nullif","converge","length","arg","coalesce","coalesceb","process","dedupe","array","matches","i","indexOf","push","typeof","toString","split","forceArray","forceBoolean","forceNumber","radix","getTime","parseInt","parseFloat","NaN","ERROR","processStackItem","item","uri","fnRegex","operation","exec","path","cwd","file","substr","location","origin","reverse","isFn","v","wrap","preFn","wrapClass","ClassFn","deprecate","WARN","deprecateClass","classFn","needs","missing","getObjectMissingPropertyNames","MissingNgnDependencyError","properties","keys","getObjectExtraneousPropertyNames","index","objectHasAll","objectHasAny","objectHasExactly","args","shift","objectRequires","check","constructor","createAlias","namespace","WARNING_EVENT","Symbol","msg","INFO_EVENT","for","INFO","ERROR_EVENT","createException","getType","defaultType","Number","RegExp","Boolean","Date","Function","String","cfg","handlers","adhoc","maxlisteners","defaultMaxListeners","subscribers","subscriberList","eventName","handler","concat","callback","pool","unshift","listenerCount","handlerFn","deleteEventHandler","scope","result","events","getAllEvents","event","adhocEvent","pop","regularEvents","adhocEvents","allEvents","test","EventEmitter","META","queued","collectionQueue","thresholdQueue","defaultTTL","wildcardEvents","Set","setTTL","ttl","off","l","listeners","clear","wrappedHandlerFn","wrapEventHandlerWithScope","delete","removeListener","deprecatedEventName","replacementEventName","on","prefix","group","topic","increaseMaxListeners","attach","preventDefaultAction","preventDefault","count","setMaxListeners","getMaxListeners","decreaseMaxListeners","forward","triggers","payload","listener","remove","relay","targetEmitter","postfix","eventNameList","relayOnce","once","delayEmit","delay","setTimeout","getInternalCollectionId","collection","handleCollectionTrigger","key","cq","remainingqueue","size","masterqueue","funnel","eventCollection","triggerEventName","funnelOnce","funnelClosureEvent","threshold","thresholdEventName","limit","finalEventName","handleThresholdTrigger","thresholdOnce","thresholdClosureEvent","applyScope","symbolEvents","getOwnPropertySymbols","_events","removeAllListeners","prepend","add","eventHandler","prependListener","addListener","prependOnceListener","eventNames","iterator","values","currentEvent","done","next","statement","tokens","rules","state","reject","lastLineIndex","currentLength","currentMatch","row","unrecognizedCharacters","addRule","input","lines","unrecognized","currentLine","currentColumn","col","pattern","action","start","flags","multiline","ignoreCase","actionFn","actionString","charAt","scan","match","token","unexpected","lastIndex","rule","states","j","k","temple","str","grammar","PROTECTED","lexer","UTILITY","Lexer","activeText","orderedList","text","orderedTokenList","from","detail","ignoreXOF","assign","mainset","subset","elements","element","has","aggregate","setA","setB","intersection","a","b","diff","difference","equal","isSuperSet","equals","hostname","host","normalizeUrl","url","queryString","params","keypair","param","encodeURIComponent","networkInterfaces","HttpMethods","Request","UrlPattern","httpmethod","enforceMethodSafety","enforcemethodsafety","headers","requestbody","body","user","username","secret","password","bearerAccessToken","accessToken","withCredentials","timeout","timer","isCrossOrigin","applyAuthorizationHeader","setHeader","basicAuthToken","btoa","parseUri","protocol","part","query","hash","credentials","port","uriParts","maximumRedirects","redirectAttempts","prepareBody","contentType","form","dataString","JSON","stringify","maxRedirects","method","queryParameters","resultSet","setQueryParameter","toUpperCase","crossOriginRequest","overwriteExisting","re","clearTimeout","xhr","XMLHttpRequest","responded","onreadystatechange","readyState","DONE","status","onerror","ontimeout","open","setRequestHeader","send","Network","parseRequestConfiguration","NET","makeRequest","request","OPTIONS","options","bind","HEAD","head","GET","POST","post","PUT","put","DELETE","TRACE","json","JSONP","jsonp","preflight","response","responseData","parse","responseText","Math","round","random","data","document","removeChild","script","createElement","src","addEventListener","appendChild","Resource","globalHeaders","globalCredentials","accesstoken","globalQuery","baseUrl","baseurl","nocache","sslonly","ssecret","prepareUrl","qp","gHeaders","Library","ObjectDiff","lhs","rhs","differences","ltype","log","relativePath","compare","compareArray","array1","array2","len1","len2","index1","val1","index2","val2","context","value1","value2","hash1","hash2","objectHash","hashCache1","hashCache2","matchByPosition","x","y","matrix","max","sequence","indices1","indices2","subsequence","backtrack","lengthMatrix","defaultMatch","crcTable","makeCRCTable","c","n","Utility","serialize","crc","charCodeAt","crypto","getRandomValues","Uint8Array","lut","d0","d1","d2","d3","SERIALIZED_ARRAY_DATA","DATA","UTIL","toISOString","mapResult","TreeNode","parent","leafs","nodes","METADATA","order","minOrder","firstNumber","secondNumber","leaf","search","node","overwrite","TreeLeaf","left","balance","Tree","root","sep","rest","right","subst","floor","unsplit","includeNodes","s","BTREE","minKey","maxKey","ptr","walk","NGNDataValidationRule","validation","RULE","validator","NGNDataField","default","EMPTYDATA","required","hidden","fieldType","identifier","isIdentifier","autocorrectInput","description","sourceName","lastValue","dataType","validators","violatedRule","allowInvalid","TRANSFORM","transformer","RAWDATAPLACEHOLDER","RAW","ENUMERABLE_VALUES","REVERSE_ENUMERABLE_VALUES","IS_NEW","EVENTS","AUDITABLE","audit","AUDITLOG","TransactionLog","auditMaxEntries","model","setValue","suppressEvents","ignoreAudit","autoCorrectValue","change","field","old","new","priorValueIsValid","valid","reason","virtual","cursor","commit","commitPayload","Rule","nonempty","range","min","minimum","maximum","RangeRule","multipleOf","abs","unique","listType","enum","tuples","enumeration","not","notin","typeList","auditable","Entity","originallyHidden","currentlyHidden","isNew","autoid","silentValue","modified","changelog","id","rollback","getCommit","advance","valueType","dt","setTime","util","maxEntryCount","transaction","changeOrder","currentValue","cursorIndex","flush","removedId","timestamp","position","removedEntries","currentPosition","entry","activeCursor","prepareRange","isString","addRange","DataField","caching","cache","virtualMethod","CACHEKEY","cachedValue","localFieldPattern","monitoredFields","content","knownFieldNames","update","create","InvalidConfigurationError","applyMonitor","manner","commonModelEventHandler","invalid","originalEvent","record","commonStoreEventHandler","Store","undo","redo","originalSource","sourceMap","reverseMap","applyData","inverse","Model","load","dataMap","fieldmap","idAttribute","IdentificationField","OID","fields","invalidFieldNames","auditFieldNames","idField","expiration","expirationTimeout","created","now","store","AUDIT_HANDLER","getAuditMap","applyField","fieldcfg","ReservedWordError","Field","Relationship","VirtualField","applyChange","fieldname","setSilent","setSilentFieldValue","DATAMAP","MAP","FieldMap","autoIdValue","UUID","checksum","expires","ID","createDate","applyInverseMap","serializeFields","unmappedData","representation","unmappedRepresentation","isNaN","expired","fieldDefinitions","ignoreID","ignoreVirtualFields","IdentificationValue","fieldConfiguration","PRIVATE","DELETE_RECORD_FIELD","applyMap","cycle","getRecordSibling","btree","CREATE_EVENT","REMOVE_EVENT","UPDATE_EVENT","uniqueValues","knownRecords","isBTree","oid","suppressEvent","recordsFor","BTree","valueIndex","btreeValue","recordsOf","removed","oldValue","newValue","reset","records","allowDuplicates","errorOnDuplicate","errorOnInvalid","autoRemoveExpiredRecords","softDelete","softDeleteTtl","fifo","FIFO","lifo","LIFO","maxRecords","minRecords","autocompact","FIRSTRECORDINDEX","LASTRECORDINDEX","INDEX","STUB","delta","CREATE_RECORD","INDEXFIELDS","DELETE_RECORD","LOAD_RECORDS","RECORDMAP","Map","ACTIVERECORDMAP","FILTEREDRECORDMAP","checkModelIndexField","metaconfig","CONFIGURATION","getModelFieldType","addRecord","convertStubToRecord","newRecord","metadata","ACTIVERECORDS","FILTEREDRECORDS","freeze","createIndex","DELETECOUNT","compact","snapshots","snapshotarchive","history","recordCount","first","last","recordList","rec","defaults","applicableData","indexedFieldNames","removedRecord","activeIndex","examinedRecord","totalSize","Index","removeIndex","currentRecord","ActiveRecords","currentIndex","findIndex","purge","ARCHIVE","newModel","dataset","GUID","modelChecksums","insertableData","time","NGNDuplicateRecordError","newRecordCount","ranges","currentRange","empty","schema","NetworkResource","MODELS","parsed","extractCommonPropertyAttributes","property","models","$ref","format","subschema","JSONSchema","getModelDefinitions","definitions","$model","minLength","maxLength","exclusiveMinimum","exclusiveMaximum","minItems","maxItems","items","extractModelDefinitions","URL","$id","$schema","tasks","Tasks","allOf","cont","URI","coreModel","additionalProperties","prop","dependencies","dependency","requiredFields","dep","subtasks","propertyName","run","number","_status","bus","buz","_skip","skipped","mode","milliseconds","steps","completed","_mode","_cancel","processing","sequential","step","list","cancelled","queue","Task","requestedStep","error","onTimeout","currentTask","currentStep","each","skip","abort","Queue","Network.Library","Data"],"mappings":"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"}