{"version":3,"file":"ngn.js","sources":["../../src/exception.js","../../src/core.js","../../src/emitter/BrowserEmitter.js","../../src/emitter/core.js","../../src/queue/task.js","../../src/queue/queue.js","../../src/utility/Lexer.js","../../src/utility/Tokenizer.js","../../src/utility/Set.js","../../src/net/Utility.js","../../src/net/Request.js","../../src/net/Network.js","../../src/net/Resource.js","../../src/net/core.js","../../src/data/Utility.js","../../src/data/index/BTree.js","../../src/data/TransactionLog.js","../../src/data/rule/Rule.js","../../src/data/rule/RangeRule.js","../../src/data/field/Field.js","../../src/data/field/VirtualField.js","../../src/data/field/Relationship.js","../../src/data/field/FieldMap.js","../../src/data/Model.js","../../src/data/index/Index.js","../../src/data/Filter.js","../../src/data/Store.js","../../src/data/core.js","../../src/main.js"],"sourcesContent":["export default class CustomException extends Error { // eslint-disable-line\n  constructor (config) {\n    super()\n\n    Object.defineProperty(this, 'frameFilter', NGN.privateconst((frame) => {\n      return NGN.nodelike\n        ? frame.getFileName() !== __filename && frame.getFileName()\n        : frame.getFileName()\n    }))\n\n    config = config || {}\n    config = typeof config === 'string' ? { message: config } : config\n    config.custom = config.custom || {}\n\n    let me = this\n\n    this.name = config.name || 'NgnError'\n    this.type = config.type || 'TypeError'\n    this.severity = config.severity || 'minor'\n    this.message = config.message || 'Unknown Error'\n    this.category = config.category || 'operational' // Alternative is \"programmer\"\n\n    // Cleanup name\n    this.name = this.name.replace(/[^a-zA-Z0-9_]/gi, '')\n\n    // Add any custom properties\n    for (let attr in config.custom) {\n      if (config.custom.hasOwnProperty(attr)) {\n        this[attr] = config.custom[attr]\n      }\n    }\n\n    this.hasOwnProperty('custom') && delete this.custom\n\n    if (NGN.nodelike || Error.prepareStackTrace) {\n      // Capture the stack trace on a new error so the detail can be saved as a structured trace.\n      Error.prepareStackTrace = function (_, stack) { return stack }\n\n      let _err = new Error()\n\n      Error.captureStackTrace(_err, this)\n\n      this.rawstack = _err.stack\n\n      Error.prepareStackTrace = function (err, stack) { // eslint-disable-line handle-callback-err\n        me.cause && console.warn(me.cause)\n        me.help && console.info(me.help)\n\n        return `${me.name}: ${me.message}\\n` + stack.filter(me.frameFilter).map((el) => {\n          return `    at ${el}`\n        }).join('\\n')\n      }\n\n      // Enable stack trace\n      Error.captureStackTrace(this)\n    }\n  }\n\n  /*\n   * @property {Array} trace\n   * The structured data of the stacktrace. Each array element is a JSON object corresponding to\n   * the full stack trace:\n   *\n   * ```js\n   * {\n   *   filename: String,\n   *   line: Number,\n   *   column: Number,\n   *   functionname: String,\n   *   native: Boolean,\n   *   eval: Boolean,\n   *   type: String\n   * }\n   * ```\n   * @readonly\n   */\n  get trace () {\n    return this.rawstack.filter(this.frameFilter).map((frame) => {\n      return {\n        filename: frame.getFileName(),\n        line: frame.getLineNumber(),\n        column: frame.getColumnNumber(),\n        functionname: frame.getFunctionName(),\n        native: frame.isNative(),\n        eval: frame.isEval(),\n        type: frame.getTypeName()\n      }\n    })\n  }\n}\n","import CustomException from './exception'\n\n/**\n * @namespace NGN\n */\nlet NGN = Object.defineProperties({\n  // Establish a globally recognized namespace for browser or node-like environment.\n  get global () {\n    /* node-only */\n    return global\n    /* end-node-only */\n    /* browser-only */\n    return window\n    /* end-browser-only */\n  }\n\n  // get worker () {\n  //   /* node-only */\n  //   return require('worker_threads').Worker\n  //   /* end-node-only */\n  //   /* browser-only */\n  //   return window.worker\n  //   /* end-browser-only */\n  // }\n}, {\n  /**\n  * @method define\n  * Create an object definition for a property.\n  * For example:\n  *\n  * ```\n  * Object.defineProperty('attr', NGN.define(true, false, true, 'value'))\n  *\n  * // The snippet above is the same as:\n  * Object.defineProperty(this, 'attr', {\n  *  enumberable: true,\n  *  writable: false,\n  *  configurable: true,\n  *  value: 'value'\n  * })\n  * ```\n  * @param  {boolean} enumerable\n  * Determines if the attribute is considered an accessible part of the object.\n  * Making an attribute enumerable will make it show up as a key in an object,\n  * which can be iterated over (ex: `Object.keys()`). A non-enumerable asset is\n  * treated as a private attribute.\n  * @param  {boolean} writable\n  * Determines whether the value can be changed.\n  * @param  {boolean} configurable\n  * Determines whether the attribute can be removed from the object.\n  * @param  {any} value\n  * The actual value of the attribute.\n  * @private\n  */\n  define: {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: function (enumerable, writable, configurable, value) {\n      return {\n        enumerable,\n        writable,\n        configurable,\n        value\n      }\n    }\n  },\n\n  /**\n   * @property {string} version\n   * Identifies the NGN version number.\n   */\n  version: {\n    enumerable: true,\n    writable: false,\n    configurable: false,\n    value: '#VERSION#'\n  }\n})\n\nObject.defineProperties(NGN, {\n  /**\n   * @method public\n   * Create a `public` property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.public('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: true,\n   *  writable: true,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  public: NGN.define(false, false, false, function (value) {\n    return NGN.define(true, typeof value !== 'function', false, value)\n  }),\n\n  /**\n   * @method private\n   * Create a `private` property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.private('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  writable: true,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  private: NGN.define(false, false, false, function (value) {\n    return NGN.define(false, typeof value !== 'function', false, value)\n  }),\n\n  /**\n   * @method const\n   * Create a `public` constant property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.const('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: true,\n   *  writable: false,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  const: NGN.define(false, false, false, function (value) {\n    return NGN.define(true, false, false, value)\n  }),\n\n  /**\n   * @method privateconst\n   * Create a `private` constant property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.privateconst('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  writable: false,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  privateconst: NGN.define(false, false, false, function (value) {\n    return NGN.define(false, false, false, value)\n  }),\n\n  /**\n   * @method get\n   * Create a private `getter` property definition for an object.\n   * Public getters are part of the ES2015 class spec.\n   *\n   * Example:\n   *\n   * ```\n   * let myFunction = function () {\n   *  return 'somevalue'\n   * }\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  get: function () {\n   *    return 'somevalue'\n   *  }\n   * })\n   * ```\n   * @param  {function} fn\n   * Any valid async JavaScript function with a `return` value.\n   * @private\n   */\n  get: NGN.define(false, false, false, function (fn) {\n    return {\n      enumerable: false,\n      get: fn\n    }\n  }),\n\n  /**\n   * @method set\n   * Create a private `setter` property definition for an object.\n   * Public setters are part of the ES2015 class spec.\n   *\n   * Example:\n   *\n   * ```\n   * let myFunction = function () {\n   *  return 'somevalue'\n   * }\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  set: function (value) {\n   *    somethingElse = value\n   *  }\n   * })\n   * ```\n   * @param  {function} fn\n   * Any valid JavaScript function that accepts a single argument (value).\n   * @private\n   */\n  set: NGN.define(false, false, false, function (fn) {\n    return {\n      enumerable: false,\n      set: fn\n    }\n  }),\n\n  /**\n   * @method getset\n   * Create a private property defintion containing both a `getter` and `setter`\n   * for the specified attribute.\n   * @param  {function} getFn\n   * Any valid async JavaScript function with a `return` value.\n   * @param  {function} setFn\n   * Any valid JavaScript function that accepts a single argument (value).\n   * @private\n   */\n  getset: NGN.define(false, false, false, (getterFn, setterFn) => {\n    return {\n      enumerable: false,\n      get: getterFn,\n      set: setterFn\n    }\n  }),\n\n  LEDGER_EVENT: NGN.define(false, false, false, EVENT => {\n    return function () {\n      NGN.BUS.emit(EVENT, ...arguments)\n    }\n  })\n})\n\nObject.defineProperties(NGN, {\n  /**\n   * @method extend\n   * Extend the NGN core object. Extending NGN is the equivalent of:\n   *\n   * Example:\n   * ```\n   * NGN.extend('greet', NGN.public(function (recipient) {\n   *  return 'Hello, ' + recipient + '!'\n   * }))\n   *\n   * // Equivalent of:\n   *\n   * Object.defineProperty(NGN, 'greet', {\n   *  enumerable: true,\n   *  writable: false,\n   *  configurable: false,\n   *  value: function (recipient) {\n   *    return 'Hello, ' + recipient + '!'\n   *  }\n   * })\n   * ```\n   * The example above produces a public function available from NGN:\n   *\n   * ```\n   * console.log(NGN.greet('world')) // outputs Hello, world!\n   * @param  {string} attribute\n   * Name of the attribute to add to the object.\n   * @param  {Object} descriptor\n   * The object descriptor, i.e.\n   * ```\n   * {\n   *  enumerable: true/false,\n   *  writable: true/false,\n   *  configurable: true/false,\n   *  value: {any}\n   * }\n   *\n   * // OR\n   *\n   * {\n   *  enumerable: true/false,\n   *  get: function () { return ... },\n   *  set: function (value) { some = value ... }\n   * }\n   * ```\n   * @private\n   */\n  extend: NGN.privateconst(function (attribute, descriptor) {\n    // If no descriptor is provided, multiple properties are being defined.\n    if (typeof attribute === 'object') {\n      Object.defineProperties(this, attribute)\n    } else {\n      Object.defineProperty(this, attribute, descriptor)\n    }\n  }),\n\n  /**\n   * @method inherit\n   * Inherit the properties of another object/class.\n   * @param  {object|function} source\n   * The source object (i.e. what gets copied)\n   * @param  {object|function} destination\n   * The object properties get copied to.\n   */\n  inherit: NGN.const(function (source = null, dest = null) {\n    if (source && dest) {\n      source = typeof source === 'function' ? source.prototype : source\n      dest = typeof dest === 'function' ? dest.prototype : dest\n\n      Object.getOwnPropertyNames(source).forEach(function (attr) {\n        const definition = Object.getOwnPropertyDescriptor(source, attr)\n        Object.defineProperty(dest, attr, definition)\n      })\n\n      const prototype = Object.getOwnPropertyNames(Object.getPrototypeOf(source)).filter((attr) => {\n        return attr.trim().toLowerCase() !== 'constructor' && !dest.hasOwnProperty(attr)\n      })\n\n      prototype.forEach((attr) => {\n        const cfg = Object.getOwnPropertyDescriptor(source, attr)\n\n        if (cfg === undefined && typeof source[attr] === 'function') {\n          Object.defineProperty(dest, attr, NGN.public(function () {\n            return source[attr].apply(this, arguments)\n          }))\n        }\n      })\n    }\n  }),\n\n  /**\n   * @method slice\n   * Converts an array-like object to an array.\n   *\n   * Example:\n   * ```\n   * function () {\n   *  return NGN.slice(arguments)\n   * }\n   * ```\n   * @param  {Object} obj\n   * The object to slice into an array.\n   * @return {array}\n   * @private\n   */\n  slice: NGN.private(function (obj) {\n    return Array.prototype.slice.call(obj)\n  }),\n\n  /**\n   * @method splice\n   * Converts an array-like object to a spliced array.\n   *\n   * Example:\n   * ```\n   * function () {\n   *  return NGN.splice(arguments)\n   * }\n   * ```\n   * @param  {Object} obj\n   * The object to splice into an array.\n   * @return {array}\n   * @private\n   */\n  splice: NGN.private(function (obj) {\n    return Array.prototype.splice.call(obj)\n  }),\n\n  /**\n   * @method nullIf\n   * Returns a null value if the two specified expressions are equal.\n   * ```js\n   * if (NGN.nullIf(myvar, 'value') === null) {\n   *   console.log('Variable had a value of \"value\", which is considered null')\n   * }\n   *\n   * // or\n   *\n   * if (NGN.nullIf(myvar) === null) {\n   *   console.log('Empty variable whose trimmed length is 0')\n   * }\n   * ```\n   * @param {any} sourceExpression\n   * The variable or value to check.\n   * @param {any} [comparisonExpression = '']\n   * The variable or value to compare the source expression against.\n   * @return {any}\n   * If the source expression matches the comparison expression, `null` will\n   * be returned. If they do not match, the source expression will be returned.\n   */\n  nullIf: NGN.public(function (sourceExpression, comparisonExpression = '') {\n    try {\n      // If the values aren't equal, make sure it's not due to blank values\n      // or hidden characters.\n      if (sourceExpression !== comparisonExpression) {\n        // Different data types indicate different values.\n        if (typeof sourceExpression !== typeof comparisonExpression) {\n          return sourceExpression\n        }\n\n        if (typeof sourceExpression === 'string') {\n          if (sourceExpression.trim() !== comparisonExpression.trim()) {\n            return sourceExpression\n          }\n        }\n      }\n\n      return sourceExpression === comparisonExpression ? null : sourceExpression\n    } catch (e) {\n      NGN.WARN(`nullIf threw an error (${e.message}) when comparing '${sourceExpression}' to '${comparisonExpression}'.`)\n      return null\n    }\n  }),\n\n  // Private alias for nullIf\n  nullif: NGN.public(function () {\n    return this.nullIf(...arguments)\n  }),\n\n  /**\n   * @method converge\n   * Provides a basic coalesce. Expects the first parameter to be a boolean\n   * value. `true` will wrap arguments in a nullIf operator. `false` will not.\n   * @private\n   */\n  converge: NGN.private(function () {\n    if (arguments.length < 2) {\n      return null\n    } else if (arguments.length === 2) {\n      if (arguments[1] === undefined) {\n        return null\n      } else if (arguments[0]) {\n        return NGN.nullIf(arguments[1])\n      } else {\n        return arguments[1]\n      }\n    }\n\n    for (let arg = 1; arg < arguments.length; arg++) {\n      // try {\n      if (arguments[arg] !== undefined &&\n        (\n          arguments[0] ? NGN.nullIf(arguments[arg]) : arguments[arg]\n        ) !== null\n      ) {\n        if (arguments[arg] !== undefined) {\n          return arguments[arg]\n        }\n      }\n      // } catch (e) {}\n    }\n\n    return null\n  }),\n\n  /**\n   * @method coalesce\n   * Finds the first non-null/defined value in a list of arguments.\n   * This can be used with {@link Boolean Boolean} values, since `true`/`false` is a\n   * non-null/defined value.\n   * @param {Mixed} args\n   * Any number of arguments can be passed to this method.\n   * @return {Any}\n   * Returns the first non-null/defined value. If non exist, `null` is retutned.\n   */\n  coalesce: NGN.public(function () {\n    return NGN.converge(false, ...arguments)\n  }),\n\n  /**\n   * @method coalesceb\n   * Provides the same functionality as #coalesce, except **b**lank/empty arguments\n   * are treated as `null` values.\n   * @param {Mixed} args\n   * Any number of arguments can be passed to this method.\n   */\n  coalesceb: NGN.public(function () {\n    return NGN.converge(true, ...arguments)\n  }),\n\n  /**\n   * @property {boolean} nodelike\n   * Indicates NGN is running in a node-like environment supporting\n   * the `require` statement. This will detect node, io.js, Electron,\n   * NW.js, and other environments presumably supporting Node.js.\n   * @private\n   */\n  nodelike: NGN.const(NGN.global.process !== undefined),\n\n  /**\n   * @method dedupe\n   * Deduplicate a simple array.\n   * @param {array} array\n   * The array to deduplicate.\n   * @return {array}\n   * The array with unique records.\n   * @private\n   */\n  dedupe: NGN.const((array) => {\n    let matches = []\n\n    // This is more performant than array.filter in most cases.\n    for (let i = 0; i < array.length; i++) {\n      if (array.indexOf(array[i]) === i) {\n        matches.push(array[i])\n      }\n    }\n\n    array = null\n\n    return matches\n  }),\n\n  /**\n   * @method typeof\n   * A more specific typeof method.\n   * @param  {any} element\n   * The element to determine the type of.\n   * @return {string}\n   * Returns the type (all lower case).\n   */\n  typeof: NGN.const((el) => {\n    if (el === undefined) {\n      return 'undefined'\n    } else if (el === null) {\n      return 'null'\n    }\n\n    let value = Object.prototype.toString.call(el).split(' ')[1].replace(/[^A-Za-z]/gi, '').toLowerCase()\n\n    if (value === 'function' || typeof el === 'function') {\n      if (!el.name) {\n        let name = NGN.coalesceb(el.toString().replace(/\\n/gi, '').replace(/^function\\s|\\(.*$/mgi, '').toLowerCase(), 'function')\n\n        if (name.indexOf(' ') >= 0) {\n          return 'function'\n        }\n\n        return name\n      } else {\n        value = NGN.coalesceb(el.name, 'function')\n      }\n    }\n\n    return value.toLowerCase()\n  }),\n\n  /**\n   * @method forceArray\n   * Forces a value to become an array if it is not already one. For example:\n   *\n   * ```js\n   * let x = 'value'\n   *\n   * x = NGN.forceArray(x)\n   *\n   * console.log(x) // Outputs ['value']\n   * ```\n   * @param {any} expression\n   * The value being forced to be an array.\n   * @private\n   */\n  forceArray: NGN.const((value) => {\n    if (value === null) {\n      return []\n    }\n\n    return NGN.typeof(value) === 'array' ? value : [value]\n  }),\n\n  /**\n   * @method forceBoolean\n   * Forces a value to become a boolean if it is not already one. For example:\n   *\n   * ```js\n   * let x = NGN.forceBoolean('false') // String ==> Boolean\n   * console.log(x) // Outputs false\n   *\n   * let y = NGN.forceBoolean('text') // String ==> Boolean\n   * console.log(y) // Outputs true (any non-blank text results in true, except the word \"false\")\n   *\n   * let z = NGN.forceBoolean(0) // Number ==> Boolean (0 = false, 1 = true)\n   * console.log(z) // Outputs false\n   * ```\n   *\n   * All other types will yield a `true` value, except for `null`. A `null`\n   * value is treated as `false`.\n   * @param {any} expression\n   * The value being forced to be a boolean.\n   * @private\n   */\n  forceBoolean: NGN.const((value) => {\n    switch (NGN.typeof(value)) {\n      case 'boolean':\n        return value\n\n      case 'number':\n        return value === 0 ? false : true // eslint-disable-line no-unneeded-ternary\n\n      case 'string':\n        value = value.trim().toLowerCase()\n\n        if (value === 'false') {\n          return false\n        }\n\n        return true\n\n      default:\n        return NGN.coalesceb(value) !== null\n    }\n  }),\n\n  /**\n   * @method forceNumber\n   * Forces a value to become a number if it is not already one. For example:\n   *\n   * ```js\n   * let x = NGN.forceNumber('10') // String ==> Number\n   * console.log(x === 10) // Outputs true\n   *\n   * let y = NGN.forceNumber(true) // Boolean ==> Number\n   * console.log(y) // Output 1\n   *\n   * let z = NGN.forceNumber(false) // Boolean ==> Number\n   * console.log(y) // Output 0\n   * ```\n   *\n   * All other types will yield a `NaN` value. This has no effect on\n   * @param {any} expression\n   * The value being forced to be a number. If the expression is a date,\n   * the result will be the number of milliseconds passed since the epoch.\n   * See [Date.getTime()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime)\n   * for details.\n   * @param {number} [radix]\n   * An integer between 2 and 36 that represents the radix (the base in\n   * mathematical numeral systems) of the expression.\n   * Specify 10 for the decimal numeral system commonly used by humans.\n   * Always specify this parameter to eliminate reader confusion and to\n   * guarantee predictable behavior. Different implementations produce\n   * different results when a radix is not specified, usually defaulting the\n   * value to 10.\n   *\n   * **If no radix is supplied**, the `parseFloat` will be used to identify\n   * the numeric value. When a radix is supplied, `parseInt` is used.\n   * @private\n   */\n  forceNumber: NGN.const((value, radix = null) => {\n    try {\n      switch (NGN.typeof(value)) {\n        case 'boolean':\n          return value ? 1 : 0\n\n        case 'number':\n          return value\n\n        case 'date':\n          return value.getTime()\n\n        case 'string':\n          return radix !== null ? parseInt(value, radix) : parseFloat(value)\n\n        default:\n          return NaN\n      }\n    } catch (e) {\n      NGN.ERROR(e)\n      return NaN\n    }\n  }),\n\n  /**\n   * @method stack\n   * Retrieve the stack trace from a specific code location without throwing\n   * an exception. Files are always listed from the root. This is the default\n   * order in browsers, but the reverse of the normal stack order in node-like\n   * environments.\n   *\n   * For example, the following stack on node shows `_test.js` as the last item\n   * in the array. In node-like environments, the `_test.js` would normally be\n   * the first item in the stacktrace.\n   *\n   * ```js\n   * [\n   *   { path: 'node.js:348:7', file: 'node.js', line: 348, column: 7 },\n   *   { path: 'module.js:575:10',\n   *     file: 'module.js',\n   *     line: 575,\n   *     column: 10 },\n   *   { path: 'module.js:550:10',\n   *     file: 'module.js',\n   *     line: 550,\n   *     column: 10 },\n   *   { path: 'module.js:541:32',\n   *     file: 'module.js',\n   *     line: 541,\n   *     column: 32 },\n   *   { path: '/_test.js:8:14', file: '/_test.js', line: 8, column: 14 }\n   * ]\n   * ```\n   *\n   * By standardizing the order of the stack trace, it is easier to programmatically\n   * identify sources of problems. This method does not prevent developers from\n   * accessing a normal stacktrace.\n   * @private\n   * @returns {array}\n   * Returns an array of objects. Each object contains the file, line, column,\n   * and path within the stack. For example:\n   *\n   * ```\n   * {\n   *   path: 'path/to/file.js:127:14'\n   *   file: 'path/to/file.js',\n   *   line: 127,\n   *   column: 14\n   * }\n   * ```\n   *\n   * If a stacktrace is unavailable for any reason, the array will contain a\n   * single element like:\n   *\n   * ```js\n   * {\n   *   path: 'unknown',\n   *   file: 'unknown',\n   *   line: 0,\n   *   column: 0\n   * }\n   * ```\n   */\n  processStackItem: NGN.privateconst(function (item, uri) {\n    return item.replace(/at.*\\(|\\)/gi, '')\n      .replace(uri, './')\n      .replace(/\\/{2,100}/gi, '/')\n      .trim().split(':')\n  }),\n\n  stack: NGN.get(function () {\n    const originalStack = (new Error).stack.split('\\n') // eslint-disable-line\n    let stack = (new Error()).stack.split('\\n') || []\n    let fnRegex = /at.*\\(/gi\n\n    stack = stack.filter((item) => {\n      return item.split(':').length > 1\n    }).map((item) => {\n      let operation = fnRegex.exec(item)\n\n      if (operation) {\n        operation = operation[0].replace(/^at\\s{1,100}|\\s{1,100}\\($/gi, '').replace('<anonymous>', 'console')\n      }\n\n      if (this.nodelike) {\n        item = this.processStackItem(item.toString(), process.cwd())\n\n        return {\n          path: item.join(':').replace('./', process.cwd() + '/'),\n          // path: item[0].substr(0, item[0].length) + ':' + item[1] + ':' + item[2],\n          file: item[0].substr(0, item[0].length),\n          line: parseInt(item[1], 10),\n          column: parseInt(item[2], 10),\n          operation: operation\n        }\n      } else {\n        item = this.processStackItem(item.toString(), window.location.origin)\n\n        return {\n          path: item[0].substr(1, item[0].length - 1) + ':' + item[1] + ':' + item[2],\n          file: item[0].substr(1, item[0].length - 1),\n          line: parseInt(item[1], 10),\n          column: parseInt(item[2], 10),\n          operation: operation\n        }\n      }\n    })\n\n    return stack.length !== 0\n      ? (this.nodelike ? stack.reverse() : stack)\n      : [{\n        path: 'unknown',\n        file: 'unknown',\n        line: 0,\n        column: 0\n      }]\n  }),\n\n  /**\n   * @method isFn\n   * A shortcut method for determining if a variable is a function.\n   * This is useful for identifying the existance of callback methods.\n   * @param {any} variable\n   * The variable to identify as a function.\n   * @returns {boolean}\n   * @private\n   */\n  isFn: NGN.privateconst((v) => {\n    return typeof v === 'function'\n  }),\n\n  /**\n   * @method wrap\n   * Executes a **synchronous** method before invoking a standard function.\n   * This is primarily designed for displaying warnings, but can also be\n   * used for other operations like migration layers.\n   * @param {function} preMethod\n   * The **synchronous** function to invoke before the class is instantiated. This\n   * method receives the same arguments passed to the class.\n   * @param {function} method\n   * The function to wrap.\n   * @return {function}\n   * @private\n   */\n  wrap: NGN.privateconst(function (preFn, fn) {\n    return function () {\n      preFn(...arguments)\n      fn(...arguments)\n    }\n  }),\n\n  /**\n   * @method wrapClass\n   * Executes a **synchronous** method before returning an instantiated class.\n   * It runs a function first, then returns the equivalent of\n   * `new MyClass(...)`. This is primarily designed for displaying warnings,\n   * but can also be used for other operations like migration layers.\n   * @param {function} preMethod\n   * The **synchronous** method to invoke before the class is instantiated. This\n   * method receives the same arguments passed to the class.\n   * @param {function} class\n   * The class to wrap.\n   * @return {Class}\n   * @private\n   */\n  wrapClass: NGN.privateconst(function (preFn, ClassFn) {\n    return function () {\n      preFn(...arguments)\n      return new ClassFn(...arguments)\n    }\n  }),\n\n  /**\n   * @method deprecate\n   * Fires an event (if NGN.BUS is available) or logs a warning indicating the\n   * method is deprecated.\n   * @param {function} method\n   * The method to return/execute.\n   * @param {string} [message='The method has been deprecated.']\n   * The warning displayed to the user.\n   * @return {function}\n   * @fires DEPRECATED.METHOD\n   * Fires `DEPRECATED.METHOD` on the NGN.BUS. The message is delivered to\n   * the event handler.\n   */\n  deprecate: NGN.privateconst(function (fn, message = 'The method has been deprecated.') {\n    return this.wrap(() => NGN.WARN('DEPRECATED.METHOD', message), fn)\n  }),\n\n  /**\n   * @method deprecateClass\n   * Logs a warning indicating the class is deprecated. This differs from\n   * #deprecate by extending & preserving the original class (the resulting\n   * class can be used with the `new` operator).\n   * @param {function} class\n   * The class to return/execute.\n   * @param {string} [message='The class has been deprecated.']\n   * The warning displayed to the user.\n   * @fires DEPRECATED.CLASS\n   * Fires `DEPRECATED.CLASS` on the NGN.BUS. The message is delivered to\n   * the event handler.\n   * @return {Class}\n   */\n  deprecateClass: NGN.privateconst(function (classFn, message = 'The class has been deprecated.') {\n    return this.wrapClass(() => NGN.WARN('DEPRECATED.CLASS', message), classFn)\n  }),\n\n  /**\n   * @method needs\n   * A method to check for the existance of required attributes in an object.\n   * This is designed to check for namespace existance.\n   *\n   * ```js\n   * NGN.needs('DOM','BUS', 'NET', 'JUNK') // Throws an error because \"JUNK\" doesn't exist.\n   * ```\n   * @param {Object} namespace\n   * The object to check.\n   * @param {String[]} attributes\n   * A list of attributes to check for.\n   * @throws {MissingNgnDependencyError}\n   * Throws an error if the namespace is missing an attribute dependency.\n   * @private\n   */\n  needs: NGN.private(function () {\n    let missing = NGN.getObjectMissingPropertyNames(NGN, ...arguments)\n\n    if (missing.length === 0) {\n      return\n    }\n\n    // Throw an error if there are any missing attributes.\n    if (missing.length > 0) {\n      throw new MissingNgnDependencyError(`Missing NGN dependencies: ${missing.join(', ')}`.replace(/\\s{2,100}/gi, ' '))\n    }\n  }),\n\n  /**\n   * @method getObjectMissingPropertyNames\n   * Given a list, returns which list items are not present in an\n   * object's enumerable properties.\n   *\n   * ```js\n   * let obj = { a: 1, b: 2 }\n   * let missing = NGN.getObjectMissingPropertyNames(obj, 'a', 'b', 'c')\n   *\n   * console.log(missing) // Outputs ['c']\n   * ```\n   * @param {Object} object\n   * The object to check.\n   * @return {String[]}\n   * @private\n   */\n  getObjectMissingPropertyNames: NGN.private(function () {\n    let missing = []\n    let properties = Object.keys(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      if (properties.indexOf(arguments[i]) < 0) {\n        missing.push(arguments[i])\n      }\n    }\n\n    return missing\n  }),\n\n  /**\n   * @method getObjectExtraneousPropertyNames\n   * Given a list, returns which enumerable object properties\n   * are not in the list.\n   *\n   * ```js\n   * let obj = { a: 1, b: 2, d: 4 }\n   * let extra = NGN.getObjectExtraneousPropertyNames(obj, 'a', 'b', 'c')\n   *\n   * console.log(extra) // Outputs ['d']\n   * ```\n   * @param {Object} object\n   * The object to check.\n   * @return {String[]}\n   * @private\n   */\n  getObjectExtraneousPropertyNames: NGN.private(function () {\n    let properties = Object.keys(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      let index = properties.indexOf(arguments[i])\n\n      if (index >= 0) {\n        properties.splice(index, 1)\n      }\n    }\n\n    return properties\n  }),\n\n  /**\n   * @method objectHasAll\n   * Determines whether the specified object has _all_ of the provided properties.\n   * This only accounts for enumerable properties. It also decorates the Boolean\n   * result with a property called `properties`, which contains any missing property\n   * names.\n   *\n   * **Example**\n   * ```js\n   * let check = NGN.objectHasAll(NGN, 'BUS', 'NET')\n   *\n   * console.log(check) // Outputs: true\n   * ```\n   *\n   * ```js\n   * let check = NGN.objectHasAll(NGN, 'BUS', 'NET', 'JUNK')\n   *\n   * console.log(check) // Outputs: false\n   * console.log(check.properties) // Outputs ['JUNK']\n   * ```js\n   * @param {Object} object\n   * The object to check.\n   * @return {Boolean}\n   */\n  objectHasAll: NGN.const(function () {\n    let properties = Object.keys(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      if (properties.indexOf(arguments[i]) < 0) {\n        return false\n      }\n    }\n\n    return true\n  }),\n\n  /**\n   * @method objectHasAny\n   * Determines whether the specified object has _any_ of the requested properties.\n   * This only accounts for enumerable properties.\n   *\n   * **Example**\n   * ```js\n   * let check = NGN.objectHasAny(NGN, 'BUS', 'NET', 'MORE')\n   *\n   * console.log(check) // Outputs: true\n   * ```\n   *\n   * ```js\n   * let check = NGN.objectHasAny(NGN, 'JUNK1', 'JUNK2', 'JUNK3')\n   *\n   * console.log(check) // Outputs: false\n   * ```js\n   * @param {Object} object\n   * The object to check.\n   * @return {Boolean}\n   */\n  objectHasAny: NGN.const(function () {\n    let properties = Object.keys(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      if (properties.indexOf(arguments[i]) >= 0) {\n        return true\n      }\n    }\n\n    return false\n  }),\n\n  /**\n   * @method objectHasExactly\n   * Determines whether the specified object has _only_ the requested properties.\n   * This only accounts for enumerable properties.\n   *\n   * **Example**\n   * ```js\n   * let obj = { a: 1, b: 2 }\n   * let check = NGN.objectHasExactly(obj, 'a', 'b')\n   *\n   * console.log(check) // Outputs: true\n   * ```\n   *\n   * ```js\n   * let obj = { a: 1, b: 2, d: 4 }\n   * let check = NGN.objectHasExactly(obj, 'a', 'b', 'c')\n   *\n   * console.log(check) // Outputs: false\n   * ```js\n   * @param {Object} object\n   * The object to check.\n   * @return {Boolean}\n   */\n  objectHasExactly: NGN.const(function () {\n    // If there are missing properties, it's not an exact match.\n    if (this.getObjectMissingPropertyNames(arguments[0]).length !== 0) {\n      return false\n    }\n\n    let properties = Object.keys(arguments[0])\n    let args = NGN.slice(arguments)\n\n    args.shift()\n\n    // Check for extra properties on the object\n    for (let i = 0; i < properties.length; i++) {\n      if (args.indexOf(properties[i]) < 0) {\n        return false\n      }\n    }\n\n    // Make sure there are enough properties.\n    for (let i = 0; i < args.length; i++) {\n      if (properties.indexOf(args[i]) < 0) {\n        return false\n      }\n    }\n\n    return true\n  }),\n\n  /**\n   * @method objectRequires\n   * This is the same as #objectHasAll, but will throw an\n   * error if the object is missing any properties.\n   * @throws Error\n   */\n  objectRequires: NGN.const(function () {\n    let check = this.objectHasAll(...arguments)\n\n    if (!check) {\n      throw new Error(`${arguments[0].constructor.name} is missing the following attributes: ${check.missing.join(', ')}`)\n    }\n  }),\n\n  /**\n   * @method createAlias\n   * A helper method to alias a value on an object. This is the equivalent of:\n   * ```js\n   * Object.defineProperty(namespace, name, NGN.get(() => {\n   *   return value\n   * }))\n   * ```\n   * @param  {Object} namespace\n   * The object to apply the alias property to.\n   * @param  {String} name\n   * The alias name.\n   * @param  {Any} value\n   * The value to return.\n   * @private\n   */\n  createAlias: NGN.private(function (namespace, name, value) {\n    Object.defineProperty(namespace, name, NGN.get(() => {\n      return value\n    }))\n  }),\n\n  /**\n   * @method WARN\n   * This method is used to emit special info events.\n   * The NGN.BUS can listen for all events using the NGN.WARN global symbol.\n   *\n   * ```js\n   * NGN.BUS.on(NGN.WARNING_EVENT, function () => {\n   *   console.warn(...arguments)\n   * })\n   * ```\n   *\n   * See NGN.EventEmitter#emit for detailed parameter usage.\n   * @private\n   */\n  WARNING_EVENT: NGN.privateconst(Symbol('NGN.WARN')),\n  WARN: NGN.privateconst(msg => NGN.LEDGER_EVENT(NGN.WARNING_EVENT)(msg)),\n\n  /**\n   * @method INFO\n   * This method is used to emit special warning events.\n   * The NGN.BUS can listen for all events using the NGN.INFO global symbol.\n   *\n   * ```js\n   * NGN.BUS.on(NGN.INFO_EVENT, function () => {\n   *   console.info(...arguments)\n   * })\n   * ```\n   *\n   * See NGN.EventEmitter#emit for detailed parameter usage.\n   * @private\n   */\n  INFO_EVENT: NGN.privateconst(Symbol.for('NGN.INFO')),\n  INFO: NGN.privateconst(msg => NGN.LEDGER_EVENT(NGN.INFO_EVENT)(msg)),\n\n  /**\n   * @method ERROR\n   * This method is used to emit special soft error events. A soft error\n   * is one that does not throw, but does get logged (typically non-critical).\n   * The NGN.BUS can listen for all events using the NGN.ERROR global symbol.\n   *\n   * ```js\n   * NGN.BUS.on(NGN.ERROR_EVENT, function () => {\n   *   console.info(...arguments)\n   * })\n   * ```\n   *\n   * See NGN.EventEmitter#emit for detailed parameter usage.\n   * @private\n   */\n  ERROR_EVENT: NGN.privateconst(Symbol.for('NGN.ERROR')),\n  ERROR: NGN.privateconst(msg => NGN.LEDGER_EVENT(NGN.ERROR_EVENT)(msg)),\n\n  /**\n   * @method INTERNAL\n   * This method is used to emit special soft internal events. An internal\n   * event is typically used for keeping track of object states.\n   * The NGN.BUS can listen for all events using the NGN.INTERNAL global symbol.\n   *\n   * ```js\n   * NGN.BUS.on(NGN.INTERNAL_EVENT, 'some.name', function () => {\n   *   console.info(...arguments)\n   * })\n   * ```\n   *\n   * See NGN.EventEmitter#emit for detailed parameter usage.\n   * @private\n   * @ignore\n   */\n  INTERNAL_EVENT: NGN.privateconst(Symbol.for('NGN.INTERNAL')),\n\n  /**\n   * Internal event trigger.\n   * @ignore\n   */\n  INTERNAL: NGN.privateconst(function () { NGN.LEDGER_EVENT(NGN.INTERNAL_EVENT)(...arguments) }),\n\n  /**\n   * @method createException\n   * Create a custom global exception (custom error).\n   * @param {Object} config\n   * The configuration of the new error.\n   * @param {String} [config.name=NgnError]\n   * The pretty name of the exception. Alphanumeric characters only (underscore is acceptable).\n   * @param {String} [config.type=TypeError]\n   * The type of error. This is commonly `TypeError` or `ReferenceError`, but\n   * it can be any custom value.\n   * @param {String} [config.severity=minor]\n   * A descriptive \"level\" indicating how critical the error is.\n   * @param {String} [config.message=Unknown Error]\n   * The default message to output when none is specified.\n   * @param {Object} [config.custom]\n   * Provide a key/value object of custom attributes for the error.\n   * There are two \"special\" custom attributes: `help` and `cause`.\n   * When provided, these will be written to stdout whenever the error's\n   * stack is viewed.\n   *\n   * For example:\n   *\n   * ```js\n   * NGN.createException({\n   *   name: 'Test Problem',\n   *   message: 'An example error.',\n   *   custom: {\n   *     help: 'Remove the throw statement.',\n   *     cause: 'Testing the error output.'\n   *   }\n   * });\n   *\n   * throw TestProblem()\n   * ```\n   * The code above generates the following console output:\n   *\n   * ```sh\n   * Testing the error output.\n   * Remove the throw statement.\n   * /path/to/test.js:12\n   *    throw TestProblem();\n   *    ^\n   *\n   * TestProblem: An example error.\n   *    at null._onTimeout (/path/to/test.js:12:11)\n   *    at Timer.listOnTimeout (timers.js:92:15)\n   * ```\n   */\n  createException: NGN.const(function (config) {\n    config = config || {}\n    config = typeof config === 'string' ? { message: config } : config\n    config.name = config.name || 'NgnError'\n\n    // Create the error as a function\n    NGN.global[config.name] = function () {\n      if (arguments.length > 0) {\n        config.message = arguments[0]\n      }\n\n      return new CustomException(config)\n    }\n  }),\n\n  /**\n   * @method getType\n   * Returns the primitive object/function of the specified type.\n   * For example:\n   *\n   * ```js\n   * let type = NGN.getType('number') // Returns Number\n   * let type = NGN.getType('string') // Returns String\n   * ```\n   */\n  getType: NGN.const(function (type, defaultType) {\n    switch (type.trim().toLowerCase()) {\n      case 'number':\n        return Number\n\n      case 'regex':\n        NGN.WARN('regex is not a valid JavaScript type. Using regexp instead.')\n\n      case 'regexp': // eslint-disable-line no-fallthrough\n        return RegExp\n\n      case 'boolean':\n        return Boolean\n\n      case 'symbol':\n        return Symbol\n\n      case 'date':\n        return Date\n\n      case 'array':\n        return Array\n\n      case 'object':\n        return Object\n\n      case 'function':\n        return Function\n\n      case 'string':\n        return String\n\n      default:\n        if (defaultType) {\n          return defaultType\n        }\n\n        return undefined\n    }\n  }),\n\n  /**\n   * @typedef {Object} OperatingSystem\n   * Represents an operating system.\n   * @property {string} name\n   * The name of the operating system, as recognized by the environment.\n   * @property {string} type\n   * A simple string indicating the class of operating system. This will be\n   * `windows`, `mac`, `linux`, `ios`, `android`, or `other`.\n   * @property {string} version\n   * A version number identifying which release of the operating system is in use.\n   */\n  /**\n   * Identifies the operating system.\n   * @returns {OperatingSystem}\n   */\n  platform: NGN.get(() => {\n    let os\n\n    /* node-only */\n    os = process.platform\n    /* end-node-only */\n    /* browser-only */\n    os = navigator.platform\n    /* end-node-only */\n\n    let type = os.toLowerCase()\n    if (type.indexOf('ios') >= 0 || type.indexOf('like mac')) {\n      type = 'ios'\n    } else if (type.indexOf('mac') >= 0) {\n      type = 'mac'\n    } else if (type.indexOf('win') >= 0) {\n      type = 'windows'\n    } else if (type.indexOf('android') >= 0) {\n      type = 'android'\n    } else if (type.indexOf('linux') >= 0) {\n      type = 'linux'\n    } else {\n      type = 'other'\n    }\n\n    let release\n    /* node-only */\n    release = require('os').release()\n    /* end-node-only */\n    /* browser-only */\n    release = /\\((.*)\\)/i.exec(navigator.userAgent)[1].split(';')[0].split(/\\s+/i).pop()\n    /* end-node-only */\n\n    return {\n      name: os,\n      type,\n      version: release\n    }\n  })\n})\n\n// Standard NGN Exceptions\nNGN.createException({\n  name: 'MissingNgnDependencyError',\n  type: 'MissingNgnDependencyError',\n  severity: 'critical',\n  message: 'An NGN dependency is missing or could not be found.',\n  category: 'programmer',\n  custom: {\n    help: 'Include the missing library.',\n    cause: 'A required dependency was not included, or it was not included in the correct sequence.'\n  }\n})\n\nNGN.createException({\n  name: 'ReservedWordError',\n  type: 'ReservedWordError',\n  severity: 'critical',\n  message: 'An attempt to use a reserved word failed.',\n  category: 'programmer',\n  custom: {\n    help: 'Use an alternative word.',\n    cause: 'A word was used to define an attribute, method, field, or other element that already exists.'\n  }\n})\n\nNGN.createException({\n  name: 'InvalidConfigurationError',\n  type: 'InvalidConfigurationError',\n  severity: 'critical',\n  message: 'Invalid configuration.',\n  category: 'programmer',\n  custom: {\n    help: 'See the documentation for the proper configuration.',\n    cause: 'The configuration specified was marked as invalid or caused an error during instantiation.'\n  }\n})\n\n// Self reference to make NGN global in any environment.\nNGN.global.NGN = NGN\n\nexport { NGN as default }\n","/**\n * @class EventEmitterBase\n * This is an extendable generic class used to apply event management\n * to non-DOM objects, such as data models, logging, and other common\n * elements of JavaScript programming.\n * @protected\n */\nexport default class BrowserEmitter { // eslint-disable-line no-unused-vars\n  /**\n   * @constructor\n   * ```\n   * let EE = new EventEmitter()\n   * ```\n   * This is a protected class. It is most commonly instantiated through\n   * the NGN namespace (i.e. `new NGN.EventEmitter()`). However; it is\n   * designed for use within the NGN library, not directly as an event emitter.\n   * Use with caution.\n   */\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    Object.defineProperties(this, {\n      handlers: NGN.private({}),\n      adhoc: NGN.private({}),\n      maxlisteners: NGN.private(cfg.defaultMaxListeners || 25)\n    })\n  }\n\n  /**\n   * @property {object} subscribers\n   * An array of all subscribers which currently have a registered event handler.\n   * @warning This is a UI-only method.\n   */\n  get subscribers () {\n    let subscriberList = {}\n\n    for (let eventName in this.handlers) {\n      subscriberList[eventName] = {\n        handler: this.handlers[eventName].length,\n        adhoc: 0\n      }\n    }\n\n    for (let eventName in this.adhoc) {\n      subscriberList[eventName] = subscriberList[eventName] || {\n        handler: 0\n      }\n\n      subscriberList[eventName].adhoc = this.adhoc[eventName].length\n    }\n\n    return subscriberList\n  }\n\n  /**\n   * @property defaultMaxListeners\n   * The maximum number of listeners for a single event.\n   */\n  get defaultMaxListeners () {\n    return this.maxlisteners\n  }\n\n  set defaultMaxListeners (value) {\n    this.maxlisteners = value\n  }\n\n  /**\n   * @method {number} listenerCount\n   * The number of listeners for a specific event.\n   * @param {string} eventName\n   * The name of the event to count listeners for.\n   */\n  listenerCount (eventName) {\n    return (this.handlers[eventName] || []).length +\n      (this.adhoc[eventName] || []).length\n  }\n\n  /**\n   * @method getMaxListeners\n   * A node-like reference to the #defaultMaxListeners value.\n   * @return {number}\n   */\n  getMaxListeners () {\n    return this.defaultMaxListeners\n  }\n\n  /**\n   * @method setMaxListeners\n   * A node-like reference to the #defaultMaxListeners value (setter).\n   */\n  setMaxListeners (value) {\n    this.defaultMaxListeners = value\n  }\n\n  /**\n   * @method eventNames\n   * A node-like reference providing an array of recognized event names.\n   * @return {array}\n   */\n  eventNames () {\n    let handlers = Object.keys(this.handlers)\n    let adhoc = Object.keys(this.adhoc)\n    return NGN.dedupe(handlers.concat(adhoc))\n  }\n\n  /**\n   * @method listeners\n   * Returns the raw listener methods for the event.\n   * @param {string} eventName\n   * Name of the event to retrieve listeners for.\n   * @return {array}\n   */\n  listeners (eventName) {\n    let handlers = this.handlers[eventName] || []\n    let adhoc = this.adhoc[eventName] || []\n    return handlers.concat(adhoc)\n  }\n\n  /**\n   * @method addListener\n   * Create a new event handler for the specified event.\n   * @param  {string|object} eventName\n   * Name of the event to listen for.\n   * If an object is passed, this method will automatically setup a #pool.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   * This is ignored if eventName is an object.\n   */\n  addListener (eventName, callback) {\n    if (typeof eventName === 'object') {\n      return this.pool(eventName)\n    }\n\n    this.handlers[eventName] = this.handlers[eventName] || []\n    this.handlers[eventName].unshift(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method prependListener\n   * This is the same as #addListener, except the event handler is added to the end of the queue.\n   * @param  {string|object} eventName\n   * Name of the event to listen for.\n   * If an object is passed, this method will automatically setup a #pool.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   * This is ignored if eventName is an object.\n   */\n  prependListener (eventName, callback) {\n    if (typeof eventName === 'object') {\n      return this.pool(eventName)\n    }\n\n    this.handlers[eventName] = this.handlers[eventName] || []\n    this.handlers[eventName].push(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method onceListener\n   * Create a new event handler for the specified event. The\n   * handler will be removed immediately after it is executed. This\n   * effectively listens for an event to happen once and only once\n   * before the handler is destroyed.\n   * @param  {string} eventName\n   * Name of the event to listen for.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   */\n  once (eventName, callback) {\n    this.adhoc[eventName] = this.adhoc[eventName] || []\n    this.adhoc[eventName].push(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method prependOnceListener\n   * A node-like reference to the #once method, adding events to the\n   * beginning of the event list (processed before others) instead of the end.\n   * @param  {string} eventName\n   * Name of the event to listen for.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   */\n  prependOnceListener (eventName, callback) {\n    this.adhoc[eventName] = this.adhoc[eventName] || []\n    this.adhoc[eventName].unshift(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method removeListener\n   * Remove an event handler. If no handler is specified, all handlers for\n   * the specified event will be removed.\n   * @param {string} eventName\n   * Name of the event to remove.\n   * @param {function} [handlerFn]\n   * The handler function to remove from the event handlers.\n   */\n  removeListener (eventName, handlerFn) {\n    this.deleteEventHandler('handlers', eventName, handlerFn)\n    this.deleteEventHandler('adhoc', eventName, handlerFn)\n  }\n\n  /**\n   * @method deleteEventHandler\n   * Remove a specific event handler.\n   * @param {string} type\n   * Either `handler` (multi-use events) or `adhoc` (one-time events)\n   * @param {string} eventName\n   * Name of the event to remove.\n   * @param {function} handlerFn\n   * The handler function to remove from the event handlers.\n   * @private\n   */\n  deleteEventHandler (type, eventName, handlerFn) {\n    let scope = this[type]\n\n    if (scope[eventName]) {\n      if (!handlerFn) {\n        delete scope[eventName]\n        return\n      }\n\n      let result = []\n      scope[eventName].forEach((handler) => {\n        if (handler.toString() !== handlerFn.toString()) {\n          result.push(handler)\n        }\n      })\n\n      if (result.length === 0) {\n        delete scope[eventName]\n        return\n      }\n\n      scope[eventName] = result\n    }\n  }\n\n  /**\n   * @method removeAllListeners\n   * Remove all event handlers from the EventEmitter (both regular and adhoc).\n   */\n  removeAllListeners (eventName = null) {\n    if (eventName !== null) {\n      delete this.handlers[eventName]\n      delete this.adhoc[eventName]\n    } else {\n      this.handlers = {}\n      this.adhoc = {}\n    }\n  }\n\n  /**\n   * @method emit\n   * Fires an event. This method accepts one or more arguments. The\n   * first argument is always the event name, followed by any number\n   * of payload arguments.\n   *\n   * Example:\n   * ```\n   * const EE = new NGN.EventEmitter()\n   *\n   * EE.emit('someevent', {payload: 1}, {payload: 2})\n   * ```\n   * The example above triggers an event called `someevent` and applies\n   * the remaining two arguments to any event handlers.\n   * @param {string} eventName\n   * The name of the event to trigger.\n   */\n  emit () {\n    let args = NGN.slice(arguments)\n    const eventName = args.shift()\n    const events = this.getAllEvents(eventName)\n\n    if (typeof eventName === 'symbol') {\n      events.push(eventName)\n    }\n\n    let scope = {\n      event: eventName\n    }\n\n    for (let name = 0; name < events.length; name++) {\n      let adhocEvent = this.adhoc[events[name]]\n\n      // Adhoc event handling\n      if (adhocEvent) {\n        delete this.adhoc[events[name]]\n\n        while (adhocEvent.length > 0) {\n          let fn = adhocEvent.pop()\n\n          scope.handler = fn\n\n          fn.apply(scope, args)\n        }\n      }\n\n      // Regular event handling\n      let handler = this.handlers[events[name]]\n\n      if (handler) {\n        for (let fn = 0; fn < handler.length; fn++) {\n          scope.handler = handler[fn]\n          handler[fn].apply(scope, args)\n        }\n      }\n    }\n  }\n\n  /**\n   * @method getAllEvents\n   * Returns all of the events that match an event name. The event name\n   * may contain wildcards (i.e. `*`) or it can be a regular expression.\n   * @param  {string|regexp} eventName\n   * A string or regular expression defining which event names to identify.\n   * A string value containing an asterisk (*) will be converted to a regular\n   * expression for simplistic wildcard event handling purposes.\n   * @return {array}\n   * An array of unique event names with handlers or adhoc handlers.\n   * @private\n   */\n  getAllEvents (eventName) {\n    const regularEvents = Object.keys(this.handlers)\n    const adhocEvents = Object.keys(this.adhoc)\n    let allEvents = NGN.dedupe(regularEvents.concat(adhocEvents))\n\n    allEvents = allEvents.filter(function (event) {\n      // If the event is an exact match, don't filter it out.\n      if (event === eventName) {\n        return true\n      }\n\n      // If the event is a regexp/wildcard, further processing is necessary.\n      if (NGN.typeof(event) === 'regexp' || event.indexOf('*') >= 0) {\n        // Convert wildcard events to a regular expression.\n        if (NGN.typeof(event) !== 'regexp') {\n          event = new RegExp(event.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\n        }\n        // If the event name matches the event, keep it.\n        return event.test(eventName)\n      }\n\n      // None of the criteria were met. Ignore the event.\n      return false\n    })\n\n    return allEvents\n  }\n}\n","// This chunk of awful is courtesy the StandardJS library!\n// We love the lib, except for its failure to allow disabling\n// a parsing error's OUTPUT.\n/* browser-only */\nimport EE from './BrowserEmitter'\n/* end-browser-only */\nlet EEmitter\n/* node-only */\nEEmitter = require('events').EventEmitter\n/* end-node-only */\n/* browser-only */\nEEmitter = EE\n/* end-browser-only */\n\n/**\n * @class NGN.EventEmitter\n * The EventEmitter is an extandable event driver non-DOM objects, such as\n * data models, objects, and other common elements of JavaScript programming.\n *\n * The NGN.EventEmitter is based on and compatible with the [Node.js EventEmitter](https://nodejs.org/dist/latest/docs/api/events.html#events_class_eventemitter).\n * It contains additional event management capabilities, which are available\n * in browser _and_ Node.js environments.\n */\nexport default class EventEmitter extends EEmitter {\n  constructor () {\n    super()\n\n    // const INSTANCE = Symbol('instance')\n\n    Object.defineProperties(this, {\n      // META: NGN.get(() => this[INSTANCE]),\n\n      META: NGN.private({\n        queued: {},\n        collectionQueue: {},\n        thresholdQueue: {},\n        defaultTTL: -1,\n        wildcardEvents: new Set()\n      }),\n\n      /**\n       * @method setTTL\n       * Set a default time-to-live for event handlers (in milliseconds).\n       * After the TTL period elapses, event handlers are removed.\n       * By default, there is no TTL (`-1`).\n       * @param {number} ttl\n       * The number of milliseconds before an event handler is automatically\n       * removed. This value may be `-1` (no TTL/never expires) or a value\n       * greater than `0`.\n       */\n      setTTL: NGN.const((ttl = -1) => {\n        if (ttl === 0) {\n          NGN.WARN('NGN.EventEmitter#TTL cannot be 0.')\n          return\n        }\n\n        this.META.defaultTTL = ttl\n      }),\n\n      /**\n       * @alias off\n       * Remove an event handler. If no handler is specified, all handlers for\n       * the specified event will be removed.\n       * This is a shortcut for #removeListener.\n       * @param {string} eventName\n       * Name of the event to remove.\n       * @param {function} [handlerFn]\n       * The handler function to remove from the event handlers.\n       */\n      off: NGN.public((eventName, handlerFn) => {\n        if (NGN.typeof(eventName) === 'array') {\n          for (let i = 0; i < eventName.length; i++) {\n            this.off(eventName[i], handlerFn)\n          }\n\n          return\n        }\n\n        let l = this.listeners(eventName)\n\n        if (!NGN.isFn(handlerFn)) {\n          return this.clear(eventName)\n        }\n\n        let wrappedHandlerFn = this.wrapEventHandlerWithScope(eventName, handlerFn)\n\n        if (l.indexOf(wrappedHandlerFn) < 0) {\n          for (let i = 0; i < l.length; i++) {\n            if (l[i].toString() === wrappedHandlerFn.toString()) {\n              this.META.wildcardEvents.delete(eventName)\n              // this.removeListener(eventName, handlerFn)\n              this.removeListener(eventName, l[i], false)\n              break\n            }\n          }\n        } else {\n          this.META.wildcardEvents.delete(eventName)\n          this.removeListener(eventName, handlerFn)\n        }\n      }),\n\n      /**\n       * @method deprecate\n       * Provides a deprecation notice for the specified event.\n       * Automatically emits the appropriate \"replacement\" event\n       * if a replacement event is configured. If no replacement\n       * event is configured, the deprecation notice will be written\n       * to the console but no replacement event will be triggered.\n       * @param {string} deprecatedEventName\n       * The name of the deprecated event.\n       * @param {string} [replacementEventName]\n       * The name of the new event.\n       */\n      deprecate: NGN.const((deprecatedEventName, replacementEventName) => {\n        const me = this\n\n        this.on(deprecatedEventName, function () {\n          NGN.WARN(`${deprecatedEventName} is deprecated. ` + (!replacementEventName ? '' : `Use ${replacementEventName} instead.`))\n\n          if (replacementEventName) {\n            let args = NGN.slice(arguments)\n\n            args.shift()\n            args.unshift(replacementEventName)\n\n            me.emit.apply(me, args)\n          }\n        })\n      }),\n\n      /**\n       * @method pool\n       * A helper command to create multiple related subscribers\n       * all at once. This is a convenience function.\n       * @property {string} [prefix]\n       * Supply a prefix to be added to every event. For example,\n       * `myScope.` would turn `someEvent` into `myScope.someEvent`.\n       * @property {Object} subscriberObject\n       * A key:value object where the key is the name of the\n       * unprefixed event and the key is the handler function.\n       * A value can be an object, allowing for nesting events. For example:\n       *\n       * ```js\n       * NGN.BUS.pool('prefix.', {\n       *   deep: {\n       *     nested: {\n       *       eventName: function () {\n       *         console.log('event triggered')\n       *       }\n       *     }\n       *   }\n       * })\n       *\n       * NGN.BUS.emit('prefix.deep.nested.eventName') // <-- Outputs \"event triggered\"\n       * ```\n       * @private\n       */\n      pool: NGN.privateconst(function (prefix, group) {\n        if (typeof prefix !== 'string') {\n          group = prefix\n          prefix = ''\n        }\n\n        let pool = {}\n\n        for (let eventName in group) {\n          let topic = `${NGN.coalesce(prefix, '')}${eventName}`\n\n          if (NGN.isFn(group[eventName])) {\n            this.increaseMaxListeners()\n\n            pool[eventName] = this.on(topic, group[eventName])\n          } else if (typeof group[eventName] === 'object') {\n            this.pool(`${topic}.`, group[eventName])\n          } else {\n            NGN.WARN(`${topic} could not be pooled in the event emitter because it's value is not a function.`)\n          }\n        }\n      }),\n\n      /**\n       * @method attach\n       * Attach a function to a topic. This can be used\n       * to forward events in response to asynchronous functions.\n       *\n       * For example:\n       *\n       * ```js\n       * myAsyncDataFetch(NGN.BUS.attach('topicName'))\n       * ```\n       *\n       * This is the same as:\n       *\n       * ```js\n       * myAsyncCall(function(data){\n       *  NGN.BUS.emit('topicName', data)\n       * })\n       * ```\n       * @param {string} eventName\n       * The name of the event to attach a handler method to.\n       * @param {boolean} [preventDefaultAction=false]\n       * Setting this to `true` will execute a `event.preventDefault()` before\n       * attaching the handler.\n       * @returns {function}\n       * Returns a function that will automatically be associated with an event.\n       */\n      attach: NGN.const(function (eventName, preventDefaultAction) {\n        preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\n\n        return (e) => {\n          if (preventDefaultAction && !NGN.nodelike) {\n            e.preventDefault()\n          }\n\n          this.emit(eventName, ...arguments)\n        }\n      }),\n\n      /**\n       * @method increaseMaxListeners\n       * Increase the number of maximum listeners.\n       * @param {Number} [value = 1]\n       * The number of events the max listener account will be increased by.\n       * @private\n       */\n      increaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() + count)\n      }),\n\n      /**\n       * @method decreaseMaxListeners\n       * Decrease the number of maximum listeners.\n       * @param {Number} [value = 1]\n       * The number of events the max listener account will be decreased by.\n       * @private\n       */\n      decreaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() - count)\n      }),\n\n      /**\n       * @method forward\n       * A special subscriber that fires one or more event in response to\n       * to an event. This is used to bubble events up/down an event chain.\n       *\n       * For example:\n       *\n       * ```js\n       * NGN.BUS.forward('sourceEvent', ['someEvent','anotherEvent'], {payload:true})\n       * ```\n       * When `sourceEvent` is published, the bind method triggers `someEvent` and\n       * `anotherEvent`, passing the payload object to `someEvent` and\n       * `anotherEvent` subscribers simultaneously.\n       *\n       * To forward an event to another EventEmitter, see #relay.\n       * @param {String} sourceEvent\n       * The event to subscribe to.\n       * @param {String|Array} triggeredEvent\n       * An event or array of events to fire in response to the sourceEvent.\n       * @param {any} data\n       * Optional data to pass to each bound event handler.\n       * @returns {Object}\n       * Returns an object with a single `remove()` method.\n       */\n      forward: NGN.const(function (eventName, triggers, payload) {\n        triggers = NGN.forceArray(triggers)\n\n        let me = this\n        let listener = function () {\n          let args = NGN.slice(arguments)\n\n          if (payload) {\n            args.push(payload)\n          }\n\n          me.emit(triggers, ...args)\n        }\n\n        this.increaseMaxListeners()\n        this.on(eventName, listener)\n\n        // Provide handle back for removal of topic\n        return {\n          remove: () => {\n            this.decreaseMaxListeners()\n            this.off(eventName, listener)\n          }\n        }\n      }),\n\n      /**\n       * This relays an entire event to a different event emitter.\n       * For example:\n       *\n       * ```js\n       * let emitterA = new NGN.EventEmitter()\n       * let emitterB = new NGN.EventEmitter()\n       *\n       * emitterA.relay('my.event', emitterB)\n       *\n       * emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n       *\n       * emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n       * ```\n       * @param  {string} eventName\n       * The name of the event to listen for.\n       * @param  {NGN.EventEmitter} targetEmitter\n       * The emitter to relay the event to.\n       * @param {string} [prefix]\n       * An optional prefix to prepend to the eventName.\n       * @param {string} [postfix]\n       * An optional postfix to append to the eventName.\n       */\n      relay: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.on(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      }),\n\n      /**\n       * This relays an entire event to a different event emitter. This is\n       * the same as #relay, but the event handler is removed after the\n       * first invocation of the event.\n       *\n       * For example:\n       *\n       * ```js\n       * let emitterA = new NGN.EventEmitter()\n       * let emitterB = new NGN.EventEmitter()\n       *\n       * emitterA.relayOnce('my.event', emitterB)\n       *\n       * emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n       *\n       * emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n       * emitterA.emit('my.event') // Does nothing\n       * ```\n       * @param  {string} eventName\n       * The name of the event to listen for.\n       * @param  {NGN.EventEmitter} targetEmitter\n       * The emitter to relay the event to.\n       * @param {string} [prefix]\n       * An optional prefix to prepend to the eventName.\n       * @param {string} [postfix]\n       * An optional postfix to append to the eventName.\n       */\n      relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.once(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      }),\n\n      /**\n       * @method delayEmit\n       * This method waits for the specified duration, then publishes an\n       * event once. This will publish the event only once at the end of the\n       * wait period, even if the event is triggered multiple times. This can\n       * be useful when working with many events triggered in rapid succession.\n       *\n       * For example, an NGN.DATA.Model representing a person may be used to\n       * track a user profile. The NGN.DATA.Model fires an event called `field.update`\n       * every time a data field is modified. In many cases, a user may update\n       * multiple fields of their profile using a form with a \"Save\" button.\n       * Instead of generating a new \"save\" (to disk, to memory, to an API, etc)\n       * operation for each field, the publishOnce event can wait until all\n       * changes are made before running the save operation.\n       *\n       * ```js\n       * // Create a data model representing a person.\n       * var Person = new NGN.DATA.Model({....})\n       *\n       * // Create a new person record for a user.\n       * var user = new Person()\n       *\n       * // When the user is modified, save the data.\n       * user.on('field.update', function () {\n       *   // Wait 300 milliseconds to trigger the save event\n       *   NGN.BUS.delayEmit('user.save', 300)\n       * })\n       *\n       * // Save the user using an API\n       * NGN.BUS.on('user.save', function () {\n       *   NGN.NET.put({\n       *     url: 'https://my.api.com/user',\n       *     json: user.data\n       *   })\n       * })\n       *\n       * // Modify the record attributes (which are blank by default)\n       * user.firstname = 'John'\n       * user.lastname = 'Doe'\n       * user.age = 42\n       *\n       * // Make another update 1 second later\n       * setTimeout(function () {\n       *   user.age = 32\n       * }, 1000)\n       * ```\n       *\n       * The code above sets up a model and record. Then it listens to the record\n       * for field updates. Each time it recognizes an update, it queues the \"save\"\n       * event. When the queue matures, it fires the `user.save` event.\n       *\n       * The first `field.update` is triggered when `user.firstname = 'John'` runs.\n       * This initiates a queue for `user.save`, set to mature in 300 millisenconds.\n       * Next, a `field.update` is triggered when `user.lastname = 'Doe'` runs.\n       * This time, since the queue for `user.save` is already initiated, notthing\n       * new happens. Finally, a `field.update` is triggered when `user.age = 42`\n       * runs. Just like the last one, nothing happens since the `user.save` queue\n       * is already active.\n       *\n       * The `user.save` queue \"matures\" after 300 milliseconds. This means after\n       * 300 milliseconds have elapsed, the `user.save` event is triggered. In this\n       * example, it means the `NGN.NET.put()` code will be executed. As a result,\n       * all 3 change (firstname, lastname, and age) will be complete before the\n       * API request is executed. The queue is cleared immediately.\n       *\n       * The final update occurs 1 second later (700 milliseconds after the queue\n       * matures). This triggers a `field.update`, but since the queue is no\n       * longer active, it is re-initiated. 300 milliseconds later, the `user.save`\n       * event is fired again, thus executing the API request again (1.3 seconds\n       * in total).\n       * @param {string} eventName\n       * The event/topic to publish/emit.\n       * @param {Number} [delay=300]\n       * The number of milliseconds to wait before firing the event.\n       * @param {Any} [payload]\n       * An optional payload, such as data to be passed to an event handler.\n       */\n      delayEmit: NGN.const(function (eventName, delay) {\n        if (!this.META.queued.hasOwnProperty(eventName)) {\n          let args = NGN.slice(arguments)\n          args.splice(1, 1)\n\n          this.META.queued[eventName] = setTimeout(() => {\n            delete this.META.queued[eventName]\n            this.emit(...args)\n          }, delay)\n        }\n      }),\n\n      /**\n       * @method getInternalCollectionId\n       * Returns a unique ID for special collections.\n       * @param {object} collection\n       * The collection to generate an ID for.\n       * @private\n       */\n      getInternalCollectionId: NGN.privateconst(function (collection) {\n        return Symbol(collection)\n        // let time = (new Date()).getTime().toString()\n        // let rand = Math.random().toString()\n        // let key = Object.keys(collection).length + 1\n        //\n        // while (collection.hasOwnProperty(`${key.toString()}${time}${rand}`)) {\n        //   key++\n        // }\n        //\n        // return `${key.toString()}${time}${rand}`\n      }),\n\n      /**\n       * @method handleCollectionTrigger\n       * A method to manage #chain event handlers.\n       * @private\n       */\n      handleCollectionTrigger: NGN.privateconst(function (eventName, key) {\n        let me = this\n\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            let cq = me.META.collectionQueue\n\n            if (cq[key]) {\n              cq[key].remainingqueue.delete(eventName)\n\n              if (cq[key].remainingqueue.size === 0) {\n                cq[key].remainingqueue = cq[key].masterqueue\n\n                if (NGN.isFn(cq[key].eventName)) {\n                  cq[key].eventName(cq[key].payload)\n                } else {\n                  me.emit(cq[key].eventName, cq[key].payload)\n                }\n              }\n            }\n          }, 0)\n        }\n      }),\n\n      /**\n       * @method funnel\n       * Emit an event after a collection of unique events have all fired.\n       * This can be useful in situations where multiple asynchronous actions\n       * must complete before another begins. For example, blending 3\n       * remote data sources from different API's into a single resultset\n       * can be achieved with this.\n       *\n       * **Example**\n       * ```js\n       * let collection = NGN.BUS.funnel(['download1done', 'download2done', 'download3done'], 'make.results')\n       *\n       * let allData = []\n       *\n       * // When all of the downloads are done, log them.\n       * NGN.BUS.on('make.results', () => {\n       *   console.log(allData)\n       * })\n       *\n       * // Download the first set of data asynchronously\n       * NGN.NET.json('http:/download1.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download1done')\n       * })\n       *\n       * // Download the second set of data asynchronously\n       * NGN.NET.json('http:/download2.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download2done')\n       * })\n       *\n       * // Download the third set of data asynchronously\n       * NGN.NET.json('http:/download3.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download3done')\n       * })\n       *\n       * // The handler can be removed with the special method:\n       * collection.remove()\n       * ```\n       * @param {array} eventCollection\n       * An array of events. Once _all_ of these events have fired,\n       * the triggerEventName will be fired.\n       * @param {string|function} triggerEventName\n       * The name of the event triggered after the collection has completed.\n       * This can also be a callback function. If a callback function is provided,\n       * it will receive the payload as the only argument when it is triggered.\n       * @param {any} [payload]\n       * An optional payload delivered to the #triggerEventName.\n       * @returns {object} collection\n       * Provides the key/value configuration of the collection.\n       * ```js\n       * {\n       *   masterqueue: ['event1', 'event2', 'etc'], // The original event array (non-editable)\n       *   remainingqueue: [...], // The events the BUS is still waiting for before firing the trigger event.\n       *   eventName: 'triggeredEventName', // Name of the event triggered after the remaining elements are flushed.\n       *   payload: 'anything', // OPTIONAL\n       *   remove: [Function]\n       * }\n       * ```\n       */\n      funnel: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        if (NGN.typeof(eventCollection) !== 'array') {\n          throw new Error(`NGN.BUS.funnel expected an array of events, but received a(n) ${NGN.typeof(eventCollection)}`)\n        }\n\n        let collection = new Set(eventCollection)\n        let key = this.getInternalCollectionId(this.META.collectionQueue)\n\n        this.META.collectionQueue[key] = {}\n\n        Object.defineProperties(this.META.collectionQueue[key], {\n          masterqueue: NGN.const(new Set(eventCollection)),\n          remainingqueue: NGN.private(collection),\n          eventName: NGN.const(triggerEventName),\n          remove: NGN.const(() => {\n            this.META.collectionQueue[key].masterqueue.forEach(event => {\n              this.off(event, this.handleCollectionTrigger(event, key))\n            })\n\n            this.decreaseMaxListeners(this.META.collectionQueue[key].masterqueue.size)\n\n            delete this.META.collectionQueue[key]\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners(collection.size)\n\n        collection.forEach(event => {\n          this.on(event, this.handleCollectionTrigger(event, key))\n        })\n\n        return this.META.collectionQueue[key]\n      }),\n\n      /**\n       * @method funnelOnce\n       * This provides the same functionality as #funnel, but\n       * removes the listener after the resultant event has fired.\n       * See #funnel for detailed usage.\n       * @param {array} eventCollection\n       * An array of events. Once _all_ of these events have fired,\n       * the triggerEventName will be fired.\n       * @param {string} triggerEventName\n       * The name of the event triggered after the collection has completed.\n       * @param {any} [payload]\n       * An optional payload delivered to the #triggerEventName.\n       * @returns {object} collection\n       * Provides the key/value configuration of the collection.\n       */\n      funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\n        // let funnelClosureEvent = Symbol(triggerEventName)\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\n\n        this.increaseMaxListeners()\n        this.once(funnelClosureEvent, () => {\n          collection.remove()\n          collection = null\n          this.emit(triggerEventName, payload)\n        })\n      }),\n\n      /**\n       * @method threshold\n       * After an event is fired a predetermined number of times (the threshold),\n       * trigger another event or function.\n       *\n       * For example:\n       *\n       * ```js\n       * NGN.BUS.threshold('push.my.button', 3, 'annoyed')\n       *\n       * NGN.BUS.on('annoyed', function () {\n       *   console.log('We apologize for the slow response, but excessive clicking will not speed up the process.')\n       * })\n       *\n       * document.getElementById('#myButton').addEventListener('click', NGN.BUS.attach('push.my.button'))\n       * ```\n       *\n       * Once the threshold is exceeded, the final event will be triggered and\n       * the threshold will be reset. Using the example above, this means\n       * clicking 3 times on `#myButton` would trigger the `annoyed` event ONCE,\n       * 6 times triggers `annoyed` TWICE, 9 times triggers `annoyed` THREE times, etc.\n       * @param {string} thresholdEventName\n       * The name of the event to count.\n       * @param {number} limit\n       * The number of occurrances allowed until the final event is triggered.\n       * The event will be triggered at the threshold. For example, if the limit\n       * is `3`, the finalEvent will be triggered the 3rd time thresholdEventName is\n       * fired.\n       * @param {string|function} finalEventName\n       * This can be an event or callback function triggered when the threshold is crossed.\n       * If a callback function is specified, the payload is passed as the only argument.\n       * @param {any} [payload]\n       * An optional payload to send to the finalEvent handler(s).\n       * @returns {object}\n       * Returns an object that can be used to remove the threshold.\n       *\n       */\n      threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        if (typeof thresholdEventName !== 'string') {\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\n        }\n\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\n\n        this.META.thresholdQueue[key] = {}\n\n        Object.defineProperties(this.META.thresholdQueue[key], {\n          key: NGN.const(key),\n          eventName: NGN.const(thresholdEventName),\n          limit: NGN.const(limit),\n          count: NGN.private(0),\n          finalEventName: NGN.const(finalEventName),\n          remove: NGN.const(() => {\n            let event = this.META.thresholdQueue[key].eventName\n\n            delete this.META.thresholdQueue[key]\n\n            this.decreaseMaxListeners()\n            this.off(event, this.handleThresholdTrigger(key))\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners()\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\n\n        return this.META.thresholdQueue[key]\n      }),\n\n      thresholdOnce: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        let thresholdClosureEvent = `::NGNTHRESHOLD::${(new Date()).getTime()}::${finalEventName}`\n        let threshold = this.threshold(thresholdEventName, limit, thresholdClosureEvent, payload)\n        let me = this\n\n        this.once(thresholdClosureEvent, function () {\n          threshold.remove()\n          threshold = null\n\n          if (NGN.isFn(finalEventName)) {\n            finalEventName(payload)\n          } else {\n            me.emit(finalEventName, payload)\n          }\n        })\n      }),\n\n      /**\n       * @method handleThresholdTrigger\n       * A method to manage #threshold event handlers.\n       * @private\n       */\n      handleThresholdTrigger: NGN.const(function (key) {\n        let me = this\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            if (me.META.thresholdQueue.hasOwnProperty(key)) {\n              me.META.thresholdQueue[key].count++\n              if (me.META.thresholdQueue[key].count === me.META.thresholdQueue[key].limit) {\n                if (NGN.isFn(me.META.thresholdQueue[key].finalEventName)) {\n                  me.META.thresholdQueue[key].finalEventName(me.META.thresholdQueue[key].payload)\n                } else {\n                  me.emit(me.META.thresholdQueue[key].finalEventName, me.META.thresholdQueue[key].payload)\n                }\n\n                // This if statement is required in case the event is removed\n                // during the reset process.\n                if (me.META.thresholdQueue.hasOwnProperty(key)) {\n                  me.META.thresholdQueue[key].count = 0\n                }\n              }\n            }\n          }, 0)\n        }\n      }),\n\n      /**\n       * An internal method to wrap node-based event handlers\n       * with the proper scope.\n       * @param {string} eventName\n       * The name of the event being handled.\n       * @param {function} handlerFn\n       * The handler function.\n       */\n      wrapEventHandlerWithScope: NGN.privateconst((name, fn) => {\n        if (!NGN.nodelike) {\n          return fn\n        }\n\n        const handlerFn = fn\n\n        return function () {\n          let args = arguments\n\n          if (typeof args[args.length - 1] === 'symbol') {\n            name = args[args.length - 1].toString().replace(/Symbol\\(|\\)/gi, '')\n            args = NGN.slice(args)\n            args.pop()\n          }\n\n          handlerFn.apply({ event: name, trace: NGN.stack }, args)\n        }\n      }),\n\n      /**\n       * An internal method to apply scope based on whether the handler\n       * is a Node-like \"once\" emitter or not.\n       * @param {string} eventName\n       * The name of the event being scoped.\n       * @param {function} handlerFn\n       * The handler function.\n       */\n      applyScope: NGN.privateconst((args) => {\n        if (NGN.nodelike && args.length > 1) {\n          if (args[args.length - 1].listener) {\n            args[args.length - 1].listener = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1].listener\n            )\n          } else {\n            args[args.length - 1] = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1]\n            )\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Remove all event handlers from the EventEmitter (both regular and adhoc).\n   * This is a shortcut for #removeAllListeners.\n   */\n  clear () {\n    let events = NGN.slice(arguments)\n\n    if (events.length === 0) {\n      this.META.wildcardEvents.clear()\n\n      let symbolEvents = []\n\n      if (NGN.nodelike) {\n        symbolEvents = Object.getOwnPropertySymbols(this._events)\n      } else {\n        symbolEvents = Object.getOwnPropertySymbols(this.adhoc)\n        symbolEvents = symbolEvents.concat(Object.getOwnPropertySymbols(this.handlers))\n      }\n\n      for (let i = 0; i < symbolEvents.length; i++) {\n        this.removeAllListeners(symbolEvents[i])\n      }\n\n      return this.removeAllListeners()\n    }\n\n    for (let i = 0; i < events.length; i++) {\n      this.META.wildcardEvents.delete(events[i])\n      this.removeAllListeners(events[i])\n    }\n  }\n\n  /**\n   * Internal method used to handle TTL and wildcard management.\n   * @private\n   */\n  eventHandler (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(ttl) === 'boolean') {\n      prepend = ttl\n      ttl = this.META.defaultTTL\n    }\n\n    if (ttl === undefined) {\n      ttl = this.META.defaultTTL\n    }\n\n    if (ttl > 0) {\n      setTimeout(() => this.off(eventName, callback), ttl)\n    }\n\n    if (typeof eventName === 'string' && eventName.indexOf('*') >= 0) {\n      this.META.wildcardEvents.add(eventName)\n    }\n\n    return prepend\n  }\n\n  /**\n   * @method on\n   * Create a new event handler for the specified event.\n   * @param {string|string[]|object} eventName\n   * Name of the event to listen for.\n   * If an object is passed, this method will automatically setup a #pool.\n   * @param {function} handler\n   * The method responsible for responding to the event.\n   * This is ignored if eventName is an object.\n   * @param {number} [TTL]\n   * Time-To-Live is the number of milliseconds before the event handler\n   * is automatically removed. This is useful for automatically cleaning\n   * up limited-life event handlers.\n   * @param {boolean} [prepend=false]\n   * When set to `true`, the event is added to the beginning of\n   * the processing list instead of the end.\n   * This is ignored if eventName is an object.\n   */\n  on (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(eventName) === 'array') {\n      for (let i = 0; i < eventName.length; i++) {\n        this.on(eventName[i], callback, ttl, prepend)\n      }\n\n      return\n    }\n\n    if (this.eventHandler(...arguments)) {\n      this.prependListener(eventName, callback)\n    } else {\n      this.addListener(eventName, callback)\n    }\n  }\n\n  /**\n   * @method once\n   * Create a new event handler for the specified event. The\n   * handler will be removed immediately after it is executed. This\n   * effectively listens for an event to happen once and only once\n   * before the handler is destroyed.\n   * @param  {string} eventName\n   * Name of the event to listen for.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   * @param {boolean} [prepend=false]\n   * When set to `true`, the event is added to the beginning of\n   * the processing list instead of the end.\n   */\n  once (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(eventName) === 'array') {\n      for (let i = 0; i < eventName.length; i++) {\n        this.once(eventName[i], callback, ttl, prepend)\n      }\n\n      return\n    }\n\n    if (this.eventHandler(...arguments)) {\n      this.prependOnceListener(eventName, callback)\n    } else {\n      super.once(eventName, this.wrapEventHandlerWithScope(eventName, callback))\n    }\n  }\n\n  // The following methods override the Node event emitter only when necessary.\n  prependListener () {\n    this.applyScope(arguments)\n    super.prependListener(...arguments)\n  }\n\n  prependOnceListener () {\n    this.applyScope(arguments)\n    super.prependOnceListener(...arguments)\n  }\n\n  addListener () {\n    this.applyScope(arguments)\n    super.addListener(...arguments)\n  }\n\n  removeListener () {\n    if (arguments[arguments.length - 1] !== true) {\n      this.applyScope(arguments)\n    }\n\n    super.removeListener(...arguments)\n    this.emit('removeListener', ...arguments)\n  }\n\n  /**\n   * @method emit\n   * Emits an event.\n   * @param {string[]} eventName\n   * The event name can be a string or an array of strings. If an array\n   * of strings is specified, an event will be fired for each event name\n   * within the array.\n   * @param {any} [payload]\n   * An optional payload. This can be any number of additional arguments.\n   */\n  emit () {\n    if (NGN.typeof(arguments[0]) === 'array') {\n      let args = NGN.slice(arguments)\n      let eventNames = args.shift()\n\n      for (let i = 0; i < eventNames.length; i++) {\n        this.emit(eventNames[i], ...args)\n      }\n\n      return\n    }\n\n    // This catches non-string event names. NGN internally uses Symbols\n    // for the NGN.WARN/INFO/ERROR event names to prevent name collisions.\n    // This check provides support for these special events. These types\n    // of events will never have wildcards.\n    if (!NGN.nodelike || !arguments[0] || this.META.wildcardEvents.size === 0) {\n      super.emit(...arguments)\n      return\n    }\n\n    if (NGN.nodelike && typeof arguments[0] === 'symbol') {\n      super.emit(...arguments)\n      return\n    }\n\n    /**\n     * The NGN browser-based event emitter supports wildcards natively, but\n     * Node.js does not. This adds simple wildcard support for Node. The\n     * only wildcard character supported at this time is `*`. This feature\n     * will check the event name for the existance of a wildcard. If a\n     * wilcard character is present, the internally-maintained list of\n     * wildcard events is checked to see if it's a known event. If none\n     * of these checks pass, the standard event emitter is used, otherwise\n     * special wildcard handling is used.\n     */\n    let iterator = this.META.wildcardEvents.values()\n    let currentEvent = null\n    let args = NGN.slice(arguments)\n\n    args.shift()\n\n    while (currentEvent === null || !currentEvent.done) {\n      if (currentEvent !== null && currentEvent.value !== arguments[0]) {\n        let pattern = new RegExp(currentEvent.value.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\n\n        if (pattern.test(arguments[0])) {\n          super.emit(currentEvent.value, ...args, typeof arguments[0] !== 'symbol' ? Symbol(arguments[0]) : arguments[0])\n          break\n        }\n      }\n\n      currentEvent = iterator.next()\n    }\n\n    super.emit(...arguments)\n  }\n}\n","import EventEmitter from '../emitter/core'\n\n/**\n * @class NGN.Task\n * Represents a unit of work as a function. A task \"executes\"\n * when it's callback method is executed.\n * @fires start\n * Triggered when task execution begins. The task itself is provided\n * as an argument to the event handler.\n * @fires complete\n * Triggered when task execution finishes. The task itself is provided\n * as an argument to the event handler.\n * @fires skip\n * Triggered when task is skipped. The task itself is provided\n * as an argument to the event handler.\n * @fires timeout\n * Triggered when task execution time exceeds the specified timeout\n * limit. The task itself is provided as an argument to the event handler.\n */\nexport default class QueueItem extends EventEmitter {\n  constructor (config) {\n    config = config || {}\n\n    super(config)\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {string} name\n       * Descriptive name of the worker.\n       */\n      name: NGN.const(NGN.coalesce(config.name, 'Unknown')),\n\n      /**\n       * @cfg {function} callback\n       * The method to execute when the queue is ready.\n       */\n      callback: NGN.privateconst(config.callback),\n\n      /**\n       * @cfg {number} number\n       * The queue item number. This is used primarily as an ID.\n       */\n      number: NGN.const(parseInt(config.number, 10)),\n\n      timer: NGN.private(null),\n      _status: NGN.private(null),\n      bus: NGN.private(config.buz),\n      _skip: NGN.private(false)\n    })\n\n    this.on('timeout', () => {\n      this._status = 'timedout'\n    })\n\n    this.on('skip', () => {\n      this._status = 'skipped'\n    })\n  }\n\n  /**\n   * @property {string} status\n   * May be `running`, `complete`, or `null` (not run yet)\n   */\n  get status () {\n    return this._status\n  }\n\n  /**\n   * @property {boolean} skipped\n   * `true` to skip the step, `false` to execute it.\n   */\n  get skipped () {\n    return this._skip\n  }\n\n  /**\n   * @method run\n   * Execute the callback function.\n   * @param {string} mode\n   * `dev` or `prod`. When in \"dev\" mode, verbose output is written\n   * to the console.\n   */\n  run (mode) {\n    if (this.skipped) {\n      this.emit('skip', this)\n\n      if (mode && mode === 'dev') {\n        NGN.WARN('SKIPPED ' + this.name)\n      }\n\n      return\n    }\n\n    this.emit('start', this)\n\n    if (mode && mode === 'dev') {\n      NGN.INFO('Executing ' + this.name + ':')\n    }\n\n    this._status = 'running'\n\n    const me = this\n    const scope = {\n      name: this.name,\n      number: this.number,\n      timeout: function (milliseconds) {\n        me.timer = setTimeout(function () {\n          me.emit('timeout', me)\n        }, milliseconds)\n      }\n    }\n\n    this.callback.apply(scope, [function () {\n      me._status = 'complete'\n      me.emit('complete', me)\n    }])\n\n    if (this.callback.length === 0) {\n      me._status = 'complete'\n      me.emit('complete', me)\n    }\n  }\n\n  /**\n   * @method skip\n   * Skip this item\n   */\n  skip () {\n    if (this._status === 'running') {\n      NGN.WARN(`Cannot skip step: ${this.name} is currently running.`)\n    } else if (this._status === 'timedout') {\n      NGN.WARN(`Cannot skip step: ${this.name} timed out.`)\n    } else if (this._status === 'complete') {\n      NGN.WARN(`Cannot skip step: ${this.name} already completed.`)\n    }\n\n    this._skip = true\n  }\n}\n","import EventEmitter from '../emitter/core'\n\n/**\n * @class NGN.Queue\n * A job runner/collection capable of parallel and sequential task processing.\n * @fires complete\n * Triggered when the entire collection of tasks has completed\n * processing/running.\n * @fires aborted\n * Triggered when processing is aborted before completion.\n * @fires aborting\n * Triggered when the abort sequence begins.\n * @fires timeout\n * Triggered when processing times out.\n * @fires taskstart\n * Triggered whenever a new task is started. The NGN.Task is\n * the only argument delivered to event handlers.\n * @fires taskcomplete\n * Triggered whenever a task completes processing. The NGN.Task is\n * the only argument delivered to event handlers.\n * @fires taskcreate\n * Triggered when a new NGN.Task is added to the queue. The NGN.Task is\n * the only argument delivered to event handlers.\n * @fires taskremove\n * Triggered when a NGN.Task is removed from the queue. The NGN.Task is\n * the only argument delivered to event handlers.\n * @fires tasktimeout\n * Triggered when an NGN.Task times out during processing. The NGN.Task is\n * the only argument delivered to event handlers.\n */\nexport default class Queue extends EventEmitter {\n  /**\n   * @constructor\n   * @param {string} [mode=production]\n   * Set this to `dev` for verbose console output.\n   */\n  constructor (mode = 'production') {\n    super()\n\n    Object.defineProperties(this, {\n      steps: NGN.private([]),\n      completed: NGN.private(0),\n      timeout: NGN.private(null),\n      _mode: NGN.private(mode),\n      _cancel: NGN.private(false),\n      processing: NGN.private(false),\n      timer: NGN.private(null),\n      sequential: NGN.private(false)\n    })\n\n    this.on('taskcomplete', (step) => {\n      // Disallow duplicates\n      if (this.sequential || step.status === 'completed') {\n        return\n      }\n\n      step._status = 'complete'\n\n      // When the step is done, tally it\n      this.completed++\n\n      if (this.mode === 'dev') {\n        NGN.INFO(step.name + ' completed.')\n      }\n\n      // If all of the queries have been tallied, we're done.\n      if (this.completed === this.steps.length) {\n        this.processing = false\n\n        Object.keys(this.steps).forEach((step) => {\n          clearTimeout(this.steps[step].timer)\n        })\n\n        this.emit('complete')\n      }\n    })\n\n    this.on('aborting', () => {\n      this._cancel = true\n    })\n  }\n\n  /**\n   * @property {Array} list\n   * A list of tasks within the collection. This is an array of\n   * objects, where each object contains the `id`, `name`, and\n   * `status` of the task.\n   *\n   * ```js\n   * {\n   *   id: <Number>,\n   *   name: <String>,\n   *   status: <String>\n   * }\n   * ```\n   */\n  get list () {\n    return this.steps.map(function (s) {\n      return {\n        id: s.number,\n        name: s.name,\n        status: s.status\n      }\n    })\n  }\n\n  /**\n   * @property {string} mode\n   * The type of processing (dev, production, etc). Setting this to\n   * `dev` enables verbose logging.\n   */\n  get mode () {\n    return this._mode\n  }\n\n  set mode (value) {\n    if (value.toLowerCase().substr(0, 3) === 'dev') {\n      this._mode = 'dev'\n    } else {\n      this._mode = 'production'\n    }\n  }\n\n  get cancelled () {\n    return this._cancel\n  }\n\n  onTimeout () {\n    let log = []\n\n    if (this.steps.length > 0) {\n      this.steps.forEach((s) => {\n        log.push(s.name, s.status === null ? 'NOT STARTED' : s.status)\n      })\n    }\n\n    this.emit('timeout', {\n      process: log\n    })\n\n    log = null\n  }\n\n  /**\n   * @method add\n   * Add a task to the list.\n   * @param {string} [name]\n   * A descriptive name for the queued process/task.\n   * @param {function} callback\n   * The function to queue.\n   * @param {function} callback.next\n   * This argument allows users to explicitly use asynchronous\n   * methods. Example:\n   *\n   * ```\n   * let tasks = new NGN.Tasks()\n   *\n   * tasks.add('Descriptive Title', function (next) {\n   *   myAsyncMethod(function () {\n   *     console.log('Ran something async.')\n   *     next()\n   *   })\n   * })\n   * @returns {NGN.Task}\n   * Returns the task object added to the queue.\n   */\n  add (name, fn) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    if (typeof name === 'function') {\n      fn = name\n      name = 'Step ' + (parseInt(this.steps.length) + 1)\n    }\n\n    if (typeof fn !== 'function') {\n      throw new Error('No processing method defined for step ' + (parseInt(this.steps.length) + 1) + '.')\n    }\n\n    const queue = new NGN.Task({\n      name: name,\n      callback: fn,\n      number: (this.steps.length > 0 ? this.steps[this.steps.length - 1].number : 0) + 1\n    })\n\n    queue.on('complete', (step) => this.emit('taskcomplete', step))\n\n    queue.on('timeout', (step) => {\n      if (step.status === 'running' || step.status === 'timedout') {\n        this.emit('tasktimeout', step)\n      }\n    })\n\n    this.steps.push(queue)\n    this.emit('taskcreate', queue)\n\n    return queue\n  }\n\n  /**\n   * @method getAt\n   * @param  {number} index\n   * Retrieve a queue item by it's index/queue number.\n   * @return {Queue}\n   */\n  getAt (index) {\n    return this.steps[index]\n  }\n\n  /**\n   * @method get\n   * Retrieve a specific queue item.\n   * @param  {string} requestedStepTitle\n   * The descriptie name of the queue item to retrieve.\n   * @return {Queue}\n   */\n  get (requestedStep) {\n    // Get by Name\n    let element = this.steps.filter((step) => {\n      return step.name === requestedStep\n    })\n\n    if (element.length === 1) {\n      return element[0]\n    }\n\n    // Get by index\n    element = this.steps.filter((step) => {\n      return step.number === requestedStep\n    })\n\n    if (element.length === 1) {\n      return element[0]\n    }\n  }\n\n  /**\n   * @method remove\n   * Remove a queue item by name or number.\n   * @param  {string} requestedStepTitle\n   * The descriptive name of the queue item to retrieve.\n   * @return {Queue}\n   * Returns the item that was removed.\n   */\n  remove (requestedStep) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    // Remove by name\n    let element = this.steps.filter((step) => {\n      return step.name === requestedStep\n    })\n\n    if (element.length === 1) {\n      this.steps = this.steps.filter((step) => {\n        return step.name !== requestedStep\n      })\n\n      this.emit('taskremove', element[0])\n      return element[0]\n    }\n\n    // Remove by ID\n    element = this.steps.filter((step) => {\n      return step.number === requestedStep\n    })\n\n    if (element.length === 1) {\n      this.steps = this.steps.filter((step) => {\n        return step.number !== requestedStep\n      })\n\n      this.emit('taskremove', element[0])\n      return element[0]\n    }\n  }\n\n  /**\n   * @method removeAt\n   * Removes a queue item from the specific index.\n   * @param  {number} requestedStepIndex\n   * The queue index/number.\n   * @return {Queue}\n   * Returns the item that was removed.\n   */\n  removeAt (requestedStep) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    // Remove by index\n    if (typeof requestedStep !== 'number') {\n      return console.error('Failed to remove step: ' + requestedStep)\n    }\n\n    if (requestedStep < 0 || requestedStep >= this.steps.length) {\n      return console.error('Step index ' + requestedStep + ' could not be found or does not exist.')\n    }\n\n    return this.steps.splice(requestedStep, 1)[0]\n  }\n\n  /**\n   * @method reset\n   * Resets all cancelled/skipped steps, essentially resetting the queue\n   * to it's pre-aborted state.\n   */\n  reset () {\n    if (this.processing) {\n      return NGN.WARN('Cannot reset a running queue. Abort or wait for the process to complete before resetting.')\n    }\n\n    // Refresh cancelled steps\n    this.steps.forEach((step) => {\n      step._skip = false\n    })\n  }\n\n  /**\n   * @method process\n   * Run the queued processes in order.\n   * @param {boolean} [sequential=false]\n   * Set to `true` to run the queue items in a synchronous-like manner.\n   * This will execute each method one after the other. Each method must\n   * complete before the next is started.\n   */\n  process (sequential = false) {\n    if (this.processing) {\n      return NGN.WARN('Cannot start processing (already running). Please wait for this process to complete before calling process() again.')\n    }\n\n    if (this.steps.length === 0) {\n      return this.emit('complete')\n    }\n\n    this.processing = true\n    this._cancel = false\n\n    if (this.timeout !== null) {\n      this.timer = setTimeout(() => this.onTimeout(), this.timeout)\n    }\n\n    this.sequential = typeof sequential === 'boolean' ? sequential : false\n    if (!this.sequential) {\n      for (let i = 0; i < this.steps.length; i++) {\n        this.steps[i].run(this.mode)\n      }\n    } else {\n      let queue = this.steps\n      let listener = new NGN.EventEmitter()\n\n      listener.on('taskcomplete', () => {\n        if (queue.length > 0) {\n          const currentTask = queue.shift()\n\n          if (currentTask.skipped) {\n            return listener.emit('taskcomplete')\n          }\n\n          currentTask.on('complete', () => listener.emit('taskcomplete'))\n          currentTask.on('start', () => this.emit('taskstart', currentTask))\n\n          currentTask.run(this.mode)\n        } else {\n          this.emit('complete')\n        }\n      })\n\n      let currentStep = queue.shift()\n\n      currentStep.on('complete', () => listener.emit('taskcomplete'))\n      currentStep.on('start', () => this.emit('taskstart', currentStep))\n\n      currentStep.run(this.mode)\n    }\n  }\n\n  // Alias for process\n  run () {\n    this.process(...arguments)\n  }\n\n  /**\n   * @method abort\n   * Abort/cancel processing. This prevents further steps from processing.\n   */\n  abort () {\n    this.emit('aborting')\n\n    // Make sure the steps are skipped.\n    this.each((step) => {\n      if (['completed', 'running', 'timedout'].indexOf(step.status) < 0 && !step.skipped) {\n        step.skip()\n      }\n    })\n\n    this.once('complete', () => this.emit('aborted'))\n  }\n\n  /**\n   * @method each\n   * Apply a method to each step.\n   * @param {function} method\n   * @private\n   */\n  each (fn) {\n    for (let i = 0; i < this.steps.length; i++) {\n      fn(this.steps[i])\n    }\n  }\n\n  // Alias for abort\n  cancel () {\n    this.abort(...arguments)\n  }\n}\n","/**\n * @class NGN.UTILITY.Lexer\n * This class performs scans static text for tokens, based on a grammar.\n * It is designed to work with NGN.UTILITY.Tokenizer to convert text into\n * a sequence of tokens (strings with an identified \"meaning\").\n *\n * This class was inspired by https://github.com/aaditmshah/lexer (MIT).\n *\n * ```js\n * let lexer = new NGN.UTILITY.Lexer('hello\\nworld\\nand moon')\n *\n * lexer.addRule(/hello/i, function (str) {\n *   return 'hi' // \"hi\" is the name of the token\n * })\n *\n * lexer.addRule(/world/i, function (str) {\n *   return 'planet'\n * })\n *\n * // Create an error if a rule passes. In this case, prevent the word \"moon\".\n * lexer.addRule(/moon/i, function (str) {\n *   this.error()\n * })\n *\n * console.log(lexer.next())\n *\n * // OUTPUT\n * // {\n * //   line: 1,\n * //   column: 1,\n * //   index: 0,\n * //   token: 'hi',\n * //   length: 5,\n * //   input: 'hello'\n * // }\n *\n * lexer.next() // Returns the next token\n * ```\n *\n * The lexer contains two built-in rules to determine the beginning of\n * file/content (token `BOF`) and the end of file content (token `EOF`).\n */\nexport default class NGNLexer { // eslint-disable-line no-unused-vars\n  /**\n   * Create a new lexer instance.\n   * @param  {String} [input='']\n   * Initialize with text input.\n   */\n  constructor (statement = '') {\n    Object.defineProperties(this, {\n      tokens: NGN.private([]),\n      rules: NGN.private([]),\n      remove: NGN.private(0),\n      state: NGN.private(0),\n      index: NGN.private(0),\n      statement: NGN.private(statement),\n      reject: NGN.private(false),\n      lastLineIndex: NGN.private(0),\n      currentLength: NGN.private(0),\n      currentMatch: NGN.private(null),\n      row: NGN.private(1),\n      unrecognizedCharacters: NGN.private(false)\n    })\n\n    // Identify beginning of file/statement\n    this.addRule(/^/, function () {\n      return 'BOF'\n    })\n\n    // Identify end of file/statement\n    this.addRule(/$/, function () {\n      return 'EOF'\n    })\n\n    if (statement && statement.length > 0) {\n      this.input = statement\n    }\n  }\n\n  /**\n   * @property {String} value\n   * The input text to analyze. Changing this automatically resets the lexer.\n   */\n  set input (value) {\n    this.remove = 0\n    this.state = 0\n    this.index = 0\n    this.currentMatch = null\n    this.tokens = []\n    this.row = 1\n    this.statement = value\n  }\n\n  get input () {\n    return this.statement\n  }\n\n  /**\n   * @property {number} lines\n   * The number of lines in the input text.\n   */\n  get lines () {\n    return this.statement.split('\\n').length\n  }\n\n  /**\n   * @property {boolean} unrecognized\n   * Set this to `true` within a rule if a value is unrecognized.\n   * The more common approach is to use the #error method, which\n   * sets this to `true` when a rule should produce an error.\n   */\n  get unrecognized () {\n    return this.unrecognizedCharacters\n  }\n\n  set unrecognized (value) {\n    // TODO: NGN.forceBoolean\n    this.reject = true\n    this.unrecognizedCharacters = NGN.forceBoolean(value)\n  }\n\n  /**\n   * @property {number} currentLine\n   * Retrieves the current line wherever the lexer left off (i.e. last\n   * recognized token).\n   */\n  get currentLine () {\n    return this.row\n  }\n\n  /**\n   * @property {number} currentColumn\n   * Retrieves the current column wherever the lexer left off (i.e. last\n   * recognized token).\n   */\n  get currentColumn () {\n    let col = (this.index - this.lastLineIndex) - this.currentLength\n\n    return col === 0 ? 1 : col\n  }\n\n  /**\n   * Called within a rule to force an error. This is most commonly used\n   * when a block of text contains a value it shouldn't.\n   * @param  {String} [message]\n   * An optional message prefixed to the error message.\n   */\n  error (message) {\n    if (message) {\n      let col = (this.index - this.lastLineIndex) - 1\n\n      throw new Error(`${message} at line ${this.currentLine}, column ${col < 1 ? 1 : col}.`)\n    }\n\n    this.unrecognized = true\n  }\n\n  /**\n   * Add a rule for detecting a token.\n   * @param {RegExp} pattern\n   * The pattern is applied to the text to determine whether the action should\n   * be triggered or not.\n   * @param {Function|String} action\n   * The action method is executed when a pattern match is detected. If the\n   * action is a function, it must return the name of the token. Functions\n   * receive a single argument, which is the text that matched the rule.\n   *\n   * If a string is provided as the action, that string will be returned as\n   * the token value whenever a pattern match occurs. This is a convenient\n   * way to avoid repetitively writing the following type of token handler:\n   *\n   * ```js\n   * function () {\n   *   return 'token'\n   * }\n   * ```\n   * @param {Array} [start=[0]]\n   * An optional array of unsigned integers acting as\n   * [start conditions](http://flex.sourceforge.net/manual/Start-Conditions.html).\n   * By default all rules are active in the initial state (i.e. `0`).\n   */\n  addRule (pattern, action, start = [0]) {\n    if (!pattern.global) {\n      let flags = 'g'\n\n      if (pattern.multiline) {\n        flags += 'm'\n      }\n\n      if (pattern.ignoreCase) {\n        flags += 'i'\n      }\n\n      pattern = new RegExp(pattern.source, flags)\n    }\n\n    let actionFn\n    if (typeof action === 'string') {\n      actionFn = function () {\n        return action\n      }\n    } else {\n      actionFn = action\n    }\n\n    if (!NGN.isFn(actionFn)) {\n      throw new Error(`INVALID LEXER ATTRIBUTES: ${pattern.toString()} rule is missing a valid handler function (action) or token name.`)\n    }\n\n    let actionString = actionFn.toString()\n\n    if (actionString.indexOf('this.error(') >= 0 && /^\\(.*\\)\\s{0,10}=>\\s{0,10}\\{/.test(actionString)) {\n      throw new Error('Cannot use a non-lexical expression (arrow function) as a lexer rule.')\n    }\n\n    this.rules.push({\n      pattern,\n      global: pattern.global,\n      action: actionFn,\n      start\n    })\n  }\n\n  /**\n   * An iterator method.\n   * @return {Object}\n   * Returns the next recognized token as a detailed object:\n   *\n   * ```js\n   * {\n   *   line: 1,\n   *   column: 1,\n   *   index: 0,\n   *   token: 'token name',\n   *   length: 5,\n   *   input: 'original input string'\n   * }\n   */\n  next () {\n    if (this.tokens.length) {\n      return this.tokens.shift()\n    }\n\n    this.reject = true\n\n    while (this.index <= this.statement.length) {\n      // Count any new line & reset column\n      if (/\\n/i.test(this.statement.charAt(this.index))) {\n        this.row++\n        this.lastLineIndex = this.index\n      }\n\n      let matches = this.scan().splice(this.remove)\n      let index = this.index\n\n      while (matches.length) {\n        if (this.reject) {\n          let match = matches.shift()\n          let result = match.result\n          let length = match.length\n\n          this.index += length\n          this.currentLength = length\n          this.reject = false\n          this.remove++\n          let token = match.action.apply(this, result)\n\n          if (this.reject) {\n            this.index = result.index\n          } else if (token !== undefined) {\n            switch (NGN.typeof(token)) {\n              case 'array':\n                this.tokens = token.slice(1)\n                token = token[0]\n\n              default: // eslint-disable-line no-fallthrough\n                if (length) {\n                  this.remove = 0\n                }\n\n                return token\n            }\n          }\n        } else {\n          break\n        }\n      }\n\n      let input = this.statement\n\n      if (index < input.length) {\n        if (this.reject) {\n          this.remove = 0\n\n          let token = this.unexpected(input.substr(this.index++, this.index + input.length))\n\n          if (token !== undefined) {\n            if (NGN.typeof(token) === 'array') {\n              this.tokens = token.slice(1)\n              return token[0]\n            } else {\n              return token\n            }\n          }\n        } else {\n          if (this.index !== index) {\n            this.remove = 0\n          }\n\n          this.reject = true\n        }\n      } else if (matches.length) {\n        this.reject = true\n      } else {\n        break\n      }\n    }\n  }\n\n  /**\n   * Scan the text and apply rules.\n   * @private\n   */\n  scan () {\n    let matches = []\n    let index = 0\n    let state = this.state\n    let lastIndex = this.index\n    let input = this.statement\n\n    for (let i = 0, length = this.rules.length; i < length; i++) {\n      let rule = this.rules[i]\n      let start = rule.start\n      let states = start.length\n\n      if (\n        (!states || start.indexOf(state) >= 0) ||\n          (state % 2 && states === 1 && !start[0])\n      ) {\n        let pattern = rule.pattern\n        pattern.lastIndex = lastIndex\n        let result = pattern.exec(input)\n\n        if (result && result.index === lastIndex) {\n          let j = matches.push({\n            result,\n            action: rule.action,\n            length: result[0].length\n          })\n\n          if (rule.global) {\n            index = j\n          }\n\n          while (--j > index) {\n            let k = j - 1\n\n            if (matches[j].length > matches[k].length) {\n              let temple = matches[j]\n              matches[j] = matches[k]\n              matches[k] = temple\n            }\n          }\n        }\n      }\n    }\n\n    return matches\n  }\n\n  /**\n   * Handles unexpected character sequences.\n   * This may throw an error if the characters are unrecognized.\n   * @param  {String} characters\n   * The characters which triggered the unexpected flag.\n   * @private\n   */\n  unexpected (str) {\n    if (this.unrecognizedCharacters) {\n      let col = (this.index - this.lastLineIndex) - 1\n\n      throw new Error(`Unexpected syntax at line ${this.currentLine}, column ${col < 1 ? 1 : col}\\nat ${str}\\n   ^`)\n    }\n  }\n}\n","/**\n * @class NGN.UTILITY.Tokenizer\n * Given a grammar, a tokenizer will perform lexical analysis of text.\n * In simple terms, it will extract tokens from text. This is accomplished\n * by applying rules with a NGN.UTILITY.Lexer and capturing responses.\n *\n * The NGN.DATA.JQL class is an implementation of a tokenizer. It extracts\n * tokens from JQL queries, splitting them into tokens that can be used in\n * programs.\n */\nexport default class NGNTokenizer { // eslint-disable-line no-unused-vars\n  /**\n   * Create a new tokenizer. This will return an instance of itself,\n   * allowing for methods to be chained like `(new Tokenizker([...])).parse('...')`.\n   * @param  {Array}  [grammar=[]]\n   * A grammar is a collection of rules that are passed to\n   * NGN.UTILITY.Lexer#addRule.\n   *\n   * The following example provides a subset of the NGN.DATA.JQL grammar.\n   *\n   * ```js\n   * new Tokenizer([\n   *   // Disallow irrelevant keywords (SQL)\n   *   [\n   *     /FROM/i,\n   *     function () {\n   *       this.error('FROM is not a valid JQL query descriptor. Found')\n   *     }\n   *   ],\n   *\n   *   // Skip whitespace\n   *   [/\\s+/, function () {}],\n   *\n   *   // Common tokens\n   *   [/SELECT\\s{1,1000}/i, 'SELECT'],\n   *   [/DISTINCT\\s{1,1000}/i, 'DISTINCT'],\n   *   [/WHERE\\s{1,1000}/i, 'WHERE'],\n   *   [/ORDER BY\\s{1,1000}/i, 'ORDERBY']\n   * ])\n   * ```\n   */\n  constructor (grammar = []) {\n    if (grammar.length === 0) {\n      throw new Error('No grammaer rules specified.')\n    }\n\n    Object.defineProperties(this, {\n      statement: NGN.private(null),\n      rules: NGN.privateconst(grammar),\n\n      PROTECTED: NGN.privateconst({\n        lexer: new NGN.UTILITY.Lexer(),\n        activeText: null,\n        orderedList: new Set()\n      })\n    })\n\n    // Add rules\n    for (let i = 0; i < this.rules.length; i++) {\n      this.PROTECTED.lexer.addRule(this.rules[i][0], this.rules[i][1])\n    }\n\n    return this\n  }\n\n  /**\n   * @property {string} text\n   * The text being \"tokenized\".\n   */\n  get text () {\n    return this.PROTECTED.activeText\n  }\n\n  /**\n   * @property {Array} orderedTokenList\n   * An ordered list of tokens as they appear within the text.\n   *\n   * **Example Result:**\n   *\n   * ```js\n   * [{\n   *   column: 1,\n   *   index: 0,\n   *   input: 'original string',\n   *   length: 15,\n   *   line: 4,\n   *   token: 'mytoken'\n   * }, {\n   *   ...\n   * }]\n   * ```\n   */\n  get orderedTokenList () {\n    return Array.from(this.PROTECTED.orderedList).map(item => item.detail)\n  }\n\n  /**\n   * Parses text to generate a token list.\n   * @param  {string} text\n   * The text to parse.\n   * @param  {Boolean} [suppressXOF=true]\n   * By default, `BOF` (Beginning of File) and `EOF` (End of File) tokens are\n   * suppressed. Set this to `false` to enable them.\n   * @return {Array}\n   * Returns an array of tokens.\n   *\n   * **Example Result:**\n   *\n   * ```js\n   * [{\n   *   column: 1,\n   *   index: 0,\n   *   input: 'original string',\n   *   length: 15,\n   *   line: 4,\n   *   token: 'mytoken'\n   * }, {\n   *   ...\n   * }]\n   * ```\n   */\n  parse (text, ignoreXOF = true) {\n    if (!NGN.coalesce(text) || typeof text !== 'string') {\n      throw new Error('Cannot parse empty string or non-string.')\n    }\n\n    this.PROTECTED.activeText = text\n\n    let tokens = {}\n    let token\n\n    this.PROTECTED.lexer.input = text\n    this.PROTECTED.orderedList.clear()\n\n    while (token = this.PROTECTED.lexer.next()) { // eslint-disable-line no-cond-assign\n      if (!ignoreXOF || (token !== 'BOF' && token !== 'EOF')) {\n        tokens[token] = NGN.coalesce(tokens[token], [])\n\n        tokens[token].push({\n          line: this.PROTECTED.lexer.currentLine,\n          column: this.PROTECTED.lexer.currentColumn,\n          length: this.PROTECTED.lexer.currentLength,\n          index: this.PROTECTED.lexer.index - this.PROTECTED.lexer.currentLength,\n          input: this.PROTECTED.lexer.statement.substr(this.PROTECTED.lexer.index - this.PROTECTED.lexer.currentLength, this.PROTECTED.lexer.currentLength)\n        })\n\n        const index = tokens[token].length - 1\n\n        this.PROTECTED.orderedList.add({\n          index: index,\n          token: token,\n          get detail () {\n            return Object.assign(tokens[this.token][this.index], {token: this.token})\n          }\n        })\n      }\n    }\n\n    return tokens\n  }\n}\n","/**\n * @class NGN.UTILITY.Set\n * Provides advanced features for [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\n * objects.\n */\nexport default class NGNSet { // eslint-disable-line\n  /**\n   * Indicates the subset is wholly contained within the main set.\n   * @param  {Set}  mainset\n   * @param  {Set}  subset\n   * @return {Boolean}\n   */\n  static isSuperSet (mainset, subset) {\n    if (subset.size > mainset.size || subset.size === 0) {\n      return false\n    }\n\n    let elements = mainset.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      if (!mainset.has(element.value)) {\n        return false\n      }\n\n      element = elements.next()\n    }\n\n    return true\n  }\n\n  /**\n   * Join any number of sets together into a single aggregate set.\n   * Only unique values will be added.\n   * Accepts any number of Set arguments.\n   * @return {Set}\n   */\n  static concat () {\n    let aggregate = new Set(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      let elements = arguments[i].values()\n      let element = elements.next()\n\n      while (!element.done) {\n        aggregate.add(element.value)\n        element = elements.next()\n      }\n    }\n\n    return aggregate\n  }\n\n  /**\n   * Identify the intersection/overlap between two sets.\n   * @param  {Set} setA\n   * @param  {Set} setB\n   * @return {Set}\n   * Returns a Set containing the common elements of setA and setB.\n   */\n  static intersection (setA, setB) {\n    let intersection = new Set()\n    let a = setA.size < setB.size ? setA : setB\n    let b = setA.size < setB.size ? setB : setA\n    let elements = a.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      if (b.has(element.value)) {\n        intersection.add(element.value)\n      }\n\n      element = elements.next()\n    }\n\n    return intersection\n  }\n\n  /**\n   * Identify the elements that are NOT part of both sets.\n   * @param  {Set} setA\n   * @param  {Set} setB\n   * @return {Set}\n   * Returns a set containing elements that are NOT common between setA and setB.\n   */\n  static difference (setA, setB) {\n    let diff = new Set(setA)\n    let elements = setB.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      diff.delete(element.value)\n      element = elements.next()\n    }\n\n    return diff\n  }\n\n  /**\n   * Determines whether two sets contain the same values.\n   * @param  {Set} setA\n   * @param  {Set} setB\n   * @return {Boolean}\n   */\n  static equal (setA, setB) {\n    return NGN.UTILITY.Set.difference(setA, setB).size === 0\n  }\n\n  static equals () {\n    NGN.WARN('NGN.UTILITY.Set.equals() should be equal() (no s at the end).')\n    NGN.UTILITY.Set.equal(...arguments)\n  }\n\n  /**\n   * A convenience method for appending the Set prototype with all\n   * of the methods in this utility, where the first argument of\n   * each method automatically refers to the Set.\n   * @private\n   */\n  static applyAll () {\n    Set.prototype.isSuperSet = function (subset) { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.isSuperSet(this, subset)\n    }\n\n    Set.prototype.concat = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.concat(this, ...arguments)\n    }\n\n    Set.prototype.intersection = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.intersection(this, ...arguments)\n    }\n\n    Set.prototype.difference = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.difference(this, ...arguments)\n    }\n\n    Set.prototype.equals = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.equal(this, ...arguments)\n    }\n  }\n}\n","/**\n * @class NGN.NET.Utility\n * A utility library for network communications.\n * @private\n */\nclass NetworkUtilities {\n  constructor () {\n    Object.defineProperties(this, {\n      hostname: NGN.private(null),\n      networkInterfaces: NGN.private([]),\n      UrlPattern: NGN.const(/^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/), // eslint-disable-line no-useless-escape\n      HttpMethods: NGN.const([ // eslint-disable-line no-unused-vars\n        'OPTIONS',\n        'HEAD',\n        'GET',\n        'POST',\n        'PUT',\n        'DELETE',\n        'TRACE',\n        'CONNECT'\n      ])\n    })\n\n    /* node-only */\n    this.hostname = require('os').hostname() // eslint-disable-line comma-style\n    /* end-node-only */\n    /* browser-only */\n    this.hostname = window.location.host // eslint-disable-line comma-style\n    /* end-browser-only */\n\n    this.networkInterfaces = [\n      '127.0.0.1'\n      , 'localhost' // eslint-disable-line comma-style\n      /* node-only */\n      , require('os').hostname() // eslint-disable-line comma-style\n      /* end-node-only */\n      /* browser-only */\n      , window.location.host // eslint-disable-line comma-style\n      /* end-browser-only */\n    ]\n\n    /* node-only */\n    // Retreive local IP's and hostnames\n    let data = require('os').networkInterfaces()\n    let interfaces = Object.keys(data)\n\n    for (let i = 0; i < interfaces.length; i++) {\n      let iface = data[interfaces[i]]\n\n      for (let x = 0; x < iface.length; x++) {\n        if (iface[x].family === 'IPv4') {\n          this.networkInterfaces.push(iface[x].address)\n        }\n      }\n    }\n    /* end-node-only */\n\n    this.networkInterfaces = NGN.dedupe(this.networkInterfaces)\n  }\n\n  /**\n   * @method normalizeUrl\n   * Normalize a URL by removing extraneous characters,\n   * applying protocol, and resolving relative links.\n   * @param {string} URI\n   * The URI to normalize.\n   * @return {string}\n   * The normalized URL.\n   */\n  normalizeUrl (url) {\n    let uri = []\n\n    if (/^(\\.|\\/|\\\\).+/.test(url)) {\n      /* node-only */\n      url = `http://${this.hostname}/${url}`\n      /* end-node-only */\n      /* browser-only */\n      let path = window.location.pathname.split('/')\n      path.pop()\n\n      url = `${window.location.origin}/${path.join('/')}/${url}`\n      /* end-browser-only */\n    }\n\n    let protocol = /^(.*):\\/.*/.exec(url)\n\n    if (!protocol) {\n      protocol = ''\n    }\n\n    protocol = protocol.length > 0 ? protocol[1] : null\n\n    if (protocol) {\n      url = url.replace(new RegExp(`${protocol}\\\\:\\\\/+`, 'i'), '')\n    }\n\n    url = url.split('/')\n\n    for (let i = 0; i < url.length; i++) {\n      if (url[i] === '..') {\n        uri.pop()\n      } else if (url[i] !== '.' && url[i].trim().length > 0) {\n        uri.push(url[i])\n      }\n    }\n\n    uri = uri.join('/').replace(/:\\/{3,50}/gi, '://')\n\n    // Handle query parameter normalization\n    let match = /(.*:\\/\\/.*)[?](.*)/.exec(uri)\n    let path = match === null ? uri : match[1]\n    let queryString = match !== null ? match[2] : ''\n\n    uri = path\n\n    if (queryString.trim().length > 0) {\n      let params = {}\n\n      queryString.split('&').forEach(attr => {\n        let keypair = attr.split('=')\n        params[keypair[0]] = keypair.length > 1 ? keypair[1] : null\n      })\n\n      queryString = []\n      Object.keys(params).forEach((param, i) => {\n        queryString.push(`${param}${params[param] !== null ? '=' + encodeURIComponent(params[param]) : ''}`)\n      })\n\n      uri = `${uri}?${queryString.join('&')}`\n    }\n\n    return protocol ? `${protocol}://${uri}` : uri\n  }\n\n  /**\n   * @method parseUri\n   * Parses the URI into composable parts.\n   * @param {string} URL\n   * The URI/URL to parse.\n   * @return {Object}\n   * Returns a key/value object:\n   *\n   * ```js\n   * {\n   *   protocol: 'http',\n   *   hostname: 'domain.com',\n   *   path: '/path/to/file.html',\n   *   query: 'a=1&b=2',\n   *   hash: null\n   * }\n   * ```\n   * @private\n   */\n  parseUri (uri) {\n    // URL Pattern Regex\n    let part = uri.match(/^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/) // eslint-disable-line no-useless-escape\n    let protocol\n    /* node-only */\n    protocol = 'http'\n    /* end-node-only */\n    /* browser-only */\n    protocol = window.location.protocol.replace(':', '').toLowerCase()\n    /* end-browser-only */\n    let url = {\n      uri,\n      protocol: NGN.coalesce(part[2], protocol),\n      hostname: NGN.coalesce(part[4], hostname),\n      path: NGN.coalesceb(part[5], '/'),\n      query: NGN.coalesceb(part[7]),\n      hash: NGN.coalesceb(part[9])\n    }\n\n    // URL contains a username/password.\n    if (url.hostname.indexOf('@') > 0) {\n      let credentials = uri.match(/^.*\\/{1,2}(.*):(.*)@/i)\n\n      url.hostname = url.hostname.split('@').pop()\n\n      this.user = credentials[1]\n      this.secret = credentials[2]\n      // this.applyAuthorizationHeader()\n    }\n\n    url.port = NGN.coalesce(url.hostname.match(/:([0-9]{1,6})/), url.protocol === 'https' ? 443 : 80)\n\n    if (url.hostname.indexOf(':') > 0) {\n      url.hostname = url.hostname.split(':')[0]\n    }\n\n    if (url.path.charAt(0) !== '/') {\n      url.path = `/${url.path}`\n    }\n\n    return url\n  }\n\n  /**\n   * @method isCrossOrigin\n   * Determine if accessing a URL is considered a cross origin request.\n   * @param {string} url\n   * The URL to identify as a COR.\n   * @param {string} [alternativeUrl]\n   * Optionally provide an alternative URL to compare the #url with.\n   * @returns {boolean}\n   * @private\n   */\n  isCrossOrigin (url, altUrl = null) {\n    let uri = this.parseUri(url)\n\n    if (altUrl !== null) {\n      altUrl = this.parseUri(altUrl)\n\n      return uri.hostname !== altUrl.hostname\n    }\n\n    /* node-only */\n    if (this.networkInterfaces.indexOf(uri.hostname) < 0) {\n      return true\n    }\n    /* end-node-only */\n\n    return uri.hostname !== this.hostname\n  }\n}\n\nconst Utility = new NetworkUtilities()\nconst networkInterfaces = Utility.networkInterfaces\nconst hostname = Utility.hostname\nconst normalizeUrl = Utility.normalizeUrl\n\nexport {\n  Utility as default,\n  networkInterfaces,\n  hostname,\n  normalizeUrl\n}\n","import Utility from './Utility'\n\n/**\n * @class NGN.NET.Request\n * Represents a network request. This class can be used\n * to create and manipulate HTTP requests, but it does not\n * actually transmit them. To send the request, use NGN.NET#request\n * or one of the many common helper methods.\n * @private\n */\nexport default class Request { // eslint-disable-line no-unused-vars\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    // Require URL and HTTP method\n    NGN.objectRequires(cfg, 'url')\n\n    if (NGN.objectHasAny(cfg, 'form', 'json')) {\n      NGN.WARN('NET.Request', '\"form\" and \"json\" configuration properties are not valid. Use \"body\" instead.')\n    }\n\n    Object.defineProperties(this, {\n      /**\n       * @cfgproperty {string} url (required)\n       * The complete URL for the request, including query parameters.\n       */\n      uri: NGN.private(null),\n\n      /**\n       * @cfg {string} [method=GET]\n       * The HTTP method to invoke when the request is sent. The standard\n       * RFC 2616 HTTP methods include:\n       *\n       * - OPTIONS\n       * - HEAD\n       * - GET\n       * - POST\n       * - PUT\n       * - DELETE\n       * - TRACE\n       * - CONNECT\n       *\n       * There are many additional non-standard methods some remote hosts\n       * will accept, including `PATCH`, `COPY`, `LINK`, `UNLINK`, `PURGE`,\n       * `LOCK`, `UNLOCK`, `VIEW`, and many others. If the remote host\n       * supports these methods, they may be used in an NGN.NET.Request.\n       * Non-standard methods will not be prevented, but NGN will trigger\n       * a warning event if a non-standard request is created.\n       */\n      httpmethod: NGN.private(null),\n\n      /**\n       * @cfg {boolean} [enforceMethodSafety=true]\n       * According to [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html),\n       * some HTTP methods are considered idempotent (safe). These methods\n       * should have no significance to data (i.e. read-only). For example,\n       * `OPTIONS`, `HEAD`, and `GET` are all idempotent. By default, NGN.NET\n       * loosely enforces idempotence by ignoring the #body when making a\n       * request. While it is not advised, nor officially supported, NGN.NET can\n       * technically ignore method safety, allowing a request body to be\n       * sent to a remote server. Set this configuration to `false` to\n       * prevent NGN.NET from enforcing idempotence/safety.\n       */\n      enforceMethodSafety: NGN.private(NGN.coalesce(cfg.enforceMethodSafety, cfg.enforcemethodsafety, true)),\n\n      /**\n       * @cfg {object} [headers]\n       * Optionally supply custom headers for the request. Most standard\n       * headers will be applied automatically (when appropriate), such\n       * as `Content-Type`, `Content-Length`, and `Authorization`.\n       * In Node-like environments, a `User-Agent` will be applied containing\n       * the `hostname` of the system making the request. Any custom headers\n       * supplied will override headers managed by NGN.NET.\n       */\n      headers: NGN.public(NGN.coalesceb(cfg.headers)),\n\n      /**\n       * @cfg {object|string|binary} [body]\n       * The body configuration supports text, an object, or a data URL or\n       * binary content. **For multi-part form data (file uploads), use\n       * the #files configuration _instead_ of this attribute.**\n       *\n       * It is also possible to construct a simple form submission\n       * (x-www-form-urlencoded) from a specially formatted key/value object\n       * conforming to the following syntax:\n       *\n       * ```json\n       * {\n       *   form: {\n       *     form_field_1: \"value\",\n       *     form_field_2: \"value\",\n       *     form_field_3: \"value\",\n       *   }\n       * }\n       * ```\n       * The object above will be automatically converted & url-encoded as:\n       *\n       * ```js\n       * form_field_1=value&form_field_2=value&form_field_3=value\n       * ```\n       *\n       * The appropriate request headers are automatically applied.\n       */\n      requestbody: NGN.public(NGN.coalesce(cfg.body)),\n\n      /**\n       * @cfg {string} [responseType=text]\n       * Specifies the type of data expected in the response.\n       * Values conform with those available in the XHR spec.\n       * See [MDN: XMLHttpRequest.responseType](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType)\n       */\n      responseType: NGN.public(NGN.coalesce(cfg.responseType, '')),\n\n      /**\n       * @cfgproperty {string} username\n       * A username to authenticate the request with (basic auth).\n       */\n      user: NGN.private(NGN.coalesceb(cfg.username)),\n\n      /**\n       * @cfgproperty {string} password\n       * A password to authenticate the request with (basic auth).\n       * @readonly\n       */\n      secret: NGN.private(NGN.coalesceb(cfg.password)),\n\n      /**\n       * @cfgproperty {string} accessToken\n       * An access token to authenticate the request with (Bearer auth).\n       * If this is configured, it will override any basic auth settings.\n       */\n      bearerAccessToken: NGN.private(NGN.coalesceb(cfg.accessToken)),\n\n      /**\n       * @cfgproperty {boolean} [withCredentials=false]\n       * Indicates whether or not cross-site `Access-Control` requests should\n       * be made using credentials such as cookies, authorization headers or\n       * TLS client certificates. Setting `withCredentials` has no effect on\n       * same-site requests.\n       *\n       * In addition, this flag is also used to indicate when cookies are to\n       * be ignored in the response. The default is `false`. XMLHttpRequest\n       * from a different domain cannot set cookie values for their own\n       * domain unless `withCredentials` is set to true before making the\n       * request. The third-party cookies obtained by setting `withCredentials`\n       * to true will still honor same-origin policy and hence can not be\n       * accessed by the requesting script through\n       * [document.cookie](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie)\n       * or from response headers.\n       */\n      withCredentials: NGN.private(NGN.coalesce(cfg.withCredentials, false)),\n\n      /**\n       * @cfgproperty {Number} [timeout=30000]\n       * The number of milliseconds to wait before considering the request to\n       * have timed out. Defaults to `30000` (30 seconds).\n       */\n      timeout: NGN.public(NGN.coalesce(cfg.timeout, 30000)),\n\n      /**\n       * @method timer\n       * A placeholder for a timeout monitor.\n       * @private\n       */\n      timer: NGN.private(null),\n\n      /**\n       * @method isCrossOrigin\n       * Determine if accessing a URL is considered a cross origin request.\n       * @param {string} url\n       * The URL to identify as a COR.\n       * @returns {boolean}\n       * @private\n       */\n      isCrossOrigin: NGN.privateconst(function (url) {\n        return Utility.isCrossOrigin(url)\n      }),\n\n      /**\n       * @method applyAuthorizationHeader\n       * Generates and applies the authorization header for the request,\n       * based on the presence of #username, #password, or #accessToken.\n       * @private\n       */\n      applyAuthorizationHeader: NGN.privateconst(() => {\n        if (NGN.coalesceb(this.bearerAccessToken) !== null) {\n          this.setHeader('Authorization', `Bearer ${this.bearerAccessToken}`, true)\n        } else if (NGN.coalesceb(this.user) && NGN.coalesceb(this.secret)) {\n          this.setHeader('Authorization', this.basicAuthToken(this.user, this.secret), true)\n        }\n      }),\n\n      /**\n       * @method basicAuthToken\n       * Generates a basic authentication token from a username and password.\n       * @return {[type]} [description]\n       * @private\n       */\n      basicAuthToken: NGN.privateconst((user, secret) => {\n        // Binary to base64-ascii conversions\n        /* node-only */\n        return 'Basic ' + Buffer.from(`${user}:${secret}`, 'binary').toString('base64')\n        /* end-node-only */\n        /* browser-only */\n        return 'Basic ' + NGN.global.btoa(`${user}:${secret}`) // eslint-disable-line no-unreachable\n        /* end-browser-only */\n      }),\n\n      /**\n       * @method parseUri\n       * Parses the URI into composable parts.\n       * @param {string} URL\n       * The URI/URL to parse.\n       * @return {Object}\n       * Returns a key/value object:\n       *\n       * ```js\n       * {\n       *   protocol: 'http',\n       *   hostname: 'domain.com',\n       *   path: '/path/to/file.html',\n       *   query: 'a=1&b=2',\n       *   hash: null\n       * }\n       * ```\n       * @private\n       */\n      parseUri: NGN.privateconst(Utility.parseUri),\n\n      uriParts: NGN.private(null),\n\n      /**\n       * @cfgproperty {Number} [maxRedirects=10]\n       * Set the maximum number of redirects. There is a hard-cap of 25\n       * redirects to prevent cyclic requests (endless loop).\n       */\n      maximumRedirects: NGN.private(10),\n      redirectAttempts: NGN.private(0),\n\n      prepareBody: NGN.private(() => {\n        // Request body management\n        if (this.requestbody !== null) {\n          if (this.headers === null) {\n            this.headers = {}\n          }\n\n          let contentType = NGN.coalesceb(this.headers['Content-Type'], this.headers['content-type'], this.headers['Content-type'])\n\n          if (typeof this.requestbody === 'object') {\n            if (NGN.objectHasExactly(this.requestbody, 'form')) {\n              let form = this.requestbody.form\n              let keys = Object.keys(form)\n              let dataString = []\n\n              for (let i = 0; i < keys.length; i++) {\n                if (NGN.isFn(form[keys[i]])) {\n                  throw new Error('Invalid form data. Form data cannot be a complex data format such as an object or function.')\n                } else if (typeof form[keys[i]] === 'object') {\n                  dataString.push(`${keys[i]}=${encodeURIComponent(JSON.stringify(form[keys[i]]))}`)\n                } else {\n                  dataString.push(`${keys[i]}:${encodeURIComponent(form[keys[i]])}`)\n                }\n              }\n\n              this.requestbody = dataString.join('&')\n            } else {\n              this.requestbody = JSON.stringify(this.requestbody).trim()\n              this.setHeader('Content-Length', this.requestbody.length, false)\n              this.setHeader('Content-Type', NGN.coalesceb(contentType, 'application/json'), false)\n              this.responseType = 'json'\n            }\n          }\n\n          if (typeof this.requestbody === 'string') {\n            if (contentType !== null) {\n              // Check for form data\n              let match = /([^=]+)=([^&]+)/.exec(this.requestbody)\n\n              if (match !== null && this.requestbody.trim().substr(0, 5).toLowerCase() !== 'data:' && this.requestbody.trim().substr(0, 1).toLowerCase() !== '<') {\n                this.setHeader('Content-Type', 'application/x-www-form-urlencoded', false)\n              } else {\n                this.setHeader('Content-Type', 'text/plain')\n\n                if (this.requestbody.trim().substr(0, 5).toLowerCase() === 'data:') {\n                  // Crude Data URL mimetype detection\n                  match = /^data:(.*);/gi.exec(this.requestbody.trim())\n\n                  if (match !== null) {\n                    this.setHeader('Content-Type', match[1])\n                  }\n                } else if (/^<\\?xml.*/gi.test(this.requestbody.trim())) {\n                  // Crude XML Detection\n                  this.setHeader('Content-Type', 'application/xml')\n                } else if (/^<html.*/gi.test(this.requestbody.trim())) {\n                  // Crude HTML Detection\n                  this.setHeader('Content-Type', 'text/html')\n                }\n              }\n            }\n\n            this.setHeader('Content-Type', this.requestbody.length, false)\n          } else {\n            NGN.WARN('NET.Request.body', `The request body must cannot be ${typeof this.requestbody}. Please provide a string, object, or binary value for the body.`)\n          }\n        }\n      })\n    })\n\n    if (cfg.maxRedirects) {\n      this.maxRedirects = cfg.maxRedirects\n    }\n\n    this.url = cfg.url\n    this.method = NGN.coalesceb(cfg.method, 'GET')\n\n    this.prepareBody()\n\n    // Apply authorization if applicable\n    if (NGN.coalesce(this.user, this.secret, this.bearerAccessToken) !== null) {\n      this.applyAuthorizationHeader()\n    }\n  }\n\n  get maxRedirects () {\n    return this.maximumRedirects\n  }\n\n  set maxRedirects (value) {\n    if (value > 25) {\n      value = 25\n    }\n\n    if (value < 0) {\n      value = 0\n    }\n\n    this.maximumRedirects = value\n  }\n\n  /**\n   * @property {string} protocol\n   * The protocol used to make the request.\n   * @readonly\n   */\n  get protocol () {\n    return NGN.coalesce(this.uriParts.protocol, 'http')\n  }\n\n  /**\n   * @property {string} host\n   * The hostname/domain of the request.\n   */\n  get host () {\n    return NGN.coalesce(this.uriParts.hostname)\n  }\n\n  get hostname () {\n    return this.host\n  }\n\n  /**\n   * @property {number} port\n   * The port of the remote host.\n   */\n  get port () {\n    return this.uriParts.port\n  }\n\n  /**\n   * @property {string} path\n   * The pathname of the URL.\n   */\n  get path () {\n    return NGN.coalesce(this.uriParts.path, '/')\n  }\n\n  /**\n   * @property {string} query\n   * The raw query string of the URI. To retrieve a key/value list,\n   * use #queryParameters instead.\n   */\n  get query () {\n    return NGN.coalesce(this.uriParts.query, '')\n  }\n\n  /**\n   * @property {object} queryParameters\n   * Returns a key/value object containing the URL query parameters of the\n   * request, as defined in the #url. The paramter values (represented as keys\n   * in this object) may be modified, but not removed (use removeQueryParameter\n   * to delete a query parameter). No new query parameters can be added (use\n   * setQueryParameter instead).\n   * @readonly\n   */\n  get queryParameters () {\n    let params = this.query.split('&')\n    let resultSet = {}\n\n    for (let i = 0; i < params.length; i++) {\n      let keypair = params[i].split('=')\n      let attr = `__qp__${keypair[0]}__qp__`\n\n      Object.defineProperty(resultSet, attr, {\n        enumerable: false,\n        configurable: false,\n        writable: true,\n        value: NGN.coalesceb(keypair[1])\n      })\n\n      Object.defineProperty(resultSet, keypair[0], {\n        enumerable: true,\n        configurable: false,\n        get: () => { return resultSet[attr] },\n        set: (value) => {\n          resultSet[attr] = value\n          this.setQueryParameter(keypair[0], value, true)\n        }\n      })\n    }\n\n    return resultSet\n  }\n\n  /**\n   * @property hash\n   * The hash part of the URL (i.e. everything after the trailing `#`).\n   */\n  get hash () {\n    return NGN.coalesce(this.uriParts.hash, '')\n  }\n\n  /**\n   * @property {string} url\n   * The URL where the request will be sent.\n   */\n  get url () {\n    return this.uri\n  }\n\n  set url (value) {\n    if (NGN.coalesceb(value) === null) {\n      NGN.WARN('NET.Request.url', 'A blank URL was identified for a request.')\n    }\n\n    // If a relative URL is provided in a browser context, prepend\n    // the current browser location to the URI.\n    if (/^.*:\\/{2}/i.exec(value) === null && /^\\.{1,2}\\/.*/.exec(value) !== null && NGN.global.hasOwnProperty('location')) {\n      let loc = NGN.global.location\n      let href = `${loc.host}${loc.pathname}`\n\n      href = href.split('/')\n\n      if (href[href.length - 1].indexOf('.') >= 0) {\n        href.pop()\n      }\n\n      href = href.join('/')\n      href = href.substring(0, href.lastIndexOf('/') + 1)\n\n      value = `${NGN.global.location.protocol}//${href}/${value}`.replace(/\\/{2,1000000}/i, '/')\n    }\n\n    this.uri = Utility.normalizeUrl(value.trim())\n    this.uriParts = this.parseUri(this.uri)\n  }\n\n  get method () {\n    return this.httpmethod\n  }\n\n  set method (value) {\n    if (this.httpmethod === value) {\n      return\n    }\n\n    if (NGN.coalesceb(value) === null) {\n      NGN.WARN('NET.Request.method', 'No HTTP method specified.')\n    }\n\n    value = value.trim().toUpperCase()\n\n    if (Utility.HttpMethods.indexOf(value) < 0) {\n      NGN.WARN('NET.Request.method', `A non-standard HTTP method was recognized in a request: ${value}.`)\n    }\n\n    this.httpmethod = value\n  }\n\n  get body () {\n    return this.requestbody\n  }\n\n  set body (value) {\n    this.requestbody = value\n    this.prepareBody()\n  }\n\n  /**\n   * @property {boolean} crossOriginRequest\n   * Indicates the request will be made to a domain outside of the\n   * one hosting the request.\n   */\n  get crossOriginRequest () {\n    return this.isCrossOrigin(this.uri)\n  }\n\n  /**\n   * @property {string} username\n   * The username that will be used in any basic authentication operations.\n   */\n  get username () {\n    return NGN.coalesce(this.user)\n  }\n\n  set username (user) {\n    user = NGN.coalesceb(user)\n\n    if (this.user !== user) {\n      this.user = user\n\n      if (NGN.coalesceb(this.secret) !== null) {\n        this.applyAuthorizationHeader()\n      }\n    }\n  }\n\n  /**\n   * @property {string} password\n   * It is possible to set a password for any basic authentication operations,\n   * but it is not possible to read a password.\n   * @writeonly\n   */\n  set password (secret) {\n    secret = NGN.coalesceb(secret)\n\n    if (this.secret !== secret) {\n      this.secret = secret\n\n      if (NGN.coalesceb(this.user) !== null) {\n        this.applyAuthorizationHeader()\n      }\n    }\n  }\n\n  /**\n   * @property {string} accessToken\n   * Supply a bearer access token for basic authenticaiton operations.\n   * @writeonly\n   */\n  set accessToken (token) {\n    token = NGN.coalesceb(token)\n\n    if (this.bearerAccessToken !== token) {\n      this.bearerAccessToken = token\n      this.applyAuthorizationHeader()\n    }\n  }\n\n  /**\n   * @method setHeader\n   * Add a header to the request.\n   * @param {string} header\n   * The name of the header.\n   * @param {string} value\n   * Value of the header.\n   * @param {Boolean} [overwriteExisting=true]\n   * If the header already exists, setting this to `false` will prevent\n   * the original header from being overwritten.\n   */\n  setHeader (key, value, overwriteExisting = true) {\n    key = key.replace(/'|\"/gi, '').toLowerCase()\n\n    if (this.headers === null || this.headers[key] === undefined || overwriteExisting) {\n      if (this.headers === null) {\n        this.headers = {}\n      }\n\n      this.headers[key] = value\n    }\n  }\n\n  /**\n   * @method getHeader\n   * @param  {string} header\n   * The name of the header to retrieve.\n   * @return {string}\n   * Returns the current value of the specified header.\n   */\n  getHeader (key) {\n    if (this.headers === null) {\n      return undefined\n    }\n\n    if (!this.headers.hasOwnProperty(key.toLowerCase())) {\n      return undefined\n    }\n\n    return this.headers[key.toLowerCase()]\n  }\n\n  /**\n   * @method removeHeader\n   * Removes a header from the request. Nothing happens if the header does\n   * not exist.\n   * @param  {string} header\n   * The header to remove.\n   */\n  removeHeader (key) {\n    if (this.headers !== null) {\n      delete this.headers[key.toLowerCase()]\n      delete this.headers[key]\n    }\n  }\n\n  /**\n   * @method setQueryParameter\n   * Add a query parameter to the request.\n   * @param {string} parameter\n   * The name of the parameter.\n   * @param {string} value\n   * Value of the parameter. The value is automatically URL encoded. If the\n   * value is null, only the key will be added to the URL (ex: `http://domain.com/page.html?key`)\n   * @param {Boolean} [overwriteExisting=true]\n   * If the parameter already exists, setting this to `false` will prevent\n   * the original parameter from being overwritten.\n   */\n  setQueryParameter (key, value, overwriteExisting = true) {\n    let re = new RegExp(\"^.*(\\\\?|&)(\" + key + \".*)(&.*)$|^.*(\\\\?|&)(\" + key + \".*)$\", 'i') // eslint-disable-line quotes\n    let exists = (re.exec(this.uri) !== null)\n    let match\n\n    if (exists) {\n      if (!overwriteExisting) {\n        return\n      }\n\n      match = re.exec(this.uri)\n\n      if (match !== null) {\n        this.url = this.uri.replace(`${NGN.coalesceb(match[5], match[2])}`, `${key}${value !== null ? '=' + encodeURIComponent(value) : ''}`)\n      }\n    } else {\n      this.url = `${this.uri}${this.query.length === 0 ? '?' : '&'}${key}${value !== null ? '=' + encodeURIComponent(value) : ''}`\n    }\n  }\n\n  /**\n   * @method removeQueryParameter\n   * Remove a query parameter from the request URI.\n   * @param {string} key\n   */\n  removeQueryParameter (key) {\n    this.url = this.uri.replace(new RegExp(`${key}=(.[^&]+)|\\\\?${key}|&${key}`, 'gi'), '')\n  }\n\n  startMonitor () {\n    if (this.timer === null) {\n      this.timer = setTimeout(() => {\n        throw new Error('Timed out retrieving ' + this.url)\n      }, this.timeout)\n    }\n  }\n\n  stopMonitor () {\n    clearTimeout(this.timer)\n    this.timer = null\n  }\n\n  /**\n   * @method send\n   * Send the request.\n   * @param {Function} callback\n   * The callback is executed when the request is complete.\n   * @param {Object} callback.response\n   * The response object returned by the server.\n   */\n  send (callback) {\n    let body = this.body\n\n    // Disable body when safe methods are enforced.\n    if (NGN.coalesce(body)) {\n      if (this.enforceMethodSafety && 'OPTIONS|HEAD|GET'.indexOf(this.method) >= 0) {\n        body = null\n      }\n    }\n\n    /* node-only */\n    // Run request in Node-like environments\n    // Support local file system retrieval in node-like environments.\n    // This short-circuits the request and reads the file system instead.\n    if (this.protocol === 'file') {\n      if (!NGN.isFn(callback)) {\n        throw new Error('A callback is required when retrieving system files in a node-like environment.')\n      }\n\n      let response = {\n        status: require('fs').existsSync(this.uri.replace('file://', '')) ? 200 : 400\n      }\n\n      response.responseText = response.status === 200 ? require('fs').readFileSync(this.uri.replace('file://', '')).toString() : 'File does not exist or could not be found.'\n\n      return callback(response)\n    }\n\n    const http = this.protocol === 'https' ? require('https') : require('http')\n\n    let params = NGN.coalesceb(this.query)\n    let reqOptions = {\n      hostname: this.hostname,\n      port: this.port,\n      method: this.method,\n      headers: this.headers,\n      path: this.path\n    }\n\n    if (params !== null) {\n      reqOptions.path = `${this.path}?${params}`\n    }\n\n    const req = http.request(reqOptions, (response) => {\n      response.setEncoding('utf8')\n\n      let body = ''\n      response.on('data', (chunk) => {\n        body += chunk\n      })\n\n      response.on('end', () => {\n        switch (response.statusCode) {\n          case 301:\n          case 302:\n          case 307:\n          case 308:\n            if (this.redirectAttempts > this.maxRedirects) {\n              this.redirectAttempts = 0\n\n              this.stopMonitor()\n\n              return callback({ // eslint-disable-line standard/no-callback-literal\n                status: 500,\n                statusText: 'Too many redirects',\n                responseText: 'Too many redirects',\n                responseXML: 'Too many redirects',\n                readyState: 4\n              })\n            }\n\n            if (response.headers.location === undefined) {\n              this.stopMonitor()\n\n              return callback({ // eslint-disable-line standard/no-callback-literal\n                status: 502,\n                statusText: 'Bad Gateway',\n                responseText: 'Bad Gateway',\n                responseXML: 'Bad Gateway',\n                readyState: 4\n              })\n            }\n\n            this.redirectAttempts++\n            this.url = response.headers.location\n\n            return this.send(callback)\n\n          default:\n            this.stopMonitor()\n\n            return callback({ // eslint-disable-line standard/no-callback-literal\n              status: response.statusCode,\n              statusText: NGN.coalesce(response.statusText),\n              responseText: body,\n              responseXML: body,\n              readyState: 4\n            })\n        }\n      })\n    })\n\n    req.on('error', (err) => {\n      this.stopMonitor()\n\n      if (NGN.isFn(callback)) {\n        callback({ // eslint-disable-line standard/no-callback-literal\n          status: 400,\n          statusText: err.message,\n          responseText: err.message,\n          responseXML: err.message,\n          readyState: 0\n        })\n      } else {\n        throw err\n      }\n    })\n\n    this.startMonitor()\n\n    if (this.body) {\n      req.write(this.body)\n    }\n\n    req.end()\n    /* end-node-only */\n    /* browser-only */\n    let xhr = new XMLHttpRequest()\n    let responded = false\n    let me = this\n\n    // Apply readystate change handler\n    xhr.onreadystatechange = function () {\n      if (responded) {\n        return\n      }\n\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        responded = true\n\n        if (xhr.status === 0) {\n          NGN.WARN(`Request Error: ${me.method} ${me.url} (likely a CORS issue).`)\n        }\n\n        if (NGN.isFn(callback)) {\n          callback(xhr)\n        }\n      }\n    }\n\n    // Apply error handler\n    xhr.onerror = function (e) {\n      NGN.WARN('NET.error', e)\n\n      if (!responded && NGN.isFn(callback)) {\n        callback(xhr)\n      }\n\n      responded = true\n    }\n\n    xhr.ontimeout = function (e) {\n      responded = true\n      callback(xhr)\n    }\n\n    xhr.timeout = this.timeout\n\n    // Open the request\n    xhr.open(this.method, this.url, true)\n\n    // Apply withCredentials\n    xhr.withCredentials = this.withCredentials\n\n    // Apply Request Headers\n    if (this.headers !== null) {\n      let headers = Object.keys(this.headers)\n      for (let i = 0; i < headers.length; i++) {\n        xhr.setRequestHeader(headers[i], this.headers[headers[i]])\n      }\n    }\n\n    // Write the body (which may be null) & send the request\n    xhr.send(body)\n    /* end-browser-only */\n  }\n}\n","import { hostname, normalizeUrl } from './Utility'\nimport Request from './Request'\n\nexport default class Network { // eslint-disable-line\n  constructor () {\n    Object.defineProperties(this, {\n      /**\n       * @method normalizeUrl\n       * Normalize a URL by removing extraneous characters,\n       * applying protocol, and resolving relative links.\n       * @param {string} URI\n       * The URI to normalize.\n       * @return {string}\n       * The normalized URL.\n       */\n      normalizeUrl: NGN.privateconst(normalizeUrl),\n\n      /**\n       * @method parseRequestConfiguration\n       * Prepare common configuration attributes for a request.\n       * @return {NGN.NET.Request}\n       * @private\n       */\n      parseRequestConfiguration: NGN.private((cfg, method = 'GET') => {\n        if (typeof cfg === 'string') {\n          cfg = {\n            url: cfg\n          }\n        }\n\n        cfg = cfg || {}\n        cfg.method = method\n        cfg.url = NGN.coalesceb(cfg.url, hostname) // eslint-disable-line no-undef\n\n        return new NGN.NET.Request(cfg)\n      }),\n\n      // Returns a scoped method for sending the request, after preparing it.\n      makeRequest: NGN.private((method) => {\n        const me = this\n\n        return function () {\n          let args = NGN.slice(arguments)\n          let callback\n\n          if (NGN.isFn(args[args.length - 1])) {\n            callback = args.pop()\n          }\n\n          args.push(method)\n\n          let request = me.parseRequestConfiguration(...args)\n\n          // Send the request\n          me.send(request, callback)\n        }\n      }),\n\n      // Helper aliases (undocumented)\n      OPTIONS: NGN.privateconst(this.options.bind(this)),\n      HEAD: NGN.privateconst(this.head.bind(this)),\n      GET: NGN.privateconst(this.get.bind(this)),\n      POST: NGN.privateconst(this.post.bind(this)),\n      PUT: NGN.privateconst(this.put.bind(this)),\n      DELETE: NGN.privateconst(this.delete.bind(this)),\n      TRACE: NGN.privateconst(this.trace.bind(this)),\n      JSON: NGN.privateconst(this.json.bind(this)),\n      JSONP: NGN.privateconst(this.jsonp.bind(this))\n    })\n  }\n\n  get Request () {\n    return Request\n  }\n\n  /**\n   * @method request\n   * Send a request. In most cases, it is easier to use one of the built-in\n   * request functions (#get, #post, #put, #delete, #json, etc). This method\n   * is available for creating custom requests.\n   * @param  {Object} configuration\n   * Provide a #NGN.NET.Request configuration.\n   * @param  {Function} callback\n   * The callback to execute when the request is complete.\n   */\n  request (cfg, callback) {\n    cfg = cfg || {}\n    cfg.method = NGN.coalesceb(cfg.method, 'GET')\n\n    if (NGN.isFn(this[cfg.method])) {\n      this.makeRequest(cfg.method)(...arguments)\n    } else {\n      this.send(new NGN.NET.Request(cfg), callback)\n    }\n  }\n\n  /**\n   * @method options\n   * Issue a `OPTIONS` request.\n   * @param {string|object} url\n   * The URL to issue the request to, or a configuration object.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  options () {\n    this.makeRequest('OPTIONS').apply(this, arguments)\n  }\n\n  /**\n   * @method head\n   * Issue a `HEAD` request.\n   * @param {string|object} url\n   * The URL to issue the request to, or a configuration object.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  head () {\n    this.makeRequest('HEAD').apply(this, arguments)\n  }\n\n  /**\n   * @method get\n   * Issue a `GET` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  get () {\n    this.makeRequest('GET').apply(this, arguments)\n  }\n\n  /**\n   * @method post\n   * Issue a `POST` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  post () {\n    this.makeRequest('POST').apply(this, arguments)\n  }\n\n  /**\n   * @method put\n   * Issue a `PUT` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  put () {\n    this.makeRequest('PUT').apply(this, arguments)\n  }\n\n  /**\n   * @method delete\n   * Issue a `DELETE` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  delete () {\n    this.makeRequest('DELETE').apply(this, arguments)\n  }\n\n  /**\n   * @method trace\n   * Issue a `TRACE` request. This is a debugging method, which\n   * echoes input back to the user. It is a standard HTTP method,\n   * but considered a security risk by many practioners and may\n   * not be supported by remote hosts.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  trace () {\n    NGN.WARN('NGN.NET.Request.method', 'An HTTP TRACE request was made.')\n    this.makeRequest('TRACE').apply(this, arguments)\n  }\n\n  /**\n   * @method json\n   * This is a shortcut method for creating a `GET` request and\n   * auto-parsing the response into a JSON object.\n   * @param  {string} url\n   * The URL to issue the request to.\n   * @param  {Function} callback\n   * This receives a JSON response object from the server.\n   * @param {Error} callback.error\n   * If the request cannot be completed for any reason, this argument will be\n   * populated with the error. If the request is successful, this will be `null`.\n   * @param {Object} callback.data\n   * The JSON response from the remote URL.\n   */\n  json (url, callback) {\n    if (!NGN.isFn(callback)) {\n      throw new Error('NGN.NET.json requires a callback method.')\n    }\n\n    // Request method is \"GET\"\n    let request = this.parseRequestConfiguration({url})\n\n    this.preflight(request)\n\n    request.send((response) => {\n      try {\n        let responseData = JSON.parse(response.responseText)\n        callback(null, responseData)\n      } catch (e) {\n        e.response = NGN.coalesce(response.responseText)\n        callback(e, null)\n      }\n    })\n  }\n\n  /**\n   * @method jsonp\n   * Execute a request via JSONP. JSONP is only available in browser\n   * environments, since it's operation is dependent on the existance of\n   * the DOM. However; this may work with some headless browsers.\n   * @param {string} url\n   * The URL of the JSONP endpoint.\n   * @param {function} callback\n   * Handles the response.\n   * @param {Error} callback.error\n   * If an error occurred, this will be populated. If no error occurred, this will\n   * be null.\n   * @param {object|array} callback.response\n   * The response.\n   * @environment browser\n   */\n  jsonp (url, callback) {\n    /* node-only */\n    NGN.WARN('NET.Request', 'An unsupported JSONP request was made.')\n    callback(new Error('JSONP unsupported in Node-like environments.'))\n    /* end-node-only */\n    /* browser-only */\n    const fn = 'jsonp_callback_' + Math.round(100000 * Math.random())\n\n    window[fn] = (data) => {\n      delete window[fn]\n\n      document.body.removeChild(script)\n\n      return callback(null, data)\n    }\n\n    let script = document.createElement('script')\n\n    script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + fn\n\n    script.addEventListener('error', (e) => {\n      delete window[fn]\n\n      return callback(new Error('The JSONP request was blocked. This may be the result of an invalid URL, cross origin restrictions, or the remote server may not be online.'))\n    })\n\n    document.body.appendChild(script)\n    /* end-browser-only */\n  }\n\n  // Apply a preflight request option to the network request.\n  send (request, callback) {\n    this.preflight(request)\n    request.send(callback)\n  }\n\n  /**\n   * @method preflight\n   * This is a no-op method that runs before a request is sent.\n   * This exists specicially to be overridden by class extensions.\n   */\n  preflight (request) {}\n}\n","import Network from './Network'\nimport { hostname, normalizeUrl } from './Utility'\n\n/**\n * @class NGN.NET.Resource\n * Represents a remote web resource, such as a backend web server or\n * an API server. This class inherits everything from NGN.NET, extending\n * it with customizable options for working with specific remote resources.\n *\n * This class was designed for use in applications where multiple requests\n * are made to multiple backends. For example, a common single page application\n * may make multiple requests for resources (media, templates, CSS, etc)\n * as well as multiple requests to an API server.\n *\n * For example:\n *\n * ```js\n * let server = new NGN.NET.Resource({\n *   credentials: {\n *     username: 'username',\n *     password: 'password'\n *   },\n *   headers: {\n *     'x-source': 'mydomain.com'\n *   }\n * })\n *\n * let API = new NGN.NET.Resource({\n *   credentials: {\n *     token: 'secret_token'\n *   },\n *   headers: {\n *     'user-agent': 'mobile'\n *   },\n *   baseUrl: 'https://api.mydomain.com'\n * })\n *\n * server.get('./templates/home.html', (response) => { ... })\n * API.json('/user', (data) => { ... })\n * ```\n *\n * Both `server` and `API` in the example above are instances of\n * NGN.NET. They each use different credentials to access the\n * remote endpoint, using different global headers and\n * a different base URL.\n *\n * This can be incredibly useful anytime a migration is required,\n * such as running code in dev ==> staging ==> production or\n * switching servers. It is also useful for creating connections\n * to different remote services, creating custom API clients,\n * and generally organizing/standardizing how an application connects\n * to remote resources.\n * @extends NGN.NET\n */\nexport default class NetworkResource extends Network {\n  constructor (cfg) {\n    super()\n\n    cfg = cfg || {}\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {object} headers\n       * Contains headers (key/value) that are applied to all requests.\n       */\n      globalHeaders: NGN.private(NGN.coalesceb(cfg.headers, {})),\n\n      /**\n       * @cfg {object} credentials\n       * Contains credentials that are applied to all requests.\n       * @private\n       */\n      globalCredentials: NGN.private(NGN.coalesceb(cfg.credentials, {})),\n\n      /**\n       * @cfg {string} username\n       * Use this to set a username (instead of using #credentials).\n       */\n      user: NGN.private(NGN.coalesceb(cfg.username)),\n\n      /**\n       * @cfg {string} password\n       * Use this to set a password (instead of using #credentials).\n       */\n      secret: NGN.private(NGN.coalesceb(cfg.password)),\n\n      /**\n       * @cfg {string} accessToken\n       * Use this to set an access token (instead of using #credentials).\n       */\n      accesstoken: NGN.private(NGN.coalesceb(cfg.token, cfg.accessToken)),\n\n      /**\n       * @cfg {object} query\n       * Contains query parameters to be applied to all requests. All values\n       * are automatically url-encoded.\n       */\n      globalQuery: NGN.private(NGN.coalesceb(cfg.query, {})),\n\n      /**\n       * @cfg {string} [baseUrl=window.loction.origin]\n       * The root domain/base URL to apply to all requests to relative URL's.\n       * This was designed for uses where a backend API may be served on\n       * another domain (such as api.mydomain.com instead of www.mydomain.com).\n       * The root will only be applied to relative paths that do not begin\n       * with a protocol. For example, `./path/to/endpoint` **will** have\n       * the root applied (`{root}/path/to/endpoint`) whereas `https://domain.com/endpoint`\n       * will **not** have the root applied.\n       */\n      baseUrl: NGN.private(NGN.coalesce(cfg.baseUrl, cfg.baseurl, `http://${hostname}/`)),\n\n      /**\n       * @cfg {boolean} [nocache=false]\n       * Set this to `true` to add a unique cache-busting URL parameter to all requests.\n       */\n      nocache: NGN.private(NGN.coalesce(cfg.nocache, false)),\n\n      /**\n       * @cfg {boolean} [sslonly=false]\n       * Set this to true to rewrite all URL's to use HTTPS.\n       */\n      sslonly: NGN.public(NGN.coalesce(cfg.sslonly, false))\n    })\n\n    if (this.baseUrl.indexOf('://') < 0 || this.baseUrl.indexOf('://') > 10) {\n      this.baseUrl = `http${this.sslonly ? 's' : ''}://${this.baseUrl}`\n    } else if (this.sslonly) {\n      this.baseUrl = this.baseUrl.replace('http://', 'https://')\n    }\n\n    if (this.accesstoken !== null) {\n      this.credentials = {\n        accessToken: this.accesstoken\n      }\n    } else if (this.user !== null && this.ssecret !== null) {\n      this.credentials = {\n        username: this.user,\n        password: this.secret\n      }\n    }\n  }\n\n  get username () {\n    return this.user\n  }\n\n  set username (value) {\n    if (this.user !== value) {\n      this.user = value\n\n      if (this.secret !== null) {\n        this.credentials = {\n          username: this.user,\n          password: this.secret\n        }\n      }\n    }\n  }\n\n  set password (value) {\n    if (this.secret !== value) {\n      this.secret = value\n\n      if (this.user !== null) {\n        this.credentials = {\n          username: this.user,\n          password: this.secret\n        }\n      }\n    }\n  }\n\n  /**\n   * @property {object} headers\n   * Represents the current global headers.\n   *\n   * This is commonly used when a remote resource requires a specific\n   * header on every call.\n   *\n   * **Example**\n   *\n   * ```js\n   * let resource = new NGN.NET.Resource(...)\n   *\n   * resource.headers = {\n   *   'user-agent': 'my custom agent name'\n   * }\n   * ```\n   */\n  get headers () {\n    return this.globalHeaders\n  }\n\n  set headers (value) {\n    this.globalHeaders = value\n  }\n\n  /**\n   * @property credentials\n   * Configure credentials that are applied to every request.\n   * This is commonly used when communicating with a RESTful API.\n   * This can accept a username and password or an access token.\n   *\n   * **Examples**\n   *\n   * ```js\n   *  let resource = new NGN.NET.Resource(...)\n   *\n   *  resource.credentials = {\n   *    username: 'user',\n   *    password: 'pass'\n   *  }\n   * ```\n   *\n   * ```js\n   * resource.credentials = {\n   *   accessToken: 'token'\n   * }\n   * ```\n   */\n  set credentials (credentials) {\n    if (credentials.hasOwnProperty('accesstoken') || credentials.hasOwnProperty('accessToken') || credentials.hasOwnProperty('token')) {\n      credentials.accessToken = NGN.coalesce(credentials.accessToken, credentials.accesstoken, credentials.token)\n\n      if (credentials.hasOwnProperty('username')) {\n        delete credentials.username\n      }\n\n      if (credentials.hasOwnProperty('password')) {\n        delete credentials.password\n      }\n    } else if (!(credentials.hasOwnProperty('username') && credentials.hasOwnProperty('password')) && !credentials.hasOwnProperty('accessToken')) {\n      throw new Error('Invalid credentials. Must contain an access token OR the combination of a username AND password.')\n    }\n\n    this.globalCredentials = credentials\n\n    if (credentials.username) {\n      this.username = credentials.username\n    }\n\n    if (credentials.password) {\n      this.password = credentials.password\n    }\n  }\n\n  // Explicitly deny credential reading.\n  get credentials () {\n    NGN.WARN('Credentials are write-only. An attempt to read credentials was denied.')\n    return {\n      username: null,\n      secret: null,\n      password: null,\n      accessToken: null\n    }\n  }\n\n  /**\n   * @property {object} query\n   * Represents the current global query paramaters.\n   *\n   * This is commonly used when a remote resource requires a specific\n   * query paramater on every call.\n   *\n   * **Example**\n   *\n   * ```js\n   * let resource = new NGN.NET.Resource(...)\n   *\n   * resource.query = {\n   *   'user_id': '12345'\n   * }\n   * ```\n   *\n   * All parameter values are automatically URL-encoded.\n   */\n  get query () {\n    return this.globalQuery\n  }\n\n  set query (value) {\n    this.globalQuery = value\n  }\n\n  /**\n   * @method prepareUrl\n   * Prepare a URL by applying the base URL (only when appropriate).\n   * @param  {string} uri\n   * The universal resource indicator (URI/URL) to prepare.\n   * @return {string}\n   * Returns a fully qualified URL.\n   * @private\n   */\n  prepareUrl (uri) {\n    if (uri.indexOf('://') < 0) {\n      uri = normalizeUrl(`${this.baseUrl}/${uri}`)\n    }\n\n    return uri.replace(/\\/{2,5}/gi, '/').replace(/:\\/{1}/i, '://')\n  }\n\n  /**\n   * @method preflight\n   * Prepares a request before it is sent.\n   * @param {NGN.NET.Request} request\n   * The request object.\n   * @private\n   */\n  preflight (request) {\n    // Apply the base URL\n    request.url = this.prepareUrl(request.url)\n\n    // If global query parameters have been defined, apply them.\n    let qp = Object.keys(this.globalQuery)\n    if (qp.length > 0) {\n      let queryString = []\n      for (let i = 0; i < qp.length; i++) {\n        queryString.push(`${qp[i]}=${encodeURIComponent(this.globalQuery[qp[i]])}`)\n      }\n\n      if (request.query === '') {\n        request.url = `${request.url}?${queryString.join('&')}`\n      } else {\n        request.url = `${request.url}&${queryString.join('&')}`\n      }\n    }\n\n    // If global credentials are available, apply them.\n    let gHeaders = Object.keys(this.globalHeaders)\n    for (let i = 0; i < gHeaders.length; i++) {\n      request.setHeader(gHeaders[i], this.globalHeaders[gHeaders[i]])\n    }\n\n    // If global headers/credentials are available, apply them.\n    if (this.globalCredentials.accessToken) {\n      request.accessToken = this.globalCredentials.accessToken\n    } else if (this.globalCredentials.username) {\n      request.username = this.globalCredentials.username\n      request.password = this.globalCredentials.password\n    }\n\n    // Add a cache buster\n    if (this.nocache) {\n      request.setQueryParameter('nocache' + (new Date()).getTime().toString() + Math.random().toString().replace('.', ''), null)\n    }\n  }\n}\n","import Request from './Request'\nimport Network from './Network'\nimport Resource from './Resource'\nimport Utility from './Utility'\n\n/**\n * @namespace NGN.NET\n * A library to issue HTTP/S requests.\n * This acts as an AJAX library.\n * @author Corey Butler\n * @singleton\n */\n\nNetwork.prototype.Resource = Resource\nNetwork.prototype.Plugin = Network\nNetwork.prototype.Utility = Utility\n\nconst normalizeUrl = Utility.normalizeUrl\nconst networkInterfaces = Utility.networkInterfaces\nconst Library = new Network()\n\nexport { Library, normalizeUrl, networkInterfaces, Request, Resource }\n","// CRC table for checksum (cached)\nlet crcTable = null\n\n/**\n * Generate the CRC table for checksums. This is a fairly complex\n * operation that should only be executed once and cached for\n * repeat use.\n */\nconst makeCRCTable = function () {\n  let c\n  let crcTable = []\n\n  for (let n = 0; n < 256; n++) {\n    c = n\n\n    for (let k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1))\n    }\n\n    crcTable[n] = c\n  }\n\n  return crcTable\n}\n\n/**\n * @class NGN.DATA.UTILITY\n * A utility library of functions relevant to data management.\n */\nexport default class Utility { // eslint-disable-line\n  /**\n   * @method checksum\n   * Create the checksum of the specified string.\n   * @param  {string} content\n   * The content to generate a checksum for.\n   * @return {string}\n   * Generates a checksum value.\n   */\n  static checksum (str) {\n    if (typeof str === 'object') {\n      str = JSON.stringify(this.serialize(str))\n    }\n\n    if (!crcTable) {\n      crcTable = makeCRCTable()\n    }\n\n    let crc = 0 ^ (-1)\n\n    for (let i = 0; i < str.length; i++) {\n      crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF]\n    }\n\n    return (crc ^ (-1)) >>> 0\n  }\n\n  /**\n   * @method UUID\n   * Generate a universally unique identifier (v4).\n   *\n   * This is a \"fast\" UUID generator, designed to work in the browser.\n   * This will generate a UUID in less than 20ms on Chrome, as of Nov 6, 2017.\n   * Code courtesy of @broofa on StackOverflow.\n   *\n   * While this method cannot absolutely guarantee there will be no collisions\n   * (duplicates), the chances are 1:5.3x10^^36 (1 in over 100 quadrillion).\n   * You are over 30 _octillion_ times more likely to win the Powerball than to\n   * generate two identical \"random\" UUIDs using the version 4 scheme.\n   * @return {string}\n   * Returns a [V4 GUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29).\n   */\n  static UUID () {\n    /* node-only */\n    return this.GUID()\n    /* end-node-only */\n    /* browser-only */\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => // eslint-disable-line\n      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16) // eslint-disable-line\n    )\n    /* end-browser-only */\n  }\n\n  /**\n   * @method GUID\n   * Generate a globally unique identifier. A GUID is the Microsoft\n   * implementation of a UUIDv4.\n   *\n   * The likelihood of an ID collision, according to the original author (Jeff\n   * Ward) is 1:3.26x10^15 (1 in 3.26 quadrillion). Results are generated between\n   * approximately 105ms (Desktop) and 726ms (Android) as of May 2016.\n   * @return {string} [description]\n   */\n  static GUID () {\n    let lut = []\n\n    for (let i = 0; i < 256; i++) {\n      lut[i] = (i < 16 ? '0' : '') + (i).toString(16)\n    }\n\n    const d0 = Math.random() * 0xffffffff | 0\n    const d1 = Math.random() * 0xffffffff | 0\n    const d2 = Math.random() * 0xffffffff | 0\n    const d3 = Math.random() * 0xffffffff | 0\n\n    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] +\n      '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] +\n      lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' +\n      lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] +\n      lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff]\n  }\n\n  /**\n   * @method serialize\n   * Creates a JSON data object with no functions. Only uses enumerable\n   * attributes of the object.\n   *\n   * Functions & Setters are always ignored. Getters are evaluated recursively\n   * until a simple object type is found or there are no further nested\n   * attributes.\n   * @param {object|array} object\n   * Supports an object or array.\n   */\n  static serialize (data) {\n    if (typeof data !== 'object') {\n      throw new Error(`Cannot serialize ${NGN.typeof(data)} value. Must be an object.`)\n    }\n\n    // Force an object for parsing\n    let SERIALIZED_ARRAY_DATA = Symbol('array.data')\n\n    if (NGN.typeof(data) === 'array') {\n      data = {\n        [SERIALIZED_ARRAY_DATA]: data\n      }\n    }\n\n    let result = {}\n    let attribute = Object.keys(data)\n\n    for (let i = 0; i < attribute.length; i++) {\n      if (data[attribute[i]] !== undefined) {\n        switch (NGN.typeof(data[attribute[i]])) {\n          case 'object':\n            Object.defineProperty(\n              result,\n              attribute[i],\n              NGN.public(NGN.DATA.UTIL.serialize(data[attribute[i]]))\n            )\n\n            break\n\n          case 'array':\n            result[attribute[i]] = []\n\n            for (let a = 0; a < data[attribute[i]].length; a++) {\n              result[attribute[i]].push(NGN.DATA.UTIL.serialize(data[attribute[i]]))\n            }\n\n            break\n\n          case 'date':\n            Object.defineProperty(result, attribute[i], NGN.public(data[attribute[i]].toISOString()))\n\n            break\n\n          case 'symbol':\n            if (SERIALIZED_ARRAY_DATA !== attribute[i]) {\n              result[attribute[i]] = data[attribute[i]].toString()\n            }\n\n            break\n\n          case 'regexp':\n            Object.defineProperty(result, attribute[i], NGN.public(data[attribute[i]].toString()))\n\n            break\n\n          case 'weakmap':\n          case 'map':\n            let mapResult = {}\n\n            data[attribute[i]].forEach((value, key) => {\n              mapResult[key.toString()] = this.serialize(value)\n            })\n\n            result[attribute[i]] = mapResult\n\n            break\n\n          case 'weakset':\n          case 'set':\n            if (data[attribute[i]].size === 0) {\n              result[attribute[i]] = []\n              break\n            }\n\n            result[attribute[i]] = this.serialize(Array.from(data[attribute[i]].values()))\n\n            break\n\n          case 'function':\n            break\n\n          default:\n            result[attribute[i]] = data[attribute[i]]\n        }\n      }\n    }\n\n    return result[SERIALIZED_ARRAY_DATA] !== undefined ? result[SERIALIZED_ARRAY_DATA] : result\n  }\n\n  /**\n   * @method isModel\n   * Determines whether an object is an instance of NGN.DATA.Model.\n   * @param {function} PossibleModel\n   * The class or function to be checked.\n   * @returns {boolean}\n   */\n  static isDataModel (Model) {\n    if (Model instanceof NGN.DATA.Model || NGN.typeof(Model) === 'model') {\n      return true\n    }\n\n    if (Model.hasOwnProperty('prototype') && Model.prototype !== null) {\n      let currentElement = Model\n      let count = 0\n\n      while (currentElement.prototype !== null && count < 30) {\n        count++\n\n        currentElement = currentElement.prototype\n\n        if (currentElement instanceof NGN.DATA.Model || NGN.typeof(currentElement) === 'model') {\n          return true\n        }\n      }\n    }\n\n    return Model instanceof NGN.DATA.Entity\n  }\n\n  // /**\n  //  * @method objectByteSize\n  //  * Calculates the _estimated_ size (in bytes) of primitive key/value objects,\n  //  * meaning those that do not contain functions, accessors (getters/setters),\n  //  * or other attributes other than `String`, `Number`, or `Boolean` values.\n  //  * NGN treats dates as `String` values.\n  //  *\n  //  * JavaScript engines differ in how they manage memory, but most do not\n  //  * calculate the size of functions. If a value of type `function` is found in\n  //  * the object, NGN will calculate the size of it's `String` representation.\n  //  * This is a weak measure of function size since most JavaScript engines\n  //  * do not expose enough realtime heap data to know calculate with accuracy at\n  //  * any given point in time.\n  //  *\n  //  * This method attempts to implement similar principles to C's `sizeOf` method.\n  //  *\n  //  * Consider this method to provide a **best guess based on the available data**.\n  //  *\n  //  * @param {Object} object\n  //  * The primitive key/value object upon which the bytesize estimation will be made.\n  //  * @param {Boolean} [ignoreFunctionEstimate=false]\n  //  * By default, NGN will calculate the `String` representation of any functions\n  //  * it encounters in the key/value object. Setting this to `true` will prevent\n  //  * this behavior, effectively using a `0` to calculate function size.\n  //  */\n  // static objectByteSize (obj, ignore=false) {\n  //   switch (typeof obj) {\n  //     case null:\n  //       return 4\n  //\n  //     case 'string':\n  //       return obj.length * 2\n  //\n  //     case 'boolean':\n  //       return 4\n  //\n  //     case 'number':\n  //       return 8\n  //\n  //     case 'function':\n  //       if (!ignore) {\n  //         return obj.toString().length * 2\n  //       }\n  //\n  //       return 0\n  //   }\n  //\n  //   let list = []\n  //   let stack = [obj]\n  //   let bytes = 0\n  //\n  //   while (stack.length) {\n  //     let value = stack.pop()\n  //\n  //     if (typeof value === 'object') {\n  //       if (list.indexOf(value) < 0) {\n  //         list.push(value)\n  //\n  //         // If the object is not an array, add key sizes\n  //         const isArray = !Array.isArray(value)\n  //\n  //         for (let key in value) {\n  //           if (!isArray) {\n  //             bytes += (2 * key.length) + NGN.DATA.util(value[key])\n  //             stack.push(value[key])\n  //           } else {\n  //\n  //           }\n  //         }\n  //       }\n  //     } else {\n  //       bytes += NGN.DATA.UTILITY.objectByteSize(value)\n  //     }\n  //   }\n  //\n  //   return bytes\n  // }\n}\n\nexport { makeCRCTable }\n","import EventEmitter from '../../emitter/core'\n\n/**\n * Inspired by btree.js (c) 2013 Daniel Wirtz <dcode@dcode.io>\n * Released under the Apache License, Version 2.0\n * see: http://github.com/dcodeIO/btree.js for details.\n *\n * Converted to ECMASCript 2016 class syntax & modified to use\n * NGN conventions. Separated code into multiple classes.\n * Copyright (c) 2018, Ecor Ventures LLC.\n * @hidden\n */\nclass TreeNode {\n  constructor (parent = null, leafs = [], nodes = [null]) {\n    Object.defineProperties(this, {\n      parent: NGN.private(parent),\n      leafs: NGN.private(leafs),\n      nodes: NGN.private(nodes),\n\n      METADATA: NGN.private({\n        order: null,\n        minOrder: null,\n\n        /**\n        * Compare two numbers\n        * @param  {number} firstNumber\n        * @param  {number} secondNumber\n        * @return {number}\n        * - Returns `-1` if first number is less than second.\n        * - Returns `0` if numbers are equal.\n        * - Returns `1` if first number is greater than second.\n        */\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })\n    })\n\n    // Associate leafs with parent\n    for (let i = 0; i < this.leafs.length; i++) {\n      this.leafs[i].parent = this\n      // Object.defineProperty(this.leafs[i], 'parent', NGN.get(() => this))\n    }\n\n    // Associate nodes with parent\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (this.nodes[i] !== null) {\n        this.nodes[i].parent = this\n        // Object.defineProperty(this.nodes[i], 'parent', NGN.get(() => this))\n      }\n    }\n  }\n\n  /**\n  * Search for the node that contains the specified key\n  * @param  {any} key\n  * @return {TreeLeaf|TreeNode}\n  */\n  search (key) {\n    if (this.leafs.length > 0) {\n      let a = this.leafs[0]\n\n      if (this.METADATA.compare(a.key, key) === 0) {\n        return {\n          leaf: a,\n          index: 0\n        }\n      }\n\n      if (this.METADATA.compare(key, a.key) < 0) {\n        if (this.nodes[0] !== null) {\n          return this.nodes[0].search(key) // Left\n        }\n\n        return { node: this, index: 0 }\n      }\n\n      let i\n      for (i = 1; i < this.leafs.length; i++) {\n        let b = this.leafs[i]\n\n        if (this.METADATA.compare(b.key, key) === 0) {\n          return {\n            leaf: b,\n            index: i\n          }\n        }\n\n        if (this.METADATA.compare(key, b.key) < 0) {\n          if (this.nodes[i] !== null) {\n            return this.nodes[i].search(key) // Inner\n          }\n\n          return { node: this, index: i }\n        }\n\n        a = b\n      }\n\n      if (this.nodes[i] !== null) {\n        return this.nodes[i].search(key) // Right\n      }\n\n      return { node: this, index: i }\n    }\n\n    return { node: this, index: 0 }\n  }\n\n  /**\n  * Retrieve the value of a key.\n  * @param {number} key\n  * @returns {NGNTreeLeaf}\n  * Returns `undefined` if no leaf is found.\n  */\n  get (key) {\n    let result = this.search(key)\n    return result.leaf ? result.leaf.value : undefined\n  }\n\n  /**\n  * Insert a key/value pair into the node.\n  * @param {number} key\n  * @param {any} value\n  * @param {boolean} [overwrite=true]\n  * Overwrite existing values.\n  */\n  put (key, value, overwrite = true) {\n    let result = this.search(key)\n\n    // Key already exists\n    if (result.leaf) {\n      if (!overwrite) {\n        return\n      }\n\n      result.leaf.value = value\n      return\n    }\n\n    let node = result.node\n    let index = result.index\n\n    node.leafs.splice(index, 0, new TreeLeaf(node, key, value))\n    node.nodes.splice(index + 1, 0, null)\n\n    if (node.leafs.length > this.METADATA.order) {\n      node.split()\n    }\n  }\n\n  /**\n  * Delete key.\n  * @param {number} key\n  */\n  delete (key) {\n    var result = this.search(key)\n\n    if (!result.leaf) {\n      return\n    }\n\n    let leaf = result.leaf\n    let node = leaf.parent\n    let index = result.index\n    let left = node.nodes[index]\n\n    if (left === null) {\n      node.leafs.splice(index, 1)\n      node.nodes.splice(index, 1)\n      node.balance()\n    } else {\n      let max = left.leafs[left.leafs.length - 1]\n\n      left.delete(max.key)\n\n      max.parent = node\n\n      node.leafs.splice(index, 1, max)\n    }\n\n    return true\n  }\n\n  /**\n  * Balance the tree.\n  * @private\n  */\n  balance () {\n    if (this.parent instanceof Tree) {\n      // Root has a single child and no leafs\n      if (this.leafs.length === 0 && this.nodes[0] !== null) {\n        this.parent.root = this.nodes[0]\n        this.parent.root.parent = this.parent\n      }\n\n      return\n    }\n\n    if (this.leafs.length >= this.METADATA.minOrder) {\n      return\n    }\n\n    let index = this.parent.nodes.indexOf(this)\n    let left = index > 0 ? this.parent.nodes[index - 1] : null\n    let right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null\n    let sep\n    let leaf\n    let rest\n\n    if (right !== null && right.leafs.length > this.METADATA.minOrder) {\n      // Append the parent separator\n      sep = this.parent.leafs[index]\n      sep.parent = this\n\n      this.leafs.push(sep)\n\n      // Replace blank with the first right leaf\n      leaf = right.leafs.shift()\n      leaf.parent = this.parent\n\n      this.parent.leafs[index] = leaf\n\n      // Append the right rest\n      rest = right.nodes.shift()\n\n      if (rest !== null) {\n        rest.parent = this\n      }\n\n      this.nodes.push(rest)\n    } else if (left !== null && left.leafs.length > this.METADATA.minOrder) {\n      // Prepend the parent seperator\n      sep = this.parent.leafs[index - 1]\n      sep.parent = this\n\n      this.leafs.unshift(sep)\n\n      // Replace the blank with the last left leaf\n      leaf = left.leafs.pop()\n      leaf.parent = this.parent\n\n      this.parent.leafs[index - 1] = leaf\n\n      // Prepend the left rest to this\n      rest = left.nodes.pop()\n\n      if (rest !== null) {\n        rest.parent = this\n      }\n\n      this.nodes.unshift(rest)\n    } else {\n      let subst\n\n      if (right !== null) {\n        // Combine this + seperator from the parent + right\n        sep = this.parent.leafs[index]\n        subst = new TreeNode(this.parent, this.leafs.concat([sep], right.leafs), this.nodes.concat(right.nodes))\n        subst.METADATA.order = this.METADATA.order\n        subst.METADATA.minOrder = this.METADATA.minOrder\n\n        // Remove the seperator from the parent\n        this.parent.leafs.splice(index, 1)\n\n        // And replace the nodes it seperated with subst\n        this.parent.nodes.splice(index, 2, subst)\n      } else if (left !== null) {\n        // Combine left + seperator from parent + this\n        sep = this.parent.leafs[index - 1]\n        subst = new TreeNode(\n          this.parent,\n          left.leafs.concat([sep], this.leafs),\n          left.nodes.concat(this.nodes)\n        )\n\n        subst.METADATA.minOrder = this.METADATA.minOrder\n        subst.METADATA.order = this.METADATA.order\n\n        // Remove the seperator from the parent\n        this.parent.leafs.splice(index - 1, 1)\n\n        // Replace seperated nodes with subst\n        this.parent.nodes.splice(index - 1, 2, subst)\n      } else {\n        throw new Error(`Internal error: ${this.toString(true)} has neither a left nor a right sibling`)\n      }\n\n      this.parent.balance()\n    }\n  }\n\n  /**\n  * Split the node.\n  */\n  split () {\n    let index = Math.floor(this.leafs.length / 2)\n\n    if (this.parent instanceof Tree) {\n      this.nodes = [\n        new TreeNode(this, this.leafs.slice(0, index), this.nodes.slice(0, index + 1)),\n        new TreeNode(this, this.leafs.slice(index + 1), this.nodes.slice(index + 1))\n      ]\n\n      this.leafs = [this.leafs[index]]\n    } else {\n      let leaf = this.leafs[index]\n      let rest = new TreeNode(\n        this.parent,\n        this.leafs.slice(index + 1),\n        this.nodes.slice(index + 1)\n      )\n\n      this.leafs = this.leafs.slice(0, index)\n      this.nodes = this.nodes.slice(0, index + 1)\n\n      this.parent.unsplit(leaf, rest)\n    }\n  }\n\n  /**\n  * Unsplits a child.\n  * @param {NGNTreeLeaf} leaf\n  * @param {NGNTreeNode} rest\n  * @param {number} [order=52]\n  * @private\n  */\n  unsplit (leaf, rest) {\n    leaf.parent = this\n    rest.parent = this\n\n    let a = this.leafs[0]\n\n    if (this.METADATA.compare(leaf.key, a.key) < 0) {\n      this.leafs.unshift(leaf)\n      this.nodes.splice(1, 0, rest)\n    } else {\n      let i\n      for (i = 1; i < this.leafs.length; i++) {\n        let b = this.leafs[i]\n\n        if (this.METADATA.compare(leaf.key, b.key) < 0) {\n          this.leafs.splice(i, 0, leaf)\n          this.nodes.splice(i + 1, 0, rest)\n          break\n        }\n      }\n\n      if (i === this.leafs.length) {\n        this.leafs.push(leaf)\n        this.nodes.push(rest)\n      }\n    }\n\n    if (this.leafs.length > this.METADATA.order) {\n      this.split()\n    }\n  }\n\n  /**\n  * A string representation of the node.\n  * @param {boolean} [includeNodes=false]\n  * Include sub-nodes\n  * @returns {string}\n  * @private\n  */\n  toString (includeNodes = false) {\n    let value = []\n    let i\n\n    for (i = 0; i < this.leafs.length; i++) {\n      value.push(this.leafs[i].key)\n    }\n\n    let s = `[${value.toString()}]${(this.parent instanceof Tree ? ':*' : ':')}${this.parent}`\n\n    if (includeNodes) {\n      for (i = 0; i < this.nodes.length; i++) {\n        s += ` -> ${this.nodes[i]}`\n      }\n    }\n\n    return s\n  }\n}\n\n/**\n * @hidden\n */\nclass TreeLeaf {\n  /**\n   * Constructs a new Leaf containing a value.\n   * @param {NGNTreeNode} parent\n   * @param {number} key\n   * @param {any} value\n   */\n  constructor (parent, key, value) {\n    Object.defineProperties(this, {\n      parent: NGN.private(parent),\n      key: NGN.private(key),\n      value: NGN.private(value)\n    })\n  }\n\n  toString () {\n    return this.key.toString()\n  }\n}\n\n/**\n * @class NGN.DATA.BTree\n * A O(n) B-tree data type.\n * @private\n */\nexport default class Tree extends EventEmitter {\n  constructor (order = 52) {\n    super()\n\n    // Sanitize input\n    order = order < 1 ? 1 : order\n\n    Object.defineProperties(this, {\n      root: NGN.private(new TreeNode(this)),\n\n      BTREE: NGN.private({}),\n\n      METADATA: NGN.private({\n        order: order,\n\n        minOrder: order > 1 ? Math.floor(order / 2) : 1,\n\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })\n    })\n\n    this.root.METADATA.minOrder = this.METADATA.minOrder\n    this.root.METADATA.order = this.METADATA.order\n  }\n\n  /**\n   * Validates a node and prints debugging info if something went wrong.\n   * @param {!TreeNode|!Tree} node\n   * @private\n   */\n  validate (node) {\n    if (node instanceof Tree) {\n      return\n    }\n\n    if (node.leafs.length + 1 !== node.nodes.length) {\n      NGN.ERROR(`Illegal leaf/node count in ${node}: ${node.leafs.length}/${node.nodes.length}`)\n    }\n\n    let i\n\n    for (i = 0; i < node.leafs.length; i++) {\n      if (!node.leafs[i]) {\n        NGN.ERROR(`Illegal leaf in ${node} at ${i}: ${node.leafs[i]}`)\n      }\n    }\n\n    for (i = 0; i < node.nodes.length; i++) {\n      if (NGN.typeof(node.nodes[i]) === 'undefined') {\n        NGN.ERROR(`Illegal node in ${node} at ${i}: undefined`)\n      }\n    }\n  }\n\n  /**\n   * Insert a key/value pair into the tree.\n   * @param {number} key\n   * @param {any} value\n   * @param {boolean} [overwrite=true]\n   * Overwrite existing values\n   */\n  put (key, value, overwrite = true) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    if (value === undefined) {\n      throw new Error(`Illegal value: ${value}`)\n    }\n\n    return this.root.put(key, value, overwrite)\n  }\n\n  /**\n   * Retrieve the value for the specified key.\n   * @param {number} key\n   * @returns {any}\n   * If there is no such key, `undefined` is returned.\n   */\n  get (key) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    return this.root.get(key)\n  }\n\n  /**\n   * Delete a key from the tree.\n   * @param {number} key\n   */\n  delete (key) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    return this.root.delete(key)\n  }\n\n  /**\n   * Walk through all keys in ascending order.\n   * @param {number} minKey\n   * If omitted or NULL, starts at the beginning\n   * @param {number} maxKey\n   * If omitted or NULL, walks till the end\n   * @param {function} callback\n   * @param {number} callback.key\n   * The key\n   * @param {any} callback.value\n   * The value.\n   */\n  walk (minKey, maxKey, callback) {\n    if (this.root.leafs.length === 0) {\n      return\n    }\n\n    if (NGN.isFn(minKey)) {\n      callback = minKey\n      minKey = maxKey = null\n    } else if (NGN.isFn(maxKey)) {\n      callback = maxKey\n      maxKey = null\n    }\n\n    minKey = NGN.coalesce(minKey)\n    maxKey = NGN.coalesce(maxKey)\n\n    let ptr\n    let index\n\n    if (minKey === null) {\n      // No minimum limit\n      ptr = this.root\n\n      while (ptr.nodes[0] !== null) {\n        ptr = ptr.nodes[0]\n      }\n\n      index = 0\n    } else {\n      // lookup\n      let result = this.root.search(minKey)\n\n      if (result.leaf) {\n        // Minimum key itself exists\n        ptr = result.leaf.parent\n        index = ptr.leafs.indexOf(result.leaf)\n      } else {\n        // Key does not exist\n        ptr = result.node\n        index = result.index\n\n        if (index >= ptr.leafs.length) {\n          // begin at parent separator in overrun\n          if (ptr.parent instanceof Tree || ptr.parent.nodes.indexOf(ptr) >= ptr.parent.leafs.length) {\n            return\n          }\n\n          ptr = ptr.parent\n        }\n      }\n    }\n\n    // ptr/index points to first result\n    while (true) {\n      if (maxKey !== null && this.METADATA.compare(ptr.leafs[index].key, maxKey) > 0) {\n        break\n      }\n      if (ptr.leafs.length === 0) {\n        break\n      }\n\n      if (callback(ptr.leafs[index].key, ptr.leafs[index].value)) {\n        break\n      }\n\n      if (ptr.nodes[index + 1] !== null) {\n        // Descend Tree\n        ptr = ptr.nodes[index + 1]\n        index = 0\n\n        while (ptr.nodes[0] !== null) {\n          ptr = ptr.nodes[0]\n        }\n      } else if (ptr.leafs.length > index + 1) {\n        // Next\n        index++\n      } else {\n        // Ascend Tree\n        do {\n          if ((ptr.parent instanceof Tree)) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr)\n          ptr = ptr.parent\n        } while (index >= ptr.leafs.length)\n      }\n    }\n  }\n\n  /**\n   * Walks through all keys in descending order.\n   * @param {number} minKey\n   * If omitted or NULL, starts at the beginning\n   * @param {number} maxKey\n   * If omitted or NULL, walks till the end\n   * @param {function} callback\n   * @param {number} callback.key\n   * The key\n   * @param {any} callback.value\n   * The value.\n   */\n  walkDesc (minKey, maxKey, callback) {\n    if (NGN.isFn(minKey)) {\n      callback = minKey\n      minKey = maxKey = null\n    } else if (NGN.isFn(maxKey)) {\n      callback = maxKey\n      maxKey = null\n    }\n\n    minKey = NGN.coalesce(minKey)\n    maxKey = NGN.coalesce(maxKey)\n\n    let ptr\n    let index\n    if (maxKey === null) {\n      // No maximum\n      ptr = this.root\n\n      while (ptr.nodes[ptr.nodes.length - 1] !== null) {\n        ptr = ptr.nodes[ptr.nodes.length - 1]\n      }\n\n      index = ptr.leafs.length - 1\n    } else {\n      // Lookup\n      let result = this.root.search(maxKey)\n\n      if (result.leaf) {\n        // Maximum key exists\n        ptr = result.leaf.parent\n        index = ptr.leafs.indexOf(result.leaf)\n      } else {\n        // Key does not exist\n        ptr = result.node\n        index = result.index - 1\n\n        while (index < 0) {\n          // Begin at parent separator on underrun\n          if (ptr.parent instanceof Tree) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr) - 1\n\n          if (index < 0) {\n            return\n          }\n\n          ptr = ptr.parent\n        }\n      }\n    }\n\n    // ptr/index points to first result\n    while (true) {\n      if (minKey !== null && this.METADATA.compare(ptr.leafs[index].key, minKey) < 0) {\n        break\n      }\n\n      if (callback(ptr.leafs[index].key, ptr.leafs[index].value)) {\n        break\n      }\n\n      if (ptr.nodes[index] !== null) {\n        // Descend Tree\n        ptr = ptr.nodes[index]\n\n        while (ptr.nodes[ptr.nodes.length - 1] !== null) {\n          ptr = ptr.nodes[ptr.nodes.length - 1]\n        }\n\n        index = ptr.leafs.length - 1\n      } else if (index > 0) {\n        // Next\n        index--\n      } else {\n        // Ascend Tree\n        do {\n          if ((ptr.parent instanceof Tree)) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr) - 1\n\n          ptr = ptr.parent\n        } while (index < 0)\n      }\n    }\n  }\n\n  /**\n   * The number of keys between minKey and maxKey (both inclusive).\n   * @param {number} minKey\n   * If omitted, counts from the start\n   * @param {number} maxKey\n   * If omitted, counts till the end\n   * @returns {number}\n   */\n  count (minKey, maxKey) {\n    let n = 0\n\n    this.walk(\n      minKey !== undefined ? minKey : null,\n      maxKey !== undefined ? maxKey : null,\n      (key, value) => { n++ }\n    )\n\n    return n\n  };\n\n  /**\n   * A string representation of the tree.\n   * @returns {string}\n   */\n  toString () {\n    return `Tree(${this.METADATA.order}) ${this.root.toString()}`\n  }\n\n  get length () {\n    return this.count()\n  }\n}\n","import EventEmitter from '../emitter/core'\n\n/**\n * @class NGN.DATA.TransactionLog\n * The transaction log is a history/changelog. It can be used to revert values\n * to a prior state or (in limited cases) restore values.\n *\n * The transaction log is based on a commit log and cursor. The commit log\n * is an ordered list of values. The cursor is a position within the log.\n *\n * **How it Works:**\n *\n * The most common purpose of a transaction log is to revert changes (undo).\n * This is accomplished with the #rollback method.\n *\n * The #rollback method does not remove records, nor does the #advance.\n * The methods repositions the log cursor. Only #commit activities actually\n * modify the log.\n *\n * For example, a log containing 5 committed records will have the cursor set to\n * the latest entry by default:\n *\n * ```\n * [1, 2, 3, 4, 5]\n *              ^\n * ```\n *\n * Executing rollback(2) moves the cursor \"back\" two positions, from `5` to\n * `3`.\n *\n * ```\n * [1, 2, 3, 4, 5]\n *        ^\n * ```\n *\n * At this point, no records have been removed. It would still be\n * possible to #advance the cursor forward to `4` or `5`. However; once a\n * #commit is executed, all logs _after_ the cursor are removed before the new\n * transaction is committed to the log.\n *\n * ```\n * [1, 2, 3] // Commit removes [4, 5]\n *        ^\n *\n * [1, 2, 3, 6] // Commit commits new entry and advances cursor.\n *           ^\n * ```\n *\n * It is also possible to immediately #flush the log without requiring a new\n * #commit. This will immediately remove all log entries after the\n * current cursor position.\n */\nexport default class NGNTransactionLog extends EventEmitter { // eslint-disable-line\n  /**\n   * Create a new transaction log.\n   * @param  {number} [maxEntryCount=10]\n   * The maximum number of entries to keep in the log. Set this to `-1` to keep\n   * an unlimited number of logs.\n   */\n  constructor (maxEntryCount) {\n    super()\n\n    Object.defineProperties(this, {\n      METADATA: NGN.private({\n        transaction: {},\n        changeOrder: [],\n        cursor: null,\n        max: NGN.coalesce(maxEntryCount, 10)\n      })\n    })\n  }\n\n  get length () {\n    return this.METADATA.changeOrder.length\n  }\n\n  /**\n   * @property {Symbol} cursor\n   * The active cursor of the log.\n   */\n  get cursor () {\n    return this.METADATA.cursor\n  }\n\n  set cursor (value) {\n    if (value !== null && !this.METADATA.transaction.hasOwnProperty(value)) {\n      throw new Error('Cannot set cursor for transaction log (does not exist).')\n    }\n\n    this.METADATA.cursor = value\n  }\n\n  /**\n   * @property {any} currentValue\n   * Returns the value at the current cursor position.\n   */\n  get currentValue () {\n    if (this.METADATA.cursor === null) {\n      return undefined\n    }\n\n    return this.getCommit(this.METADATA.cursor).value\n  }\n\n  /**\n   * @property {Number}\n   * The index of the log entry at the current cursor position.\n   */\n  get cursorIndex () {\n    if (this.METADATA.cursor === null) {\n      return undefined\n    }\n\n    return this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n  }\n\n  /**\n   * Add a new value to the transaction log.\n   * @param {Any} value\n   * The value to assign to the log (record).\n   * @return {Number}\n   * Returns the transaction number\n   * @fires log {Symbol}\n   * Fires a log event with the transaction ID (symbol) for reference.\n   */\n  commit (value) {\n    let id = typeof value === 'symbol' ? Symbol(String(value)) : Symbol(NGN.coalesce(value, NGN.typeof(value)).toString())\n\n    this.METADATA.transaction[id] = [\n      new Date(),\n      value\n    ]\n\n    this.flush()\n\n    this.METADATA.changeOrder.push(id)\n    this.METADATA.cursor = id\n\n    if (this.METADATA.max > 0 && this.METADATA.changeOrder.length > this.METADATA.max) {\n      let removedId = this.METADATA.changeOrder.shift()\n      delete this.METADATA.transaction[removedId]\n    }\n\n    this.emit('commit', id, null)\n\n    return id\n  }\n\n  /**\n   * Return the entry for the specified commit ID.\n   * @param  {Symbol} id\n   * The transaction ID.\n   * @return {Object}\n   * Returns an object with `timestamp` and `value` keys.\n   */\n  getCommit (id = null) {\n    if (!this.METADATA.transaction.hasOwnProperty(id)) {\n      return undefined\n    }\n\n    return {\n      timestamp: this.METADATA.transaction[id][0],\n      value: this.METADATA.transaction[id][1]\n    }\n  }\n\n  /**\n   * Remove all transaction log entries from the current cursor onward.\n   */\n  flush () {\n    if (this.METADATA.cursor === null) {\n      return\n    }\n\n    let position = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n\n    // If the whole log is cleared, reset it silently.\n    if (position === 0) {\n      return\n    }\n\n    let removedEntries = this.METADATA.changeOrder.splice(position + 1)\n\n    for (let i = 0; i < removedEntries.length; i++) {\n      delete this.METADATA.transaction[removedEntries[i]]\n    }\n\n    this.METADATA.cursor = this.METADATA.changeOrder[this.METADATA.changeOrder.length - 1]\n  }\n\n  /**\n   * Rollback the log to the specified index/cursor.\n   * @param  {Number|Symbol} [index=1]\n   * The index may be a number or a commit ID (symbol).\n   *\n   * **Specifying a number** will rollback the log by the specified number of\n   * commits. By default, the index is `1`, which is the equivalent of a simple\n   * \"undo\" operation. Specifying `2` would \"undo\" two operations. Values less\n   * than or equal to zero are ignored. Values greater than the total number of\n   * committed transactions trigger a reset.\n   *\n   * **Specifying a symbol** will rollback the log to the specified commit log\n   * (the symbol is the commit log ID).\n   * @fires rollback {Object}\n   * This fires a `rollback` event containing the active cursor.\n   * @return {Symbol}\n   * Returns the active cursor upon completion of rollback.\n   */\n  rollback (index = 1) {\n    // If the log is empty, ignore the rollback\n    if (this.METADATA.changeOrder.length === 0) {\n      return null\n    }\n\n    if (typeof index === 'symbol') {\n      this.cursor = index\n      return index\n    }\n\n    if (index >= this.METADATA.changeOrder.length) {\n      this.METADATA.cursor = this.METADATA.changeOrder[0]\n    } else {\n      // Make sure the index is a symbol\n      if (typeof index === 'number') {\n        if (index <= 0) {\n          return this.METADATA.cursor\n        }\n\n        let currentPosition = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n        currentPosition -= index\n\n        if (currentPosition <= 0) {\n          currentPosition = 0\n        }\n\n        index = this.METADATA.changeOrder[currentPosition]\n      }\n\n      this.METADATA.cursor = index\n    }\n\n    this.emit('rollback', this.METADATA.cursor, null)\n\n    return this.METADATA.cursor\n  }\n\n  /**\n   * Advance the log to the specified index/cursor.\n   * @param  {Number|Symbol} [index=1]\n   * The index may be a number or a commit ID (symbol).\n   *\n   * **Specifying a number** will advance the log by the specified number of\n   * commits. By default, the index is `1`, which is the equivalent of a simple\n   * \"redo\" operation. Specifying `2` would \"redo\" two operations. Values less\n   * than or equal to zero are ignored. Values greater than the total number of\n   * committed transactions will advance the cursor to the last entry.\n   *\n   * **Specifying a symbol** will advance the log to the specified commit log\n   * record (the symbol is the commit log ID).\n   * @fires advance {Object}\n   * This fires a `advance` event containing the active cursor.\n   * @return {Symbol}\n   * Returns the active cursor upon completion of rollback.\n   */\n  advance (index = 1) {\n    // If the log is empty, ignore the rollback\n    if (this.METADATA.changeOrder.length === 0) {\n      return null\n    }\n\n    // Make sure the index is a symbol\n    if (typeof index === 'number') {\n      if (index <= 0) {\n        return this.METADATA.cursor\n      }\n\n      let currentPosition = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n      currentPosition += index\n\n      if (currentPosition >= this.METADATA.changeOrder.length) {\n        currentPosition = this.METADATA.changeOrder.length - 1\n      }\n\n      index = this.METADATA.changeOrder[currentPosition]\n    }\n\n    this.METADATA.cursor = index\n\n    this.emit('advance', this.METADATA.cursor, null)\n\n    return this.METADATA.cursor\n  }\n\n  /**\n   * Clear the transaction log.\n   */\n  reset (suppressEvents = false) {\n    this.METADATA.transaction = {}\n    this.METADATA.changeOrder = []\n    this.METADATA.cursor = null\n\n    if (!suppressEvents) {\n      this.emit('reset')\n    }\n  }\n\n  /**\n   * @property {Array} log\n   * Returns the entire log, in ascending historical order (oldest first).\n   * This may be a time-consuming operation if the log is large.\n   *\n   * **Example:**\n   *\n   * ```js\n   * [{\n   *   timestamp: Date,\n   *   value: 'some value'\n   * },{\n   *   timestamp: Date,\n   *   value: 'some other value'\n   * }]\n   */\n  get log () {\n    return this.METADATA.changeOrder.map(entry => {\n      return {\n        timestamp: this.METADATA.transaction[entry][0],\n        value: this.METADATA.transaction[entry][1],\n        activeCursor: this.METADATA.cursor === entry\n      }\n    })\n  }\n}\n","/**\n  * @class NGN.DATA.Rule\n  * A data validation rule.\n  * @fires validator.add\n  */\nexport default class NGNDataValidationRule { // eslint-disable-line\n  /**\n   * Create a new data rule.\n   * @param {Function/String[]/Number[]/Date[]/RegExp/Array} rule\n   * * When rule is a _function_, the value is passed to it as an argument.\n   * * When rule is a _String_, the value is compared for an exact match (case sensitive)\n   * * When rule is a _Number_, the value is compared for equality.\n   * * When rule is a _Date_, the value is compared for exact equality.\n   * * When rule is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n   * * When rule is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n   * * When rule is _an array of dates_, the value is compared to each date for equality.\n   * @param {string} [name]\n   * An optional name for the rule. This can be useful when debugging data issues.\n   * @param {object} [scope]\n   * Apply a custom scope to the validation functions (applicable to custom methods only).\n   */\n  constructor (validation, name = null, scope = null) {\n    const type = NGN.typeof(validation)\n\n    Object.defineProperties(this, {\n      RULE: NGN.private({\n        type,\n        validator: validation,\n        name: NGN.coalesce(name, `Untitled ${type.toUpperCase()} Validation`),\n        scope: NGN.coalesce(scope, this)\n      })\n    })\n  }\n\n  get name () {\n    return this.RULE.name\n  }\n\n  get type () {\n    return this.RULE.type\n  }\n\n  /**\n   * @method test\n   * Test a value against the validation rule.\n   * @param {any} value\n   * The value to test.\n   * @returns {boolean}\n   * Returns `true` when the value meets the rule expectations and `false` when it does not.\n   */\n  test (value) {\n    if (NGN.isFn(this.RULE.validator)) {\n      // Custom enforcement function\n      return this.RULE.validator.apply(this.RULE.scope, [value])\n    } else {\n      switch (this.type) {\n        // Enumeration\n        case 'array':\n          return this.RULE.validator.indexOf(value) !== -1\n\n        // Pattern Matching\n        case 'regexp':\n          return this.RULE.validator.test(value)\n\n        default:\n          return this.RULE.validator === value\n      }\n    }\n  }\n}\n","import Rule from './Rule'\n\n/**\n * @class NGN.DATA.RangeRule\n * A special rule to validate values within one or more ranges.\n * Supports numeric ranges, date ranges, and simple string-based\n * ranges (string length).\n */\nexport default class NGNDataRangeValidationRule extends Rule { // eslint-disable-line\n  /**\n   * Create a new range rule.\n   * @param {string} [name]\n   * An optional name for the rule. This can be useful when debugging data issues.\n   * @param {object} [scope=null]\n   * Apply a custom scope to the validation functions (applicable to custom methods only).\n   * @param {Array} [range]\n   * An enumeration of acceptable numeric ranges. For example, if\n   * the value must be between 5-10 or from 25-50, the configuration\n   * would look like:\n   *\n   * ```js\n   * range: [\n   *   [5, 10],\n   *   ['25-50']\n   * ]\n   * ```\n   *\n   * To accept anything below a certain number or anything over a certain\n   * number while also specifying one or more ranges, use a `null` value.\n   *\n   * For example:\n   *\n   * ```js\n   * range: [\n   *   [null, 0],\n   *   [5, 10],\n   *   ['25-50'],\n   *   [100, null]\n   * ]\n   * ```\n   *\n   * The aforementioned example would accept a value less than `zero`,\n   * between `5` and `10`, between `25` and `50`, or over `100`. Therefore,\n   * acceptable values could be `-7`, `7`, `25`, `42`,  `10000`, or anything\n   * else within the ranges. However, the values `3`, `19`, and `62` would\n   * all fail because they're outside the ranges.\n   */\n  constructor (name, scope, range = []) {\n    if (NGN.typeof(scope) === 'array') {\n      range = scope\n      scope = null\n    }\n\n    super(null, name, scope)\n\n    this.RULE.prepareRange = function (value) {\n      // If a simple range is specified (single array), format it for the rule processor.\n      value = NGN.forceArray(value)\n\n      if (NGN.typeof(value[0]) !== 'array') {\n        value = [value]\n      }\n\n      for (let i = 0; i < value.length; i++) {\n        if (value[i].length !== 2) {\n          if (NGN.typeof(value[i][0]) !== 'string') {\n            throw new Error(`Invalid range: \"${value[i].toString()}\"`)\n          }\n\n          value[i] = value[i][0].replace(/[^0-9->]/gi, '').split(/->{1,100}/)\n        }\n\n        if (NGN.typeof(value[i][0]) !== 'number') {\n          value[i][0] = NGN.coalesce(value[i][0], '').replace(/null|none|any/gi, '')\n        }\n\n        if (NGN.typeof(value[i][1]) !== 'number') {\n          value[i][1] = NGN.coalesce(value[i][1], '').replace(/null|none|any/gi, '')\n        }\n      }\n\n      return value\n    }\n\n    // Initialize the range\n    this.RULE.range = new Set()\n    this.range = range\n\n    // Create the validation function.\n    this.RULE.validator = (value) => {\n      let isString = NGN.typeof(value) === 'string'\n      let range = this.range\n\n      for (let i = 0; i < range.length; i++) {\n        let min = NGN.coalesceb(range[i][0], isString ? value.length : value)\n        let max = NGN.coalesceb(range[i][1], isString ? value.length : value)\n\n        if (\n          (isString && value.length >= min && value.length <= max) ||\n          (!isString && value >= min && value <= max)\n        ) {\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n\n  get range () {\n    return Array.from(this.RULE.range.values())\n  }\n\n  set range (value) {\n    this.RULE.range = new Set()\n    this.addRange(value)\n  }\n\n  /**\n   * Add a range to the rule.\n   * @param {array} value\n   * A range can be a single array, such as `[min, max]`. An array of arrays is\n   * also acceptable, such as `[[min1, max1], [min2, max2]]`.\n   */\n  addRange (value) {\n    value = this.RULE.prepareRange(value)\n\n    for (let i = 0; i < value.length; i++) {\n      if (NGN.coalesceb(value[i][0]) !== null && NGN.coalesceb(value[i][1]) !== null && value[i][1] < value[i][0]) {\n        throw new Error(`Invalid value \"${value[i][0].toString()} -> ${value[i][1].toString()}\". Minimum value cannot exceed maximum.`)\n      }\n\n      this.RULE.range.add(value[i])\n    }\n  }\n\n  /**\n   * Remove an existing range from the rule.\n   * @param {array} value\n   * A range can be a single array, such as `[min, max]`. An array of arrays is\n   * also acceptable, such as `[[min1, max1], [min2, max2]]`.\n   */\n  removeRange (value) {\n    let range = this.range\n    value = this.RULE.prepareRange(value)\n\n    for (let i = 0; i < value.length; i++) {\n      for (let x = 0; x < range.length; x++) {\n        if (value[i].toString() === range[x].toString()) {\n          this.RULE.range.delete(range[x])\n        }\n      }\n    }\n  }\n}\n","import EventEmitter from '../../emitter/core'\n\n/**\n * @class NGN.DATA.Field\n * Represents a data field to be used in a model/record.\n * @fires hidden\n * Triggered when the field changes from unhidden to hidden.\n * @fires unhidden\n * Triggered when the field changes from hidden to unhidden.\n * @fires update {object}\n * Triggered when the field value is updated. The payload contains\n * an object with old and new values:\n *\n * ```js\n * {\n *   old: 'old value',\n *   new: 'new value'\n * }\n * ```\n * @fires invalid\n * Triggered when a previously valid value becomes invalid.\n * @fires valid\n * Triggered when a previously invalid value becomes valid.\n * @fires rule.add {NGN.DATA.Rule}\n * Triggered when a new validation rule is added. The rule is emitted\n * to event handlers.\n * @fires rule.remove {NGN.DATA.Rule}\n * Triggered when a validation rule is removed. The rule is emitted\n * to event handlers.\n * @fires keystatus.changed {boolean}\n * Triggered when the key (identifier) status changes. The boolean\n * payload indicates whether the field is considered an identifier.\n */\nexport default class NGNDataField extends EventEmitter { // eslint-disable-line\n  /**\n   * @param {string|object} configuration\n   * Accepts an object with all configuration objects, or a string representing\n   * the name of the field.\n   */\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    if (typeof cfg === 'string') {\n      cfg = {\n        name: cfg\n      }\n    }\n\n    // Validate field configuration values\n    if (cfg.hasOwnProperty('pattern') && NGN.typeof(cfg.pattern) !== 'regexp') {\n      throw new Error('Invalid data field configuration. Pattern must be a valid JavaScript regular expression (RegExp).')\n    }\n\n    if (cfg.type === undefined) {\n      if (cfg.default) {\n        cfg.type = NGN.getType(NGN.typeof(cfg.default), String)\n      }\n    }\n\n    super(cfg)\n\n    const EMPTYDATA = Symbol('empty')\n\n    Object.defineProperties(this, {\n      METADATA: NGN.privateconst({\n        /**\n         * @cfg {boolean} [required=false]\n         * Indicates the value is required.\n         */\n        required: NGN.coalesce(cfg.required, false),\n\n        /**\n         * @cfgproperty {boolean} [hidden=false]\n         * Indicates the field is hidden (metadata).\n         */\n        hidden: NGN.coalesce(cfg.hidden, false),\n\n        // Identifies the property as a standard data attribute.\n        // Alternative options include `data`, `key`, `join`, `virtual`.\n        fieldType: NGN.coalesce(cfg.identifier, false) ? 'key' : 'data',\n\n        isIdentifier: NGN.coalesce(cfg.identifier, false),\n\n        /**\n         * @cfg {boolean} [autocorrectInput=true]\n         * Attempt to automatically correct data type values. For example,\n         * a numeric field receiving a value of `'10'` will automatically\n         * convert the input to `10`. Only arrays, numbers, and booleans are\n         * supported. See NGN#forceArray, NGN#forceBoolean, and NGN#forceNumber\n         * for details.\n         */\n        autocorrectInput: NGN.coalesce(cfg.autocorrectInput, false),\n\n        /**\n         * @cfg {RegExp} [pattern]\n         * A pattern, as defined by a standard RegExp, that the data must match.\n         */\n        pattern: NGN.coalesceb(cfg.pattern),\n\n        /**\n         * @cfgproperty {string} name\n         * The field name.\n         */\n        name: NGN.coalesce(cfg.name),\n\n        /**\n         * @cfgproperty {string} description\n         * This is a metadata field, primarily used for documentation\n         * or schema generation purposes.\n         */\n        description: NGN.coalesce(cfg.description, `${NGN.typeof(cfg.type)} field`),\n\n        /**\n         * @cfgproperty {string} [sourceName]\n         * A source name represents the physical name of an attribute as it\n         * would be recognized in a system of record. For example, a field\n         * named `firstname` may need to be written to disk/memory as `gn`\n         * (commonly used as shorthand for givenName in LDAP environments\n         * and relational databases).\n         *\n         * By specifying `firstname` as the field name and `gn` as the source\n         * name, the field will automatically map values from the source\n         * to model name and vice versa.\n         *\n         * For instance, a JSON input may look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"John\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         *\n         * When this data is applied to the field (or loaded in a\n         * NGN.DATA.Model), the field #value for `firstname` would be `John`.\n         * If the field #value is changed to `Jill` (i.e.\n         * `firstname.value = 'Jill'`), the resulting data set would look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"Jill\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         */\n        sourceName: NGN.coalesce(cfg.sourceName),\n\n        /**\n         * @cfg {any} default\n         * The default value of the field when no value is specified.\n         */\n        default: NGN.coalesce(cfg.default),\n\n        lastValue: Symbol('no.value'),\n\n        /**\n         * @cfg {Primitive} [type=String]\n         * The JS primitive representing the type of data represented\n         * by the field.\n         */\n        dataType: NGN.coalesce(cfg.type, String),\n\n        /**\n         * @cfg {function} [rule[]]\n         * A function, or an array of functions, which determine whether the\n         * field value is valid or not. These functions receive a single argument\n         * (the data value) and must return a Boolean value.\n         */\n        rules: NGN.coalesce(cfg.rule, cfg.rules, cfg.validators, []),\n        violatedRule: null,\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * If this is set to `false`, invalid values will throw an error.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {function} transformer\n         * A synchronous transformation function will be applied each time\n         * the field value is set. This can be used to modify data _before_ it\n         * is stored as a field value. The returned value from the function\n         * will be the new value of the field.\n         *\n         * The transformation function will receive the input as it's only\n         * aregument. For example:\n         *\n         * ```js\n         * let field = new NGN.DATA.Field({\n         *   name: 'testfield',\n         *   transformer: function (input) {\n         *     return input + '_test'\n         *   }\n         * })\n         *\n         * field.value = 'a'\n         *\n         * console.log(field.value) // Outputs \"a_test\"\n         * ```\n         *\n         * **Transformations can affect performance.** In small data sets,\n         * transformations are typically negligible, only adding a few\n         * milliseconds to processing time. This may affect large data sets,\n         * particularly data stores using defauly bulk recod loading.\n         */\n        TRANSFORM: NGN.coalesce(cfg.transformer),\n\n        RAWDATAPLACEHOLDER: EMPTYDATA,\n        RAW: EMPTYDATA,\n        ENUMERABLE_VALUES: null,\n        REVERSE_ENUMERABLE_VALUES: null,\n        IS_NEW: true,\n\n        EVENTS: new Set([\n          'hidden',\n          'unhidden',\n          'update',\n          'invalid',\n          'valid',\n          'rule.add',\n          'rule.remove'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n\n        /**\n         * @cfg {Number} [auditMaxEntries=20]\n         * The maximum number of historical records to maintain for the field.\n         * See NGN.DATA.TransactionLog#constructor for details.\n         */\n        AUDITLOG: NGN.coalesce(cfg.audit, false)\n          ? new NGN.DATA.TransactionLog(NGN.coalesce(cfg.auditMaxEntries, 10))\n          : null,\n\n        /**\n         * @cfg {NGN.DATA.Model} [model]\n         * Optionally specify the parent model.\n         */\n        model: null,\n\n        // Set the value using a configuration.\n        setValue: (value, suppressEvents = false, ignoreAudit = false) => {\n          // Preprocessing (transform input)\n          if (this.METADATA.TRANSFORM !== null && NGN.isFn(this.METADATA.TRANSFORM)) {\n            value = this.METADATA.TRANSFORM.call(this, value)\n          }\n\n          // Attempt to auto-correct input when possible.\n          if (this.METADATA.autocorrectInput && this.type !== NGN.typeof(value)) {\n            value = this.autoCorrectValue(value)\n          }\n\n          // Ignore changes when the value hasn't been modified.\n          if (value === this.value) {\n            return\n          }\n\n          let change = {\n            field: this,\n            old: typeof this.METADATA.RAW === 'symbol' ? undefined : this.METADATA.RAW,\n            new: value\n          }\n\n          let priorValueIsValid = this.valid\n\n          this.METADATA.RAW = value\n\n          // Notify when an invalid value is detected.\n          if (!this.valid) {\n            // If invalid values are explicitly prohibited, throw an error.\n            // The value is rolled back before throwing the error so developers may\n            // catch the error and continue processing.\n            if (!this.METADATA.allowInvalid) {\n              this.METADATA.RAW = change.old\n              throw new Error(`\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`)\n            } else {\n              change.reason = `\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`\n              NGN.WARN(change.reason)\n            }\n\n            this.emit('invalid', change)\n          } else if (!suppressEvents && priorValueIsValid !== null && priorValueIsValid) {\n            // If the field BECAME valid (compared to prior value),\n            // emit an event.\n            this.emit('valid', change)\n          }\n\n          if (typeof this.METADATA.lastValue === 'symbol') {\n            this.METADATA.lastValue = value\n          }\n\n          // If auditing is enabled and not explicitly ignored by an internal\n          // operation, commit the change.\n          if (!ignoreAudit && !this.virtual && this.METADATA.AUDITABLE) {\n            change.cursor = this.METADATA.AUDITLOG.commit(this.METADATA.RAW)\n          }\n\n          // Notify when the update is complete.\n          if (!suppressEvents) {\n            this.emit('update', change)\n          }\n\n          // Mark unnecessary code for garbage collection.\n          priorValueIsValid = null\n          change = null\n        },\n\n        // Submit the payload to the parent model (if applicable).\n        commitPayload: (payload) => {\n          if (this.METADATA.model) {\n            payload.action = 'update'\n            payload.join = true\n\n            this.increaseMaxListeners(3)\n            this.METADATA.model.emit(\n              [\n                'update',\n                `${payload.field}.update`,\n                `update.${payload.field}`\n              ],\n              payload\n            )\n\n            payload = null // Mark for garbage collection\n          }\n        }\n      })\n    })\n\n    // Apply common rules\n    if (NGN.typeof(this.METADATA.rules) !== 'array') {\n      this.METADATA.rules = NGN.forceArray(this.METADATA.rules)\n    }\n\n    if (this.METADATA.rules.length > 0) {\n      for (let i = 0; i < this.METADATA.rules.length; i++) {\n        if (NGN.isFn(this.METADATA.rules[i]) && !(this.METADATA.rules[i] instanceof NGN.DATA.Rule)) {\n          this.METADATA.rules[i] = new NGN.DATA.Rule(this.METADATA.rules[i], `Custom Rule #${i + 1}`)\n        }\n      }\n    }\n\n    // Apply pattern validation if specified.\n    if (this.METADATA.dataType === String) {\n      if (this.METADATA.pattern !== null) {\n        this.METADATA.rules.unshift(new NGN.DATA.Rule(cfg.pattern, `Pattern Match (${cfg.pattern.toString()})`))\n      }\n\n      /**\n       * @cfg {Boolean} [nonempty]\n       * @info This validation attribute applies to #String fields only.\n       * Validates a value is not blank, `null`, or `undefined`.\n       */\n      if (cfg.nonempty) {\n        this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n          return value.trim().length > 0\n        }, `No Blanks (${cfg.pattern.toString()})`))\n      }\n    }\n\n    /**\n     * @cfg {Number} [min]\n     * @info This validation attribute applies to #Array, #String, and #Number fields only.\n     * Specify a minimum value:\n     *\n     * - For string values, this is a minimum number of characters.\n     * - For numeric values, this is a minimum inclusive value (i.e. value must be greater than\n     * or equal to the minimum).\n     * - For arrays, this is a minimum number of items that must exist in the array.\n     */\n    /**\n     * @cfg {Number} [max]\n     * @info This validation attribute applies to #Array, #String, and #Number fields only.\n     * Specify a maximum value:\n     *\n     * - For string values, this is a maximum number of characters.\n     * - For numeric values, this is a maximum inclusive value (i.e. value must be less than\n     * or equal to the maximum).\n     * - For arrays, this is a maximum number of items that may exist in the array.\n     */\n\n    // Apply number-specific validations.\n    if (this.METADATA.dataType === Number || this.METADATA.dataType === Date || this.METADATA.dataType === String) {\n      // Support minimum/maximum range\n      if (NGN.objectHasAny(cfg, 'min', 'minimum', 'max', 'maximum')) {\n        cfg.range = NGN.forceArray(NGN.coalesce(cfg.range))\n        cfg.range.push([NGN.coalesce(cfg.min, cfg.minimum), NGN.coalesce(cfg.max, cfg.maximum)])\n      }\n\n      /**\n       * @cfg {Number} [range]\n       * @info This validation attribute applies to #String and #Number fields only.\n       * Specify a range of acceptable values:\n       *\n       * - For numbers, this implies inclusive ranges. For example, `1-10` means \"between 1 and 10, where both 1 and 10 are valid.\"\n       * - For strings, this implies inclusive ranges just like numbers, where the number is the character count.\n       */\n      if (cfg.hasOwnProperty('range')) {\n        this.METADATA.rules.unshift(new NGN.DATA.RangeRule('Numeric Range', cfg.range))\n      }\n\n      if (this.METADATA.dataType === Number) {\n        // Support numeric patterns (i.e. support for integers)\n        if (NGN.coalesce(cfg.pattern)) {\n          this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n            return cfg.pattern.test(value.toString())\n          }, `Numeric Pattern (${cfg.pattern.toString().substr(0, 15) + (cfg.pattern.toString().length > 15 ? '...' : '')})`))\n        }\n\n        /**\n         * @cfg {Number} [multipleOf]\n         * @info This validation attribute applies to #Number fields only.\n         * Insures the field value is a multiple of this number. For example,\n         * if the multiple is `10` and the value is `100`, it is valid.\n         * If the multiple is `10` and the value is `101`, it is invalid.\n         */\n        if (NGN.typeof(cfg.multipleOf) === 'number') {\n          this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n            return Math.abs(value % cfg.multipleOf) === 0\n          }, `Numeric Multiple of ${cfg.multipleOf}`))\n        }\n      }\n    }\n\n    // Apply array-specific native validations\n    if (this.METADATA.dataType === Array) {\n      // Enforce minimum number of array items\n      if (NGN.objectHasAny(cfg, 'min', 'minimum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => value.length >= NGN.coalesce(cfg.min, cfg.minimum), `${NGN.coalesce(cfg.min, cfg.minimum)} count minimum`))\n      }\n\n      // Enforce maximum number of array items\n      if (NGN.objectHasAny(cfg, 'max', 'maximum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => value.length <= NGN.coalesce(cfg.max, cfg.maximum), `${NGN.coalesce(cfg.max, cfg.maximum)} count maximum`))\n      }\n\n      /**\n       * @cfg {Array} [unique]\n       * @info This validation attribute applies to #Array fields only.\n       * @warning This is a computationally expensive validation when used in NGN Data Stores.\n       * Validates that all items are unique.\n       */\n      if (NGN.coalesce(cfg.unique, false)) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => NGN.dedupe(value).length === value.length, 'Unique value constraint'))\n      }\n\n      /**\n       * @cfg {any} [listType]\n       * @info This validation attribute applies to #Array fields only.\n       * Require each element of the array to conform to the specified data\n       * type. For example, setting `listType: Number` will validate that\n       * each element of the array is a number.\n       *\n       * ```js\n       * [1, 2, 3, 4, 5] // Valid\n       * [1, 2, 'three', 4, 5] // Invalid\n       * ```\n       */\n      if (cfg.hasOwnProperty('listType')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          for (let i = 0; i < value.length; i++) {\n            if (NGN.typeof(value[i]) !== NGN.typeof(cfg.listType)) {\n              return false\n            }\n          }\n\n          return true\n        }, `${NGN.typeof(cfg.listType).toUpperCase()} list type constraint`))\n      }\n\n      // Support enumerations in array values\n      if (cfg.hasOwnProperty('enum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          return cfg.enum.indexOf(value) >= 0\n        }))\n      }\n\n      /**\n       * @cfg {Array} [tuples]\n       * @info This validation attribute applies to #Array fields only.\n       * @warning This is a computationally expensive validation when used in NGN Data Stores.\n       * Validate each item of an array according to a unique schema.\n       * Each item is a key value object, which supports only the `type` and\n       * `enum` validations.\n       *\n       * For example:\n       *\n       * ```js\n       * {\n       *   tuples: [{\n       *     type: Number\n       *   }, {\n       *     type: String,\n       *     enum: ['a', 'b', 'c']\n       *   }, {\n       *     enum: ['d', 1]\n       *   }]\n       * }\n       * ```\n       * The configuration above will make sure the first array item is a number,\n       * while the second is either `a`, `b`, or `c`, and the third is either\n       * the letter `d` or the number `1`. Only the first three items of the\n       * array will be checked, but there must be at least 3 items.\n       */\n      if (cfg.hasOwnProperty('tuples')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          if (value.length < cfg.tuples.length) {\n            return false\n          }\n\n          for (let i = 0; i < cfg.tuples.length; i++) {\n            if (cfg.tuples[i].hasOwnProperty('type')) {\n              if (NGN.typeof(value[i]) !== NGN.typeof(cfg.tuples[i].type)) {\n                return false\n              }\n            }\n\n            if (cfg.tuples[i].hasOwnProperty('enum')) {\n              if (cfg.tuples[i].enum.indexOf(value[i]) < 0) {\n                return false\n              }\n            }\n          }\n\n          return true\n        }, 'Tuple constraint'))\n      }\n    }\n\n    /**\n     * @cfg {Array} [enum]\n     * An enumeration of available values this field is allowed to have.\n     */\n    if (NGN.objectHasAny(cfg, 'enum', 'enumeration')) {\n      this.METADATA.ENUMERABLE_VALUES = new Set(NGN.forceArray(NGN.coalesce(cfg.enum, cfg.enumeration)))\n      this.METADATA.rules.push(new NGN.DATA.Rule((value) => this.METADATA.ENUMERABLE_VALUES.has(value), 'Enumerable Values'))\n    }\n\n    /**\n     * @cfg {Array} [not]\n     * A \"reverse\" enumeration, i.e. a list of values this field is **not** allowed to be.\n     */\n    if (NGN.objectHasAny(cfg, 'not', 'notin')) {\n      this.METADATA.REVERSE_ENUMERABLE_VALUES = new Set(NGN.forceArray(NGN.coalesce(cfg.not, cfg.notin)))\n      this.METADATA.rules.push(new NGN.DATA.Rule((value) => !this.METADATA.REVERSE_ENUMERABLE_VALUES.has(value), 'Rejected Values'))\n    }\n\n    // Check if the field type is an array, which indicates multiple\n    // data types are considered valid.\n    if (cfg.type instanceof Array) {\n      // If the array has no values, assume the user meant to create an \"Array\" data type.\n      // Warn them, in case this was not the intention.\n      if (cfg.type.length === 0) {\n        NGN.WARN(`No data type specified for ${this.name} field. Autoconverted to an array.`)\n        cfg.type = Array\n      } else if (cfg.type.length === 1) {\n        // If there is only one data type, the array is extraneous and standard\n        // datatype validation can be used.\n        cfg.type = cfg.type[0]\n      }\n    }\n\n    /**\n     * @cfg {Primitive|Array} [type=String]\n     * The type should be a JavaScript primitive, class, or constructor.\n     * For example, `String`, `Number`, `Boolean`, `RegExp`, `Array`, or `Date`.\n     * This can also be an array of primitive values. For example, `[String, Number]`\n     * indicates the field could be a string or a numeric value.\n     */\n    if (cfg.type instanceof Array) {\n      let typeList = cfg.type.map(type => NGN.typeof(type))\n\n      this.METADATA.rules.unshift(\n        new NGN.DATA.Rule(\n          (value) => typeList.indexOf(NGN.typeof(value)) >= 0,\n          `${this.type.toUpperCase()} Multitype Check`\n        )\n      )\n    } else {\n      this.METADATA.rules.unshift(\n        new NGN.DATA.Rule(\n          (value) => NGN.typeof(value) === NGN.typeof(this.METADATA.dataType),\n          `${this.type.toUpperCase()} Type Check`\n        )\n      )\n    }\n\n    // Associate a model if one is defined.\n    if (NGN.coalesce(cfg.model) !== null) {\n      this.model = cfg.model\n    }\n  }\n\n  get sourceName () {\n    return this.METADATA.sourceName\n  }\n\n  get auditable () {\n    return this.METADATA.AUDITABLE\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n      this.METADATA.AUDITLOG.relay('*', this, 'transaction.')\n    }\n  }\n\n  /**\n   * @property {NGN.DATA.Model} model\n   * Represents the model/record the field is associated to.\n   * The model may be configured once, after which this property\n   * becomes read-only. This will also be read-only if #model is set\n   * to a valid value.\n   */\n  get model () {\n    return this.METADATA.model\n  }\n\n  set model (value) {\n    if (this.METADATA.model === null) {\n      if (value instanceof NGN.DATA.Entity) {\n        this.METADATA.model = value\n\n        // let events = Array.from(this.METADATA.EVENTS.values())\n        // events.splice(events.indexOf('update'), 1)\n        //\n        this.on('update', (payload) => this.METADATA.commitPayload(payload))\n        //\n        // for (let i = 0; i < events.length; i++) {\n        //   this.on(events[i], () => this.METADATA.model.emit(`field.${events[i]}`, ...arguments))\n        // }\n      } else {\n        NGN.WARN('Invalid model.')\n      }\n    } else {\n      NGN.WARN('Cannot set model multiple times.')\n    }\n  }\n\n  /**\n   * @property {string} fieldType\n   * The type of field.\n   */\n  get fieldType () {\n    return this.METADATA.fieldType\n  }\n\n  /**\n   * @property {boolean} required\n   * Indicates the field must have a non-null value.\n   */\n  get required () {\n    return this.METADATA.required\n  }\n\n  set required (value) {\n    this.METADATA.required = NGN.forceBoolean(value)\n  }\n\n  /**\n   * @property {string} type\n   * The type of data in string format.\n   */\n  get type () {\n    return NGN.typeof(this.METADATA.dataType)\n  }\n\n  /**\n   * @property {boolean} hidden\n   * Indicates the field should be considered hidden.\n   */\n  get hidden () {\n    return this.METADATA.hidden\n  }\n\n  set hidden (value) {\n    let originallyHidden = this.hidden\n    let currentlyHidden = NGN.forceBoolean(value)\n\n    if (originallyHidden !== currentlyHidden) {\n      this.METADATA.hidden = currentlyHidden\n      this.emit(originallyHidden ? 'unhidden' : 'hidden')\n    }\n  }\n\n  /**\n   * @property {boolean} virtual\n   * Indicates the field should be considered virtual.\n   */\n  get virtual () {\n    return this.METADATA.fieldType === 'virtual'\n  }\n\n  /**\n   * @property {boolean} identifier\n   * Indicates the field is considered an identifier.\n   */\n  get identifier () {\n    return this.METADATA.isIdentifier\n  }\n\n  set identifier (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.isIdentifier) {\n      this.METADATA.isIdentifier = value\n      this.emit('keystatus.changed', this)\n    }\n  }\n\n  get name () {\n    return this.METADATA.name\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates the model is new or does not exist according to the persistence store.\n   * @private\n   * @readonly\n   */\n  get isNew () {\n    return this.METADATA.IS_NEW\n  }\n\n  /**\n   * @property {Any} default\n   * The default field value.\n   */\n  get default () {\n    if (this.isIdentifier) {\n      return NGN.coalesce(this.METADATA.autoid, this.METADATA.default)\n    }\n\n    if (NGN.isFn(this.METADATA.default) && this.type !== 'function') {\n      return this.METADATA.default.apply(this)\n    }\n\n    return this.METADATA.default\n  }\n\n  /**\n   * @property {Any} value\n   * The value of the field.\n   */\n  get value () {\n    if (typeof this.METADATA.RAW !== 'symbol') {\n      return this.METADATA.RAW\n    }\n\n    return this.METADATA.default\n  }\n\n  set value (value) {\n    this.METADATA.setValue(value)\n  }\n\n  /**\n   * @property silentValue\n   * A write-only attribute to set the value without triggering an update event.\n   * This is designed primarily for use with live update proxies to prevent\n   * endless event loops.\n   * @param {any} value\n   * The new value of the field.\n   * @private\n   * @writeonly\n   */\n  set silentValue (value) {\n    this.METADATA.setValue(value, true)\n  }\n\n  get modified () {\n    if (typeof this.META.lastValue === 'symbol') {\n      return false\n    }\n\n    return this.METADATA.lastValue !== this.value\n  }\n\n  /**\n   * @property {boolean} valid\n   * Indicates the field value is valid.\n   */\n  get valid () {\n    if (this.required && NGN.coalesce(this.METADATA.RAW) === null) {\n      this.METADATA.violatedRule = 'Data Required'\n      NGN.WARN(`${this.METADATA.name} is a required field.`)\n      return false\n    }\n\n    if (this.METADATA.rules.length > 0) {\n      for (let rule = 0; rule < this.METADATA.rules.length; rule++) {\n        if (!this.METADATA.rules[rule].test(this.METADATA.RAW)) {\n          this.METADATA.violatedRule = this.METADATA.rules[rule].name\n          return false\n        }\n      }\n    }\n\n    this.METADATA.violatedRule = null\n\n    return true\n  }\n\n  /**\n   * @property {String}\n   * Name of the rule which was violated.\n   */\n  get violatedRule () {\n    return NGN.coalesce(this.METADATA.violatedRule, 'None')\n  }\n\n  /**\n   * @property {Array} changelog\n   * The changelog returns the underlying NGN.DATA.TransactionLog#log if\n   * auditing is available. The array will be empty if auditing is disabled.\n   */\n  get changelog () {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The changelog for the ${this.name} field is empty because auditing is disabled.`)\n      return []\n    }\n\n    return this.METADATA.AUDITLOG.log\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog (transaction log). To \"undo\" an \"undo\", use #redo.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  undo (count = 1, suppressEvents = false) {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The undo operation failed on the ${this.name} field because auditing is disabled.`)\n      return\n    }\n\n    let id = this.METADATA.AUDITLOG.rollback(count)\n\n    // Silently set the value to an older value.\n    this.METADATA.setValue(this.METADATA.AUDITLOG.getCommit(id).value, suppressEvents, true)\n  }\n\n  /**\n   * @method redo\n   * A function to reapply known changes. This operation affects\n   * the changelog (transaction log).\n   *\n   * The redo operation only works after an undo operation, but before a new\n   * value is committed to the transaction log. In other words, `undo -> redo`\n   * will work, but `undo -> update -> redo` will not. For details, see how\n   * the NGN.DATA.TransactionLog cursor system works.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  redo (count = 1, suppressEvents = false) {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The redo operation failed on the ${this.name} field because auditing is disabled.`)\n      return\n    }\n\n    let id = this.METADATA.AUDITLOG.advance(count)\n\n    // Silently set the value to a newer value.\n    this.METADATA.setValue(this.METADATA.AUDITLOG.getCommit(id).value, suppressEvents, true)\n  }\n\n  /**\n   * Hide the field.\n   */\n  hide () {\n    this.hidden = true\n  }\n\n  /**\n   * Unhide the field.\n   */\n  unhide () {\n    this.hidden = false\n  }\n\n  /**\n   * Do not throw errors whan a value is marked as invalid.\n   */\n  allowInvalid () {\n    this.METADATA.allowInvalid = true\n  }\n\n  /**\n   * Throw errors whan a value is marked as invalid.\n   */\n  disallowInvalid () {\n    this.METADATA.allowInvalid = false\n  }\n\n  /**\n   * Attempt to automatically correct a value according to the\n   * field's data type.\n   * @param  {Any} value\n   * The value to attempt to autocorrect.\n   * @return {Any}\n   * Returns the value after attempting to autocorrect the value.\n   */\n  autoCorrectValue (value) {\n    try {\n      switch (this.type) {\n        case 'number':\n          value = NGN.forceNumber(value)\n          break\n\n        case 'boolean':\n          value = NGN.forceBoolean(value)\n          break\n\n        case 'array':\n          value = NGN.forceArray(value)\n          break\n\n        case 'string':\n          value = value.toString()\n          break\n\n        case 'date':\n          let valueType = NGN.typeof(value)\n\n          if (valueType !== 'date') {\n            if (valueType === 'number') {\n              let dt = new Date()\n              dt.setTime(value)\n\n              value = dt\n            } else {\n              value = new Date(Date.parse(value))\n            }\n          }\n\n          break\n      }\n    } finally {\n      return value // eslint-disable-line no-unsafe-finally\n    }\n  }\n}\n","import DataField from './Field'\n\n/**\n * @class NGN.DATA.VirtualField\n * A virtual field is a read-only ephemeral representation of data,\n * generated dynamically.\n * In other words, it's a made up data field that isn't part of what gets stored.\n * The value can be changed at any time, without warning or events. This is most\n * commonly used as an _internal class_ to support virtual fields within data\n * models. Consider the following:\n *\n * **Example:**\n *\n * ```js\n * let Person = new NGN.DATA.Model({\n *   fields: {\n *     dateOfBirth: Date\n *     age: function () {\n *       return YearsApart(new Date(), this.dateOfBirth)\n *     }\n *   }\n * })\n * ```\n *\n * The `age` example above (shorthand syntax) compares the `dateOfBirth` field\n * to the current date, expecting a numeric response. This particular virtual\n * field is useful for calculating a common value on the fly, and it is reusable\n * for any number of instances of the model.\n *\n * This functionality is available by implementing the NGN.DATA.VirtualField.\n * For example, the `age` virtual field would be created as:\n *\n * ```js\n * let age = new NGN.DATA.VirtualField(model, function () {\n *   return YearsApart(new Date(), this.dateOfBirth)\n * })\n * ```\n * @fires cache.clear {NGN.DATA.VirtualField}\n * Fired whenever the cache is cleared. The field is passed as the only argument\n * to event handler functions.\n */\nexport default class NGNVirtualDataField extends DataField { // eslint-disable-line\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    if (!(cfg.model instanceof NGN.DATA.Entity)) {\n      NGN.WARN('No model specified for the virtual field to reference.')\n    }\n\n    // Remove unnecessary config values\n    delete cfg.required\n    delete cfg.default\n    delete cfg.min\n    delete cfg.minimum\n    delete cfg.max\n    delete cfg.maximum\n    delete cfg.range\n    delete cfg.rule\n    delete cfg.rules\n    delete cfg.validators\n    delete cfg.pattern\n\n    super(cfg)\n\n    this.METADATA.AUDITABLE = false\n    this.METADATA.fieldType = 'virtual'\n\n    /**\n     * @cfg {boolean} [cache=true]\n     * By default, virtual fields _associated with a model_ will cache results\n     * to prevent unnecessary function calls. The cache is cleared whenever a\n     * local data field is modified.\n     *\n     * Caching can substantially reduce processing time in large data sets\n     * by calling methods less often. In most use cases, it will provide a\n     * substantial performance gain. However; since virtual fields can also\n     * leverage variables and methods that are not a part of the data model,\n     * caching may prevent the value from updating as expected. While this case\n     * may occur less often, it can occur. If you suspect caching is interfering\n     * with a virtual field value, it can be disabled by setting this to `false`.\n     */\n    this.METADATA.caching = NGN.coalesce(cfg.cache, true)\n\n    /**\n     * @cfg {NGN.DATA.Model|NGN.DATA.Store|Object} scope\n     * The model, store, or object that will be referenceable within the\n     * virtual field #method. The model will be available in the `this` scope.\n     */\n    this.METADATA.scope = NGN.coalesce(cfg.scope, cfg.model, this)\n\n    /**\n     * @cfg {Function} method\n     * The method used to generate a value.\n     * This is an asynchronous method the returns a value (of any type).\n     */\n    const me = this\n    const handlerFn = cfg.method\n\n    this.METADATA.virtualMethod = function () {\n      return handlerFn.apply(me.METADATA.scope, ...arguments)\n    }\n\n    // Add smart-cache support\n    this.METADATA.CACHEKEY = Symbol('no.cache')\n    this.METADATA.cachedValue = this.METADATA.CACHEKEY\n\n    // Only add caching support if a model is associated\n    if (this.METADATA.caching && this.model) {\n      // Create a method for identifying which local data fields\n      // need to be monitored (for caching)\n      const localFieldPattern = /this(\\.(.[^\\W]+)|\\[['\"]{1}(.*)+['\"]{1}\\])/g\n\n      // Returns a Set of fieldnames used in the virtual function.\n      let monitoredFields = new Set()\n      let content = handlerFn.toString()\n      let iterator = localFieldPattern.exec(content)\n\n      while (iterator !== null) {\n        let field = NGN.coalesce(iterator[2], iterator[3])\n\n        if (this.model.METADATA.knownFieldNames.has(field)) {\n          monitoredFields.add(field)\n        }\n\n        content = content.replace(localFieldPattern, '')\n        iterator = localFieldPattern.exec(content)\n      }\n\n      this.METADATA.model.pool('field.', {\n        update: (change) => {\n          if (change.field && monitoredFields.has(change.field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n          }\n        },\n\n        remove: (field) => {\n          if (monitoredFields.has(field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n            NGN.ERROR(`The ${this.name} virtual field uses the ${field.name} field, which was removed. This virtual field may no longer work.`)\n          }\n        },\n\n        create: (field) => {\n          if (monitoredFields.has(field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n            NGN.INFO(`The ${this.name} virtual field uses the ${field.name} field, which was added.`)\n          }\n        }\n      })\n    }\n  }\n\n  get auditable () {\n    NGN.WARN('Virtual fields do not support the auditable property.')\n    return false\n  }\n\n  set auditable (value) {\n    NGN.WARN('Virtual fields do not support the auditable property.')\n  }\n\n  /**\n   * @property {any} value\n   * This will always return the value of the virtual field, but it may only\n   * be _set_ to a synchronous function that returns a value.\n   */\n  get value () {\n    if (this.METADATA.caching) {\n      if (this.METADATA.cachedValue !== this.METADATA.CACHEKEY) {\n        return this.METADATA.cachedValue\n      } else {\n        this.METADATA.cachedValue = this.METADATA.virtualMethod()\n        return this.METADATA.cachedValue\n      }\n    }\n\n    return this.METADATA.virtualMethod()\n  }\n\n  set value (value) {\n    NGN.WARN('Cannot set the value of a virtual field (read only).')\n  }\n\n  get required () {\n    NGN.WARN('Virtual fields do not support the required property.')\n    return false\n  }\n\n  set required (value) {\n    NGN.WARN('Virtual fields do not support the required property.')\n  }\n\n  get isNew () {\n    NGN.WARN('Virtual fields do not support the isNew property.')\n    return false\n  }\n\n  get default () {\n    NGN.WARN('Virtual fields do not have default values.')\n    return undefined\n  }\n\n  set default (value) {\n    NGN.WARN('Virtual fields do not have default values.')\n    return undefined\n  }\n\n  get violatedRule () {\n    return 'None'\n  }\n\n  get valid () {\n    NGN.WARN('Virtual fields are always valid.')\n    return true\n  }\n\n  get modified () {\n    NGN.WARN('modified attribute does nothing on virtual fields.')\n    return false\n  }\n\n  allowInvalid () {\n    NGN.WARN('allowInvalid() unavailable for virtual fields.')\n  }\n\n  disallowInvalid () {\n    NGN.WARN('disallowInvalid() unavailable for virtual fields.')\n  }\n\n  autocorrectInput () {\n    NGN.WARN('autocorrectInput() unavailable for virtual fields.')\n  }\n}\n","import DataField from './Field'\n\n/**\n * @class NGN.DATA.Relationship\n * Represents a data field linked to another NGN.DATA.Model or\n * NGN.DATA.Store. This is used for nesting models/stores within a field,\n * supporting creation of complex data structures that are still easy\n * to work with.\n *\n * While there is no limit to how deeply nested fields can be, it is considered\n * a best practice to avoid circular relationships, which can lead to infinite\n * loops when serializing data.\n *\n * Nested models (i.e. records) each have their own data\n * NGN.DATA.Model#validators, so relationship fields defer all validation to\n * the individual record/model.\n *\n * Relationships using NGN.DATA.Stores behave a little differently, since they\n * represent a collection of data instead of a single record/model. NGN manages\n * [referential integrity](https://en.wikipedia.org/wiki/Referential_integrity)\n * using simplistic\n * [cardinality](https://en.wikipedia.org/wiki/Cardinality_(data_modeling)).\n *\n * Referential integrity & cardinality rules are data modeling principles\n * designed to enforce data quality standards. The nature of JavaScript objects\n * naturally enforces rudimentary data linking/nesting. NGN data relationships\n * build upon this, using proven data modeling principles.\n *\n * This is done, very simply, by using the @cfg#min and @cfg#max configuration\n * options. However; these options don't always need to be enforced, depending\n * on what type of cardniality needs to be achieved.\n *\n * For more information, see the Data Modeling Guide.\n *\n * **Note to self, use this next part in the guide:**\n *\n * There are five (5) common types of cardinality.\n *\n * - **1 => 1**: One-to-One\n * - **0 => 1**: Zero-or-One\n * - **0 => N**: Zero-to-Many\n * - **1 => N**: One-to-Many\n * - **N => N**: Many-to-Many\n *\n * There are also more granular types of cardinality, which are less common in\n * web applications, but often used in data and ETL operations.\n *\n * - **0,1 => 0,N**: Zero-or-One to Zero-or-More\n * - **0,1 => 1,N**: Zero-or-One to One-or-More\n * - ... write the rest in the guide...\n */\nexport default class NGNRelationshipField extends DataField { // eslint-disable-line\n  constructor (cfg = {}) {\n    let type = NGN.typeof(cfg.join)\n\n    // Assure valid configuration\n    if (!cfg.join) {\n      throw new InvalidConfigurationError('Missing \"join\" configuration property.')\n    } else if (\n      ['model', 'store'].indexOf(type) < 0 &&\n      (\n        type !== 'array' ||\n        NGN.typeof(cfg.join[0]) !== 'model'\n      )\n    ) {\n      throw new InvalidConfigurationError(`The join specified is not a valid NGN.DATA.Model, NGN.DATA.Store, or collection. It is a ${NGN.typeof(cfg.join)}\"`)\n    }\n\n    // Create optional cardinality validations\n\n    // Initialize\n    cfg.identifier = false\n    super(cfg)\n\n    this.METADATA.fieldType = 'join'\n    this.METADATA.join = Symbol('relationship')\n\n    // Apply event monitoring to the #record.\n    this.METADATA.applyMonitor = () => {\n      if (this.METADATA.manner === 'model') {\n        // Model Event Relay\n        this.METADATA.join.pool('field.', {\n          create: this.METADATA.commonModelEventHandler('field.create'),\n          update: this.METADATA.commonModelEventHandler('field.update'),\n          remove: this.METADATA.commonModelEventHandler('field.remove'),\n          invalid: (data) => {\n            this.emit(['invalid', `invalid.${this.METADATA.name}.${data.field}`])\n          },\n          valid: (data) => {\n            this.emit(['valid', `valid.${this.METADATA.name}.${data.field}`])\n          }\n        })\n      //   this.METADATA.join.pool('field.', {\n      //     create: this.METADATA.commonModelEventHandler('field.create'),\n      //     update: this.METADATA.commonModelEventHandler('field.update'),\n      //     remove: this.METADATA.commonModelEventHandler('field.remove'),\n      //     invalid: (data) => {\n      //       this.emit(['invalid', `invalid.${this.name}.${data.field}`])\n      //     },\n      //     valid: (data) => {\n      //       this.emit(['valid', `valid.${this.name}.${data.field}`])\n      //     }\n      //   })\n      // } else {\n      //   // Store Event Relay\n      //   this.METADATA.join.pool('record.', {\n      //     create: this.METADATA.commonStoreEventHandler('record.create'),\n      //     update: this.METADATA.commonStoreEventHandler('record.update'),\n      //     remove: this.METADATA.commonStoreEventHandler('record.remove'),\n      //     invalid: (data) => {\n      //       this.emit('invalid', `invalid.${this.name}.${data.field}`)\n      //     },\n      //     valid: (data) => {\n      //       this.emit('valid', `valid.${this.name}.${data.field}`)\n      //     }\n      //   })\n      }\n    }\n\n    // Event handling for nested models.\n    this.METADATA.commonModelEventHandler = (type) => {\n      const me = this\n\n      return function (change) {\n        me.METADATA.commitPayload({\n          field: `${me.name}.${change.field}`,\n          old: NGN.coalesce(change.old),\n          new: NGN.coalesce(change.new),\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: me.METADATA.record\n          }\n        })\n      }\n    }\n\n    // Event handling for nested stores.\n    this.METADATA.commonStoreEventHandler = (type) => {\n      const me = this\n\n      return function (record, change) {\n        let old = change ? NGN.coalesce(change.old) : me.data\n\n        if (this.event === 'record.create') {\n          old.pop()\n        } else if (this.event === 'record.delete') {\n          old.push(record.data)\n        }\n\n        me.METADATA.commitPayload({\n          field: me.name + (change ? `.${change.field}` : ''),\n          old: change ? NGN.coalesce(change.old) : old,\n          new: change ? NGN.coalesce(change.new) : me.data,\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: record\n          }\n        })\n      }\n    }\n\n    // const commitPayload = this.METADATA.commitPayload\n    //\n    // this.METADATA.commitPayload = (payload) => {\n    //   console.log('HERE')\n    //   commitPayload(...arguments)\n    // }\n\n    /**\n     * @cfg join {NGN.DATA.Store|NGN.DATA.Model[]}\n     * A relationship to another model/store is defined by a join.\n     * The join may be a data store or data model. It is also possible\n     * to specify a collection.\n     *\n     * For example, a join may be defined as:\n     *\n     * ```js\n     * // Use of a model\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: new NGN.DATA.Model(...)\n     * })\n     *\n     * // Use of a model collection\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: [new NGN.DATA.Model(...)]\n     * })\n     *\n     * // Use of a store\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: new NGN.DATA.Store(...)\n     * })\n     * ```\n     *\n     * A store and a model collection are both a group of models,\n     * Internally, model collections are converted to data stores.\n     *\n     * By supporting all three formats, it is possible to create complex\n     * data models, such as:\n     *\n     * ```js\n     * let Pet = new NGN.DATA.Model(...)\n     * let Kid = new NGN.DATA.Model(...)\n     * let Kids = new NGN.DATA.Store({\n     *   model: Kid\n     * })\n     *\n     * let Person = new NGN.DATA.Model({\n     *   fields: {\n     *     dateOfBirth: Date,\n     *     spouse: Person,  // <== Join a Model\n     *     kids: Kids,      // <== Join a Store\n     *     pets: [Pet]      // <== Join a Collection\n     *   }\n     * })\n     * ```\n     *\n     * The `pets` field contains a \"collection\". This shorthand notation is used\n     * to help understand real data relationships. In this case, it is easy to\n     * infer that a person may have zero or more pets.\n     */\n    this.value = NGN.coalesce(cfg.join)\n    this.METADATA.AUDITABLE = false\n    this.auditable = NGN.coalesce(cfg.audit, false)\n  }\n\n  /**\n   * @property {string} manner\n   * The manner of relationship. This can be one of 3 values: `store`\n   * (NGN.DATA.Store), `model` (NGN.DATA.Model), or `collection`. A collection\n   * is a special configuration shortcut used to represent a new store of models.\n   * ```math\n   * E = mc^2\n   * ```\n   * ```graph\n   * graph LR\n   * a-->b\n   * ```\n   * For example, a model may be defined as:\n   *\n   * ```js\n   * let Pet = new NGN.DATA.Model({\n   *   fields: {\n   *     name: String,\n   *     animalType: String\n   *   }\n   * })\n   *\n   * let Person = new NGN.DATA.Model({\n   *   fields: {\n   *     dateOfBirth: Date\n   *   },\n   *   relationships: {\n   *     pets: [Pet]        // <== Collection\n   *   }\n   * })\n   * ```\n   */\n  get manner () {\n    return NGN.coalesce(this.METADATA.manner, 'unknown')\n  }\n\n  get value () {\n    return this.METADATA.join\n  }\n\n  // Override the default value setter\n  set value (value) {\n    // Short-circuit if the value hasn't changed.\n    let currentValue = this.METADATA.join\n\n    if (currentValue === value) {\n      return\n    }\n\n    let type = NGN.typeof(value)\n\n    if (type === 'array') {\n      if (value.length !== 1) {\n        throw new Error(`${this.METADATA.name} cannot refer to an empty data store/model collection. A record must be provided.`)\n      }\n\n      this.METADATA.manner = 'store'\n      value = new NGN.DATA.Store({\n        model: value[0]\n      })\n    } else if (['model', 'store'].indexOf(type) >= 0) {\n      this.METADATA.manner = type\n    } else {\n      NGN.ERROR(`The \"${this.METADATA.name}\" relationship has an invalid record type. Only instances of NGN.DATA.Store, NGN.DATA.Model, or [NGN.DATA.Model] are supported.\" .`)\n      throw new InvalidConfigurationError(`Invalid record configuration for \"${this.METADATA.name}\" field.`)\n    }\n\n    if (this.manner === 'unknown') {\n      throw new Error('Cannot set a relationship field to anything other than an NGN.DATA.Store, NGN.DATA.Model, or an array of NGN.DATA.Model collections. (Unknown manner of relationship)')\n    }\n\n    this.METADATA.join = type === 'model' ? new value() : value // eslint-disable-line new-cap\n    this.auditable = this.METADATA.AUDITABLE\n    this.METADATA.applyMonitor()\n\n    // Notify listeners of change\n    if (typeof currentValue !== 'symbol') {\n      this.emit('update', {\n        old: currentValue,\n        new: value\n      })\n    }\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.join.auditable = value\n    }\n  }\n\n  // Override the default undo\n  undo () {\n    if (this.METADATA.manner === 'model') {\n      this.METADATA.join.undo(...arguments)\n    }\n  }\n\n  redo () {\n    if (this.METADATA.manner === 'model') {\n      this.METADATA.join.redo(...arguments)\n    }\n  }\n}\n","/**\n * @class NGN.DATA.FieldMap\n * A field map is a special data transformer that maps field names (keys)\n * to a different format. Consider the following field map:\n *\n * ```js\n * let fieldMap = new NGN.DATA.FieldMap({\n *   father: 'pa',\n *   mother: 'ma',\n *   brother: 'bro',\n *   sister: 'sis'\n * })\n * ```\n *\n * The map above reads as \"the `father` field is also known as `pa`\",\n * \"the `mother` field is also known as `ma`\", etc.\n *\n * The following transformation is possible:\n *\n * ```js\n * let result = fieldMap.apply({\n *   pa: 'John',\n *   ma: 'Jill',\n *   bro: 'Joe',\n *   sis: 'Jane'\n * })\n *\n * console.log(result)\n * ```\n *\n * _yields:_\n *\n * ```sh\n * {\n *   father: 'John'\n *   mother: 'Jill',\n *   brother: 'Joe',\n *   sister: 'Jane'\n * }\n * ```\n *\n * It is also possible to reverse field names:\n *\n * ```js\n * let result = fieldMap.applyReverse({\n *   father: 'John'\n *   mother: 'Jill',\n *   brother: 'Joe',\n *   sister: 'Jane'\n * })\n *\n * console.log(result)\n * ```\n *\n * _yields:_\n *\n * ```sh\n * {\n *   pa: 'John',\n *   ma: 'Jill',\n *   bro: 'Joe',\n *   sis: 'Jane'\n * }\n * ```\n *\n * This class is designed to assist with reading and writing data\n * to NGN.DATA.Model and NGN.DATA.Store instances.\n * @private\n */\nexport default class NGNDataFieldMap { // eslint-disable-line\n  constructor (cfg = {}) {\n    Object.defineProperties(this, {\n      originalSource: NGN.privateconst(cfg),\n      sourceMap: NGN.private(null),\n      reverseMap: NGN.private(null),\n      applyData: NGN.privateconst((map = 'map', data) => {\n        if (NGN.typeof(data) !== 'object') {\n          return data\n        }\n\n        let keys = Object.keys(data)\n        map = map === 'map' ? this.inverse : this.map\n\n        for (let i = 0; i < keys.length; i++) {\n          if (map.hasOwnProperty(keys[i])) {\n            data[map[keys[i]]] = data[keys[i]]\n            delete data[keys[i]]\n          }\n        }\n\n        return data\n      })\n    })\n  }\n\n  /**\n   * @property {object} map\n   * A reference to the data mapping object.\n   */\n  get map () {\n    if (this.sourceMap === null) {\n      let keys = Object.keys(this.originalSource)\n\n      this.sourceMap = {}\n\n      for (let i = 0; i < keys.length; i++) {\n        if (NGN.typeof(keys[i]) === 'string' && NGN.typeof(this.originalSource[keys[i]]) === 'string') {\n          this.sourceMap[keys[i]] = this.originalSource[keys[i]]\n        }\n      }\n    }\n\n    return this.sourceMap\n  }\n\n  /**\n   * @property {object} inverse\n   * A reference to the inversed data map.\n   */\n  get inverse () {\n    if (this.reverseMap === null) {\n      let keys = Object.keys(this.originalSource)\n\n      this.reverseMap = {}\n\n      for (let i = 0; i < keys.length; i++) {\n        if (NGN.typeof(keys[i]) === 'string' && NGN.typeof(this.originalSource[keys[i]]) === 'string') {\n          this.reverseMap[this.originalSource[keys[i]]] = keys[i]\n        }\n      }\n    }\n\n    return this.reverseMap\n  }\n\n  /**\n   * Apply the map to an object.\n   * @param  {object} data\n   * @return {object}\n   */\n  applyMap (data) {\n    return this.applyData('map', data)\n  }\n\n  /**\n   * Apply the inversed map to an object.\n   * @param  {object} data\n   * @return {object}\n   */\n  applyInverseMap (data) {\n    return this.applyData('reverse', data)\n  }\n}\n","import EventEmitter from '../emitter/core'\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.EventEmitter\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create {NGN.DATA.Field}\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\nexport default class NGNDataEntity extends EventEmitter { // eslint-disable-line\n  constructor (cfg) {\n    cfg = NGN.coalesce(cfg, {})\n\n    super()\n\n    if (cfg.dataMap) {\n      cfg.fieldmap = cfg.dataMap\n      NGN.WARN('\"dataMap\" is deprecated. Use \"map\" instead.')\n    }\n\n    if (cfg.idAttribute) {\n      cfg.IdentificationField = cfg.idAttribute\n      NGN.WARN('\"idAttribute\" is deprecated. Use \"IdentificationField\" instead.')\n    }\n\n    const me = this\n\n    // Create private attributes & data placeholders\n    Object.defineProperties(this, {\n      /**\n       * @property {Symbol} OID\n       * A unique object ID assigned to the model. This is an\n       * internal readon-only reference.\n       * @private\n       */\n      OID: NGN.private(Symbol('model.id')),\n\n      METADATA: NGN.privateconst({\n        /**\n         * @cfg {string} [name]\n         * A descriptive name for the model. This is typically used for\n         * debugging, logging, schema defintions, and (sometimes) data proxies.\n         */\n        name: NGN.coalesce(cfg.name, 'Untitled Model'),\n\n        /**\n         * @cfg {string} [description]\n         * A description of the model. This is typically used for\n         * debugging, logging, schema definitions, and (sometimes) data proxies.\n         */\n        description: NGN.coalesce(cfg.description, cfg.name, 'Generic Data Model'),\n\n        /**\n         * @cfg {object} fields\n         * A private object containing the data fields of the model.\n         * Each key contains the field name, while each value can be one of\n         * the following:\n         *\n         * - Primitive (String, Number, RegExp, Boolean)\n         * - Standard Type (Array, Object, Date)\n         * - Custom Class\n         * - NGN.DATA.Field\n         * - An NGN.DATA.Field configuration\n         * - `null` (Defaults to String primitive)\n         *\n         * ```js\n         * fields: {\n         *   a: String,\n         *   b: Date,\n         *   c: MyCustomClass,\n         *   d: new NGN.DATA.Field({\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   }),\n         *   e: {\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   },\n         *   f: null // Uses default field config (String)\n         * }\n         * ```\n         *\n         * Extensions of the NGN.DATA.Field are also supported,\n         * such as NGN.DATA.VirtualField and NGN.DATA.Relationship.\n         */\n        fields: Object.assign({}, NGN.coalesce(cfg.fields, {})),\n        knownFieldNames: new Set(),\n        invalidFieldNames: new Set(),\n        auditFieldNames: NGN.coalesce(cfg.audit, false) ? new Set() : null,\n\n        /**\n         * @property {[NGN.DATA.Rule]|Object}\n         * Custom validation rules used to verify the integrity of the entire\n         * model. This only applies to the full model. Individual data fields\n         * may have their own validators.\n         *\n         * If an object is specified, it should contain simple key/value pairs,\n         * where the key is the descriptive name of the rule and the value is\n         * a synchronous callback function that returns a `true`/`false` value.\n         * For instance, assume the fields called `price`, `items`, and `tax` exist\n         * in the example model below. :\n         *\n         * ```js\n         * {\n         *   'Positive Sale': function () {\n         *      return (this.price * this.items) > 0\n         *   },\n         *   'Taxes Applied': function () {\n         *      return this.tax > 0\n         *   }\n         * }\n         * ```\n         *\n         * Alternatively, an array of NGN.DATA.Rule instances may be provided.\n         */\n        validators: NGN.coalesce(cfg.rules, cfg.rule, cfg.validators),\n\n        /**\n         * @cfgproperty {boolean} [validation=true]\n         * Toggle data validation using this.\n         */\n        validation: NGN.coalesce(cfg.validation, true),\n\n        /**\n         * @cfg {boolean} [autoid=false]\n         * If the NGN.DATA.Model#IdentificationField/id is not provided for a record,\n         * a unique ID will be automatically generated for it.\n         *\n         * An NGN.DATA.Store using a model with this set to `true` will never\n         * have a duplicate record, since the #id or #IdentificationField will always\n         * be unique.\n         */\n        autoid: NGN.coalesce(cfg.autoid, false),\n\n        /**\n         * @cfg {String} [IdentificationField='id']\n         * Setting this allows an attribute of the object to be used as the ID.\n         * For example, if an email is the ID of a user, this would be set to\n         * `email`.\n         */\n        IdentificationField: NGN.coalesce(cfg.IdentificationField, cfg.idField, 'id'),\n\n        /**\n         * @cfgproperty {Date|Number} [expires]\n         * When this is set to a date/time, the model record will be marked\n         * as expired at the specified time/date. If a number is specified\n         * (milliseconds), the record will be marked as expired after the\n         * specified time period has elapsed. When a record/model is marked as\n         * \"expired\", it triggers the `expired` event. By default, expired\n         * records/models within an NGN.DATA.Store will be removed from the store.\n         *\n         * Setting this to any value less than `0` disables expiration.\n         * @fires expired\n         * Triggered when the model/record expires.\n         */\n        expiration: null,\n\n        // Holds a setTimeout method for expiration events.\n        expirationTimeout: null,\n\n        created: Date.now(),\n        store: null,\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: false,\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: function (change) {\n          if (change.hasOwnProperty('cursor')) {\n            me.METADATA.AUDITLOG.commit(me.METADATA.getAuditMap())\n          }\n        },\n\n        EVENTS: new Set([\n          'field.update',\n          'field.create',\n          'field.remove',\n          'field.invalid',\n          'field.valid',\n          'field.hidden',\n          'field.unhidden',\n          'field.rule.add',\n          'field.rule.remove',\n          'rule.add',\n          'rule.remove',\n          'relationship.create',\n          'relationship.remove',\n          'expired',\n          'deleted',\n          'reset',\n          'load'\n        ]),\n\n        /**\n         * An internal method used to apply field definitions to the model.\n         * @param  {string} fieldname\n         * Name of the field (as applied to the model).\n         * @param  {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\n         * The configuration to apply. See #addField for details.\n         * @param  {Boolean} [suppressEvents=false]\n         * Optionally suppress the `field.create` event.\n         * @private\n         */\n        applyField: (field, fieldcfg = null, suppressEvents = false) => {\n          // Prevent duplicate fields\n          if (this.METADATA.knownFieldNames.has(field)) {\n            return NGN.WARN(`Duplicate field \"${field}\" detected.`)\n          }\n\n          // Prevent reserved words\n          if (this.hasOwnProperty(field) && field.toLowerCase() !== 'id') {\n            throw new ReservedWordError(`\"${field}\" cannot be used as a field name (reserved word).`)\n          }\n\n          // If the field config isn't already an NGN.DATA.Field, create it.\n          if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            if (fieldcfg instanceof NGN.DATA.Store || fieldcfg instanceof NGN.DATA.Model) {\n              if (this.METADATA.IdentificationField === field) {\n                throw new InvalidConfigurationError(`\"${field}\" cannot be an ID. Relationship fields cannot be an identification field/attribute.`)\n              }\n\n              this.METADATA.fields[field] = new NGN.DATA.Relationship({\n                name: field,\n                record: fieldcfg,\n                model: this\n              })\n            } else {\n              switch (NGN.typeof(fieldcfg)) {\n                // Custom config\n                case 'object':\n                  fieldcfg.model = this\n                  fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n                  fieldcfg.name = field\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field(fieldcfg)\n\n                  break\n\n                // Collection of models\n                case 'array':\n                  return this.METADATA.applyField(field, fieldcfg[0], suppressEvents)\n\n                // Type-based cfg.\n                default:\n                  if (NGN.isFn(fieldcfg) || fieldcfg === null) {\n                    if (NGN.isFn(fieldcfg) && ['string', 'number', 'boolean', 'number', 'symbol', 'regexp', 'date', 'array', 'object'].indexOf(NGN.typeof(fieldcfg)) < 0) {\n                      this.METADATA.fields[field] = new NGN.DATA.VirtualField({\n                        name: field,\n                        identifier: this.METADATA.IdentificationField === field,\n                        model: this,\n                        method: fieldcfg\n                      })\n\n                      break\n                    }\n\n                    this.METADATA.fields[field] = new NGN.DATA.Field({\n                      name: field,\n                      type: fieldcfg,\n                      identifier: this.METADATA.IdentificationField === field,\n                      model: this\n                    })\n\n                    break\n                  }\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field({\n                    name: field,\n                    type: NGN.isFn(fieldcfg) ? fieldcfg : String,\n                    identifier: NGN.isFn(fieldcfg)\n                      ? false\n                      : NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field),\n                    model: this\n                  })\n\n                  break\n              }\n            }\n          } else if (fieldcfg.model === null) {\n            fieldcfg.name = field\n            fieldcfg.identifier = fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n            this.METADATA.fields[field].model = this\n          } else if (fieldcfg.model === this) {\n            fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n          } else if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            return NGN.WARN(`The \"${fieldcfg.name}\" field cannot be applied because model is already specified.`)\n          }\n\n          // Add a direct reference to the model.\n          Object.defineProperty(this, field, {\n            enumerable: true,\n            configurable: true,\n            get: () => this.get(field),\n            set: (value) => this.set(field, value)\n          })\n\n          // Enable auditing if necessary.\n          if (this.METADATA.AUDITABLE) {\n            if (this.METADATA.fields[field].fieldType !== 'virtual') {\n              this.METADATA.fields[field].auditable = true\n              this.METADATA.auditFieldNames.add(field)\n            }\n          }\n\n          // Add the field to the list\n          this.METADATA.knownFieldNames.add(field)\n\n          this.METADATA.fields[field].relay('*', this, 'field.')\n\n          if (!suppressEvents) {\n            this.emit('field.create', this.METADATA.fields[field])\n          }\n\n          return this.METADATA.fields[field]\n        },\n\n        /**\n         * An internal helper method for applying changes to the model.\n         * @param  {String} [type='undo']\n         * This can be `undo` or `redo`.\n         * @param  {Number} [count=1]\n         * The number of cursor indexes to shift\n         * @param  {Boolean} [suppressEvents=false]\n         * Indicates events should be suppressed.\n         * @private\n         */\n        applyChange: (type = 'undo', count = 1, suppressEvents = false) => {\n          if (!this.METADATA.AUDITABLE) {\n            NGN.WARN(`The ${type} operation failed on the ${this.name} model because auditing is disabled.`)\n            return\n          }\n\n          this.METADATA.AUDITLOG[type === 'undo' ? 'rollback' : 'advance'](count)\n\n          let data = this.METADATA.AUDITLOG.currentValue\n\n          if (data) {\n            this.METADATA.auditFieldNames.forEach(fieldname => {\n              let field = this.METADATA.fields[fieldname]\n              let log = field.METADATA.AUDITLOG\n\n              if (log.cursor !== data[fieldname]) {\n                if (typeof data[fieldname] === 'symbol') {\n                  log.cursor = data[fieldname]\n                } else {\n                  log.cursor = null\n                }\n\n                field.METADATA.setValue(NGN.coalesce(log.currentValue, field.default), suppressEvents, true)\n              }\n            })\n          }\n        },\n\n        /**\n         * Generates a key/value representation of the model where\n         * each key represents an auditable field and each value is the\n         * transaction cursor ID.\n         * @return {Object}\n         * @private\n         */\n        getAuditMap: () => {\n          let map = {}\n\n          this.METADATA.auditFieldNames.forEach(field => {\n            map[field] = this.METADATA.fields[field].METADATA.AUDITLOG.cursor\n          })\n\n          return map\n        },\n\n        /**\n         * Restore the model to a specific audit map (i.e. historical state\n         * of multiple fields).\n         * @param {Object} map\n         * The audit map to restore.\n         */\n        // restore: (map) => {\n        //   let keys = Object.keys(map)\n        //\n        //   for (let i = 0; i < keys.length; i++) {\n        //     if (this.METADATA.knownFieldNames.has(keys[i]) && typeof map[keys[i]] === 'symbol') {\n        //       console.log('Has', keys[i])\n        //\n        //     }\n        //   }\n        // },\n\n        // Deprecations\n        setSilent: NGN.deprecate(this.setSilentFieldValue, 'setSilent has been deprecated. Use setSilentFieldValue instead.'),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        DATAMAP: null\n      }),\n\n      MAP: NGN.get(() => {\n        return NGN.coalesce(\n          this.METADATA.DATAMAP,\n          this.METADATA.store instanceof NGN.DATA.Store\n            ? this.METADATA.store.map\n            : null\n        )\n      })\n    })\n\n    if (cfg.fieldmap instanceof NGN.DATA.FieldMap) {\n      this.METADATA.DATAMAP = cfg.fieldmap\n    } else if (NGN.typeof(cfg.fieldmap) === 'object') {\n      this.METADATA.DATAMAP = new NGN.DATA.FieldMap(cfg.fieldmap)\n    }\n\n    // Bubble events to the BUS\n    // this.relay('*', NGN.BUS, 'record.')\n\n    // Add data fields.\n    let fields = Object.keys(this.METADATA.fields)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i]\n\n      if (this.METADATA.knownFieldNames.has(name)) {\n        NGN.WARN(`Duplicate field \"${name}\" detected.`)\n      } else {\n        // Configure a data field for each configuration.\n        this.METADATA.applyField(name, this.METADATA.fields[name], true)\n      }\n    }\n\n    // Apply automatic ID's when applicable\n    if (this.METADATA.autoid) {\n      let autoIdValue = null\n\n      Object.defineProperty(this.METADATA, 'IdentificationValue', NGN.get(() => {\n        if (autoIdValue === null) {\n          autoIdValue = NGN.DATA.UTILITY.UUID()\n        }\n\n        return autoIdValue\n      }))\n    }\n\n    // Apply auditing if configured\n    this.auditable = NGN.coalesce(cfg.audit, false)\n\n    // Clear any cached checksums when the model changes.\n    this.on(['field.update', 'field.create', 'field.delete', 'field.hidden', 'field.unhidden'], () => {\n      if (this.METADATA.checksum) {\n        this.METADATA.checksum = null\n      }\n    })\n\n    // Configure TTL/Expiration\n    if (cfg.expires) {\n      this.expires = cfg.expires\n    }\n\n    // Configure model-level validation rules\n    if (this.METADATA.validators !== null) {\n      switch (NGN.typeof(this.METADATA.validators)) {\n        // Support key/value objects where the key is the name and value is a function.\n        case 'object':\n          let keys = Object.keys(this.METADATA.validators)\n          let rules = []\n\n          for (let i = 0; i < keys.length; i++) {\n            rules.push(new NGN.DATA.Rule(this.METADATA.validators[keys[i]], keys[i], this))\n          }\n\n          break\n\n        // Support an array of existing data rules.\n        case 'array':\n          for (let i = 0; i < this.METADATA.validators.length; i++) {\n            if (this.METADATA.validators[i].hasOwnProperty('RULE')) {\n              this.METADATA.validators[i].RULE.scope = this\n            } else {\n              throw new Error(`Invalid data rule configuration for ${this.name} model. Rule #${i} is not a valid NGN.DATA.Rule instance.`)\n            }\n          }\n\n          break\n\n        // Diasllow any other kinds of rules.\n        default:\n          throw new Error(`Invalid data rule configuration for ${this.name} model. Expected an object or array of NGN.DATA.Rule instances. Received \"${NGN.typeof(this.METADATA.validators)}\"`)\n      }\n    }\n\n    if (NGN.coalesce(cfg.expires) !== null) {\n      this.expires = cfg.expires\n    }\n  }\n\n  get name () {\n    return this.METADATA.name\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n      this.METADATA.auditFieldNames = value ? new Set() : null\n\n      // Set each field to an auditable state (or not).\n      this.METADATA.knownFieldNames.forEach(fieldname => {\n        if (!this.METADATA.fields[fieldname].virtual) {\n          this.METADATA.fields[fieldname].auditable = value\n\n          if (value) {\n            this.METADATA.auditFieldNames.add(fieldname)\n          }\n        }\n      })\n\n      if (value) {\n        // Track Changes (if auditing enabled)\n        this.on('field.transaction.*', (id) => {\n          this.METADATA.AUDIT_HANDLER({ cursor: id })\n        })\n      } else {\n        this.METADATA.auditFieldNames.clear()\n\n        this.off('field.transaction.*')\n      }\n    }\n  }\n\n  /**\n   * The unique ID assigned to the model.\n   * @return {string}\n   */\n  get id () {\n    return this.get(this.METADATA.IdentificationField)\n  }\n\n  set id (value) {\n    this.set('id', value)\n  }\n\n  /**\n   * @property ID\n   * An alias for #id.\n   */\n  get ID () {\n    return this.id\n  }\n\n  set ID (value) {\n    this.set('id', value)\n  }\n\n  /**\n   * Returns a reference to the store in which the model/record is a part of.\n   * @return {NGN.DATA.Store}\n   */\n  get store () {\n    return this.METADATA.store\n  }\n\n  /**\n   * @property {Array} changelog\n   * The changelog returns the underlying NGN.DATA.TransactionLog#log if\n   * auditing is available. The array will be empty if auditing is disabled.\n   */\n  get changelog () {\n    return this.METADATA.AUDITLOG.log.map(entry => {\n      let result = {\n        timestamp: entry.timestamp,\n        activeCursor: entry.activeCursor,\n        value: {}\n      }\n\n      let data = entry.value\n      let field = Object.keys(data)\n\n      for (let i = 0; i < field.length; i++) {\n        if (typeof data[field[i]] === 'symbol') {\n          result.value[field[i]] = NGN.coalesce(\n            this.METADATA.fields[field[i]].METADATA.AUDITLOG.getCommit(data[field[i]]).value,\n            this.METADATA.fields[field[i]].default\n          )\n        } else {\n          result.value[field[i]] = NGN.coalesce(this.METADATA.fields[field[i]].default)\n        }\n      }\n\n      return result\n    })\n  }\n\n  /**\n   * @property {Number} createDate\n   * The date/time when the model is created.\n   */\n  get createDate () {\n    return this.METADATA.created\n  }\n\n  /**\n   * @property {object} data\n   * A serialized version of the data represented by the model. This\n   * only includes non-virtual fields. See #representation to use\n   * a representation of data containing virtual fields.\n   */\n  get data () {\n    if (this.MAP) {\n      return this.MAP.applyInverseMap(this.serializeFields())\n    }\n\n    return this.serializeFields()\n  }\n\n  /**\n   * @property {object} unmappedData\n   * Returns #data _without applying_ the data #map.\n   */\n  get unmappedData () {\n    return this.serializeFields()\n  }\n\n  /**\n   * @property {object} representation\n   * A serialized version of the data represented by the model. This\n   * includes virtual fields. See #data to use just the raw values.\n   */\n  get representation () {\n    if (this.MAP) {\n      return this.MAP.applyInverseMap(this.serializeFields(false, false))\n    }\n\n    return this.serializeFields(false, false)\n  }\n\n  /**\n   * @property {object} unmappedRepresentation\n   * Returns #representation _without applying_ the data #map.\n   */\n  get unmappedRepresentation () {\n    return this.serializeFields(false, false)\n  }\n\n  /**\n   * @property {string} checksum\n   * The checksum is a unique \"fingerprint\" of the data stored in the model.\n   * Please note that generating a checksum for an individual record is\n   * usually a quick operation, but generating large quantities of checksums\n   * simultaneously/sequentially can be computationally expensive. On average,\n   * a checksum takes 3-125ms to generate.\n   */\n  get checksum () {\n    this.METADATA.checksum = NGN.coalesce(this.METADATA.checksum, NGN.DATA.UTILITY.checksum(JSON.stringify(this.data)))\n\n    return this.METADATA.checksum\n  }\n\n  /**\n   * @property {Date} expires\n   * The date/time when the record expires. This may be set to\n   * a future date, or a numeric value. Numeric values\n   * represent the number of milliseconds from the current time\n   * before the record expires. For example, set this to `3000`\n   * to force the record to expire 3 seconds from now.\n   *\n   * Set this to `0` to immediately expire the record. Set this to\n   * `-1` or `null` to prevent the record from expiring.\n   */\n  get expires () {\n    return this.METADATA.expiration\n  }\n\n  set expires (value) {\n    if (value === null) {\n      clearTimeout(this.METADATA.expirationTimeout)\n      this.METADATA.expiration = null\n      return\n    }\n\n    let now = new Date()\n\n    if (!isNaN(value) && !(value instanceof Date)) {\n      // Handle numeric (millisecond) expiration\n      if (value < 0) {\n        this.METADATA.expiration = null\n\n        return\n      }\n\n      if (value === 0) {\n        this.METADATA.expiration = now\n        this.emit('expire', this)\n\n        return\n      }\n\n      this.METADATA.expiration = new Date()\n      this.METADATA.expiration.setTime(now.getTime() + value)\n    } else if (!(value instanceof Date) || value <= now) {\n      throw new Error(`${this.name} expiration (TTL) value must be a positive number (milliseconds) or future date.`)\n    } else {\n      // Handle date-based expiration\n      this.METADATA.expiration = value\n    }\n\n    clearTimeout(this.METADATA.expirationTimeout)\n\n    this.METADATA.expirationTimeout = setTimeout(() => this.emit('expire', this), this.METADATA.expiration.getTime() - now.getTime())\n  }\n\n  get expired () {\n    if (this.METADATA.expiration === null) {\n      return false\n    }\n\n    return this.METADATA.expiration <= (new Date())\n  }\n\n  get fieldDefinitions () {\n    return this.METADATA.fields\n    // if (this.METADATA.knownFieldNames.size === 0) {\n    //   return {}\n    // }\n    //\n    // let fields = this.METADATA.knownFieldNames.keys()\n    // let result = {}\n    // let fieldname = fields.next()\n    //\n    // while (!fieldname.done) {\n    //   let field = this.METADATA.fields[fieldname.value]\n    //\n    //   if ((\n    //     field.value === undefined ||\n    //     (ignoreID && fieldname.value === this.IdentificationField) ||\n    //     (!field.virtual || (!ignoreVirtualFields && field.virtual))\n    //   )) {\n    //     // Do not serialize hidden values or virtuals\n    //     if (!field.hidden) {\n    //       switch (NGN.typeof(field.value)) {\n    //         case 'array':\n    //         case 'object':\n    //           result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\n    //           break\n    //\n    //         default:\n    //           result[fieldname.value] = field.value\n    //       }\n    //     }\n    //   }\n    // }\n  }\n\n  serializeFields (ignoreID = false, ignoreVirtualFields = true) {\n    if (this.METADATA.knownFieldNames.size === 0) {\n      return {}\n    }\n\n    let fields = this.METADATA.knownFieldNames.keys()\n    let result = {}\n    let fieldname = fields.next()\n\n    while (!fieldname.done) {\n      let field = this.METADATA.fields[fieldname.value]\n\n      // Ignore unserializable fields\n      if ((\n        field.value === undefined ||\n        (ignoreID && fieldname.value === this.IdentificationField) ||\n        (!field.virtual || (!ignoreVirtualFields && field.virtual))\n      )) {\n        // Do not serialize hidden values or virtuals\n        if (!field.hidden) {\n          switch (NGN.typeof(field.value)) {\n            case 'array':\n            case 'object':\n              result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\n              break\n\n            default:\n              result[fieldname.value] = field.value\n          }\n        }\n      }\n\n      fieldname = fields.next()\n    }\n\n    return result\n  }\n\n  serialize () {\n    return NGN.deprecate(this.serializeFields, 'serialize is now serializeFields. Use NGN.DATA.UTILITY.serialize for generic object serialization.')\n  }\n\n  /**\n   * Determines whether a field exists in the model or not.\n   * @param  {string} field\n   * Name of the field to check for.\n   * @return {boolean}\n   */\n  fieldExists (field) {\n    return this.METADATA.knownFieldNames.has(field)\n  }\n\n  /**\n   * Retrieve the value of the specified field.\n   * @param  {string} field\n   * Name of the field whose value should be returned.\n   * @return {any}\n   * Returns the value of the field.\n   */\n  get (field) {\n    if (field === 'id' || field === 'ID' || field === this.METADATA.IdentificationField) {\n      field = this.METADATA.IdentificationField\n\n      if (this.METADATA.autoid) {\n        if (!this.METADATA.knownFieldNames.has(field)) {\n          return this.METADATA.IdentificationValue\n        } else {\n          return NGN.coalesce(this.METADATA.fields[field].value, this.METADATA.IdentificationValue)\n        }\n      }\n    }\n\n    if (this.METADATA.knownFieldNames.has(field)) {\n      return this.METADATA.fields[field].value\n    } else {\n      NGN.WARN(`Cannot get \"${field}\". The field is not part of the model.`)\n      return undefined\n    }\n  }\n\n  /**\n   * Set a new value for the specified field.\n   * @param {string} field\n   * Name of the field whose value will be changed.\n   * @param {any} value\n   * The new value of the field.\n   */\n  set (field, value) {\n    if (field === 'id' || field === 'ID') {\n      field = this.METADATA.IdentificationField\n    }\n\n    if (this.METADATA.knownFieldNames.has(field)) {\n      this.METADATA.fields[field].value = value\n    } else {\n      NGN.WARN(`Cannot set \"${field}\". Unrecognized field name.`)\n    }\n  }\n\n  /**\n   * Add a data field after the initial model definition.\n   * @param {string} fieldname\n   * The name of the field.\n   * @param {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\n   * The field configuration (see cfg#fields for syntax).\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addField (name, fieldConfiguration = null, suppressEvents = false) {\n    if (name instanceof NGN.DATA.Field) {\n      fieldConfiguration = name\n      name = fieldConfiguration.name\n    } else if (typeof name !== 'string') {\n      throw new Error('Cannot add a non-string based field.')\n    }\n\n    this.METADATA.applyField(name, fieldConfiguration, suppressEvents)\n  }\n\n  /**\n   * @method removeField\n   * Remove a field from the data model.\n   * @param {string} name\n   * Name of the field to remove.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is removed.\n   */\n  removeField (name, suppressEvents = false) {\n    if (this.METADATA.knownFieldNames.has(name)) {\n      this.METADATA.knownFieldNames.delete(name)\n      this.METADATA.invalidFieldNames.delete(name)\n\n      const field = this.METADATA.fields[name]\n\n      delete this[name]\n      delete this.METADATA.fields[name] // eslint-disable-line no-undef\n\n      // let change = {\n      //   action: 'delete',\n      //   field: field.name,\n      //   value: field,\n      //   join: field instanceof NGN.DATA.Relationship\n      // }\n\n      if (!suppressEvents) {\n        this.emit('field.remove', field)\n      }\n\n      if (this.METADATA.store !== null) {\n        this.METADATA.store.emit(this.METADATA.store.PRIVATE.EVENT.DELETE_RECORD_FIELD, {\n          record: this,\n          field\n        })\n      }\n    }\n  }\n\n  /**\n   * Returns the NGN.DATA.Field object for the specified field.\n   * @param  {string} fieldName\n   * Name of the field to retrieve.\n   * @return {NGN.DATA.Field}\n   * The raw field.\n   */\n  getField (name) {\n    if (name.toLowerCase() === 'id' && !this.METADATA.fields.hasOwnProperty(name) && this.METADATA.fields.hasOwnProperty(this.METADATA.IdentificationField)) {\n      return this.METADATA.fields[this.METADATA.IdentificationField]\n    }\n\n    return this.METADATA.fields[name]\n  }\n\n  /**\n   * @method setSilent\n   * A method to set a field value without triggering an update event.\n   * This is designed primarily for use with live update proxies to prevent\n   * endless event loops.\n   * @param {string} fieldname\n   * The name of the #field to update.\n   * @param {any} value\n   * The new value of the field.\n   * @private\n   */\n  setSilentFieldValue (field, value) {\n    this.METADATA.fields[field].silentValue = value\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog (transaction log). To \"undo\" an \"undo\", use #redo.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  undo (count = 1, suppressEvents = false) {\n    this.METADATA.applyChange('undo', ...arguments)\n  }\n\n  /**\n   * @method redo\n   * A function to reapply known changes. This operation affects\n   * the changelog (transaction log).\n   *\n   * The redo operation only works after an undo operation, but before a new\n   * value is committed to the transaction log. In other words, `undo -> redo`\n   * will work, but `undo -> update -> redo` will not. For details, see how\n   * the NGN.DATA.TransactionLog cursor system works.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  redo (count = 1, suppressEvents = false) {\n    this.METADATA.applyChange('redo', ...arguments)\n  }\n\n  /**\n   * @method load\n   * Load a data record.\n   * @param {object} data\n   * The data to apply to the model.\n   * @param {boolean} [suppressEvents=false]\n   * Do not emit a change event when the data is loaded.\n   */\n  load (data, suppressEvents = false) {\n    if (this.MAP) {\n      data = this.MAP.applyMap(data)\n    }\n\n    let keys = Object.keys(data)\n\n    for (let i = 0; i < keys.length; i++) {\n      if (this.METADATA.knownFieldNames.has(keys[i])) {\n        this.METADATA.fields[keys[i]].METADATA.setValue(data[keys[i]], suppressEvents)\n      } else {\n        NGN.WARN(`Failed to load ${keys[i]} field of ${this.name} model. \"${keys[i]}\" is not a recognized field.`)\n      }\n    }\n\n    if (!suppressEvents) {\n      this.emit('load')\n    }\n\n    return this\n  }\n\n  /**\n   * @info This method only works on records within a store. If this method is\n   * called on a model that is not part of a store, the model itself will be\n   * returned.\n   *\n   * Retrieve the next record (after this one) from the store.\n   * This can be used to iterate through a store by calling `model.next()`.\n   * This is operation acts as a linked list iterator.\n   * @param  {Number}  [count=1]\n   * The number of records to retrieve. For example, `1` retrieves the next record.\n   * `2` retrieves the second record after this one. A negative number will\n   * automatically use the #previous method to retrieve prior records. Setting this\n   * to `0` will return the current record (i.e. no change).\n   * @param  {Boolean}  [cycle=false] [description]\n   * If this `next` is called on the last record, it will fail. Setting `cycle` to\n   * `true` will automatically restart the iteration, returning the first record in\n   * the store.\n   * @return {NGN.DATA.Model}\n   * Returns the next model in the store (after this one.)\n   */\n  next (count = 1, cycle = false) {\n    if (count === 0) {\n      return this\n    }\n\n    if (this.METADATA.store) {\n      if (typeof count === 'boolean') {\n        cycle = count\n        count = 1\n      }\n\n      return this.METADATA.store.getRecordSibling(this, count, cycle)\n    } else {\n      NGN.WARN('Attempted to call next() on a model that does not belong to a store.')\n      return this\n    }\n  }\n\n  /**\n   * Retrieve the previous record (before this one) from the store.\n   * This can be used to iterate through a store in reverse by calling\n   * `model.previous()`. This is operation acts as a doubly linked list iterator.\n   *\n   * @info This method only works on records within a store. If this method is\n   * called on a model that is not part of a store, the model itself will be\n   * returned.\n   * @param  {Number}  [count=1]\n   * The number of records to retrieve. For example, `1` retrieves the prior record.\n   * `2` retrieves the second record before this one. A negative number will\n   * automatically use the #next method to retrieve forward records. Setting this\n   * to `0` will return the current record (i.e. no change).\n   * @param  {Boolean}  [cycle=false]\n   * If this `next` is called on the first record, it will fail. Setting `cycle` to\n   * `true` will automatically restart the iteration, returning the last record in\n   * the store.\n   * @return {NGN.DATA.Model}\n   * Returns the previous model in the store (before this one.)\n   */\n  previous (count = 1, cycle = false) {\n    if (count === 0) {\n      return this\n    }\n\n    if (this.METADATA.store) {\n      if (typeof count === 'boolean') {\n        cycle = count\n        count = 1\n      }\n\n      return this.METADATA.store.getRecordSibling(this, 0 - count, cycle)\n    } else {\n      NGN.WARN('Attempted to call previous() on a model that does not belong to a store.')\n      return this\n    }\n  }\n\n  /**\n   * Remove this model from the NGN.DATA.Store it is a part of.\n   *\n   * @info This method only works on records within a store. If this method is\n   * called on a model that is not part of a store, nothing will happen.\n   */\n  destroy () {\n    if (this.METADATA.store) {\n      this.METADATA.store.remove(this.OID)\n    } else {\n      NGN.WARN('Attempted to call remove() on a model that does not belong to a store.')\n    }\n  }\n}\n","import EventEmitter from '../../emitter/core'\n\n/**\n * @class NGN.DATA.Index\n * Data indexes are a data structure that improves the speed\n * of data retrieval from an NGN.DATA.Store, at the cost of\n * additional memory usage. Even though memory usage is increased\n * for each index applied to a store, it tends to be a very small\n * fraction of the memory required for storing data.\n *\n * Indexes help locate data within a store without having to read\n * every record. They will, in the overwhelming majority of cases,\n * speed up queries. However; if overused or misused, they may\n * marginally _increase_ query processing time.\n *\n * NGN data indexes were designed to be used the same way relational\n * data indexes and graph data vertices are used.\n * @fires create {Symbol}\n * Triggered when a new record is indexed. The payload (Symbol)\n * represents the NGN.DATA.Model#oid.\n * @fires delete {Symbol}\n * Triggered when a record is de-indexed. The payload (Symbol)\n * represents the NGN.DATA.Model#oid.\n * @fires update {Symbol}\n * Triggered when a record is re-indexed (updated). The payload (Symbol)\n * represents the NGN.DATA.Model#oid.\n * @fires reset\n * Triggered when the index is completely cleared/reset to it's original state.\n * @private\n */\nexport default class NGNDataIndex extends EventEmitter { // eslint-disable-line\n  /**\n   * Create a new data index.\n   * @param {Boolean} [BTree=false]\n   * Use a B-Tree index. This is only available for numeric values and dates.\n   * @param {String} [name='Untitled Index']\n   * Optional name for index. This is useful for debugging when multiple\n   * indexes exist.\n   */\n  constructor (btree = false, name = 'Untitled Index') {\n    super()\n\n    Object.defineProperties(this, {\n      // Private constants\n      CREATE_EVENT: NGN.privateconst(Symbol('create')),\n      REMOVE_EVENT: NGN.privateconst(Symbol('delete')),\n      UPDATE_EVENT: NGN.privateconst(Symbol('update')),\n\n      // Private data attributes\n      uniqueValues: NGN.privateconst(new Set()),\n      knownRecords: NGN.privateconst([]), // Linked list of Sets\n      name: NGN.const(name),\n      isBTree: NGN.privateconst(btree)\n    })\n\n    // Bubble up private events when applicable\n    const me = this\n    this.on([\n      this.CREATE_EVENT,\n      this.REMOVE_EVENT,\n      this.UPDATE_EVENT\n    ], function (oid, value, suppressEvent = false) {\n      if (!suppressEvent) {\n        me.emit(this.event.toString().replace(/^Symbol\\(|\\)$/g, ''), oid)\n      }\n    })\n\n    // When all known records for a given value are removed,\n    // clear the unique value index.\n    this.on(this.REMOVE_EVENT, (oid, value) => {\n      if (this.recordsFor(value).length === 0) {\n        let index = this.indexOf(value)\n\n        if (index >= 0) {\n          this.knownRecords.splice(index, 1)\n          this.uniqueValues.delete(value)\n        }\n      }\n    })\n\n    // Support BTree Indexing\n    if (this.isBTree) {\n      Object.defineProperty(this, 'BTREE', NGN.privateconst(new NGN.DATA.BTree(2, name)))\n    }\n  }\n\n  get keys () {\n    if (this.uniqueValues.size === 0) {\n      return []\n    }\n\n    return Array.from(this.uniqueValues.values())\n  }\n\n  /**\n   * Add a field/value to the index.\n   * @param {any} value\n   * The value of the model/record indexed field.\n   * @param {Symbol} oid\n   * The record's object ID (NGN.DATA.Model#OID)\n   */\n  add (value, oid, suppressEvent = false) {\n    let valueIndex = -1\n\n    // Create or identify the index of the unique value\n    if (!this.uniqueValues.has(value)) {\n      this.uniqueValues.add(value)\n      this.knownRecords.push(new Set())\n      valueIndex += this.uniqueValues.size\n    } else {\n      valueIndex = this.indexOf(value)\n    }\n\n    this.knownRecords[valueIndex].add(oid)\n\n    // Add BTree indexing\n    if (this.isBTree) {\n      let btreeValue = value instanceof Date ? value.getTime() : value\n\n      if (this.BTREE.get(btreeValue) === undefined) {\n        this.BTREE.put(btreeValue, valueIndex)\n      }\n    }\n\n    this.emit(this.CREATE_EVENT, oid, value, suppressEvent)\n  }\n\n  /**\n   * Remove a record from the index.\n   * @param  {Symbol} oid\n   * The record's object ID (NGN.DATA.Model#OID)\n   * @param  {any} [value=undefined]\n   * When specified, the field value will be used to identify\n   * the index value. Specifying this value will make the remove\n   * operation faster (uses introspection).\n   */\n  remove (oid, value, suppressEvent = false) {\n    // If a value is specified, attempt to lookup the OID by value.\n    if (value !== undefined) {\n      let index = this.recordsOf(value)\n\n      // If a value index is found, remove the OID\n      if (index) {\n        if (index.delete(oid)) { // Returns false if nothing is actually deleted.\n          if (this.isBTree && (!index || index.size === 0)) {\n            this.BTREE.delete(value instanceof Date ? value.getTime() : value)\n          }\n\n          this.emit(this.REMOVE_EVENT, oid, value, suppressEvent)\n\n          return\n        }\n      }\n\n      NGN.WARN(`Index value \"${value}\" not found in index.`)\n    }\n\n    // Iterate through all index values to remove the OID (slow)\n    let removed = false\n    for (let i = 0; i < this.knownRecords.length; i++) {\n      if (this.knownRecords[i].delete(oid) && !removed) {\n        removed = true\n        value = Array.from(this.uniqueValues.values())[i]\n\n        if (this.isBTree) {\n          this.BTREE.delete(value instanceof Date ? value.getTime() : value)\n        }\n\n        break\n      }\n    }\n\n    if (removed) {\n      this.emit(this.REMOVE_EVENT, oid, value, suppressEvent)\n    }\n  }\n\n  /**\n   * Update an index to reflect an updated value.\n   * @param  {[type]} oid      [description]\n   * @param  {[type]} oldvalue [description]\n   * @param  {[type]} newvalue [description]\n   * @return {[type]}          [description]\n   */\n  update (oid, oldValue, newValue, suppressEvent = false) {\n    if (oldValue !== newValue) {\n      this.remove(oid, oldValue, true)\n      this.add(newValue, oid, true)\n      this.emit(this.UPDATE_EVENT, oid, null, suppressEvent)\n    }\n  }\n\n  /**\n   * Forcibly reset the index (clears everything).\n   */\n  reset () {\n    this.uniqueValues.clear()\n    this.knownRecords.splice(0)\n\n    if (this.isBTree) {\n      this.BTREE.reset()\n    }\n\n    this.emit('reset')\n  }\n\n  /**\n   * Retrieve the index number of known records for the\n   * specified value.\n   * @private\n   * @param  {any} value\n   * The unique value for which records are known.\n   * @return {[numeric]}\n   * The 0-based index of known records. Returns `-1` if no\n   * index exists.\n   */\n  indexOf (value) {\n    return Array.from(this.uniqueValues.keys()).indexOf(value)\n  }\n\n  /**\n   * The records of a particular value.\n   * @private\n   * @param  {any} value\n   * The index field value to use as a lookup.\n   * @return {Set}\n   * An set of object ID's or `null` if none exist.\n   */\n  recordsOf (value) {\n    let valueIndex = this.indexOf(value)\n\n    return valueIndex < 0 ? null : this.knownRecords[valueIndex]\n  }\n\n  /**\n   * Get the list of records for the given value.\n   * @param  {any} value\n   * The value of the index to lookup.\n   * @return {array}\n   * The array contains OID reference values (records).\n   */\n  recordsFor (value) {\n    let index = this.recordsOf(value)\n\n    if (index === null || index.size === 0) {\n      return []\n    }\n\n    return Array.from(index.values())\n  }\n}\n","import EventEmitter from '../emitter/core'\n\n/**\n * @class NGN.DATA.Filter\n * Filters can be applied to NGN.DATA.Store objects to filter\n * records out of the resultset. A store can have any number of\n * filters applied.\n *\n * Typically this class is not invoked directly. A more common\n * approach is to create the filters using the filtering methods\n * found in the NGN.DATA.Store class.\n * @fires enabled\n * Fired when the filter changes state from `disabled` to `enabled`\n * @fires disabled\n * Fired when the filter changes state from `enabled` to `disabled`\n * @fires renamed\n * Fired when the name of the filter changes.\n */\nexport default class NGNDataFilter extends EventEmitter { // eslint-disable-line\n  /**\n   * Create a filter function\n   * @param {string} [name]\n   * The name of the filter. This can be used to reference the filter,\n   * and it will also be displayed in any error messages related to filtering.\n   * @param {function}  filterFn\n   * The function used to filter out a record. This method should return\n   * `true` when the record should **remain** in the result set.\n   * Returning `false` means the record _should not remain_ in\n   * result set (filter out).\n   * @param {Boolean} [enabled=true]\n   * Indicates the filter should be enforced/applied.\n   */\n  constructor (name, filterFn, enabled = true) {\n    if (NGN.isFn(name)) {\n      enabled = NGN.type(filterFn) === 'boolean' ? filterFn : enabled\n      filterFn = name\n      name = `Filter_${filterFn.toString().length}${(new Date()).getTime()}`\n    }\n\n    // If the filter is not a function, convert it to one.\n    // if (!NGN.isFn(filterFn)) {\n    //\n    // }\n\n    super()\n\n    const me = this\n\n    Object.defineProperties(this, {\n      recordUpdates: NGN.private(new Map()),\n      filterName: NGN.private(name),\n      fn: NGN.private(filterFn),\n      active: NGN.private(enabled),\n      filteredRecords: NGN.private({}),\n      filteredRecordStores: NGN.private(new Map()),\n      clean: NGN.privateconst(function () {\n        for (let i = 0; i < arguments.length; i++) {\n          let store = arguments[0]\n          if (store instanceof NGN.DATA.Store) {\n            me.filteredRecordStores.set(store.OID, store)\n            me.filteredRecords[store.OID] = new Set()\n          } else {\n            throw new Error('Cannot clean filter for an unrecognized data store.')\n          }\n        }\n      }),\n      clearFilter: NGN.privateconst(function () {\n        let stores = arguments.length > 0 ? Array.from(arguments).map(store => store.OID) : Object.keys(me.filteredRecords)\n\n        stores.forEach(storeOID => {\n          let store = me.filteredRecordStores.get(storeOID)\n\n          if (store) {\n            me.filteredRecords[storeOID].forEach(recordOID => {\n              store.PRIVATE.ACTIVERECORDS.set(recordOID, store.PRIVATE.FILTEREDRECORDS.get(recordOID))\n              store.PRIVATE.FILTEREDRECORDS.delete(recordOID)\n            })\n          } else {\n            NGN.WARN(`An attempt to remove ${this.name} filter occurred for a NGN.DATA.Store that could not be found or does not exist.`)\n          }\n        })\n\n        this.active = false\n      }),\n      STORE_EVENT: NGN.privateconst(Symbol(`monitor.store.event-${name}-filter`)),\n      // When the store is disabled, restore the records to the active list.\n      deactivate: NGN.privateconst(() => {\n        NGN.INFO('filter.disable', `Disabling \"${this.name}\"`)\n\n        this.filteredRecordStores.forEach(store => {\n          this.filteredRecords[store.OID].forEach(recordOID => {\n            let recordIndex = store.indexOf(recordOID)\n\n            if (recordIndex < 0) {\n              console.log('Record DNE?');\n              this.filteredRecords[store.OID].delete(recordOID)\n            } else {\n              store.PRIVATE.ACTIVERECORDS.set(recordOID, store.indexOf(recordOID))\n              store.PRIVATE.FILTEREDRECORDS.delete(recordOID)\n            }\n          })\n        })\n\n        this.active = false\n      }),\n      // When the store is enabled, reapply the filter.\n      activate: NGN.privateconst(() => {\n        NGN.INFO('filter.enable', `Enabling \"${this.name}\"`)\n        this.filteredRecordStores.forEach(store => {\n          // Support updates that occured while filter was inactive.\n          if (this.recordUpdates.has(store.OID)) {\n            this.recordUpdates.get(store.OID).forEach(recordOID => {\n              if (store.PRIVATE.RECORDMAP.has(recordOID)) {\n                this.exec(store.METADATA.records[store.PRIVATE.RECORDMAP.get(recordOID)])\n              }\n            })\n\n            this.recordUpdates.get(store.OID).clear()\n          }\n\n          // Refilter known records\n          this.filteredRecords[store.OID].forEach(recordOID => {\n            if (!this.recordUpdates.has(store.OID) || !this.recordUpdates.get(store.OID).has(recordOID)) {\n              // Add the record to the store's filtered recordset\n              store.PRIVATE.FILTEREDRECORDS.set(recordOID, store.indexOf(recordOID))\n\n              // Remove the filtered record from the store's active record set.\n              store.PRIVATE.ACTIVERECORDS.delete(recordOID)\n            }\n          })\n        })\n\n        this.active = true\n      })\n    })\n\n    // Monitor data changes\n    this.on(this.STORE_EVENT, payload => {\n      if (!this.recordUpdates.has(payload.record.store.OID)) {\n        this.recordUpdates.set(payload.record.store.OID, new Set())\n      }\n\n      switch (payload.event) {\n        case 'record.create':\n          if (!this.active) {\n            this.recordUpdates.get(payload.record.store.OID).add(payload.record.OID)\n          } else {\n            this.exec(payload.record)\n          }\n          break\n\n        case 'record.delete':\n          if (!this.active) {\n            this.recordUpdates.get(payload.record.store.OID).add(payload.record.OID)\n          } else if (this.filteredRecords.hasOwnProperty(payload.record.store.OID)) {\n            this.filteredRecords[payload.record.store.OID].delete(payload.record.OID)\n          }\n          break\n\n        case 'record.update':\n          if (!this.active) {\n            this.recordUpdates.get(payload.record.store.OID).add(payload.record.OID)\n          } else {\n            let filtered = this.filteredRecords[payload.record.store.OID].get(payload.record.OID)\n            let retained = this.exec(payload.record)\n\n            if (retained && filtered) {\n              this.filteredRecords[payload.record.store.OID].delete(payload.record.OID)\n\n              payload.record.store.PRIVATE.ACTIVERECORDS.set(payload.record.OID, payload.record.store.PRIVATE.FILTEREDRECORDS.get(payload.record.OID))\n              payload.record.store.PRIVATE.FILTEREDRECORDS.delete(payload.record.OID)\n            }\n          }\n\n          break\n\n        default:\n          NGN.WARN(`\"${payload.event}\" is not handled by filter functions.`)\n      }\n    })\n  }\n\n  get applied () {\n    return this.active\n  }\n\n  get name () {\n    return this.filterName\n  }\n\n  set name (value) {\n    if (value !== this.filterName) {\n      let old = this.filterName\n      this.filterName = value\n      this.emit('renamed', { old, new: value })\n    }\n  }\n\n  get enabled () {\n    return this.active\n  }\n\n  set enabled (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.active) {\n      if (value) {\n        this.enable()\n      } else {\n        this.disable()\n      }\n    }\n  }\n\n  get disabled () {\n    return !this.active\n  }\n\n  set disabled (value) {\n    value = !NGN.forceBoolean(value)\n\n    if (value !== !this.active) {\n      if (!value) {\n        this.enable()\n      } else {\n        this.disable()\n      }\n    }\n  }\n\n  enable () {\n    if (!this.active) {\n      this.activate()\n      this.emit('enabled')\n    }\n  }\n\n  disable () {\n    if (this.active) {\n      this.deactivate()\n      this.emit('disabled')\n    }\n  }\n\n  /**\n   * Apply the filter to the store. If the filter is disabled, it will\n   * be added to the store, but not enforced (i.e. it will do nothing until\n   * it is enabled).\n   * @param  {NGN.DATA.Store} store\n   * The NGN.DATA.Store to apply the filter to.\n   */\n  apply (store) {\n    store.addFilter(this)\n  }\n\n  /**\n   * Run the filter function against a record.\n   * @param  {NGN.DATA.Model} record\n   * The record to process.\n   * @return {boolean}\n   * Returns `true` if filtered or `false` if unfiltered.\n   * @private\n   */\n  exec (record) {\n    if (!this.active) {\n      return false\n    }\n\n    if (!record) {\n      throw new Error('Cannot execute filter against a null/undefined record.')\n    }\n\n    if (!record.METADATA) {\n      record = record.store.getRecord(record.OID)\n    }\n\n    const store = record.METADATA.store\n\n    if (store === null || store === undefined) {\n      throw new Error('Cannot filter a record which is not part of a store: \\n' + JSON.stringify(record.data, null, 2))\n    }\n\n    let retain = this.fn(record)\n\n    if (!retain) {\n      if (!this.filteredRecords.hasOwnProperty(store.OID)) {\n        this.filteredRecords[store.OID] = new Set()\n        this.filteredRecordStores.set(store.OID, store)\n\n        let me = this\n        store.on('record.*', function (storeRecord) {\n          me.delayEmit(me.STORE_EVENT, 0, {\n            event: this.event,\n            record: storeRecord\n          }) // Specify 0 to emit on the next event loop, assuring the record is written to memory before handling the event.\n        })\n      }\n\n      // Store references to the filtered records\n      this.filteredRecords[store.OID].add(record.OID)\n\n      // Add the record to the store's filtered recordset\n      store.PRIVATE.FILTEREDRECORDS.set(record.OID, store.indexOf(record.OID))\n\n      // Remove the filtered record from the store's active record set.\n      store.PRIVATE.ACTIVERECORDS.delete(record.OID)\n    }\n\n    return retain\n  }\n\n  /**\n   * Clear the filtered records.\n   * @param {NGN.DATA.Store[]} stores\n   * Optionally provide known stores as arguments.\n   * All stores are cleared of this filter by default.\n   */\n  clear () {\n    if (!this.active) {\n      return\n    }\n\n    this.clearFilter(...arguments)\n  }\n\n  /**\n   * Purge the cached record filter.\n   * @param {NGN.DATA.Store[]} stores\n   * Optionally provide known stores as arguments.\n   * All stores are cleared of this filter by default.\n   * @private\n   */\n  purge () {\n    if (arguments.length === 0) {\n      this.filteredRecords = {}\n      this.filteredRecordStores = new Map()\n      return\n    }\n\n    let stores = Array.from(arguments).map(store => store.OID)\n\n    stores.forEach(storeOID => {\n      delete this.filteredRecords[storeOID]\n      this.filteredRecordStores.delete(storeOID)\n    })\n  }\n\n  destroy () {\n    this.clearFilter(...arguments)\n\n    let args = Array.from(arguments)\n    let stores = args.length === 0 ? Array.from(this.filteredRecordStores).map(item => item[1]) : args\n\n    stores.forEach(store => store.METADATA.filters.delete(this.name))\n  }\n}\n","import EventEmitter from '../emitter/core'\n\nNGN.createException({\n  name: 'NGNDuplicateRecordError',\n  message: 'A duplicate record exists within the unique data set.'\n})\n\nNGN.createException({\n  name: 'NGNMissingRecordError',\n  message: 'The specified record does not exist or cannot be found.'\n})\n\n/**\n * @class NGN.DATA.Store\n * Represents a collection of data.\n * @fires record.create\n * Fired when a new record is created. The new\n * record is provided as an argument to the event\n * handler.\n * @fires record.delete\n * Fired when a record(s) is removed. The old record\n * is provided as an argument to the event handler.\n * @fires record.update\n * Fired when a record(s) is modified. A change object\n * is provided as an argument to event handlers. The object\n * contains a reference to the store, the old record, and\n * the new record.\n *\n * ```\n * {\n *   store: <current data store>,\n *   new: <NGN.DATA.Model>,\n *   old: <NGN.DATA.Model>\n * }\n * ```\n */\nexport default class NGNDataStore extends EventEmitter { // eslint-disable-line\n  constructor (cfg = {}) {\n    if (NGN.typeof(cfg) === 'model') {\n      cfg = { model: cfg }\n    } else if (!cfg.model || !NGN.DATA.UTILITY.isDataModel(cfg.model)) {\n      throw new InvalidConfigurationError('Missing or invalid \"model\" configuration property.')\n    }\n\n    super()\n\n    const me = this\n\n    Object.defineProperties(this, {\n      OID: NGN.privateconst(Symbol('store.id')),\n\n      METADATA: NGN.private({\n        /**\n         * @cfgproperty {string} [name]\n         * A descriptive name for the store. This is typically used for\n         * debugging, logging, and (somtimes) data proxies.\n         */\n        name: NGN.coalesce(cfg.name, 'Untitled Data Store'),\n\n        // Holds the models/records\n        records: [],\n\n        // Holds all of the relevant filters associated with the store.\n        filters: new Map(),\n\n        /**\n         * @cfgproperty {NGN.DATA.Model} model\n         * An NGN Data Model to which data records conform.\n         */\n        Model: NGN.coalesce(cfg.model),\n\n        /**\n         * @cfg {Number} [expires=-1]\n         * Sets the default NGN.DATA.Model#expiration value (Milliseconds) for each new record as it\n         * is added to the store.\n         */\n        expires: NGN.coalesce(cfg.expires, -1),\n\n        /**\n         * @cfg {boolean} [allowDuplicates=true]\n         * Set to `false` to prevent duplicate records from being added.\n         * If a duplicate record is added, it will be ignored and an\n         * error will be thrown.\n         *\n         * **Identifying duplicates _may_ be slow** on data sets with 200+ records.\n         * Uniqueness is determined by a checksum of the current NGN.DATA.Model#data\n         * of a record. The amount of time required to generate a checksum can range\n         * from 3ms to 150ms per record depending on data complexity.\n         *\n         * In most scenarios, the performance impact will be negligible/indistinguishable\n         * to the naked eye. However; if an application experiences slow data\n         * load or processing times, setting this to `false` may help.\n         */\n        allowDuplicates: NGN.coalesce(cfg.allowDuplicates, true),\n\n        /**\n         * @cfg {boolean} [errorOnDuplicate=false]\n         * Set to `true` to throw an error when a duplicate record is detected.\n         * If this is not set, it will default to the value of #allowDuplicates.\n         * If #allowDuplicates is not defined either, this will be `true`\n         */\n        errorOnDuplicate: NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, false),\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * Allow invalid records to be added to the store.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {boolean} [errorOnInvalid=false]\n         * Set to `true` to throw an error when an attempt is made to add an\n         * invalid record.\n         */\n        errorOnInvalid: NGN.coalesce(cfg.errorOnInvalid, cfg.allowInvalid, false),\n\n        /**\n         * @cfgproperty {boolean} [autoRemoveExpiredRecords=true]\n         * When set to `true`, the store will automatically delete expired records.\n         */\n        autoRemoveExpiredRecords: NGN.coalesce(cfg.autoRemoveExpiredRecords, true),\n\n        /**\n         * @cfg {boolean} [softDelete=false]\n         * When set to `true`, the store makes a copy of a record before removing\n         * it from the store. The store will still emit a `record.delete` event,\n         * and it will still behanve as though the record has been completely\n         * removed. However; the record copy can be retrieved using the #restore\n         * method.\n         *\n         * Since it is not always desirable to store a copy of every deleted\n         * record indefinitely, it is possible to expire and permanently remove\n         * records by setting the #softDeleteTtl.\n         *\n         * ```js\n         * var People = new NGN.DATA.Store({\n         *   model: Person,\n         *   softDelete: true,\n         *   softDeleteTtl: 10000\n         * })\n         *\n         * People.add(somePerson)\n         *\n         * var removedRecordId\n         * People.once('record.delete', function (record) {\n         *   removedRecordId = record.id\n         * })\n         *\n         * People.remove(somePerson)\n         *\n         * setTimeout(function () {\n         *   People.restore(removedRecordId)\n         * }, 5000)\n         *\n         * ```\n         *\n         * The code above creates a new store and adds a person to it.\n         * Then a placeholder variable (`removedRecordId`) is created.\n         * Next, a one-time event listener is added to the store, specifically\n         * for handling the removal of a record. Then the record is removed,\n         * which triggers the `record.delete` event, which populates\n         * `removedRecordId` with the ID of the record that was deleted.\n         * Finally, the code waits for 5 seconds, then restores the record. If\n         * the #restore method _wasn't_ called, the record would be purged\n         * from memory after 10 seconds (because `softDeleteTtl` is set to 10000\n         * milliseconds).\n         */\n        softDelete: NGN.coalesce(cfg.softDelete, false),\n\n        /**\n         * @cfg {number} [softDeleteTtl=-1]\n         * This is the number of milliseconds the store waits before purging a\n         * soft-deleted record from memory. `-1` = Infinite (no TTL).\n         */\n        softDeleteTtl: NGN.coalesce(cfg.softDeleteTtl, -1),\n\n        // ARCHIVE contains soft deleted records\n\n        /**\n         * @cfg {Number} [FIFO=-1]\n         * Configures the store to use \"**F**irst **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the oldest record (i.e. the 1st). This guarantees the\n         * store will never have more than 10 records at any given time and it\n         * will always maintain the latest records.\n         *\n         * FIFO and LIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. FIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        fifo: NGN.coalesce(cfg.FIFO, -1),\n\n        /**\n         * @cfg {Number} [LIFO=-1]\n         * Configures the store to use \"**L**ast **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * This methos acts in the opposite manner as #FIFO. However; for\n         * all intents and purposes, this merely replaces the last record in\n         * the store when a new record is added.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the latest record (i.e. the 10th). This guarantees the\n         * store will never have more than 10 records at any given time. Every\n         * time a new record is added (assuming the store already has the maximum\n         * allowable records), it replaces the last record (10th) with the new\n         * record.\n         *\n         * LIFO and FIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. LIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        lifo: NGN.coalesce(cfg.LIFO, -1),\n\n        /**\n         * @cfg {Number} [maxRecords=-1]\n         * Setting this will prevent new records from being added past this limit.\n         * Attempting to add a record to the store beyond it's maximum will throw\n         * an error.\n         */\n        maxRecords: NGN.coalesce(cfg.maxRecords, -1),\n\n        /**\n         * @cfg {Number} [minRecords=0]\n         * Setting this will prevent removal of records if the removal would\n         * decrease the count below this limit.\n         * Attempting to remove a record below the store's minimum will throw\n         * an error.\n         */\n        minRecords: NGN.coalesce(cfg.minRecords, 0),\n\n        /**\n         * @cfg {Number} [autocompact=50000]\n         * Identify the number of deletions that should occur before\n         * the store is compacted. See #compact. Set this to any value\n         * below `100` (the minimum) to disable autocompact.\n         */\n        autocompact: NGN.coalesce(cfg.autocompact, 50000),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        MAP: NGN.coalesce(cfg.fieldmap),\n\n        EVENTS: new Set([\n          'record.duplicate',\n          'record.create',\n          'record.update',\n          'record.delete',\n          'record.restored',\n          'record.expired',\n          'record.purged',\n          'record.move',\n          'record.invalid',\n          'record.valid',\n          'clear',\n          'filter.create',\n          'filter.delete',\n          'index.create',\n          'index.delete',\n          'compact.start',\n          'compact.complete'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: (change) => {\n          if (change.hasOwnProperty('cursor')) {\n            this.METADATA.AUDITLOG.commit(this.METADATA.getAuditMap())\n          }\n        },\n\n        // The first and last indexes are maintained to determine which active\n        // record is considered first/last. Sometimes data is filtered out,\n        // so the first/last active record is not guaranteed to represent the\n        // first/last actual record. These indexes are maintained to prevent\n        // unnecessary iteration in large data sets.\n        FIRSTRECORDINDEX: 0,\n        LASTRECORDINDEX: 0,\n\n        /**\n         * @cfg {array} [index]\n         * An array of #model fields that will be indexed.\n         * See NGN.DATA.Index for details.\n         */\n        INDEX: null\n      }),\n\n      // Internal attributes that should not be extended.\n      PRIVATE: NGN.privateconst({\n        STUB: Symbol('record.stub'),\n\n        // A private indexing method\n        INDEX: function (record, delta) {\n          if (typeof this.event === 'symbol') {\n            switch (this.event) {\n              case me.PRIVATE.EVENT.CREATE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(record[field], record.OID))\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].remove(record.OID, record[field]))\n                break\n\n              case me.PRIVATE.EVENT.LOAD_RECORDS:\n                for (let i = 0; i < me.METADATA.records.length; i++) {\n                  me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(me.METADATA.records[i][field], me.METADATA.records[i].OID))\n                }\n\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD_FIELD:\n                if (me.METADATA.INDEXFIELDS.has(record.field.name)) {\n                  me.METADATA.INDEX[record.field.name].remove(record.record.OID, record.field.value)\n                }\n\n                break\n\n              case me.PRIVATE.EVENT.CLEAR_RECORDS:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].reset())\n\n                break\n            }\n          } else {\n            switch (this.event) {\n              case 'record.update':\n                if (me.METADATA.INDEXFIELDS.has(delta.field.name)) {\n                  me.METADATA.INDEX[delta.field.name].update(record.OID, delta.old, delta.new)\n                }\n                break\n\n              case 'clear':\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].reset())\n                break\n            }\n          }\n        },\n\n        // Contains a map of all records, in order.\n        RECORDMAP: new Map(),\n\n        // A reference to active records\n        ACTIVERECORDMAP: null,\n\n        // A reference to filtered records (non-active/non-deleted)\n        FILTEREDRECORDMAP: null,\n\n        // Internal events\n        EVENT: {\n          CREATE_RECORD: Symbol('record.create'),\n          DELETE_RECORD: Symbol('record.delete'),\n          DELETE_RECORD_FIELD: Symbol('records.field.delete'),\n          LOAD_RECORDS: Symbol('records.load'),\n          CLEAR_RECORDS: Symbol('records.delete')\n        },\n\n        ORIGINALCFG: cfg,\n\n        // Makes sure the model configuration specifies a valid and indexable field.\n        checkModelIndexField (field) {\n          let metaconfig = me.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields && metaconfig.fields.hasOwnProperty(field)) {\n            if (metaconfig.fields[field] !== null) {\n              if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(metaconfig.fields[field])) >= 0) {\n                throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n              } else if (NGN.typeof(metaconfig.fields[field]) === 'object') {\n                if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(NGN.coalesce(metaconfig.fields[field].type))) >= 0) {\n                  throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n                }\n              }\n            }\n          } else {\n            throw new Error(`Cannot create index for unrecognized field \"${field}\".`)\n          }\n        },\n\n        // Get the type of field from the model definition\n        getModelFieldType (field) {\n          let metaconfig = me.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields[field] === null) {\n            return NGN.typeof(metaconfig.fields[field])\n          }\n\n          if (metaconfig.fields[field].type) {\n            return NGN.typeof(metaconfig.fields[field].type)\n          }\n\n          if (metaconfig.fields[field].default) {\n            return NGN.typeof(metaconfig.fields[field].default)\n          }\n\n          return NGN.typeof(NGN.coalesce(metaconfig.fields[field]))\n        },\n\n        // Prepare record for insertion into the store.\n        createRecord (data, suppressEvents = false) {\n          const record = new me.METADATA.Model(data)\n\n          if (!(record instanceof NGN.DATA.Entity)) {\n            throw new Error(`Only a NGN.DATA.Model or JSON object may be used in NGN.DATA.Store#add. Received a \"${NGN.typeof(data)}\" value.`)\n          }\n\n          // Prevent invalid record addition (if configured)\n          if (!me.METADATA.allowInvalid && !record.valid) {\n            NGN.WARN(`An attempt to add invalid data to the \"${this.name}\" store was prevented. The following fields are invalid: ${Array.from(record.METADATA.invalidFieldNames.keys()).join(', ')}`)\n\n            if (!suppressEvents) {\n              this.emit('record.invalid', record)\n            }\n\n            if (this.METADATA.errorOnInvalid) {\n              throw new Error(`Invalid data cannot be added to the \"${this.name}\" store.`)\n            }\n          }\n\n          // If duplicates are prevented, check the new data.\n          if (!me.METADATA.allowDuplicates) {\n            for (let i = 0; i < this.METADATA.records.length; i++) {\n              if (this.METADATA.records[i].checksum === record.checksum) {\n                NGN.WARN(`An attempt to add a duplicate record to the \"${this.name}\" store was prevented.`)\n\n                if (!suppressEvents) {\n                  this.emit('record.duplicate', record)\n                }\n\n                if (this.METADATA.errorOnDuplicate) {\n                  throw new Error(`Duplicate records are not allowed in the \"${this.name}\" data store.`)\n                }\n\n                break\n              }\n            }\n          }\n\n          // Handle special record count processing (LIFO/FIFO support)\n          if (me.METADATA.lifo > 0 && me.METADATA.records.length + 1 > me.METADATA.lifo) {\n            me.remove(me.METADATA.records.length - 1, suppressEvents)\n          } else if (me.METADATA.fifo > 0 && me.METADATA.records.length + 1 > me.METADATA.fifo) {\n            me.remove(0, suppressEvents)\n          }\n\n          // Relay model events to this store.\n          // record.relay('*', this, 'record.')\n          record.on('*', function () {\n            switch (this.event) {\n              // case 'field.update':\n              // case 'field.delete':\n              //   // TODO: Update indices\n              //   return\n\n              case 'field.invalid':\n              case 'field.valid':\n                return me.emit(this.event.replace('field.', 'record.'), record)\n\n              case 'expire':\n                if (me.METADATA.autoRemoveExpiredRecords) {\n                  me.remove(arguments[0])\n                }\n\n                me.emit('record.expired', arguments[0])\n                return\n            }\n          })\n\n          delete record.METADATA.store\n          Object.defineProperty(record.METADATA, 'store', NGN.get(() => me))\n\n          if (me.METADATA.expires > 0) {\n            record.expires = me.METADATA.expires\n\n          }\n\n          return record\n        },\n\n        // Add a record\n        addRecord (data, suppressEvents = false) {\n          let record = me.PRIVATE.createRecord(...arguments)\n\n          // Indexing is handled in an internal event handler\n          let length = me.METADATA.records.push(record)\n\n          // Add the record to the map for efficient retrievel by OID\n          me.PRIVATE.RECORDMAP.set(record.OID, length - 1)\n\n          me.PRIVATE.ACTIVERECORDS.set(record.OID, length - 1)\n\n          me.METADATA.filters.forEach(filter => filter.exec(record))\n\n          me.emit(me.PRIVATE.EVENT.CREATE_RECORD, record)\n\n          return record\n        },\n\n        /**\n         * Insert record at specific position.\n         * This is accomplished by splicing the record into the records array,\n         * then splitting the record map at the insertion point and recreating\n         * the record map with updated pointer values.\n         */\n        insertRecord (data, index = 0, suppressEvents = false) {\n          index = index < 0 ? 0 : index\n\n          // If the record is supposed to be inserted at the end, just use the\n          // standard addRecord method instead.\n          if (index > me.PRIVATE.RECORDMAP.size) {\n            return me.PRIVATE.addRecord(data, suppressEvents)\n          }\n\n          let record = me.PRIVATE.createRecord(data, suppressEvents)\n          me.METADATA.records.push(record)\n\n          let rawIndex = me.METADATA.records.length - 1\n          let updatedRecords = Array.from(me.PRIVATE.RECORDMAP)\n\n          if (index === 0) {\n            updatedRecords.unshift([record.OID, rawIndex])\n          } else {\n            let lastRecords = updatedRecords.splice(index, updatedRecords.length, [record.OID, rawIndex])\n            updatedRecords = updatedRecords.concat(lastRecords)\n          }\n\n          me.PRIVATE.RECORDMAP = new Map(updatedRecords)\n\n          let firstActiveRecords = index === 0 ? new Array(0) : Array.from(me.PRIVATE.ACTIVERECORDS).filter(item => item[1] < index)\n          let lastActiveRecords = Array.from(me.PRIVATE.ACTIVERECORDS)\n\n          if (index === 0) {\n            lastActiveRecords = lastActiveRecords.filter(item => item[1] >= index)\n          }\n\n          me.PRIVATE.ACTIVERECORDMAP = new Map([...firstActiveRecords, [record.OID, rawIndex], ...lastActiveRecords])\n          me.METADATA.filters.forEach(filter => filter.exec(record))\n          me.PRIVATE.updateOrderIndex()\n\n          me.emit(me.PRIVATE.EVENT.CREATE_RECORD, record)\n\n          return record\n        },\n\n        updateOrderIndex () {\n          let activeRecords = Array.from(me.PRIVATE.ACTIVERECORDS)\n\n          if (activeRecords.length === 0) {\n            me.METADATA.FIRSTRECORDINDEX = 0\n            me.METADATA.LASTRECORDINDEX = 0\n          } else {\n            me.METADATA.FIRSTRECORDINDEX = activeRecords[0][1]\n            me.METADATA.LASTRECORDINDEX = activeRecords[activeRecords.length - 1][1]\n          }\n        },\n\n        convertStubToRecord (index, record) {\n          if (record !== null && record.hasOwnProperty(me.PRIVATE.STUB)) {\n            let newRecord = me.PRIVATE.addRecord(record.metadata, false)\n            newRecord.OID = record.OID\n\n            me.METADATA.records[index] = newRecord\n\n            if (me.METADATA.expires > 0) {\n              newRecord.expires = this.METADATA.expires\n            }\n\n            return newRecord\n          } else if (record === null || record === undefined) {\n            throw new Error('Null stub cannot be converted to record.')\n          } else {\n            return record\n          }\n        },\n\n        /**\n         * Determines whether a specific record should be filtered\n         * @param  {NGN.DATA.Model} record\n         * The record to check.\n         * @return {boolean}\n         * Returns `true` if the record should be retained or `false`\n         * if it should be filtered out.\n         * @private\n         */\n        shouldFilterRecord (record) {\n          let retain = true\n\n          me.METADATA.filters.forEach((filter, name) => {\n            if (retain && !filter.fn(record)) {\n              retain = false\n            }\n          })\n\n          return retain\n        },\n\n        // Force JSON data into the store's specified data model.\n        forceDataObject (data) {\n          if (!(data instanceof me.METADATA.Model)) {\n            // Force a data model\n            if (NGN.typeof(data) === 'string') {\n              data = JSON.parse(data)\n            }\n\n            if (typeof data !== 'object') {\n              throw new Error(`${NGN.typeof(data)} is an invalid data type (must be an object conforming to the ${this.METADATA.Model.name} field configuration).`)\n            }\n          } else {\n            data = data.data\n          }\n\n          return data\n        }\n      }),\n\n      // Create a convenience alias for the remove method.\n      delete: NGN.const(NGN.deprecate(this.remove, 'Store.delete is deprecated. Use Store.remove instead.'))\n    })\n\n    // Create a smart reference to record lists\n    Object.defineProperties(this.PRIVATE, {\n      ACTIVERECORDS: NGN.get(() => {\n        if (this.PRIVATE.ACTIVERECORDMAP === null) {\n          this.PRIVATE.ACTIVERECORDMAP = new Map([...this.PRIVATE.RECORDMAP])\n        }\n\n        return this.PRIVATE.ACTIVERECORDMAP\n      }),\n\n      FILTEREDRECORDS: NGN.get(() => {\n        if (this.PRIVATE.FILTEREDRECORDMAP === null) {\n          this.PRIVATE.FILTEREDRECORDMAP = new Map()\n        }\n\n        return this.PRIVATE.FILTEREDRECORDMAP\n      })\n    })\n\n    // Disallow modification of internal events\n    Object.freeze(this.PRIVATE.EVENT)\n\n    // Support LIFO (Last In First Out) & FIFO(First In First Out)\n    if (this.METADATA.lifo > 0 && this.METADATA.fifo > 0) {\n      throw new InvalidConfigurationError('NGN.DATA.Store can be configured to use FIFO or LIFO, but not both simultaneously.')\n    }\n\n    // If LIFO/FIFO is used, disable alternative record count limitations.\n    if (this.METADATA.lifo > 0 || this.METADATA.fifo > 0) {\n      this.METADATA.minRecords = 0\n      this.METADATA.maxRecords = -1\n    } else {\n      this.METADATA.minRecords = this.METADATA.minRecords < 0 ? 0 : this.METADATA.minRecords\n    }\n\n    // Bubble events to the BUS\n    // this.relay('*', NGN.BUS, 'store.')\n\n    // Configure Indices\n    if (NGN.coalesce(cfg.index) && NGN.typeof(this.METADATA.Model.prototype.CONFIGURATION.fields) === 'object') {\n      this.createIndex(cfg.index)\n    }\n\n    // Setup auto-compact\n    if (this.METADATA.autocompact < 100) {\n      this.METADATA.DELETECOUNT = 0\n      this.on(this.PRIVATE.EVENTS.DELETE_RECORD, () => {\n        this.METADATA.DELETECOUNT++\n\n        if (this.METADATA >= this.METADATA.autocompact) {\n          this.METADATA.DELETECOUNT = 0\n          this.compact()\n        }\n      })\n    }\n\n    NGN.INTERNAL('datastore.created', this)\n  }\n\n  get name () {\n    return this.METADATA.name\n  }\n\n  /**\n   * @property {string}\n   * Name of the store.\n   * @fires {object} renamed\n   * Fired when the name of the store changes.\n   */\n  set name (value) {\n    if (this.METADATA.name !== value) {\n      let oldName = this.METADATA.name\n      NGN.LABELS.DATASTORES.rename(oldName, value)\n      this.METADATA.name = value\n      this.emit('renamed', {\n        old: oldName,\n        new: value\n      })\n    }\n  }\n\n  /**\n   * @property {array} snapshots\n   * Contains the data snapshot of the entire store.\n   * @readonly\n   * @private\n   */\n  get snapshots () {\n    return NGN.coalesce(this.snapshotarchive, [])\n  }\n\n  // Deprecation notice\n  get history () {\n    NGN.WARN('history is deprecated. Use NGN.DATA.Store#changelog instead.')\n    return this.changelog\n  }\n\n  // Deprecation notice\n  get recordCount () {\n    NGN.WARN('recordCount is deprecated. Use NGN.DATA.Store#size instead.')\n    return this.size\n  }\n\n  /**\n   * @property {number} count\n   * The total number of **active** records contained in the store.\n   * Active records are any records that aren't filtered out.\n   */\n  get size () {\n    return this.PRIVATE.ACTIVERECORDS.size\n  }\n\n  /**\n   * @property {number} length\n   * The total number of records contained in the store.\n   * This value does not include any soft-deleted/volatile records.\n   */\n  get length () {\n    return this.METADATA.records.length\n  }\n\n  /**\n   * @property {NGN.DATA.Model} first\n   * Return the first active record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get first () {\n    let record = NGN.coalesce(this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n\n    return this.PRIVATE.convertStubToRecord(this.METADATA.FIRSTRECORDINDEX, record)\n    // return NGN.coalesce(this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n  }\n\n  /**\n   * @property {NGN.DATA.Model} last\n   * Return the last active record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get last () {\n    let record = NGN.coalesce(this.METADATA.records[this.METADATA.LASTRECORDINDEX])\n\n    return this.PRIVATE.convertStubToRecord(this.METADATA.LASTRECORDINDEX, record)\n  }\n\n  /**\n   * @property {object} data\n   * A serialized version of the data represented by the store. This\n   * only includes non-virtual fields. See #representation to use\n   * a representation of data containing virtual fields.\n   */\n  get data () {\n    const recordList = this.PRIVATE.ACTIVERECORDS\n\n    // If no records exist, skip\n    if (recordList.size === 0) {\n      return []\n    }\n    let rec = this.PRIVATE.convertStubToRecord(this.METADATA.FIRSTRECORDINDEX, this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n\n    if (this.METADATA.MAP === null) {\n      this.METADATA.MAP = NGN.coalesce(rec.MAP)\n    }\n\n    let defaults = null\n\n    if (rec instanceof NGN.DATA.Entity) {\n      let fieldDefinitions = rec.fieldDefinitions\n      let fields = Object.keys(fieldDefinitions)\n\n      defaults = {}\n\n      fields.forEach(field => {\n        if (!fieldDefinitions[field].hidden && !fieldDefinitions[field].virtual) {\n          defaults[field] = fieldDefinitions[field].default\n        }\n      })\n    }\n\n    const result = []\n    // const fields = defaults !== null ? Object.keys(defaults) : []\n\n    // Iterate through set\n    recordList.forEach(index => {\n      if (this.METADATA.records[index] !== null) {\n        // If the value is a stub, map it.\n        if (this.METADATA.records[index].hasOwnProperty(this.PRIVATE.STUB)) {\n          let applicableData = Object.assign({}, defaults)\n          let data = Object.assign(applicableData, this.METADATA.records[index].metadata)\n\n          if (this.METADATA.MAP !== null) {\n            result.push(this.METADATA.MAP.applyInverseMap(data))\n          } else {\n            result.push(data)\n          }\n        } else {\n          result.push(this.METADATA.records[index].data)\n        }\n      }\n    })\n\n    return result\n  }\n\n  /**\n  * @property {array} filtered\n  * An array of NGN.DATA.Model records that have been filtered out.\n  * The results reflect the inverse of #data.\n  */\n  get filtered () {\n    return Array.from(this.PRIVATE.FILTEREDRECORDS).map(item => this.METADATA.records[item[1]].data)\n  }\n\n  /**\n   * @property {array} representation\n   * The complete and unfiltered underlying representation dataset\n   * (data + virtuals of each model).\n   */\n  get representation () {\n    const result = []\n    const recordList = this.PRIVATE.ACTIVERECORDS\n\n    recordList.forEach(index => {\n      if (this.METADATA.records[index] !== null) {\n        result.push(this.METADATA.records[index].representation)\n      }\n    })\n\n    return result\n  }\n\n  get auditable () {\n    return this.METADATA.AUDITABLE\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n    }\n  }\n\n  get model () {\n    return this.METADATA.Model\n  }\n\n  set model (value) {\n    if (value !== this.METADATA.Model) {\n      if (NGN.typeof(value) !== 'model') {\n        throw new InvalidConfigurationError(`\"${this.name}\" model could not be set because the value is a ${NGN.typeof(value)} type (requires NGN.DATA.Model).`)\n      }\n\n      this.METADATA.Model = value\n    }\n  }\n\n  get map () {\n    return this.METADATA.MAP\n  }\n\n  /**\n   * @property {array} indexedFieldNames\n   * An array of the field names for which the store maintains indexes.\n   */\n  get indexedFieldNames () {\n    if (this.METADATA.INDEXFIELDS) {\n      return Array.from(this.METADATA.INDEXFIELDS)\n    } else {\n      return []\n    }\n  }\n\n  /**\n   * @method add\n   * Append a data record to the store. This adds the record to the end of the list.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in #model.\n   * @param {boolean} [suppressEvents=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  add (data, suppressEvents = false) {\n    // Support array input\n    if (NGN.typeof(data) === 'array') {\n      let result = new Array(data.length)\n\n      for (let i = 0; i < data.length; i++) {\n        result[i] = this.add(data[i], suppressEvents)\n      }\n\n      return result\n    }\n\n    // Prevent creation if it will exceed maximum record count.\n    if (this.METADATA.maxRecords > 0 && this.METADATA.records.length + 1 > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    const record = this.PRIVATE.addRecord(this.PRIVATE.forceDataObject(data))\n\n    this.METADATA.LASTRECORDINDEX = this.METADATA.records.length - 1\n\n    if (!suppressEvents) {\n      this.emit('record.create', record)\n    }\n\n    return record\n  }\n\n  /**\n   * @method insertBefore\n   * Add a record before the specified record or index.\n   *\n   * **BE CAREFUL** when using this in combination with #LIFO or #FIFO.\n   * LIFO/FIFO is applied _after_ the record is added to the store but\n   * _before_ it is moved to the desired index.\n   * @param  {NGN.DATA.Model|number} target\n   * The record (model) or index where the new record will be before.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  insertBefore (beforeRecord, data, suppressEvents = false) {\n    let recordIndex = typeof beforeRecord === 'number' ? beforeRecord : this.indexOf(beforeRecord)\n\n    if (recordIndex < 0) {\n      throw new NGNMissingRecordError()\n    }\n\n    if (recordIndex >= this.METADATA.records.length) {\n      recordIndex = this.METADATA.records.length - 1\n      recordIndex = recordIndex < 0 ? 0 : recordIndex\n    }\n\n    // Support array input\n    // Records must be inserted in reverse order, since they're being added\n    // BEFORE the same record on each iteration.\n    if (NGN.typeof(data) === 'array') {\n      let result = new Array(data.length)\n\n      for (let i = data.length - 1; i >= 0; i--) {\n        result[i] = this.insertBefore(recordIndex, suppressEvents)\n      }\n\n      return result\n    }\n\n    // Prevent creation if it will exceed maximum record count.\n    if (this.METADATA.maxRecords > 0 && this.METADATA.records.length + 1 > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    const record = this.PRIVATE.insertRecord(this.PRIVATE.forceDataObject(data), recordIndex, suppressEvents)\n\n    // Filters are auto-applied to new records\n\n    if (!suppressEvents) {\n      this.emit('record.create', record)\n    }\n\n    return record\n  }\n\n  /**\n   * @method insertAfter\n   * Add a record after the specified record or index.\n   *\n   * **BE CAREFUL** when using this in combination with #LIFO or #FIFO.\n   * LIFO/FIFO is applied _after_ the record is added to the store but\n   * _before_ it is moved to the desired index.\n   * @param  {NGN.DATA.Model|number} target\n   * The record (model) or index where the new record will be inserted after.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  insertAfter (afterRecord, data, suppressEvents = false) {\n    let recordIndex = typeof afterRecord === 'number' ? afterRecord : this.indexOf(afterRecord)\n\n    if (recordIndex < 0) {\n      throw new NGNMissingRecordError()\n    }\n\n    if (recordIndex >= this.METADATA.records.length) {\n      recordIndex = this.METADATA.records.length - 1\n      recordIndex = recordIndex < 0 ? 0 : recordIndex\n    }\n\n    // Support array input\n    if (NGN.typeof(data) === 'array') {\n      let result = new Array(data.length)\n\n      for (let i = data.length - 1; i >= 0; i--) {\n        result[i] = this.insertAfter(recordIndex, suppressEvents)\n      }\n\n      return result\n    }\n\n    // Prevent creation if it will exceed maximum record count.\n    if (this.METADATA.maxRecords > 0 && this.METADATA.records.length + 1 > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    const record = this.PRIVATE.insertRecord(this.PRIVATE.forceDataObject(data), recordIndex + 1, suppressEvents)\n\n    // Filters are auto-applied to new records\n\n    if (!suppressEvents) {\n      this.emit('record.create', record)\n    }\n\n    return record\n  }\n\n  /**\n   * @method move\n   * Move an existing record to a specific index. This can be used\n   * to reorder a single record.\n   * @param {NGN.DATA.Model|number|string} source\n   * The record or the index of a record within the store to move.\n   * This can also be the unique ID of a record.\n   * @param {NGN.DATA.Model|number|string} target\n   * The record or the index of a record within the store where the source\n   * will be positioned against. This can also be the unique ID of a record.\n   * @returns {NGN.DATA.Model}\n   * Returns the model.\n   * @fires {change:Object} record.moved\n   * This event is triggered when the move is complete.\n   * The change data sent to this event handler looks like:\n   *\n   * ```\n   * {\n   *   oldPosition: {number},\n   *   newPosition: {number},\n   *   record: {NGN.DATA.Model}\n   * }\n   * ```\n   */\n  move (sourceRecord, targetRecord) {\n    sourceRecord = typeof sourceRecord === 'symbol' || typeof sourceRecord === 'number'\n      ? this.getRecord(sourceRecord)\n      : sourceRecord\n\n    if (!sourceRecord) {\n      throw NGNMissingRecordError('Could not find source record.')\n    }\n\n    targetRecord = typeof targetRecord === 'symbol' || typeof targetRecord === 'number'\n      ? this.getRecord(targetRecord)\n      : targetRecord\n\n    if (!targetRecord) {\n      throw NGNMissingRecordError('Could not find target record.')\n    }\n\n    if (sourceRecord === targetRecord) {\n      return\n    }\n\n    let activeRecords = Array.from(this.PRIVATE.ACTIVERECORDS)\n    let sourceIndex = activeRecords.findIndex(item => item[0] === sourceRecord.OID)\n    let targetIndex = activeRecords.findIndex(item => item[0] === targetRecord.OID)\n\n    activeRecords.splice(targetIndex, 0, activeRecords.splice(sourceIndex, 1)[0])\n\n    this.PRIVATE.ACTIVERECORDMAP = new Map([...activeRecords])\n    this.PRIVATE.updateOrderIndex()\n\n    this.emit('record.moved', {\n      oldPosition: sourceIndex,\n      newPosition: targetIndex,\n      record: sourceRecord\n    })\n\n    return this\n  }\n\n  /**\n   * @method moveToEnd\n   * Move a record to the end of the dataset.\n   * @param {NGN.DATA.Model|number|string} source\n   * The record or the index of a record within the store to move.\n   * This can also be the unique ID of a record.\n   * will be positioned against. This can also be the unique ID of a record.\n   * @returns {NGN.DATA.Model}\n   * Returns the model.\n   * @fires {change:Object} record.moved\n   * This event is triggered when the move is complete.\n   * The change data sent to this event handler looks like:\n   *\n   * ```\n   * {\n   *   oldPosition: {number},\n   *   newPosition: {number},\n   *   record: {NGN.DATA.Model}\n   * }\n   * ```\n   */\n  moveToEnd (record) {\n    return this.move(record, this.PRIVATE.ACTIVERECORDS.size - 1)\n  }\n\n  /**\n   * @method moveToStart\n   * Move a record to the beginning of the dataset.\n   * @param {NGN.DATA.Model|number|string} source\n   * The record or the index of a record within the store to move.\n   * This can also be the unique ID of a record.\n   * will be positioned against. This can also be the unique ID of a record.\n   * @returns {NGN.DATA.Model}\n   * Returns the model.\n   * @fires {change:Object} record.moved\n   * This event is triggered when the move is complete.\n   * The change data sent to this event handler looks like:\n   *\n   * ```\n   * {\n   *   oldPosition: {number},\n   *   newPosition: {number},\n   *   record: {NGN.DATA.Model}\n   * }\n   * ```\n   */\n  moveToStart (record) {\n    return this.move(record, 0)\n  }\n\n  /**\n   * @method remove\n   * Remove a record.\n   * @param {NGN.DATA.Model|number|Symbol} record\n   * Accepts an existing NGN Data Model or index number.\n   * Using a model is slower than using an index number.\n   * This may also be the NGN.DATA.Model#OID value (for\n   * advanced use cases).\n   * @fires record.delete\n   * The record delete event sends 2 arguments to handler methods:\n   * `record` and `index`. The record refers to the model that was\n   * removed. The `index` refers to the position of the record within\n   * the store's data list. **NOTICE** the `index` refers to where\n   * the record _used to be_.\n   * @returns {NGN.DATA.Model}\n   * Returns the data model that was just removed. If a model\n   * is unavailable (i.e. remove didn't find the specified record),\n   * this will return `null`.\n   */\n  remove (record, suppressEvents = false) {\n    // Short-circuit processing if there are no records.\n    if (this.METADATA.records.length === 0) {\n      NGN.INFO(`\"${this.name}\" store called remove(), but the store contains no records.`)\n      return\n    }\n\n    // Support simultaneously removing multiple records\n    if (NGN.typeof(record) === 'array') {\n      let result = new Array(record.length)\n\n      for (let i = 0; i < record.length; i++) {\n        result[i] = this.remove(record[i])\n      }\n\n      return result\n    }\n\n    // Prevent removal if it will exceed minimum record count.\n    if (this.minRecords > 0 && this.METADATA.records.length - 1 < this.minRecords) {\n      throw new Error('Removing this record would violate the minimum record count.')\n    }\n\n    // Identify which record will be removed.\n    let index\n\n    switch (NGN.typeof(record)) {\n      case 'number':\n        if (record < 0 || !this.METADATA.records[record]) {\n          NGN.ERROR(`Record removal failed (record not found at index ${(record || 'undefined').toString()}).`)\n          return null\n        }\n\n        index = record\n\n        break\n\n      // The default case comes before the symbol case specifically\n      // so the record can be converted to an OID value (for use with\n      // the RECORDMAP lookup).\n      default:\n        if (!(record instanceof NGN.DATA.Entity)) {\n          NGN.ERROR('Invalid record value passed to Store.remove() method.')\n          return null\n        }\n\n        record = record.OID\n\n      case 'symbol': // eslint-disable-line no-fallthrough\n        index = this.PRIVATE.ACTIVERECORDS.get(record)\n\n        if (index < 0) {\n          NGN.ERROR(`Record removal failed. Record OID not found (\"${record.toString()}\").`)\n          return null\n        }\n\n        break\n    }\n\n    // If nothing has been deleted yet, create an active record map.\n    // The active record map contains Model OID values with a reference\n    // to the actual record index.\n    if (this.PRIVATE.ACTIVERECORDMAP === null) {\n      // Copy the record map to initialize the active records\n      this.PRIVATE.ACTIVERECORDMAP = new Map([...this.PRIVATE.RECORDMAP])\n    }\n\n    // Identify the record to be removed.\n    let removedRecord = this.METADATA.records[index]\n\n    // If the record isn't among the active records, do not remove it.\n    if (removedRecord === null) {\n      NGN.WARN('Specified record does not exist.')\n      return null\n    }\n\n    let activeIndex = this.PRIVATE.ACTIVERECORDS.get(removedRecord.OID)\n\n    if (isNaN(activeIndex)) {\n      NGN.WARN(`Record not found for \"${removedRecord.OID.toString()}\".`)\n      return null\n    }\n\n    this.PRIVATE.ACTIVERECORDS.delete(removedRecord.OID)\n\n    // If the store is configured to soft-delete,\n    // don't actually remove it until it expires.\n    if (this.METADATA.softDelete) {\n      if (this.METADATA.softDeleteTtl >= 0) {\n        removedRecord.once('expired', () => {\n          this.METADATA.records[this.PRIVATE.RECORDMAP.get(removedRecord.OID)] = null\n          this.PRIVATE.RECORDMAP.delete(removedRecord.OID)\n\n          if (!suppressEvents) {\n            this.emit('record.purge', removedRecord)\n          }\n        })\n\n        removedRecord.expires = this.METADATA.softDeleteTtl\n      }\n    } else {\n      this.METADATA.records[activeIndex] = null\n      this.PRIVATE.RECORDMAP.delete(removedRecord.OID)\n    }\n\n    // Update cursor indexes (to quickly reference first and last active records)\n    if (this.METADATA.LASTRECORDINDEX === activeIndex) {\n      if (this.PRIVATE.ACTIVERECORDS.size <= 1) {\n        this.METADATA.LASTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.values().next().value\n        this.METADATA.FIRSTRECORDINDEX = this.METADATA.LASTRECORDINDEX\n      } else if (activeIndex !== 0) {\n        for (let i = (activeIndex - 1); i >= 0; i--) {\n          if (i === 0) {\n            this.METADATA.LASTRECORDINDEX = 0\n            break\n          }\n\n          const examinedRecord = this.METADATA.records[i]\n\n          if (examinedRecord !== null) {\n            if (this.PRIVATE.ACTIVERECORDS.has(examinedRecord.OID)) {\n              this.METADATA.LASTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.get(examinedRecord.OID)\n              break\n            }\n          }\n        }\n      }\n    } else if (this.METADATA.FIRSTRECORDINDEX === activeIndex) {\n      let totalSize = this.PRIVATE.ACTIVERECORDS.size\n\n      for (let i = (activeIndex + 1); i < totalSize; i++) {\n        const examinedRecord = this.METADATA.records[i]\n\n        if (examinedRecord !== null) {\n          if (this.PRIVATE.ACTIVERECORDS.has(examinedRecord.OID)) {\n            this.METADATA.FIRSTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.get(examinedRecord.OID)\n            break\n          }\n        }\n      }\n    }\n\n    this.emit(this.PRIVATE.EVENT.DELETE_RECORD, removedRecord)\n\n    if (!suppressEvents) {\n      this.emit('record.delete', removedRecord)\n    }\n\n    return removedRecord\n  }\n\n  /**\n   * @method restore\n   * Restore a soft-deleted record to the store. This does not preserve the\n   * original index (a new index number is assigned).\n   * @param  {NGN.DATA.Model,Number,Symbol} id\n   * This may be the archived model/record, the index number of the record,\n   * or the record OID value.\n   * @return {NGN.DATA.Model}\n   * Returns the archived record. This will be `null` if the record cannot be\n   * found or does not exist, has been purged, or otherwise does not exist in\n   * the store.\n   * @fires {restoredRecord:NGN.DATA.Model} record.restored\n   * Triggered once a previously removed record has been restored .\n   */\n  restore (id) {\n    let index = typeof id === 'number' ? id : this.indexOf(id)\n\n    if (index < 0) {\n      return null\n    }\n\n    let record = this.PRIVATE.convertStubToRecord(index, this.METADATA.records[index])\n\n    if (!record) {\n      return null\n    }\n\n    if (this.PRIVATE.ACTIVERECORDMAP.has(record.OID) || this.PRIVATE.FILTEREDRECORDS.has(record.OID)) {\n      NGN.WARN(`${this.name} could not restore the specified record because it already exists amongst the active or filtered records.`)\n\n      return record\n    }\n\n    this.PRIVATE.ACTIVERECORDS.set(record.OID, index)\n    this.filter(record)\n\n    record.removeAllListeners('expired')\n\n    this.emit('record.restored', record)\n\n    return record\n  }\n\n  /**\n   * Create a copy of the store.\n   * @param {string} [name]\n   * An optional name for the new store.\n   * @param {boolean} [copyData=true]\n   * Copy the data. If this is set to `false`, the store configuration will be\n   * copied, but it will contain no data.\n   * Snapshots are not copied.\n   * @return {NGN.DATA.Store}\n   */\n  clone (name = null, includeData = true) {\n    let cfg = Object.assign({}, this.PRIVATE.ORIGINALCFG)\n\n    if (this.auditable) {\n      cfg.audit = true\n    }\n\n    if (typeof name === 'boolean') {\n      includeData = name\n      name = null\n    }\n\n    cfg.name = NGN.LABELS.DATASTORES.create(NGN.coalesce(name, this.name))\n\n    let store = new NGN.DATA.Store(cfg)\n\n    // Apply model\n    store.METADATA.Model = this.METADATA.Model\n\n    // Indexes\n    if (this.METADATA.hasOwnProperty('INDEXFIELDS')) {\n      this.METADATA.INDEXFIELDS.forEach(field => store.PRIVATE.createIndex(field))\n    }\n\n    store.METADATA.autoRemoveExpiredRecords = this.METADATA.autoRemoveExpiredRecords\n\n    store.METADATA.MAP = this.METADATA.MAP\n    store.auditable = this.auditable\n\n    // Apply filters\n    this.METADATA.filters.forEach(filter => store.addFilter(filter))\n\n    if (includeData) {\n      store.METADATA.records = this.data.slice().concat(this.filtered.slice())\n    }\n\n    return store\n  }\n\n  // TODO: find/query\n  // TODO: merge (with another data store)\n  // TODO: split (into more data stores)\n  // TODO: splitAt (specfific record/s)\n  // TODO: pop, shift (for parity w/ array)\n  // TODO: Copy\n\n  /**\n   * Split records into multiple stores. This\n   * does **not** delete the original store.\n   *\n   * ```\n   * let store = new NGN.DATA.Store(...)\n   *\n   * store.add([{\n   *   field: 'a'\n   * }, {\n   *   field: 'b'\n   * }, {\n   *   field: 'c'\n   * }, {\n   *   field: 'd'\n   * }])\n   *\n   * let smallerStores = store.split()\n   *\n   * smallerStores.forEach((store, index) => console.log(`\\nStore ${index+1}\\n`, store.data))\n   * ```\n   *\n   * The output of the example above would be:\n   *\n   * ```\n   *\n   * Store 1\n   * [{\n   *   field: 'a'\n   * }, {\n   *   field: 'b'\n   * }]\n   *\n   * Store 2\n   * [{\n   *   field: 'c'\n   * }, {\n   *   field: 'd'\n   * }]\n   * ```\n   * @param  {Number}  [recordsPerStore]\n   * The number of records that will be in each result store.\n   * If this is not specified, it will be automatically\n   * calculated by dividing the total number of records by 2.\n   * This would result in 2 stores.\n   *\n   * The appropriate number of stores will automatically\n   * be created by dividing the total number of records by\n   * the `recordPerStore` value, rounding up to the nearest integer.\n   * @param  {Boolean} [includeFiltered=false]\n   * Include records which have been filtered out but not deleted from the store.\n   * @return {NGN.DATA.Store[]}\n   * An array of the data stores.\n   */\n  split (chunkSize = null, includeFiltered = false) {\n    if (typeof chunkSize === 'boolean') {\n      includeFiltered = chunkSize\n      chunkSize = null\n    }\n\n    if (isNaN(chunkSize)) {\n      chunkSize = (this.size + (includeFiltered ? this.PRIVATE.FILTEREDRECORDS.size : 0)) / 2\n    }\n\n    if (chunkSize < 0) {\n      throw new Error('Cannot split a store into 0 or fewer records.')\n    }\n\n    let activeRecords = Array.from(this.PRIVATE.ACTIVERECORDS)\n\n    if (includeFiltered) {\n      activeRecords = activeRecords.concat(Array.from(this.PRIVATE.FILTEREDRECORDS))\n    }\n\n    let count = Math.ceil(activeRecords.length / chunkSize)\n    let results = new Array(count)\n\n    for (let i = 0; i < count; i++) {\n      // Create a copy of the store\n      results[i] = this.clone(false)\n      results[i].load(activeRecords.splice(0, chunkSize).map(item => this.METADATA.records[item[1]]))\n    }\n\n    return results\n  }\n\n  /**\n   * Split the store into a specific number of smaller stores.\n   * @param  {Number}  [divisions=2]\n   * The number of stores that should be returned.\n   * Records are dispersed as evenly as possible amongst the divisions.\n   * @param  {Boolean} [includeFiltered=false]\n   * Include records which have been filtered out but not deleted from the store.\n   * @return {NGN.DATA.Store[]}\n   * An array of the data stores.\n   */\n  splitTo (divisions = 2, includeFiltered = false) {\n    if (divisions < 1) {\n      throw new Error('Cannot split to less than one division.')\n    }\n\n    let total = this.PRIVATE.ACTIVERECORDS.size\n\n    if (includeFiltered) {\n      total += this.PRIVATE.FILTEREDRECORDS.size\n    }\n\n    let chunkSize = Math.ceil(total / divisions)\n\n    return this.split(chunkSize, includeFiltered)\n  }\n\n  /**\n   * Merge similar stores into this one. Each store\n   * must have the same data model.\n   * @param {NGN.DATA.Store[]} stores\n   * The other store/s to be merged into this one.\n   * An unlimited number of stores can be specified.\n   * @return {NGN.DATA.Store}\n   * Returns the store with the new records merged in.\n   */\n  concat () {\n    if (arguments.length < 0) {\n      return this\n    }\n\n    let args\n    if (NGN.typeof(arguments[0]) === 'array') {\n      args = arguments[0]\n    } else {\n      args = NGN.slice(arguments)\n    }\n\n    args = args.filter(store => store instanceof NGN.DATA.Store && store.METADATA.Model === this.METADATA.Model)\n\n    if (args.length === 0) {\n      throw new Error('Cannot concatenate/merge stores with different model types.')\n    }\n\n    const EVENT = new Symbol('store.merge')\n\n    this.thresholdOnce(EVENT, args.length, 'merge', {\n      sourceStores: args\n    })\n\n    args.forEach(store => {\n      store.once(store.PRIVATE.EVENT.LOAD_RECORDS, () => this.emit(EVENT))\n      this.load(store.data.concat(includeFiltered ? store.filtered : []))\n    })\n\n    return this\n  }\n\n  /**\n   * Create a new index on the store.\n   * @param  {string} field\n   * The name of the field to index.\n   * @fires index.create\n   * Triggered when an index is created. The name of field is passed\n   * as the only argument.\n   */\n  createIndex (field) {\n    // Support multiple indexes\n    if (NGN.typeof(field) === 'array') {\n      for (let i = 0; i < field.length; i++) {\n        this.createIndex(field[i])\n      }\n\n      return\n    }\n\n    // Make sure index fields are known to the store\n    if (!this.METADATA.INDEXFIELDS) {\n      this.METADATA.INDEXFIELDS = new Set()\n\n      // this.on('record.*', this.PRIVATE.INDEX)\n      this.on([\n        this.PRIVATE.EVENT.CREATE_RECORD,\n        this.PRIVATE.EVENT.DELETE_RECORD,\n        this.PRIVATE.EVENT.LOAD_RECORDS,\n        this.PRIVATE.EVENT.DELETE_RECORD_FIELD,\n        this.PRIVATE.EVENT.CLEAR_RECORDS,\n      ], this.PRIVATE.INDEX)\n    }\n\n    // In an index already exists, ignore it.\n    if (this.METADATA.INDEXFIELDS.has(field)) {\n      return\n    }\n\n    // Guarantee the existance of the index list\n    this.METADATA.INDEX = NGN.coalesce(this.METADATA.INDEX, {})\n\n    this.PRIVATE.checkModelIndexField(field)\n\n    this.METADATA.INDEXFIELDS.add(field)\n\n    // Identify BTree\n    let btree = ['number', 'date'].indexOf(this.PRIVATE.getModelFieldType(field)) >= 0\n\n    this.METADATA.INDEX[field] = new NGN.DATA.Index(btree, `${field.toUpperCase()} ${btree ? 'BTREE ' : ''}INDEX`)\n\n    // Apply to any existing records\n    if (this.METADATA.records.length > 0) {\n      this.PRIVATE.INDEX.apply({ event: this.PRIVATE.EVENT.LOAD_RECORDS })\n    }\n\n    this.emit('index.created', field)\n  }\n\n  /**\n   * Remove an existing index from the store.\n   * @param  {string} [field=null]\n   * The name of the indexed field. Set this to `null` (or leave blank) to\n   * remove all existing indexes.\n   * @fires index.delete\n   * Triggered when an index is removed. The name of field is passed\n   * as the only argument.\n   */\n  removeIndex (field = null) {\n    if (!this.METADATA.INDEXFIELDS) {\n      return\n    }\n\n    if (NGN.coalesce(field) === null) {\n      field = this.indexedFieldNames\n    }\n\n    // Support multiple indexes\n    if (NGN.typeof(field) === 'array') {\n      for (let i = 0; i < field.length; i++) {\n        this.removeIndex(field[i])\n      }\n\n      return\n    }\n\n    // Remove the specific index.\n    this.METADATA.INDEXFIELDS.delete(field)\n    delete this.METADATA.INDEX[field]\n    this.emit('index.delete', field)\n\n    // When there are no more indexes, clear out event\n    // listeners and fields.\n    if (this.METADATA.INDEXFIELDS.size === 0) {\n      this.METADATA.INDEX = null\n      delete this.METADATA.INDEXFIELDS\n\n      this.off([\n        this.PRIVATE.EVENT.CREATE_RECORD,\n        this.PRIVATE.EVENT.DELETE_RECORD,\n        this.PRIVATE.EVENT.LOAD_RECORDS,\n        this.PRIVATE.EVENT.DELETE_RECORD_FIELD\n      ], this.PRIVATE.INDEX)\n    }\n  }\n\n  /**\n   * Retrieve a record based on it's relative position to another\n   * record. This method is used by NGN.DATA.Model#next and NGN.DATA.Model#previous\n   * to support \"doubly linked list\" approach to record iteration.\n   * @param  {[type]}  currentRecord [description]\n   * @param  {Number}  [count=1]     [description]\n   * @param  {Boolean} [cycle=false] [description]\n   * @return {[type]}                [description]\n   */\n  getRecordSibling (currentRecord, count = 1, cycle = false) {\n    let size = this.size\n\n    if (size === 0) {\n      NGN.WARN('Attempted to execute getRecordSibling with no active records.')\n      return null\n    }\n\n    // Make sure the iterator fits within the range\n    if (Math.abs(count) > size) {\n      count = count % size\n    }\n\n    if (size === 1 || count === 0) {\n      return currentRecord\n    }\n\n    let ActiveRecords = Array.from(this.PRIVATE.ACTIVERECORDS)\n    let currentIndex = ActiveRecords.findIndex(item => currentRecord.OID === item[0])\n\n    if (ActiveRecords.length === 0) {\n      NGN.WARN(`\"${this.name}\" data store has no active records and ${this.PRIVATE.FILTEREDRECORDS.size} record${this.PRIVATE.FILTEREDRECORDS.size !== 1 ? 's' : ''}. record.next() & record.previous() do not iterate through filtered records.`)\n      return null\n    }\n\n    if (currentIndex < 0) {\n      let recordIndex = Array.from(this.PRIVATE.FILTEREDRECORDS).findIndex(item => currentRecord.OID === item[0])\n\n      if (recordIndex < 0) {\n        throw new Error('Record not found.')\n      }\n\n      let iterations = 0\n\n      while (ActiveRecords.findIndex(item => recordIndex === item[1]) < 0 && iterations < ActiveRecords.length) {\n        recordIndex++\n        iterations++\n      }\n\n      if (iterations < ActiveRecords.length) {\n        currentIndex = recordIndex\n      } else {\n        return null\n      }\n    }\n\n    currentIndex += count\n\n    // Support cycling through records.\n    if ((currentIndex >= ActiveRecords.length || currentIndex < 0) && cycle) {\n      // Cycle forwards\n      if (count > 0) {\n        currentIndex = currentIndex % ActiveRecords.length\n      } else {\n        // Cycle Backwards\n        currentIndex = ActiveRecords.length - Math.abs(currentIndex)\n      }\n    }\n\n    if (currentIndex < 0 || currentIndex >= ActiveRecords.length) {\n      return null\n    }\n\n    return this.METADATA.records[ActiveRecords[currentIndex][1]]\n  }\n\n  /**\n   * Returns the index number of the model. If the same\n   * model exists more than once (duplicate records), only\n   * the first index is returned.\n   * @param  {NGN.DATA.Model} model\n   * The model/record to retrieve an index number for.\n   * @return {number}\n   * The zero-based index number of the model.\n   */\n  indexOf (record) {\n    if (typeof record !== 'symbol') {\n      record = record.OID\n    }\n\n    return NGN.coalesce(this.PRIVATE.RECORDMAP.get(record), -1)\n  }\n\n  /**\n   * Determine whether the store contains a record.\n   * This only checks the _active_ record set (ignores filtered records).\n   * @param  {NGN.DATA.Model|NGN.DATA.Model#OID} record\n   * The record to test for inclusion.\n   * Internal methods may use the unique Object ID of a record.\n   * @return {boolean}\n   */\n  contains (record) {\n    return this.PRIVATE.ACTIVERECORDS.has(typeof record === 'symbol' ? record : record.OID)\n  }\n\n  /**\n   * Get the list of records for the given value.\n   * @param {string} fieldName\n   * The name of the indexed field.\n   * @param  {any} fieldValue\n   * The value of the index field. This is used to lookup\n   * the list of records/models whose field is equal to\n   * the specified value.\n   * @return {NGN.DATA.Model[]}\n   * Returns an array of models/records within the index for\n   * the given value.\n   */\n  getIndexRecords (field, value) {\n    if (this.METADATA.INDEX && this.METADATA.INDEX.hasOwnProperty(field)) {\n      let oid = this.METADATA.INDEX[field].recordsFor(value)\n      let result = new Array(oid.length)\n\n      for (let i = 0; i < oid.length; i++) {\n        result[i] = this.METADATA.records[this.PRIVATE.RECORDMAP.get(oid[i])]\n      }\n\n      return result\n    }\n\n    return []\n  }\n\n  /**\n   * Retrieve an active record by index number (0-based, similar to an array).\n   * @param  {number} [index=0]\n   * The index of the record to retrieve.\n   */\n  getRecord (index = 0) {\n    if (typeof index === 'symbol') {\n      index = this.indexOf(index)\n    }\n\n    if (index < 0) {\n      NGN.WARN('Cannot retrieve a record for a negative index.')\n      return null\n    }\n\n    if (index >= this.PRIVATE.RECORDMAP.size) {\n      NGN.WARN('Cannot retrieve a record for an out-of-scope index (index greater than total record count.)')\n      return null\n    }\n\n    return this.PRIVATE.convertStubToRecord(index, this.METADATA.records[Array.from(this.PRIVATE.ACTIVERECORDS)[index][1]])\n  }\n\n  /**\n   * @method clear\n   * Removes all data. If auditing is enabled, the transaction log is reset.\n   * @param {boolean} [purgeSoftDelete=true]\n   * Purge soft deleted records from memory.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from triggering when this method is run.\n   * @fires clear\n   * Fired when all data is removed\n   */\n  clear (purge = true, suppressEvents = false) {\n    if (this.METADATA.ARCHIVE) {\n      if (!purge) {\n        this.METADATA.ARCHIVE = this.records\n      } else {\n        delete this.METADATA.ARCHIVE\n      }\n    }\n\n    this.METADATA.records = []\n    this.PRIVATE.RECORDMAP = new Map()\n    this.PRIVATE.ACTIVERECORDMAP = null\n    this.PRIVATE.FILTEREDRECORDMAP = null\n    this.METADATA.LASTRECORDINDEX = 0\n    this.METADATA.FIRSTRECORDINDEX = 0\n    this.METADATA.filters.forEach(filter => filter.purge(this))\n\n    if (this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITLOG.reset()\n    }\n\n    // Indexes updated automatically (listening for 'clear' event)\n    this.emit(this.PRIVATE.EVENT.CLEAR_RECORDS)\n\n    if (!suppressEvents) {\n      this.emit('clear')\n    }\n  }\n\n  /**\n   * A special method to clear events from the underlying event emitter.\n   * This exists because #clear has a special meaning in a data store (removing\n   * all data records vs removing all events).\n   * @private\n   */\n  clearEvents () {\n    super.clear(...arguments)\n  }\n\n  /**\n   * Replace a model.\n   * @deprecated 2.0.0\n   * @param  {NGN.DATA.Model} newModel\n   * The new model.\n   */\n  replaceModel (newModel) {\n    NGN.deprecate(\n      () => { this.model = newModel },\n      'replaceModel has been deprected. Set the model directly instead.'\n    )\n  }\n\n  /**\n   * @method snapshot\n   * Add a snapshot of the current store to the #snapshot archive.\n   * This can potentially be a computationally/memory-expensive operation.\n   * The method creates a copy of all data in the store along with checksums\n   * of each element and holds the snapshot in RAM. Large stores may consume\n   * large amounts of RAM until the snapshots are released/cleared.\n   * Snapshots are most commonly used with data proxies to calculate\n   * differences in a data set before persisting them to a database.\n   * @fires snapshot\n   * Triggered when a new snapshot is created. The snapshot dataset is\n   * passed as the only argument to event handlers.\n   * @returns {object}\n   * Returns an object containing the following fields:\n   *\n   * ```js\n   * {\n   *   timestamp: 'ex: 2018-01-19T16:43:03.279Z',\n   *   checksum: 'snapshotchecksum',\n   *   modelChecksums: [\n   *     'record1_checksum',\n   *     'record2_checksum'\n   *   ],\n   *   data: { ... } // Actual data at the time of the snapshot\n   * }\n   * ```\n   */\n  snapshot () {\n    this.METADATA.snapshotarchive = NGN.coalesce(this.METADATA.snapshotarchive, [])\n\n    let data = this.data\n    let dataset = {\n      id: NGN.DATA.UTILITY.GUID(),\n      timestamp: (new Date()).toISOString(),\n      checksum: NGN.DATA.UTILITY.checksum(JSON.stringify(data)).toString(),\n      modelChecksums: this.data.map((item) => {\n        return NGN.DATA.UTILITY.checksum(JSON.stringify(item)).toString()\n      }),\n      data: data\n    }\n\n    this.METADATA.snapshotarchive.unshift(dataset)\n    this.emit('snapshot', dataset)\n\n    return dataset\n  }\n\n  /**\n   * @method clearSnapshots\n   * Remove all archived snapshots.\n   */\n  clearSnapshots () {\n    this.snapshotarchive = null\n  }\n\n  /**\n   * Load bulk data.\n   * @param  {Array} data\n   * An array of data Object or NGN.DATA.Model values.\n   * @param {Boolean} [autoApplyFilters=false]\n   * Set this to `true` to automatically apply filters to\n   * the data once loaded into the store.\n   * @warning Filtering is a O(n) operation, meaning the\n   * larger the dataset, the slower it will perform. Unfortunately,\n   * there is no generic way to circumvent this challenge in JavaScript.\n   * @fires {Object} loaded\n   * Triggered when the load is complete. The object returned to the event\n   * handler looks like:\n   *\n   * ```\n   * {\n   *   recordCount: 5,\n   *   activeRecordCount: 3,\n   *   filteredRecordCount: 2,\n   *   loadDuration: 300 // milliseconds\n   * }\n   * ```\n   */\n  load (data, autoApplyFilters = false, suppressEvents = false) {\n    let start = new Date()\n    let insertableData\n\n    // Guarantee unique records amongst only the new records\n    if (!this.METADATA.allowDuplicates) {\n      let uniqueValues = new Set()\n\n      insertableData = []\n\n      for (let i = 0; i < data.length; i++) {\n        if (data[i]) {\n          if (!uniqueValues.has(JSON.stringify(data[i]))) {\n            uniqueValues.add(JSON.stringify(data[i]))\n            insertableData.push(data[i])\n          } else if (this.METADATA.errorOnDuplicate) {\n            throw new NGNDuplicateRecordError()\n          }\n        }\n      }\n    } else {\n      insertableData = data\n\n      // Remove any null or undefined records, which would otherwise be recognized as deleted record placeholders\n      while (insertableData.indexOf(null) >= 0 || insertableData.indexOf(undefined) >= 0) {\n        insertableData.splice(NGN.coalesceb(NGN.nullIf(insertableData.indexOf(null), -1), NGN.nullIf(insertableData.indexOf(undefined), -1)) - 1, 1)\n      }\n    }\n\n    let newRecordCount = insertableData.length + this.METADATA.records.length\n\n    // Don't exceed the maximum record count if it exists.\n    if (this.METADATA.maxRecords > 0 && newRecordCount > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    if (newRecordCount > 4000000) {\n      throw new Error('Maximum load size exceeded. A store may contain a maximum of 4M records.')\n    }\n\n    let me = this\n    for (let i = 0; i < insertableData.length; i++) {\n      let oid\n\n      if (insertableData[i] instanceof NGN.DATA.Entity) {\n        oid = insertableData[i].OID\n        this.METADATA.records.push(insertableData[i])\n      } else {\n        oid = Symbol('model.id')\n\n        let stub = {\n          [this.PRIVATE.STUB]: true,\n          OID: oid,\n          metadata: insertableData[i]\n        }\n\n        Object.defineProperty(stub, 'store', {\n          get () {\n            return me\n          }\n        })\n\n        this.METADATA.records.push(stub)\n      }\n\n      // Add the record to the map for efficient retrieval by OID\n      this.PRIVATE.RECORDMAP.set(oid, this.METADATA.records.length - 1)\n      this.PRIVATE.ACTIVERECORDS.set(oid, this.METADATA.records.length - 1)\n    }\n\n    if (autoApplyFilters) {\n      let startFilter = new Date()\n      this.filter()\n      let endFilter = new Date()\n    } else {\n      this.PRIVATE.updateOrderIndex()\n    }\n\n    let end = new Date()\n\n    this.emit(this.PRIVATE.EVENT.LOAD_RECORDS)\n\n    let result = {\n      recordCount: this.length,\n      activeRecordCount: this.size,\n      filteredRecordCount: this.length - this.size,\n      loadDuration: (end - start),\n      filterDuration: autoApplyFilters ? (endFilter - startFilter) : 0\n    }\n\n    if (!suppressEvents) {\n      this.emit('loaded', result)\n    }\n\n    return result\n  }\n\n  /**\n   * Drop all records and reload. This is the equivalent of running #clear()\n   * before a new #load().\n   ** @param  {Array} data\n   * An array of data Object or NGN.DATA.Model values.\n   * @param {Boolean} [autoApplyFilters=false]\n   * Set this to `true` to automatically apply filters to\n   * the data once loaded into the store.\n   * @warning Filtering is a O(n) operation, meaning the\n   * larger the dataset, the slower it will perform. Unfortunately,\n   * there is no generic way to circumvent this challenge in JavaScript.\n   * @fires {Object} reloaded\n   * Triggered when the reload is complete. The object returned to the event\n   * handler looks like:\n   *\n   * ```\n   * {\n   *   recordCount: 5,\n   *   activeRecordCount: 3,\n   *   filteredRecordCount: 2,\n   *   loadDuration: 300 // milliseconds\n   * }\n   * ```\n   */\n  reload (data, autoApplyFilters = false) {\n    this.clear(true)\n\n    this.METADATA.records = new Array(data.length)\n\n    let result = this.load(data, autoApplyFilters, false)\n\n    this.emit('reloaded', result)\n  }\n\n  /**\n   * Removes all data, filters, and \"resets\" the store back to\n   * the original unpopulated state.\n   * @param {Boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from triggering when this method is run.\n   */\n  reset (suppressEvents = false) {\n    this.clear(true, suppressEvents)\n    this.clearSnapshots()\n    this.clearFilter()\n    this.METADATA.filters = new Map()\n  }\n\n  /**\n   * This rebuilds the local index of records, removing any dead records.\n   * While deleted records are destroyed (in accordance to #softDeleteTtl),\n   * the active record table contains a `null` or `undefined` value for each\n   * deleted/dead record. This method removes such records, akin in nature to\n   * the common JavaScript garbage collection process.\n   *\n   * This method almost never needs to be run, since stores\n   * attempt to manage this process for themselves automatically. However; if\n   * large volume deletions occur rapidly (50K+), it's possible (though not assured)\n   * performance could be negatively impacted. Compacting the store can\n   * improve performance in these cases. However; running this too often or\n   * excessively may degrade performance since it is essentially rewriting\n   * the store's data each time.\n   *\n   * When in doubt, *don't* use this method.\n   * @info This method will not run when fewer than 100 cumulative records have\n   * existed in the store, due to the inefficient nature at such low volume.\n   * @fires compact.start\n   * Triggered when the compact process begins.\n   * @fires compact.complete\n   * Triggered when the compact process completes.\n   */\n  compact () {\n    this.emit('compact.start')\n\n    if (this.METADATA.records.length < 100) {\n      this.emit('compact.complete')\n\n      if (this.METADATA.records.length !== 0) {\n        NGN.WARN(`compact() called on ${this.name} with fewer than 100 elements.`)\n      }\n\n      return\n    }\n\n    let ranges = []\n    let currentRange = []\n    let empty = 0\n\n    // Identify null ranges (dead records)\n    for (let i = 0; i < this.METADATA.records.length; i++) {\n      if (this.METADATA.records[i] === null) {\n        empty++\n\n        if (currentRange.length === 0) {\n          currentRange.push(i)\n        }\n      } else {\n        // Identify new index values for remaining records\n        if (empty > 0) {\n          this.PRIVATE.RECORDMAP.set(this.METADATA.records[i].OID, i - empty)\n\n          if (this.METADATA.FIRSTRECORDINDEX === i) {\n            this.METADATA.FIRSTRECORDINDEX = i - empty\n          }\n\n          if (this.METADATA.LASTRECORDINDEX === i) {\n            this.METADATA.LASTRECORDINDEX = i - empty\n          }\n        }\n\n        if (currentRange.length === 1) {\n          currentRange.push(i - 1)\n          ranges.push(currentRange)\n          currentRange = []\n        }\n      }\n    }\n\n    // Clear null ranges\n    empty = 0\n    while (ranges.length > 0) {\n      this.METADATA.records.splice(ranges[0][0] - empty, ranges[0][1] - ranges[0][0] + 1)\n      empty += ranges[0][1] - ranges[0][0] + 1\n      ranges.shift()\n    }\n\n    // Reset the active record map\n    this.PRIVATE.ACTIVERECORDMAP = null\n\n    this.emit('compact.complete')\n  }\n\n  /**\n   * Performs executes the callback method on each active record\n   * within the store. For example:\n   *\n   * ```js\n   * Store.forEach(function (record) {\n   *   // Do Something\n   * })\n   * ```\n   * @param  {Function} callback\n   * The callback method is applied to each record.\n   */\n  forEach (fn) {\n    if (!NGN.isFn(fn)) {\n      throw new Error(`A ${NGN.typeof(fn)} was applied to ${this.name}'s each() method when a function was expected.`)\n    }\n\n    this.PRIVATE.ACTIVERECORDS.forEach((value, key, map) => {\n      fn(this.METADATA.records[value])\n    })\n  }\n\n  /**\n   * @method addFilter\n   * Add a filter to the record set.\n   * @param {string} [name]\n   * The name of the filter. This is unnecessary/ignored if a NGN.DATA.Filter\n   * is supplied for the filter argument.\n   * @param {NGN.DATA.Filter|function} filter\n   * Add a filter object/function. This function should comply\n   * with the [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) specification,\n   * returning a boolean value.\n   * The item passed to the filter will be the NGN.DATA.Model specified\n   * in the cfg#model.\n   * @fires filter.create\n   * Fired when a filter is created.\n   * @returns {NGN.DATA.Filter}\n   * Returns the new filter.\n   */\n  addFilter (name, filterFn) {\n    if (name instanceof NGN.DATA.Filter) {\n      filterFn = name\n      name = filterFn.name\n    } else if (NGN.isFn(name)) {\n      filterFn = new NGN.DATA.Filter(name, filterFn)\n      name = filterFn\n    }\n\n    if (!(filterFn instanceof NGN.DATA.Filter)) {\n      filterFn = new NGN.DATA.Filter(name, filterFn)\n    }\n\n    this.METADATA.filters.set(filterFn.name, filterFn)\n\n    this.emit('filter.create', filterFn)\n\n    return filterFn\n  }\n\n  /**\n   * Apply all enabled filters to the Store's recordset.\n   *\n   * For example:\n   *\n   * ```js\n   * let firstNameIsJohn = new NGN.DATA.Filter('only_john', record => {\n   *   return record.firstName === 'John'\n   * })\n   *\n   * let lastNameIsGeneric = new NGN.DATA.Filter('generic_names', record => {\n   *   return ['Doe', 'Smith'].indexOf(record.lastName) >= 0\n   * })\n   *\n   * let weirdLastName = new NGN.DATA.Filter('weird_names', record => {\n   *   return ['Beeblebrox', 'Anastasio'].indexOf(record.lastName) >= 0\n   * })\n   *\n   * MyStore.addFilter(firstNameIsJohn)\n   * MyStore.addFilter(lastNameIsGeneric)\n   * MyStore.addFilter(weirdLastName)\n   *\n   * MyStore.filter('only_john', 'generic_names')\n   * ```\n   *\n   * In the example above, the store's records would only display people\n   * of the name `John Doe` or `John Smith`, even though there are 3 known filters\n   * associated with the store.\n   * @param {NGN.DATA.Model} [record]\n   * Optionally identify a specific record to run filters against.\n   * @param {string[]} [namedFilters]\n   * A list of filters can be supplied to selectively enable\n   * a specific subset of filters. If no filters are specified,\n   * all known filters are applied. Disabled filters will not be applied.\n   * @return {NGN.DATA.Store}\n   * Returns a reference to the data store, which enables\n   * chaining methods together.\n   */\n  filter () {\n    if (this.METADATA.filters.size === 0) {\n      return this\n    }\n\n    let args = Array.from(arguments)\n\n    this.METADATA.filters.forEach((filter, name) => {\n      if (args[0] instanceof NGN.DATA.Entity) {\n        filter.exec(args[0])\n      } else if (args.length === 0 || args.indexOf(name) >= 0) {\nconsole.log(`>> Filtering ${this.name} with ${filter.name}:`);\n        this.PRIVATE.ACTIVERECORDS.forEach(index => {\n          console.log(`Retain?`, filter.exec(this.PRIVATE.convertStubToRecord(index, this.METADATA.records[index])))\n        })\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Restores any records which were removed by the specified filters.\n   * @param {string[]} namedFilters\n   * A list of named filters can be supplied to selectively clear\n   * a specific subset of filters. If no named filters are specified,\n   * all known filters are cleared. Disabled filters will not be processed.\n   * @return {NGN.DATA.Store}\n   * Returns a reference to the data store, which enables\n   * chaining methods together.\n   */\n  clearFilter () {\n    if (arguments.length === 0) {\n      this.PRIVATE.ACTIVERECORDMAP = new Map([...this.PRIVATE.ACTIVERECORDS, ...this.PRIVATE.FILTEREDRECORDS])\n      this.PRIVATE.FILTEREDRECORDMAP = null\n      this.METADATA.filters.forEach(filter => { filter.purge() })\n    } else {\n      Array.from(arguments).forEach(filter => { filter.clear() })\n    }\n\n    return this\n  }\n\n  /**\n   * This is the same as #clearFilter, but it also permanently\n   * removes the filter from the store (un-apply).\n   * @param {string[]} namedFilters\n   * A list of named filters can be supplied to selectively remove\n   * a specific subset of filters. If no named filters are specified,\n   * all known filters are removed. This includes disabled filters.\n   * @return {NGN.DATA.Store}\n   * Returns a reference to the data store, which enables\n   * chaining methods together.\n   */\n  removeFilter () {\n    let args = Array.from(arguments)\n\n    if (args.length === 0) {\n      this.PRIVATE.ACTIVERECORDMAP = new Map([...this.PRIVATE.ACTIVERECORDS, ...this.PRIVATE.FILTEREDRECORDS])\n      this.PRIVATE.FILTEREDRECORDMAP = null\n      this.METADATA.filters.forEach(filter => { filter.destroy(this) })\n    } else {\n      args.forEach(filter => { this.METADATA.filters.get(filter).destroy(this) })\n    }\n\n    return this\n  }\n\n  /**\n   * This acts like #clearFilter. However, unlike clearing a filter\n   * on a specific data store, disabling a filter will affect all\n   * data stores to which the filter is applied.\n   * @param {string[]} namedFilters\n   * A list of named filters can be supplied to selectively remove\n   * a specific subset of filters. If no named filters are specified,\n   * all known filters are disabled.\n   * @return {NGN.DATA.Store}\n   * Returns a reference to the data store, which enables\n   * chaining methods together.\n   */\n  disableFilter () {\n    let args = new Set(Array.from(arguments))\n\n    this.METADATA.filters.forEach(filter => {\n      if (args.size === 0 || args.has(filter.name)) {\n        filter.disable()\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Enabling a filter will make it available\n   * _on all stores to which the filter is applied_.\n   *\n   * Filters are enabled by default, so this method\n   * typically isn't used unless a filter has been explicitly\n   * disabled. The anticipated use case is toggling filters on/off,\n   * likely fordata visualizations, table renderings, and other\n   * data exploration uses.\n   * @param {string[]} namedFilters\n   * A list of named filters can be supplied to selectively remove\n   * a specific subset of filters. If no named filters are specified,\n   * all known filters are disabled.\n   * @return {NGN.DATA.Store}\n   * Returns a reference to the data store, which enables\n   * chaining methods together.\n   */\n  enableFilter () {\n    let args = new Set(Array.from(arguments))\n\n    this.METADATA.filters.forEach(filter => {\n      if (args.size === 0 || args.has(filter.name)) {\n        filter.enable()\n      }\n    })\n\n    return this\n  }\n}\n","import UTILITY from './Utility'\nimport BTree from './index/BTree'\nimport TransactionLog from './TransactionLog'\nimport Rule from './rule/Rule'\nimport RangeRule from './rule/RangeRule'\nimport Field from './field/Field'\nimport VirtualField from './field/VirtualField'\nimport Relationship from './field/Relationship'\nimport FieldMap from './field/FieldMap'\nimport Entity from './Model'\nimport Index from './index/Index'\nimport Filter from './Filter'\nimport Store from './Store'\n\nconst Model = function (cfg) {\n  if (NGN.typeof(cfg) !== 'object') {\n    throw new Error('Model must be configured.')\n  }\n\n  const me = this\n\n  let Model = function (data, suppressEvents = false) {\n    let Entity = new NGN.DATA.Entity(cfg)\n\n    Object.defineProperty(Entity, 'ENTITY', {\n      enumerable: false,\n      get () {\n        return me\n      }\n    })\n\n    if (data) {\n      Entity.load(data, suppressEvents)\n    }\n\n    return Entity\n  }\n\n  Object.defineProperty(Model.prototype, 'CONFIGURATION', NGN.const(cfg))\n  Object.defineProperty(Model.prototype, 'ENTITY', {\n    enumerable: false,\n    get () {\n      return me\n    }\n  })\n\n  return Model\n}\n\nconst util = NGN.deprecate(UTILITY, 'NGN.DATA.util is now NGN.DATA.UTILITY')\n\nexport {\n  UTILITY,\n  util,\n  TransactionLog,\n  Rule,\n  RangeRule,\n  Field,\n  VirtualField,\n  Relationship,\n  FieldMap,\n  Model,\n  Entity,\n  Index,\n  Store,\n  BTree,\n  Filter\n}\n","import NGN from './core'\nimport EventEmitter from './emitter/core'\nimport * as Queue from './queue/core'\nimport * as Utility from './utility/core'\nimport * as Network from './net/core'\nimport * as Data from './data/core'\n\n// Add Event Emitter Class & Global Event Bus\nNGN.extend('EventEmitter', NGN.public(EventEmitter))\nNGN.extend('BUS', NGN.const(new NGN.EventEmitter()))\n\n// Add Queuing System\nNGN.extend('Task', NGN.const(Queue.Task))\nNGN.extend('Queue', NGN.const(Queue.Queue))\nNGN.extend('Tasks', NGN.deprecate(NGN.Queue, 'NGN.Tasks is now NGN.Queue'))\n\n// Add Networking\nNGN.extend('NET', NGN.const(Network.Library))\n\n// Add Utilities\nNGN.extend('UTILITY', NGN.const(Utility))\n\n// Add Data Library\nNGN.extend('DATA', NGN.const(Data))\n\n// Add Name Management Utilities\n// Object.defineProperty(NGN, 'LABELS',\n//   NGN.privateconst({\n//     DATASTORES: new NGN.UTILITY.NameManager('NGN Data Store')\n//   })\n// )\n\n// NGN.BUS.on(NGN.INTERNAL_EVENT, function (eventName, payload) {\n//   switch (eventName.toLowerCase()) {\n//     case 'datastore.created':\n//       NGN.LABELS.DATASTORES.set(payload.name, payload)\n//       // NGN.INFO(`${payload.name} data store created.`)\n//       break\n//   }\n// })\n"],"names":["CustomException","config","super","Object","defineProperty","this","NGN","privateconst","frame","nodelike","getFileName","__filename","message","custom","let","me","attr","name","type","severity","category","replace","hasOwnProperty","Error","prepareStackTrace","_","stack","_err","captureStackTrace","rawstack","err","cause","console","warn","help","info","filter","frameFilter","map","el","join","prototypeAccessors","trace","filename","line","getLineNumber","column","getColumnNumber","functionname","getFunctionName","native","isNative","eval","isEval","getTypeName","defineProperties","global","window","define","enumerable","writable","configurable","value","version","public","private","const","get","fn","set","getset","getterFn","setterFn","LEDGER_EVENT","EVENT","BUS","emit","argsArray","extend","attribute","descriptor","inherit","source","dest","prototype","getOwnPropertyNames","forEach","definition","getOwnPropertyDescriptor","getPrototypeOf","trim","toLowerCase","undefined","apply","arguments","slice","obj","Array","call","splice","nullIf","sourceExpression","comparisonExpression","e","WARN","nullif","ref","converge","length","arg","coalesce","coalesceb","process","dedupe","array","matches","i","indexOf","push","typeof","toString","split","forceArray","forceBoolean","forceNumber","radix","getTime","parseInt","parseFloat","NaN","ERROR","processStackItem","item","uri","fnRegex","operation","exec","path","cwd","file","substr","location","origin","reverse","isFn","v","wrap","preFn","wrapClass","ClassFn","deprecate","deprecateClass","classFn","needs","missing","getObjectMissingPropertyNames","MissingNgnDependencyError","properties","keys","getObjectExtraneousPropertyNames","index","objectHasAll","objectHasAny","objectHasExactly","args","shift","objectRequires","check","constructor","createAlias","namespace","WARNING_EVENT","Symbol","msg","INFO_EVENT","for","INFO","ERROR_EVENT","INTERNAL_EVENT","INTERNAL","createException","getType","defaultType","Number","RegExp","Boolean","Date","Function","String","platform","os","navigator","userAgent","pop","BrowserEmitter","cfg","handlers","adhoc","maxlisteners","defaultMaxListeners","subscribers","subscriberList","eventName","handler","listenerCount","getMaxListeners","setMaxListeners","eventNames","concat","listeners","addListener","callback","pool","unshift","prependListener","once","prependOnceListener","removeListener","handlerFn","deleteEventHandler","scope","result","removeAllListeners","events","getAllEvents","event","adhocEvent","regularEvents","adhocEvents","allEvents","test","EventEmitter","META","queued","collectionQueue","thresholdQueue","defaultTTL","wildcardEvents","Set","setTTL","ttl","off","l","clear","wrappedHandlerFn","wrapEventHandlerWithScope","delete","deprecatedEventName","replacementEventName","on","prefix","group","topic","increaseMaxListeners","attach","preventDefaultAction","preventDefault","count","decreaseMaxListeners","forward","triggers","payload","listener","remove","relay","targetEmitter","postfix","eventNameList","relayOnce","delayEmit","delay","setTimeout","getInternalCollectionId","collection","handleCollectionTrigger","key","cq","remainingqueue","size","masterqueue","funnel","eventCollection","triggerEventName","funnelOnce","funnelClosureEvent","threshold","thresholdEventName","limit","finalEventName","handleThresholdTrigger","thresholdOnce","thresholdClosureEvent","applyScope","symbolEvents","getOwnPropertySymbols","_events","eventHandler","prepend","add","iterator","values","currentEvent","done","next","EE","QueueItem","number","timer","_status","bus","buz","_skip","status","skipped","run","mode","timeout","milliseconds","skip","Queue","steps","completed","_mode","_cancel","processing","sequential","step","clearTimeout","list","s","id","cancelled","onTimeout","log","queue","Task","getAt","requestedStep","element","removeAt","error","reset","currentTask","currentStep","abort","each","cancel","NGNLexer","statement","tokens","rules","state","reject","lastLineIndex","currentLength","currentMatch","row","unrecognizedCharacters","addRule","input","lines","unrecognized","currentLine","currentColumn","col","pattern","action","start","flags","multiline","ignoreCase","actionFn","actionString","charAt","this$1","scan","match","token","unexpected","lastIndex","rule","states","j","k","temple","str","NGNTokenizer","grammar","PROTECTED","lexer","UTILITY","Lexer","activeText","orderedList","text","orderedTokenList","from","detail","parse","ignoreXOF","assign","NGNSet","isSuperSet","mainset","subset","elements","has","aggregate","intersection","setA","setB","a","b","difference","diff","equal","equals","applyAll","NetworkUtilities","hostname","networkInterfaces","UrlPattern","HttpMethods","host","normalizeUrl","url","pathname","path$1","protocol","queryString","params","keypair","param","encodeURIComponent","parseUri","part","query","hash","credentials","user","secret","port","isCrossOrigin","altUrl","Utility","Request","httpmethod","enforceMethodSafety","enforcemethodsafety","headers","requestbody","body","responseType","username","password","bearerAccessToken","accessToken","withCredentials","applyAuthorizationHeader","setHeader","basicAuthToken","btoa","uriParts","maximumRedirects","redirectAttempts","prepareBody","contentType","form","dataString","JSON","stringify","maxRedirects","method","queryParameters","resultSet","setQueryParameter","loc","href","substring","lastIndexOf","toUpperCase","crossOriginRequest","overwriteExisting","getHeader","removeHeader","re","removeQueryParameter","startMonitor","stopMonitor","send","xhr","XMLHttpRequest","responded","onreadystatechange","readyState","DONE","onerror","ontimeout","open","setRequestHeader","Network","parseRequestConfiguration","NET","makeRequest","request","OPTIONS","options","bind","HEAD","head","GET","POST","post","PUT","put","DELETE","TRACE","json","JSONP","jsonp","preflight","response","responseData","responseText","Math","round","random","data","document","removeChild","script","createElement","src","addEventListener","appendChild","NetworkResource","globalHeaders","globalCredentials","accesstoken","globalQuery","baseUrl","baseurl","nocache","sslonly","ssecret","prepareUrl","qp","gHeaders","Resource","Plugin","Library","crcTable","checksum","serialize","c","n","makeCRCTable","crc","charCodeAt","UUID","crypto","getRandomValues","Uint8Array","GUID","lut","d0","d1","d2","d3","SERIALIZED_ARRAY_DATA","DATA","UTIL","toISOString","mapResult","isDataModel","Model","currentElement","Entity","TreeNode","parent","leafs","nodes","METADATA","order","minOrder","compare","firstNumber","secondNumber","search","leaf","node","overwrite","TreeLeaf","left","balance","max","Tree","root","sep","rest","right","subst","floor","unsplit","includeNodes","BTREE","validate","walk","minKey","maxKey","ptr","walkDesc","NGNTransactionLog","maxEntryCount","transaction","changeOrder","cursor","currentValue","getCommit","cursorIndex","commit","flush","removedId","timestamp","position","removedEntries","rollback","currentPosition","advance","suppressEvents","entry","activeCursor","NGNDataValidationRule","validation","RULE","validator","NGNDataRangeValidationRule","range","prepareRange","isString","min","addRange","removeRange","x","Rule","NGNDataField","default","EMPTYDATA","required","hidden","fieldType","identifier","isIdentifier","autocorrectInput","description","sourceName","lastValue","dataType","validators","violatedRule","allowInvalid","TRANSFORM","transformer","RAWDATAPLACEHOLDER","RAW","ENUMERABLE_VALUES","REVERSE_ENUMERABLE_VALUES","IS_NEW","EVENTS","AUDITABLE","audit","AUDITLOG","TransactionLog","auditMaxEntries","model","setValue","ignoreAudit","autoCorrectValue","change","field","old","new","priorValueIsValid","valid","reason","virtual","commitPayload","nonempty","minimum","maximum","RangeRule","multipleOf","abs","unique","listType","enum","tuples","enumeration","not","notin","typeList","auditable","originallyHidden","currentlyHidden","isNew","autoid","silentValue","modified","changelog","undo","redo","hide","unhide","disallowInvalid","valueType","dt","setTime","NGNVirtualDataField","caching","cache","virtualMethod","CACHEKEY","cachedValue","localFieldPattern","monitoredFields","content","knownFieldNames","update","create","DataField","NGNRelationshipField","InvalidConfigurationError","applyMonitor","manner","commonModelEventHandler","invalid","originalEvent","record","commonStoreEventHandler","Store","NGNDataFieldMap","originalSource","sourceMap","reverseMap","applyData","inverse","applyMap","applyInverseMap","NGNDataEntity","dataMap","fieldmap","idAttribute","IdentificationField","OID","fields","invalidFieldNames","auditFieldNames","idField","expiration","expirationTimeout","created","now","store","AUDIT_HANDLER","getAuditMap","applyField","fieldcfg","ReservedWordError","Field","Relationship","VirtualField","applyChange","fieldname","setSilent","setSilentFieldValue","DATAMAP","MAP","FieldMap","autoIdValue","expires","ID","createDate","serializeFields","unmappedData","representation","unmappedRepresentation","isNaN","expired","fieldDefinitions","ignoreID","ignoreVirtualFields","fieldExists","IdentificationValue","addField","fieldConfiguration","removeField","PRIVATE","DELETE_RECORD_FIELD","getField","load","cycle","getRecordSibling","previous","destroy","NGNDataIndex","btree","CREATE_EVENT","REMOVE_EVENT","UPDATE_EVENT","uniqueValues","knownRecords","isBTree","oid","suppressEvent","recordsFor","BTree","valueIndex","btreeValue","recordsOf","removed","oldValue","newValue","NGNDataFilter","filterFn","enabled","recordUpdates","Map","filterName","active","filteredRecords","filteredRecordStores","clean","clearFilter","storeOID","recordOID","ACTIVERECORDS","FILTEREDRECORDS","STORE_EVENT","deactivate","activate","RECORDMAP","records","filtered","applied","enable","disable","disabled","addFilter","getRecord","retain","storeRecord","purge","filters","NGNDataStore","allowDuplicates","errorOnDuplicate","errorOnInvalid","autoRemoveExpiredRecords","softDelete","softDeleteTtl","fifo","FIFO","lifo","LIFO","maxRecords","minRecords","autocompact","FIRSTRECORDINDEX","LASTRECORDINDEX","INDEX","STUB","delta","CREATE_RECORD","INDEXFIELDS","DELETE_RECORD","LOAD_RECORDS","CLEAR_RECORDS","ACTIVERECORDMAP","FILTEREDRECORDMAP","ORIGINALCFG","checkModelIndexField","metaconfig","CONFIGURATION","getModelFieldType","createRecord","addRecord","insertRecord","rawIndex","updatedRecords","lastRecords","firstActiveRecords","lastActiveRecords","updateOrderIndex","activeRecords","convertStubToRecord","newRecord","metadata","shouldFilterRecord","forceDataObject","freeze","createIndex","DELETECOUNT","compact","oldName","LABELS","DATASTORES","rename","snapshots","snapshotarchive","history","recordCount","first","last","recordList","rec","defaults","applicableData","indexedFieldNames","insertBefore","beforeRecord","recordIndex","NGNMissingRecordError","insertAfter","afterRecord","move","sourceRecord","targetRecord","sourceIndex","findIndex","targetIndex","oldPosition","newPosition","moveToEnd","moveToStart","removedRecord","activeIndex","examinedRecord","totalSize","restore","clone","includeData","chunkSize","includeFiltered","ceil","results","splitTo","divisions","total","sourceStores","Index","removeIndex","currentRecord","ActiveRecords","currentIndex","iterations","contains","getIndexRecords","ARCHIVE","clearEvents","replaceModel","newModel","snapshot","dataset","modelChecksums","clearSnapshots","autoApplyFilters","insertableData","NGNDuplicateRecordError","newRecordCount","stub","end","activeRecordCount","filteredRecordCount","loadDuration","filterDuration","endFilter","startFilter","reload","ranges","currentRange","empty","Filter","removeFilter","disableFilter","enableFilter","util","Queue.Task","Queue.Queue","Network.Library","Data"],"mappings":"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"}