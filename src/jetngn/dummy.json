{
  "classes": {
    "ObjectDiff": {
      "type": "class",
      "label": "ObjectDiff",
      "description": "Modified: ['m', path, oldValue, newValue]",
      "code": "class ObjectDiff {\n  static compare (lhs, rhs, path = []) {\n    let differences = []\n    let ltype = NGN.typeof(lhs)\n    let rtype = NGN.typeof(rhs)\n\n    // If the comparators aren't the same type, then\n    // it is a replacement. This is identified as\n    // removal of one object and creation of the other.\n    if (ltype !== rtype) {\n      return [\n        ['m', path, lhs, rhs]\n      ]\n    }\nconsole.log('Diffing:', ltype, lhs, rhs, 'PATH', path.join('.'))\n    switch (ltype) {\n      // case 'function':\n      //   if (lhs.toString() !== rhs.toString()) {\n      //     return ['m', path, lhs, rhs]\n      //   }\n      //\n      //   return []\n\n      case 'object':\n        let keys = Object.keys(lhs)\n        // let relativePath\n\n        // Compare left to right for modifications and removals\n        for (let i = 0; i < keys.length; i++) {\n          // Reset the relative path\n          let relativePath = Object.assign([], path)\n\n          relativePath.push(keys[i])\n\n          if (!rhs.hasOwnProperty(keys[i])) {\n            // If no right hand argument exists, it was removed.\n            differences.push(['-', relativePath, lhs[keys[i]]])\n          } else if (NGN.typeof(lhs[keys[i]]) === 'object') {\n            // Recursively compare objects\n            differences = differences.concat(this.compare(lhs[keys[i]], rhs[keys[i]], relativePath))\n          } else if (lhs[keys[i]] !== rhs[keys[i]]) {\n            if (NGN.typeof(lhs[keys[i]]) === 'array' && NGN.typeof(rhs[keys[i]]) === 'array') {\n              // If the keys contain arrays, re-run the comparison.\n              differences = differences.concat(this.compare(lhs[keys[i]], rhs[keys[i]], relativePath))\n            } else {\n              // If the comparators exist but are different, a\n              // modification ocurred.\n              differences.push(['m', relativePath, lhs[keys[i]], rhs[keys[i]]])\n            }\n          }\n        }\n\n        // Compare right to left for additions\n        keys = Object.keys(lhs)\n        keys.unshift(rhs)\n        keys = NGN.getObjectExtraneousPropertyNames.apply(this, keys)\n\n        for (let i = 0; i < keys.length; i++) {\n          // Reset the relative path\n          let relativePath = Object.assign([], path)\n          relativePath.push(keys[i])\n\n          differences.push(['+', relativePath, rhs[keys[i]]])\n        }\n\n        break\n\n      case 'array':\n        differences = this.compareArray(lhs, rhs)\n\n        break\n\n      case 'string':\n        console.log('TO DO: Add String Diff') // eslint-disable-line no-fallthrough\n\n      default:\n        if (lhs !== rhs) {\n          if (NGN.typeof(lhs) !== 'undefined' && NGN.typeof(rhs) === 'undefined') {\n            differences.push(['-', path, lhs])\n          } else if (NGN.typeof(lhs) === 'undefined' && NGN.typeof(rhs) !== 'undefined') {\n            differences.push(['+', path, rhs])\n          } else {\n            differences.push(['m', path, lhs, rhs])\n          }\n        }\n    }\n\n    return differences\n  }\n\n  compareArray (lhs, rhs) {\n    // if (lhs === rhs) {\n      return []\n    // }\n    //\n    // for (let i = 0; i < lhs.length; i++) {\n    //   if (false) {}\n    // }\n  }\n\n  static arraysHaveMatchByRef (array1, array2, len1, len2) {\n    for (let index1 = 0; index1 < len1; index1++) {\n      let val1 = array1[index1]\n\n      for (let index2 = 0; index2 < len2; index2++) {\n        let val2 = array2[index2]\n\n        if (index1 !== index2 && val1 === val2) {\n          return true\n        }\n      }\n    }\n  }\n\n  static matchItems (array1, array2, index1, index2, context) {\n    let value1 = array1[index1]\n    let value2 = array2[index2]\n\n    if (value1 === value2) {\n      return true\n    }\n\n    if (typeof value1 !== 'object' || typeof value2 !== 'object') {\n      return false\n    }\n\n    let objectHash = context.objectHash\n\n    if (!objectHash) {\n      // no way to match objects was provided, try match by position\n      return context.matchByPosition && index1 === index2\n    }\n\n    let hash1\n    let hash2\n\n    if (typeof index1 === 'number') {\n      context.hashCache1 = NGN.forceArray(context.hashCache1)\n      hash1 = context.hashCache1[index1]\n\n      if (typeof hash1 === 'undefined') {\n        context.hashCache1[index1] = hash1 = objectHash(value1, index1)\n      }\n    } else {\n      hash1 = objectHash(value1)\n    }\n\n    if (typeof hash1 === 'undefined') {\n      return false\n    }\n\n    if (typeof index2 === 'number') {\n      context.hashCache2 = NGN.forceArray(context.hashCache2)\n      hash2 = context.hashCache2[index2]\n\n      if (typeof hash2 === 'undefined') {\n        context.hashCache2[index2] = hash2 = objectHash(value2, index2)\n      }\n    } else {\n      hash2 = objectHash(value2)\n    }\n\n    if (typeof hash2 === 'undefined') {\n      return false\n    }\n\n    return hash1 === hash2\n  }\n\n  /*\n   * LCS implementation that supports arrays or strings\n   * reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n   * This code abstracted from BenjamÃ­n Eidelman's JSONDiffPatch (MIT).\n   */\n  static lcsDefaultMatch (array1, array2, index1, index2) {\n    return array1[index1] === array2[index2]\n  }\n\n  static lcsLengthMatrix (array1, array2, match, context) {\n    let len1 = array1.length\n    let len2 = array2.length\n    let x\n    let y\n\n    // initialize empty matrix of len1+1 x len2+1\n    let matrix = [len1 + 1]\n\n    for (x = 0; x < len1 + 1; x++) {\n      matrix[x] = [len2 + 1]\n\n      for (y = 0; y < len2 + 1; y++) {\n        matrix[x][y] = 0\n      }\n    }\n\n    matrix.match = match\n\n    // save sequence lengths for each coordinate\n    for (x = 1; x < len1 + 1; x++) {\n      for (y = 1; y < len2 + 1; y++) {\n        if (match(array1, array2, x - 1, y - 1, context)) {\n          matrix[x][y] = matrix[x - 1][y - 1] + 1\n        } else {\n          matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1])\n        }\n      }\n    }\n\n    return matrix\n  };\n\n  static lcsBacktrack (matrix, array1, array2, index1, index2, context) {\n    if (index1 === 0 || index2 === 0) {\n      return {\n        sequence: [],\n        indices1: [],\n        indices2: []\n      }\n    }\n\n    if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {\n      let subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context)\n\n      subsequence.sequence.push(array1[index1 - 1])\n      subsequence.indices1.push(index1 - 1)\n      subsequence.indices2.push(index2 - 1)\n\n      return subsequence\n    }\n\n    if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {\n      return backtrack(matrix, array1, array2, index1, index2 - 1, context)\n    } else {\n      return backtrack(matrix, array1, array2, index1 - 1, index2, context)\n    }\n  };\n\n  static lcsGet (array1, array2, match, context) {\n    context = context || {}\n\n    let matrix = lengthMatrix(array1, array2, match || defaultMatch, context)\n    let result = backtrack(matrix, array1, array2, array1.length, array2.length, context)\n\n    if (typeof array1 === 'string' && typeof array2 === 'string') {\n      result.sequence = result.sequence.join('')\n    }\n\n    return result\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 4,
        "column": 15
      },
      "end": {
        "line": 253,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/DiffEngine.js",
      "extends": null,
      "configuration": {},
      "properties": {},
      "methods": {
        "compare": {
          "type": "method",
          "label": "compare",
          "description": null,
          "code": "static compare (lhs, rhs, path = []) {\n    let differences = []\n    let ltype = NGN.typeof(lhs)\n    let rtype = NGN.typeof(rhs)\n\n    // If the comparators aren't the same type, then\n    // it is a replacement. This is identified as\n    // removal of one object and creation of the other.\n    if (ltype !== rtype) {\n      return [\n        ['m', path, lhs, rhs]\n      ]\n    }\nconsole.log('Diffing:', ltype, lhs, rhs, 'PATH', path.join('.'))\n    switch (ltype) {\n      // case 'function':\n      //   if (lhs.toString() !== rhs.toString()) {\n      //     return ['m', path, lhs, rhs]\n      //   }\n      //\n      //   return []\n\n      case 'object':\n        let keys = Object.keys(lhs)\n        // let relativePath\n\n        // Compare left to right for modifications and removals\n        for (let i = 0; i < keys.length; i++) {\n          // Reset the relative path\n          let relativePath = Object.assign([], path)\n\n          relativePath.push(keys[i])\n\n          if (!rhs.hasOwnProperty(keys[i])) {\n            // If no right hand argument exists, it was removed.\n            differences.push(['-', relativePath, lhs[keys[i]]])\n          } else if (NGN.typeof(lhs[keys[i]]) === 'object') {\n            // Recursively compare objects\n            differences = differences.concat(this.compare(lhs[keys[i]], rhs[keys[i]], relativePath))\n          } else if (lhs[keys[i]] !== rhs[keys[i]]) {\n            if (NGN.typeof(lhs[keys[i]]) === 'array' && NGN.typeof(rhs[keys[i]]) === 'array') {\n              // If the keys contain arrays, re-run the comparison.\n              differences = differences.concat(this.compare(lhs[keys[i]], rhs[keys[i]], relativePath))\n            } else {\n              // If the comparators exist but are different, a\n              // modification ocurred.\n              differences.push(['m', relativePath, lhs[keys[i]], rhs[keys[i]]])\n            }\n          }\n        }\n\n        // Compare right to left for additions\n        keys = Object.keys(lhs)\n        keys.unshift(rhs)\n        keys = NGN.getObjectExtraneousPropertyNames.apply(this, keys)\n\n        for (let i = 0; i < keys.length; i++) {\n          // Reset the relative path\n          let relativePath = Object.assign([], path)\n          relativePath.push(keys[i])\n\n          differences.push(['+', relativePath, rhs[keys[i]]])\n        }\n\n        break\n\n      case 'array':\n        differences = this.compareArray(lhs, rhs)\n\n        break\n\n      case 'string':\n        console.log('TO DO: Add String Diff') // eslint-disable-line no-fallthrough\n\n      default:\n        if (lhs !== rhs) {\n          if (NGN.typeof(lhs) !== 'undefined' && NGN.typeof(rhs) === 'undefined') {\n            differences.push(['-', path, lhs])\n          } else if (NGN.typeof(lhs) === 'undefined' && NGN.typeof(rhs) !== 'undefined') {\n            differences.push(['+', path, rhs])\n          } else {\n            differences.push(['m', path, lhs, rhs])\n          }\n        }\n    }\n\n    return differences\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 5,
            "column": 2
          },
          "end": {
            "line": 92,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "lhs": {
              "type": "argument",
              "label": "lhs",
              "description": null,
              "code": "lhs",
              "start": {
                "line": 5,
                "column": 18
              },
              "end": {
                "line": 5,
                "column": 21
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "rhs": {
              "type": "argument",
              "label": "rhs",
              "description": null,
              "code": "rhs",
              "start": {
                "line": 5,
                "column": 23
              },
              "end": {
                "line": 5,
                "column": 26
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "path": {
              "type": "argument",
              "label": "path",
              "description": null,
              "code": "path = []",
              "start": {
                "line": 5,
                "column": 28
              },
              "end": {
                "line": 5,
                "column": 37
              },
              "flags": [],
              "default": "[]",
              "datatype": "object",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "compareArray": {
          "type": "method",
          "label": "compareArray",
          "description": null,
          "code": "compareArray (lhs, rhs) {\n    // if (lhs === rhs) {\n      return []\n    // }\n    //\n    // for (let i = 0; i < lhs.length; i++) {\n    //   if (false) {}\n    // }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 94,
            "column": 2
          },
          "end": {
            "line": 102,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "lhs": {
              "type": "argument",
              "label": "lhs",
              "description": null,
              "code": "lhs",
              "start": {
                "line": 94,
                "column": 16
              },
              "end": {
                "line": 94,
                "column": 19
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "rhs": {
              "type": "argument",
              "label": "rhs",
              "description": null,
              "code": "rhs",
              "start": {
                "line": 94,
                "column": 21
              },
              "end": {
                "line": 94,
                "column": 24
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "arraysHaveMatchByRef": {
          "type": "method",
          "label": "arraysHaveMatchByRef",
          "description": null,
          "code": "static arraysHaveMatchByRef (array1, array2, len1, len2) {\n    for (let index1 = 0; index1 < len1; index1++) {\n      let val1 = array1[index1]\n\n      for (let index2 = 0; index2 < len2; index2++) {\n        let val2 = array2[index2]\n\n        if (index1 !== index2 && val1 === val2) {\n          return true\n        }\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 104,
            "column": 2
          },
          "end": {
            "line": 116,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "array1": {
              "type": "argument",
              "label": "array1",
              "description": null,
              "code": "array1",
              "start": {
                "line": 104,
                "column": 31
              },
              "end": {
                "line": 104,
                "column": 37
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "array2": {
              "type": "argument",
              "label": "array2",
              "description": null,
              "code": "array2",
              "start": {
                "line": 104,
                "column": 39
              },
              "end": {
                "line": 104,
                "column": 45
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "len1": {
              "type": "argument",
              "label": "len1",
              "description": null,
              "code": "len1",
              "start": {
                "line": 104,
                "column": 47
              },
              "end": {
                "line": 104,
                "column": 51
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "len2": {
              "type": "argument",
              "label": "len2",
              "description": null,
              "code": "len2",
              "start": {
                "line": 104,
                "column": 53
              },
              "end": {
                "line": 104,
                "column": 57
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "matchItems": {
          "type": "method",
          "label": "matchItems",
          "description": null,
          "code": "static matchItems (array1, array2, index1, index2, context) {\n    let value1 = array1[index1]\n    let value2 = array2[index2]\n\n    if (value1 === value2) {\n      return true\n    }\n\n    if (typeof value1 !== 'object' || typeof value2 !== 'object') {\n      return false\n    }\n\n    let objectHash = context.objectHash\n\n    if (!objectHash) {\n      // no way to match objects was provided, try match by position\n      return context.matchByPosition && index1 === index2\n    }\n\n    let hash1\n    let hash2\n\n    if (typeof index1 === 'number') {\n      context.hashCache1 = NGN.forceArray(context.hashCache1)\n      hash1 = context.hashCache1[index1]\n\n      if (typeof hash1 === 'undefined') {\n        context.hashCache1[index1] = hash1 = objectHash(value1, index1)\n      }\n    } else {\n      hash1 = objectHash(value1)\n    }\n\n    if (typeof hash1 === 'undefined') {\n      return false\n    }\n\n    if (typeof index2 === 'number') {\n      context.hashCache2 = NGN.forceArray(context.hashCache2)\n      hash2 = context.hashCache2[index2]\n\n      if (typeof hash2 === 'undefined') {\n        context.hashCache2[index2] = hash2 = objectHash(value2, index2)\n      }\n    } else {\n      hash2 = objectHash(value2)\n    }\n\n    if (typeof hash2 === 'undefined') {\n      return false\n    }\n\n    return hash1 === hash2\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 118,
            "column": 2
          },
          "end": {
            "line": 171,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "array1": {
              "type": "argument",
              "label": "array1",
              "description": null,
              "code": "array1",
              "start": {
                "line": 118,
                "column": 21
              },
              "end": {
                "line": 118,
                "column": 27
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "array2": {
              "type": "argument",
              "label": "array2",
              "description": null,
              "code": "array2",
              "start": {
                "line": 118,
                "column": 29
              },
              "end": {
                "line": 118,
                "column": 35
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "index1": {
              "type": "argument",
              "label": "index1",
              "description": null,
              "code": "index1",
              "start": {
                "line": 118,
                "column": 37
              },
              "end": {
                "line": 118,
                "column": 43
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "index2": {
              "type": "argument",
              "label": "index2",
              "description": null,
              "code": "index2",
              "start": {
                "line": 118,
                "column": 45
              },
              "end": {
                "line": 118,
                "column": 51
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "context": {
              "type": "argument",
              "label": "context",
              "description": null,
              "code": "context",
              "start": {
                "line": 118,
                "column": 53
              },
              "end": {
                "line": 118,
                "column": 60
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "lcsDefaultMatch": {
          "type": "method",
          "label": "lcsDefaultMatch",
          "description": "LCS implementation that supports arrays or strings\n  reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n  This code abstracted from BenjamÃ­n Eidelman's JSONDiffPatch (MIT).",
          "code": "static lcsDefaultMatch (array1, array2, index1, index2) {\n    return array1[index1] === array2[index2]\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 178,
            "column": 2
          },
          "end": {
            "line": 180,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "array1": {
              "type": "argument",
              "label": "array1",
              "description": null,
              "code": "array1",
              "start": {
                "line": 178,
                "column": 26
              },
              "end": {
                "line": 178,
                "column": 32
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "array2": {
              "type": "argument",
              "label": "array2",
              "description": null,
              "code": "array2",
              "start": {
                "line": 178,
                "column": 34
              },
              "end": {
                "line": 178,
                "column": 40
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "index1": {
              "type": "argument",
              "label": "index1",
              "description": null,
              "code": "index1",
              "start": {
                "line": 178,
                "column": 42
              },
              "end": {
                "line": 178,
                "column": 48
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "index2": {
              "type": "argument",
              "label": "index2",
              "description": null,
              "code": "index2",
              "start": {
                "line": 178,
                "column": 50
              },
              "end": {
                "line": 178,
                "column": 56
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "lcsLengthMatrix": {
          "type": "method",
          "label": "lcsLengthMatrix",
          "description": null,
          "code": "static lcsLengthMatrix (array1, array2, match, context) {\n    let len1 = array1.length\n    let len2 = array2.length\n    let x\n    let y\n\n    // initialize empty matrix of len1+1 x len2+1\n    let matrix = [len1 + 1]\n\n    for (x = 0; x < len1 + 1; x++) {\n      matrix[x] = [len2 + 1]\n\n      for (y = 0; y < len2 + 1; y++) {\n        matrix[x][y] = 0\n      }\n    }\n\n    matrix.match = match\n\n    // save sequence lengths for each coordinate\n    for (x = 1; x < len1 + 1; x++) {\n      for (y = 1; y < len2 + 1; y++) {\n        if (match(array1, array2, x - 1, y - 1, context)) {\n          matrix[x][y] = matrix[x - 1][y - 1] + 1\n        } else {\n          matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1])\n        }\n      }\n    }\n\n    return matrix\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 182,
            "column": 2
          },
          "end": {
            "line": 213,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "array1": {
              "type": "argument",
              "label": "array1",
              "description": null,
              "code": "array1",
              "start": {
                "line": 182,
                "column": 26
              },
              "end": {
                "line": 182,
                "column": 32
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "array2": {
              "type": "argument",
              "label": "array2",
              "description": null,
              "code": "array2",
              "start": {
                "line": 182,
                "column": 34
              },
              "end": {
                "line": 182,
                "column": 40
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "match": {
              "type": "argument",
              "label": "match",
              "description": null,
              "code": "match",
              "start": {
                "line": 182,
                "column": 42
              },
              "end": {
                "line": 182,
                "column": 47
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "context": {
              "type": "argument",
              "label": "context",
              "description": null,
              "code": "context",
              "start": {
                "line": 182,
                "column": 49
              },
              "end": {
                "line": 182,
                "column": 56
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "lcsBacktrack": {
          "type": "method",
          "label": "lcsBacktrack",
          "description": null,
          "code": "static lcsBacktrack (matrix, array1, array2, index1, index2, context) {\n    if (index1 === 0 || index2 === 0) {\n      return {\n        sequence: [],\n        indices1: [],\n        indices2: []\n      }\n    }\n\n    if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {\n      let subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context)\n\n      subsequence.sequence.push(array1[index1 - 1])\n      subsequence.indices1.push(index1 - 1)\n      subsequence.indices2.push(index2 - 1)\n\n      return subsequence\n    }\n\n    if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {\n      return backtrack(matrix, array1, array2, index1, index2 - 1, context)\n    } else {\n      return backtrack(matrix, array1, array2, index1 - 1, index2, context)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 215,
            "column": 2
          },
          "end": {
            "line": 239,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "matrix": {
              "type": "argument",
              "label": "matrix",
              "description": null,
              "code": "matrix",
              "start": {
                "line": 215,
                "column": 23
              },
              "end": {
                "line": 215,
                "column": 29
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "array1": {
              "type": "argument",
              "label": "array1",
              "description": null,
              "code": "array1",
              "start": {
                "line": 215,
                "column": 31
              },
              "end": {
                "line": 215,
                "column": 37
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "array2": {
              "type": "argument",
              "label": "array2",
              "description": null,
              "code": "array2",
              "start": {
                "line": 215,
                "column": 39
              },
              "end": {
                "line": 215,
                "column": 45
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "index1": {
              "type": "argument",
              "label": "index1",
              "description": null,
              "code": "index1",
              "start": {
                "line": 215,
                "column": 47
              },
              "end": {
                "line": 215,
                "column": 53
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "index2": {
              "type": "argument",
              "label": "index2",
              "description": null,
              "code": "index2",
              "start": {
                "line": 215,
                "column": 55
              },
              "end": {
                "line": 215,
                "column": 61
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "context": {
              "type": "argument",
              "label": "context",
              "description": null,
              "code": "context",
              "start": {
                "line": 215,
                "column": 63
              },
              "end": {
                "line": 215,
                "column": 70
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "lcsGet": {
          "type": "method",
          "label": "lcsGet",
          "description": null,
          "code": "static lcsGet (array1, array2, match, context) {\n    context = context || {}\n\n    let matrix = lengthMatrix(array1, array2, match || defaultMatch, context)\n    let result = backtrack(matrix, array1, array2, array1.length, array2.length, context)\n\n    if (typeof array1 === 'string' && typeof array2 === 'string') {\n      result.sequence = result.sequence.join('')\n    }\n\n    return result\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 241,
            "column": 2
          },
          "end": {
            "line": 252,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "array1": {
              "type": "argument",
              "label": "array1",
              "description": null,
              "code": "array1",
              "start": {
                "line": 241,
                "column": 17
              },
              "end": {
                "line": 241,
                "column": 23
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "array2": {
              "type": "argument",
              "label": "array2",
              "description": null,
              "code": "array2",
              "start": {
                "line": 241,
                "column": 25
              },
              "end": {
                "line": 241,
                "column": 31
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "match": {
              "type": "argument",
              "label": "match",
              "description": null,
              "code": "match",
              "start": {
                "line": 241,
                "column": 33
              },
              "end": {
                "line": 241,
                "column": 38
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "context": {
              "type": "argument",
              "label": "context",
              "description": null,
              "code": "context",
              "start": {
                "line": 241,
                "column": 40
              },
              "end": {
                "line": 241,
                "column": 47
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.Model": {
      "type": "class",
      "label": "NGN.DATA.Model",
      "description": "The date/time when the record expires. This may be set to\n  a future date, or a numeric value. Numeric values\n  represent the number of milliseconds from the current time\n  before the record expires. For example, set this to `3000`\n  to force the record to expire 3 seconds from now.\n    Set this to `0` to immediately expire the record. Set this to\n  `-1` or `null` to prevent the record from expiring.",
      "code": "class NGNDataEntity extends EventEmitter { // eslint-disable-line\n  constructor (cfg) {\n    cfg = NGN.coalesce(cfg, {})\n\n    super()\n\n    if (cfg.dataMap) {\n      cfg.fieldmap = cfg.dataMap\n      NGN.WARN('\"dataMap\" is deprecated. Use \"map\" instead.')\n    }\n\n    if (cfg.idAttribute) {\n      cfg.IdentificationField = cfg.idAttribute\n      NGN.WARN('\"idAttribute\" is deprecated. Use \"IdentificationField\" instead.')\n    }\n\n    const me = this\n\n    // Create private attributes & data placeholders\n    Object.defineProperties(this, {\n      /**\n       * @property {Symbol} OID\n       * A unique object ID assigned to the model. This is an\n       * internal readon-only reference.\n       * @private\n       */\n      OID: NGN.private(Symbol('model.id')),\n\n      METADATA: NGN.privateconst({\n        /**\n         * @cfg {string} [name]\n         * A descriptive name for the model. This is typically used for\n         * debugging, logging, schema defintions, and (sometimes) data proxies.\n         */\n        name: NGN.coalesce(cfg.name, 'Untitled Model'),\n\n        /**\n         * @cfg {string} [description]\n         * A description of the model. This is typically used for\n         * debugging, logging, schema definitions, and (sometimes) data proxies.\n         */\n        description: NGN.coalesce(cfg.description, cfg.name, 'Generic Data Model'),\n\n        /**\n         * @cfg {object} fields\n         * A private object containing the data fields of the model.\n         * Each key contains the field name, while each value can be one of\n         * the following:\n         *\n         * - Primitive (String, Number, RegExp, Boolean)\n         * - Standard Type (Array, Object, Date)\n         * - Custom Class\n         * - NGN.DATA.Field\n         * - An NGN.DATA.Field configuration\n         * - `null` (Defaults to String primitive)\n         *\n         * ```js\n         * fields: {\n         *   a: String,\n         *   b: Date,\n         *   c: MyCustomClass,\n         *   d: new NGN.DATA.Field({\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   }),\n         *   e: {\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   },\n         *   f: null // Uses default field config (String)\n         * }\n         * ```\n         *\n         * Extensions of the NGN.DATA.Field are also supported,\n         * such as NGN.DATA.VirtualField and NGN.DATA.Relationship.\n         */\n        fields: Object.assign({}, NGN.coalesce(cfg.fields, {})),\n        knownFieldNames: new Set(),\n        invalidFieldNames: new Set(),\n        auditFieldNames: NGN.coalesce(cfg.audit, false) ? new Set() : null,\n\n        /**\n         * @property {[NGN.DATA.Rule]|Object}\n         * Custom validation rules used to verify the integrity of the entire\n         * model. This only applies to the full model. Individual data fields\n         * may have their own validators.\n         *\n         * If an object is specified, it should contain simple key/value pairs,\n         * where the key is the descriptive name of the rule and the value is\n         * a synchronous callback function that returns a `true`/`false` value.\n         * For instance, assume the fields called `price`, `items`, and `tax` exist\n         * in the example model below. :\n         *\n         * ```js\n         * {\n         *   'Positive Sale': function () {\n         *      return (this.price * this.items) > 0\n         *   },\n         *   'Taxes Applied': function () {\n         *      return this.tax > 0\n         *   }\n         * }\n         * ```\n         *\n         * Alternatively, an array of NGN.DATA.Rule instances may be provided.\n         */\n        validators: NGN.coalesce(cfg.rules, cfg.rule, cfg.validators),\n\n        /**\n         * @cfgproperty {boolean} [validation=true]\n         * Toggle data validation using this.\n         */\n        validation: NGN.coalesce(cfg.validation, true),\n\n        /**\n         * @cfg {boolean} [autoid=false]\n         * If the NGN.DATA.Model#IdentificationField/id is not provided for a record,\n         * a unique ID will be automatically generated for it.\n         *\n         * An NGN.DATA.Store using a model with this set to `true` will never\n         * have a duplicate record, since the #id or #IdentificationField will always\n         * be unique.\n         */\n        autoid: NGN.coalesce(cfg.autoid, false),\n\n        /**\n         * @cfg {String} [IdentificationField='id']\n         * Setting this allows an attribute of the object to be used as the ID.\n         * For example, if an email is the ID of a user, this would be set to\n         * `email`.\n         */\n        IdentificationField: NGN.coalesce(cfg.IdentificationField, cfg.idField, 'id'),\n\n        /**\n         * @cfgproperty {Date|Number} [expires]\n         * When this is set to a date/time, the model record will be marked\n         * as expired at the specified time/date. If a number is specified\n         * (milliseconds), the record will be marked as expired after the\n         * specified time period has elapsed. When a record/model is marked as\n         * \"expired\", it triggers the `expired` event. By default, expired\n         * records/models within an NGN.DATA.Store will be removed from the store.\n         *\n         * Setting this to any value less than `0` disables expiration.\n         * @fires expired\n         * Triggered when the model/record expires.\n         */\n        expiration: null,\n\n        // Holds a setTimeout method for expiration events.\n        expirationTimeout: null,\n\n        created: Date.now(),\n        store: null,\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: false,\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: function (change) {\n          if (change.hasOwnProperty('cursor')) {\n            me.METADATA.AUDITLOG.commit(me.METADATA.getAuditMap())\n          }\n        },\n\n        EVENTS: new Set([\n          'field.update',\n          'field.create',\n          'field.remove',\n          'field.invalid',\n          'field.valid',\n          'field.hidden',\n          'field.unhidden',\n          'field.rule.add',\n          'field.rule.remove',\n          'rule.add',\n          'rule.remove',\n          'relationship.create',\n          'relationship.remove',\n          'expired',\n          'deleted',\n          'reset',\n          'load'\n        ]),\n\n        /**\n         * An internal method used to apply field definitions to the model.\n         * @param  {string} fieldname\n         * Name of the field (as applied to the model).\n         * @param  {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\n         * The configuration to apply. See #addField for details.\n         * @param  {Boolean} [suppressEvents=false]\n         * Optionally suppress the `field.create` event.\n         * @private\n         */\n        applyField: (field, fieldcfg = null, suppressEvents = false) => {\n          // Prevent duplicate fields\n          if (this.METADATA.knownFieldNames.has(field)) {\n            return NGN.WARN(`Duplicate field \"${field}\" detected.`)\n          }\n\n          // Prevent reserved words\n          if (this.hasOwnProperty(field) && field.toLowerCase() !== 'id') {\n            throw new ReservedWordError(`\"${field}\" cannot be used as a field name (reserved word).`)\n          }\n\n          // If the field config isn't already an NGN.DATA.Field, create it.\n          if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            if (fieldcfg instanceof NGN.DATA.Store || fieldcfg instanceof NGN.DATA.Model) {\n              if (this.METADATA.IdentificationField === field) {\n                throw new InvalidConfigurationError(`\"${field}\" cannot be an ID. Relationship fields cannot be an identification field/attribute.`)\n              }\n\n              this.METADATA.fields[field] = new NGN.DATA.Relationship({\n                name: field,\n                record: fieldcfg,\n                model: this\n              })\n            } else {\n              switch (NGN.typeof(fieldcfg)) {\n                // Custom config\n                case 'object':\n                  fieldcfg.model = this\n                  fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n                  fieldcfg.name = field\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field(fieldcfg)\n\n                  break\n\n                // Collection of models\n                case 'array':\n                  return this.applyField(field, fieldcfg[0], suppressEvents)\n\n                // Type-based cfg.\n                default:\n                  if (NGN.isFn(fieldcfg) || fieldcfg === null) {\n                    if (NGN.isFn(fieldcfg) && ['string', 'number', 'boolean', 'number', 'symbol', 'regexp', 'date', 'array', 'object'].indexOf(NGN.typeof(fieldcfg)) < 0) {\n                      this.METADATA.fields[field] = new NGN.DATA.VirtualField({\n                        name: field,\n                        identifier: this.METADATA.IdentificationField === field,\n                        model: this,\n                        method: fieldcfg\n                      })\n\n                      break\n                    }\n\n                    this.METADATA.fields[field] = new NGN.DATA.Field({\n                      name: field,\n                      type: fieldcfg,\n                      identifier: this.METADATA.IdentificationField === field,\n                      model: this\n                    })\n\n                    break\n                  }\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field({\n                    name: field,\n                    type: NGN.isFn(fieldcfg) ? fieldcfg : String,\n                    identifier: NGN.isFn(fieldcfg)\n                      ? false\n                      : NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field),\n                    model: this\n                  })\n\n                  break\n              }\n            }\n          } else if (fieldcfg.model === null) {\n            fieldcfg.name = field\n            fieldcfg.identifier = fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n            this.METADATA.fields[field].model = this\n          } else if (fieldcfg.model === this) {\n            fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n          } else if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            return NGN.WARN(`The \"${fieldcfg.name}\" field cannot be applied because model is already specified.`)\n          }\n\n          // Add a direct reference to the model.\n          Object.defineProperty(this, field, {\n            enumerable: true,\n            configurable: true,\n            get: () => this.get(field),\n            set: (value) => this.set(field, value)\n          })\n\n          // Enable auditing if necessary.\n          if (this.METADATA.AUDITABLE) {\n            if (this.METADATA.fields[field].fieldType !== 'virtual') {\n              this.METADATA.fields[field].auditable = true\n              this.METADATA.auditFieldNames.add(field)\n            }\n          }\n\n          // Add the field to the list\n          this.METADATA.knownFieldNames.add(field)\n\n          this.METADATA.fields[field].relay('*', this, 'field.')\n\n          if (!suppressEvents) {\n            this.emit('field.create', this.METADATA.fields[field])\n          }\n\n          return this.METADATA.fields[field]\n        },\n\n        /**\n         * An internal helper method for applying changes to the model.\n         * @param  {String} [type='undo']\n         * This can be `undo` or `redo`.\n         * @param  {Number} [count=1]\n         * The number of cursor indexes to shift\n         * @param  {Boolean} [suppressEvents=false]\n         * Indicates events should be suppressed.\n         * @private\n         */\n        applyChange: (type = 'undo', count = 1, suppressEvents = false) => {\n          if (!this.METADATA.AUDITABLE) {\n            NGN.WARN(`The ${type} operation failed on the ${this.name} model because auditing is disabled.`)\n            return\n          }\n\n          this.METADATA.AUDITLOG[type === 'undo' ? 'rollback' : 'advance'](count)\n\n          let data = this.METADATA.AUDITLOG.currentValue\n\n          if (data) {\n            this.METADATA.auditFieldNames.forEach(fieldname => {\n              let field = this.METADATA.fields[fieldname]\n              let log = field.METADATA.AUDITLOG\n\n              if (log.cursor !== data[fieldname]) {\n                if (typeof data[fieldname] === 'symbol') {\n                  log.cursor = data[fieldname]\n                } else {\n                  log.cursor = null\n                }\n\n                field.METADATA.setValue(NGN.coalesce(log.currentValue, field.default), suppressEvents, true)\n              }\n            })\n          }\n        },\n\n        /**\n         * Generates a key/value representation of the model where\n         * each key represents an auditable field and each value is the\n         * transaction cursor ID.\n         * @return {Object}\n         * @private\n         */\n        getAuditMap: () => {\n          let map = {}\n\n          this.METADATA.auditFieldNames.forEach(field => {\n            map[field] = this.METADATA.fields[field].METADATA.AUDITLOG.cursor\n          })\n\n          return map\n        },\n\n        /**\n         * Restore the model to a specific audit map (i.e. historical state\n         * of multiple fields).\n         * @param {Object} map\n         * The audit map to restore.\n         */\n        // restore: (map) => {\n        //   let keys = Object.keys(map)\n        //\n        //   for (let i = 0; i < keys.length; i++) {\n        //     if (this.METADATA.knownFieldNames.has(keys[i]) && typeof map[keys[i]] === 'symbol') {\n        //       console.log('Has', keys[i])\n        //\n        //     }\n        //   }\n        // },\n\n        // Deprecations\n        setSilent: NGN.deprecate(this.setSilentFieldValue, 'setSilent has been deprecated. Use setSilentFieldValue instead.'),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        DATAMAP: null\n      }),\n\n      MAP: NGN.get(() => {\n        return NGN.coalesce(\n          this.METADATA.DATAMAP,\n          this.METADATA.store instanceof NGN.DATA.Store\n            ? this.METADATA.store.map\n            : null\n        )\n      })\n    })\n\n    if (cfg.fieldmap instanceof NGN.DATA.FieldMap) {\n      this.METADATA.DATAMAP = cfg.fieldmap\n    } else if (NGN.typeof(cfg.fieldmap) === 'object') {\n      this.METADATA.DATAMAP = new NGN.DATA.FieldMap(cfg.fieldmap)\n    }\n\n    // Bubble events to the BUS\n    // this.relay('*', NGN.BUS, 'record.')\n\n    // Add data fields.\n    let fields = Object.keys(this.METADATA.fields)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i]\n\n      if (this.METADATA.knownFieldNames.has(name)) {\n        NGN.WARN(`Duplicate field \"${name}\" detected.`)\n      } else {\n        // Configure a data field for each configuration.\n        this.METADATA.applyField(name, this.METADATA.fields[name], true)\n      }\n    }\n\n    // Apply automatic ID's when applicable\n    if (this.METADATA.autoid) {\n      let autoIdValue = null\n\n      Object.defineProperty(this.METADATA, 'IdentificationValue', NGN.get(() => {\n        if (autoIdValue === null) {\n          autoIdValue = NGN.DATA.UTILITY.UUID()\n        }\n\n        return autoIdValue\n      }))\n    }\n\n    // Apply auditing if configured\n    this.auditable = NGN.coalesce(cfg.audit, false)\n\n    // Clear any cached checksums when the model changes.\n    this.on(['field.update', 'field.create', 'field.delete', 'field.hidden', 'field.unhidden'], () => {\n      if (this.METADATA.checksum) {\n        this.METADATA.checksum = null\n      }\n    })\n\n    // Configure TTL/Expiration\n    if (cfg.expires) {\n      this.expires = cfg.expires\n    }\n\n    // Configure model-level validation rules\n    if (this.METADATA.validators !== null) {\n      switch (NGN.typeof(this.METADATA.validators)) {\n        // Support key/value objects where the key is the name and value is a function.\n        case 'object':\n          let keys = Object.keys(this.METADATA.validators)\n          let rules = []\n\n          for (let i = 0; i < keys.length; i++) {\n            rules.push(new NGN.DATA.Rule(this.METADATA.validators[keys[i]], keys[i], this))\n          }\n\n          break\n\n        // Support an array of existing data rules.\n        case 'array':\n          for (let i = 0; i < this.METADATA.validators.length; i++) {\n            if (this.METADATA.validators[i].hasOwnProperty('RULE')) {\n              this.METADATA.validators[i].RULE.scope = this\n            } else {\n              throw new Error(`Invalid data rule configuration for ${this.name} model. Rule #${i} is not a valid NGN.DATA.Rule instance.`)\n            }\n          }\n\n          break\n\n        // Diasllow any other kinds of rules.\n        default:\n          throw new Error(`Invalid data rule configuration for ${this.name} model. Expected an object or array of NGN.DATA.Rule instances. Received \"${NGN.typeof(this.METADATA.validators)}\"`)\n      }\n    }\n  }\n\n  get name () {\n    return this.METADATA.name\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n      this.METADATA.auditFieldNames = value ? new Set() : null\n\n      // Set each field to an auditable state (or not).\n      this.METADATA.knownFieldNames.forEach(fieldname => {\n        if (!this.METADATA.fields[fieldname].virtual) {\n          this.METADATA.fields[fieldname].auditable = value\n\n          if (value) {\n            this.METADATA.auditFieldNames.add(fieldname)\n          }\n        }\n      })\n\n      if (value) {\n        // Track Changes (if auditing enabled)\n        this.on('field.transaction.*', (id) => {\n          this.METADATA.AUDIT_HANDLER({ cursor: id })\n        })\n      } else {\n        this.METADATA.auditFieldNames.clear()\n\n        this.off('field.transaction.*')\n      }\n    }\n  }\n\n  /**\n   * The unique ID assigned to the model.\n   * @return {string}\n   */\n  get id () {\n    return this.get(this.METADATA.IdentificationField)\n  }\n\n  set id (value) {\n    this.set('id', value)\n  }\n\n  /**\n   * @property ID\n   * An alias for #id.\n   */\n  get ID () {\n    return this.id\n  }\n\n  set ID (value) {\n    this.set('id', value)\n  }\n\n  /**\n   * @property {Array} changelog\n   * The changelog returns the underlying NGN.DATA.TransactionLog#log if\n   * auditing is available. The array will be empty if auditing is disabled.\n   */\n  get changelog () {\n    return this.METADATA.AUDITLOG.log.map(entry => {\n      let result = {\n        timestamp: entry.timestamp,\n        activeCursor: entry.activeCursor,\n        value: {}\n      }\n\n      let data = entry.value\n      let field = Object.keys(data)\n\n      for (let i = 0; i < field.length; i++) {\n        if (typeof data[field[i]] === 'symbol') {\n          result.value[field[i]] = NGN.coalesce(\n            this.METADATA.fields[field[i]].METADATA.AUDITLOG.getCommit(data[field[i]]).value,\n            this.METADATA.fields[field[i]].default\n          )\n        } else {\n          result.value[field[i]] = NGN.coalesce(this.METADATA.fields[field[i]].default)\n        }\n      }\n\n      return result\n    })\n  }\n\n  /**\n   * @property {Number} createDate\n   * The date/time when the model is created.\n   */\n  get createDate () {\n    return this.METADATA.created\n  }\n\n  /**\n   * @property {object} data\n   * A serialized version of the data represented by the model. This\n   * only includes non-virtual fields. See #representation to use\n   * a representation of data containing virtual fields.\n   */\n  get data () {\n    if (this.MAP) {\n      return this.MAP.applyInverseMap(this.serializeFields())\n    }\n\n    return this.serializeFields()\n  }\n\n  /**\n   * @property {object} unmappedData\n   * Returns #data _without applying_ the data #map.\n   */\n  get unmappedData () {\n    return this.serializeFields()\n  }\n\n  /**\n   * @property {object} representation\n   * A serialized version of the data represented by the model. This\n   * includes virtual fields. See #data to use just the raw values.\n   */\n  get representation () {\n    if (this.MAP) {\n      return this.MAP.applyInverseMap(this.serializeFields(false, false))\n    }\n\n    return this.serializeFields(false, false)\n  }\n\n  /**\n   * @property {object} unmappedRepresentation\n   * Returns #representation _without applying_ the data #map.\n   */\n  get unmappedRepresentation () {\n    return this.serializeFields(false, false)\n  }\n\n  /**\n   * @property {string} checksum\n   * The checksum is a unique \"fingerprint\" of the data stored in the model.\n   * Please note that generating a checksum for an individual record is\n   * usually a quick operation, but generating large quantities of checksums\n   * simultaneously/sequentially can be computationally expensive. On average,\n   * a checksum takes 3-125ms to generate.\n   */\n  get checksum () {\n    this.METADATA.checksum = NGN.coalesce(this.METADATA.checksum, NGN.DATA.UTILITY.checksum(JSON.stringify(this.data)))\n\n    return this.METADATA.checksum\n  }\n\n  /**\n   * @property {Date} expires\n   * The date/time when the record expires. This may be set to\n   * a future date, or a numeric value. Numeric values\n   * represent the number of milliseconds from the current time\n   * before the record expires. For example, set this to `3000`\n   * to force the record to expire 3 seconds from now.\n   *\n   * Set this to `0` to immediately expire the record. Set this to\n   * `-1` or `null` to prevent the record from expiring.\n   */\n  get expires () {\n    return this.METADATA.expiration\n  }\n\n  set expires (value) {\n    if (value === null) {\n      clearTimeout(this.METADATA.expirationTimeout)\n      this.METADATA.expiration = null\n      return\n    }\n\n    let now = new Date()\n\n    if (!isNaN(value) && !(value instanceof Date)) {\n      // Handle numeric (millisecond) expiration\n      if (value < 0) {\n        this.METADATA.expiration = null\n\n        return\n      }\n\n      if (value === 0) {\n        this.METADATA.expiration = now\n        this.emit('expire')\n\n        return\n      }\n\n      this.METADATA.expiration = new Date()\n      this.METADATA.expiration.setTime(now.getTime() + value)\n    } else if (!(value instanceof Date) || value <= now) {\n      throw new Error(`${this.name} expiration (TTL) value must be a positive number (milliseconds) or future date.`)\n    } else {\n      // Handle date-based expiration\n      this.METADATA.expiration = value\n    }\n\n    clearTimeout(this.METADATA.expirationTimeout)\n\n    this.METADATA.expirationTimeout = setTimeout(() => this.emit('expire'), this.METADATA.expiration.getTime() - now.getTime())\n  }\n\n  get expired () {\n    if (this.METADATA.expiration === null) {\n      return false\n    }\n\n    return this.METADATA.expiration <= (new Date())\n  }\n\n  get fieldDefinitions () {\n    return this.METADATA.fields\n    // if (this.METADATA.knownFieldNames.size === 0) {\n    //   return {}\n    // }\n    //\n    // let fields = this.METADATA.knownFieldNames.keys()\n    // let result = {}\n    // let fieldname = fields.next()\n    //\n    // while (!fieldname.done) {\n    //   let field = this.METADATA.fields[fieldname.value]\n    //\n    //   if ((\n    //     field.value === undefined ||\n    //     (ignoreID && fieldname.value === this.IdentificationField) ||\n    //     (!field.virtual || (!ignoreVirtualFields && field.virtual))\n    //   )) {\n    //     // Do not serialize hidden values or virtuals\n    //     if (!field.hidden) {\n    //       switch (NGN.typeof(field.value)) {\n    //         case 'array':\n    //         case 'object':\n    //           result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\n    //           break\n    //\n    //         default:\n    //           result[fieldname.value] = field.value\n    //       }\n    //     }\n    //   }\n    // }\n  }\n\n  serializeFields (ignoreID = false, ignoreVirtualFields = true) {\n    if (this.METADATA.knownFieldNames.size === 0) {\n      return {}\n    }\n\n    let fields = this.METADATA.knownFieldNames.keys()\n    let result = {}\n    let fieldname = fields.next()\n\n    while (!fieldname.done) {\n      let field = this.METADATA.fields[fieldname.value]\n\n      // Ignore unserializable fields\n      if ((\n        field.value === undefined ||\n        (ignoreID && fieldname.value === this.IdentificationField) ||\n        (!field.virtual || (!ignoreVirtualFields && field.virtual))\n      )) {\n        // Do not serialize hidden values or virtuals\n        if (!field.hidden) {\n          switch (NGN.typeof(field.value)) {\n            case 'array':\n            case 'object':\n              result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\n              break\n\n            default:\n              result[fieldname.value] = field.value\n          }\n        }\n      }\n\n      fieldname = fields.next()\n    }\n\n    return result\n  }\n\n  serialize () {\n    return NGN.deprecate(this.serializeFields, 'serialize is now serializeFields. Use NGN.DATA.UTILITY.serialize for generic object serialization.')\n  }\n\n  /**\n   * Determines whether a field exists in the model or not.\n   * @param  {string} field\n   * Name of the field to check for.\n   * @return {boolean}\n   */\n  fieldExists (field) {\n    return this.METADATA.knownFieldNames.has(field)\n  }\n\n  /**\n   * Retrieve the value of the specified field.\n   * @param  {string} field\n   * Name of the field whose value should be returned.\n   * @return {any}\n   * Returns the value of the field.\n   */\n  get (field) {\n    if (field === 'id' || field === 'ID' || field === this.METADATA.IdentificationField) {\n      field = this.METADATA.IdentificationField\n\n      if (this.METADATA.autoid) {\n        if (!this.METADATA.knownFieldNames.has(field)) {\n          return this.METADATA.IdentificationValue\n        } else {\n          return NGN.coalesce(this.METADATA.fields[field].value, this.METADATA.IdentificationValue)\n        }\n      }\n    }\n\n    if (this.METADATA.knownFieldNames.has(field)) {\n      return this.METADATA.fields[field].value\n    } else {\n      NGN.WARN(`Cannot get \"${field}\". The field is not part of the model.`)\n      return undefined\n    }\n  }\n\n  /**\n   * Set a new value for the specified field.\n   * @param {string} field\n   * Name of the field whose value will be changed.\n   * @param {any} value\n   * The new value of the field.\n   */\n  set (field, value) {\n    if (field === 'id' || field === 'ID') {\n      field = this.METADATA.IdentificationField\n    }\n\n    if (this.METADATA.knownFieldNames.has(field)) {\n      this.METADATA.fields[field].value = value\n    } else {\n      NGN.WARN(`Cannot set \"${field}\". Unrecognized field name.`)\n    }\n  }\n\n  /**\n   * Add a data field after the initial model definition.\n   * @param {string} fieldname\n   * The name of the field.\n   * @param {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\n   * The field configuration (see cfg#fields for syntax).\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addField (name, fieldConfiguration = null, suppressEvents = false) {\n    if (name instanceof NGN.DATA.Field) {\n      fieldConfiguration = name\n      name = fieldConfiguration.name\n    } else if (typeof name !== 'string') {\n      throw new Error('Cannot add a non-string based field.')\n    }\n\n    this.METADATA.applyField(name, fieldConfiguration, suppressEvents)\n  }\n\n  /**\n   * @method removeField\n   * Remove a field from the data model.\n   * @param {string} name\n   * Name of the field to remove.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is removed.\n   */\n  removeField (name, suppressEvents = false) {\n    if (this.METADATA.knownFieldNames.has(name)) {\n      this.METADATA.knownFieldNames.delete(name)\n      this.METADATA.invalidFieldNames.delete(name)\n\n      const field = this.METADATA.fields[name]\n\n      delete this[name]\n      delete this.METADATA.fields[name] // eslint-disable-line no-undef\n\n      // let change = {\n      //   action: 'delete',\n      //   field: field.name,\n      //   value: field,\n      //   join: field instanceof NGN.DATA.Relationship\n      // }\n\n      if (!suppressEvents) {\n        this.emit('field.remove', field)\n      }\n\n      if (this.METADATA.store !== null) {\n        this.METADATA.store.emit(this.METADATA.store.PRIVATE.EVENT.DELETE_RECORD_FIELD, {\n          record: this,\n          field\n        })\n      }\n    }\n  }\n\n  /**\n   * Returns the NGN.DATA.Field object for the specified field.\n   * @param  {string} fieldName\n   * Name of the field to retrieve.\n   * @return {NGN.DATA.Field}\n   * The raw field.\n   */\n  getField (name) {\n    if (name.toLowerCase() === 'id' && !this.METADATA.fields.hasOwnProperty(name) && this.METADATA.fields.hasOwnProperty(this.METADATA.IdentificationField)) {\n      return this.METADATA.fields[this.METADATA.IdentificationField]\n    }\n\n    return this.METADATA.fields[name]\n  }\n\n  /**\n   * @method setSilent\n   * A method to set a field value without triggering an update event.\n   * This is designed primarily for use with live update proxies to prevent\n   * endless event loops.\n   * @param {string} fieldname\n   * The name of the #field to update.\n   * @param {any} value\n   * The new value of the field.\n   * @private\n   */\n  setSilentFieldValue (field, value) {\n    this.METADATA.fields[field].silentValue = value\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog (transaction log). To \"undo\" an \"undo\", use #redo.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  undo (count = 1, suppressEvents = false) {\n    this.METADATA.applyChange('undo', ...arguments)\n  }\n\n  /**\n   * @method redo\n   * A function to reapply known changes. This operation affects\n   * the changelog (transaction log).\n   *\n   * The redo operation only works after an undo operation, but before a new\n   * value is committed to the transaction log. In other words, `undo -> redo`\n   * will work, but `undo -> update -> redo` will not. For details, see how\n   * the NGN.DATA.TransactionLog cursor system works.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  redo (count = 1, suppressEvents = false) {\n    this.METADATA.applyChange('redo', ...arguments)\n  }\n\n  /**\n   * @method load\n   * Load a data record.\n   * @param {object} data\n   * The data to apply to the model.\n   * @param {boolean} [suppressEvents=false]\n   * Do not emit a change event when the data is loaded.\n   */\n  load (data, suppressEvents = false) {\n    if (this.MAP) {\n      data = this.MAP.applyMap(data)\n    }\n\n    let keys = Object.keys(data)\n\n    for (let i = 0; i < keys.length; i++) {\n      if (this.METADATA.knownFieldNames.has(keys[i])) {\n        this.METADATA.fields[keys[i]].METADATA.setValue(data[keys[i]], suppressEvents)\n      } else {\n        NGN.WARN(`Failed to load ${keys[i]} field of ${this.name} model. \"${keys[i]}\" is not a recognized field.`)\n      }\n    }\n\n    if (!suppressEvents) {\n      this.emit('load')\n    }\n\n    return this\n  }\n\n  /**\n   * @info This method only works on records within a store. If this method is\n   * called on a model that is not part of a store, the model itself will be\n   * returned.\n   *\n   * Retrieve the next record (after this one) from the store.\n   * This can be used to iterate through a store by calling `model.next()`.\n   * This is operation acts as a linked list iterator.\n   * @param  {Number}  [count=1]\n   * The number of records to retrieve. For example, `1` retrieves the next record.\n   * `2` retrieves the second record after this one. A negative number will\n   * automatically use the #previous method to retrieve prior records. Setting this\n   * to `0` will return the current record (i.e. no change).\n   * @param  {Boolean}  [cycle=false] [description]\n   * If this `next` is called on the last record, it will fail. Setting `cycle` to\n   * `true` will automatically restart the iteration, returning the first record in\n   * the store.\n   * @return {NGN.DATA.Model}\n   * Returns the next model in the store (after this one.)\n   */\n  next (count = 1, cycle = false) {\n    if (count === 0) {\n      return this\n    }\n\n    if (this.METADATA.store) {\n      if (typeof count === 'boolean') {\n        cycle = count\n        count = 1\n      }\n\n      return this.METADATA.store.getRecordSibling(this, count, cycle)\n    } else {\n      NGN.WARN('Attempted to call next() on a model that does not belong to a store.')\n      return this\n    }\n  }\n\n  /**\n   * Retrieve the previous record (before this one) from the store.\n   * This can be used to iterate through a store in reverse by calling\n   * `model.previous()`. This is operation acts as a doubly linked list iterator.\n   *\n   * @info This method only works on records within a store. If this method is\n   * called on a model that is not part of a store, the model itself will be\n   * returned.\n   * @param  {Number}  [count=1]\n   * The number of records to retrieve. For example, `1` retrieves the prior record.\n   * `2` retrieves the second record before this one. A negative number will\n   * automatically use the #next method to retrieve forward records. Setting this\n   * to `0` will return the current record (i.e. no change).\n   * @param  {Boolean}  [cycle=false] [description]\n   * If this `next` is called on the first record, it will fail. Setting `cycle` to\n   * `true` will automatically restart the iteration, returning the last record in\n   * the store.\n   * @return {NGN.DATA.Model}\n   * Returns the previous model in the store (before this one.)\n   */\n  previous (count = 1, cycle = false) {\n    if (count === 0) {\n      return this\n    }\n\n    if (this.METADATA.store) {\n      if (typeof count === 'boolean') {\n        cycle = count\n        count = 1\n      }\n\n      return this.METADATA.store.getRecordSibling(this, 0 - count, cycle)\n    } else {\n      NGN.WARN('Attempted to call previous() on a model that does not belong to a store.')\n      return this\n    }\n  }\n\n  /**\n   * Remove this model from the NGN.DATA.Store it is a part of.\n   *\n   * @info This method only works on records within a store. If this method is\n   * called on a model that is not part of a store, nothing will happen.\n   */\n  destroy () {\n    if (this.METADATA.store) {\n      this.METADATA.store.remove(this.OID)\n    } else {\n      NGN.WARN('Attempted to call remove() on a model that does not belong to a store.')\n    }\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "field.create": {
          "type": "event",
          "label": "field.create",
          "description": null,
          "code": "this.emit('field.create', this.METADATA.fields[field])",
          "start": {
            "line": 325,
            "column": 12
          },
          "end": {
            "line": 325,
            "column": 66
          },
          "flags": [],
          "parameters": {
            "undefined.METADATA.fields.field": {
              "type": "argument",
              "label": "undefined.METADATA.fields.field",
              "description": null,
              "code": "this.METADATA.fields[field]",
              "start": {
                "line": 325,
                "column": 38
              },
              "end": {
                "line": 325,
                "column": 65
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "field.remove": {
          "type": "event",
          "label": "field.remove",
          "description": null,
          "code": "this.emit('field.remove', field)",
          "start": {
            "line": 918,
            "column": 8
          },
          "end": {
            "line": 918,
            "column": 40
          },
          "flags": [],
          "parameters": {
            "field": {
              "type": "argument",
              "label": "field",
              "description": null,
              "code": "field",
              "start": {
                "line": 918,
                "column": 34
              },
              "end": {
                "line": 918,
                "column": 39
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "load": {
          "type": "event",
          "label": "load",
          "description": null,
          "code": "this.emit('load')",
          "start": {
            "line": 1017,
            "column": 6
          },
          "end": {
            "line": 1017,
            "column": 23
          },
          "flags": [],
          "parameters": {},
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 15,
        "column": 15
      },
      "end": {
        "line": 1112,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/Model.js",
      "extends": "EventEmitter",
      "configuration": {},
      "properties": {
        "OID": {
          "type": "property",
          "label": "OID",
          "description": "A unique object ID assigned to the model. This is an\ninternal readon-only reference.",
          "code": "OID: NGN.private(Symbol('model.id'))",
          "start": {
            "line": 41,
            "column": 6
          },
          "end": {
            "line": 41,
            "column": 42
          },
          "flags": [],
          "default": null,
          "datatype": "symbol",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "METADATA": {
          "type": "property",
          "label": "METADATA",
          "description": null,
          "code": "METADATA: NGN.privateconst({\n        /**\n         * @cfg {string} [name]\n         * A descriptive name for the model. This is typically used for\n         * debugging, logging, schema defintions, and (sometimes) data proxies.\n         */\n        name: NGN.coalesce(cfg.name, 'Untitled Model'),\n\n        /**\n         * @cfg {string} [description]\n         * A description of the model. This is typically used for\n         * debugging, logging, schema definitions, and (sometimes) data proxies.\n         */\n        description: NGN.coalesce(cfg.description, cfg.name, 'Generic Data Model'),\n\n        /**\n         * @cfg {object} fields\n         * A private object containing the data fields of the model.\n         * Each key contains the field name, while each value can be one of\n         * the following:\n         *\n         * - Primitive (String, Number, RegExp, Boolean)\n         * - Standard Type (Array, Object, Date)\n         * - Custom Class\n         * - NGN.DATA.Field\n         * - An NGN.DATA.Field configuration\n         * - `null` (Defaults to String primitive)\n         *\n         * ```js\n         * fields: {\n         *   a: String,\n         *   b: Date,\n         *   c: MyCustomClass,\n         *   d: new NGN.DATA.Field({\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   }),\n         *   e: {\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   },\n         *   f: null // Uses default field config (String)\n         * }\n         * ```\n         *\n         * Extensions of the NGN.DATA.Field are also supported,\n         * such as NGN.DATA.VirtualField and NGN.DATA.Relationship.\n         */\n        fields: Object.assign({}, NGN.coalesce(cfg.fields, {})),\n        knownFieldNames: new Set(),\n        invalidFieldNames: new Set(),\n        auditFieldNames: NGN.coalesce(cfg.audit, false) ? new Set() : null,\n\n        /**\n         * @property {[NGN.DATA.Rule]|Object}\n         * Custom validation rules used to verify the integrity of the entire\n         * model. This only applies to the full model. Individual data fields\n         * may have their own validators.\n         *\n         * If an object is specified, it should contain simple key/value pairs,\n         * where the key is the descriptive name of the rule and the value is\n         * a synchronous callback function that returns a `true`/`false` value.\n         * For instance, assume the fields called `price`, `items`, and `tax` exist\n         * in the example model below. :\n         *\n         * ```js\n         * {\n         *   'Positive Sale': function () {\n         *      return (this.price * this.items) > 0\n         *   },\n         *   'Taxes Applied': function () {\n         *      return this.tax > 0\n         *   }\n         * }\n         * ```\n         *\n         * Alternatively, an array of NGN.DATA.Rule instances may be provided.\n         */\n        validators: NGN.coalesce(cfg.rules, cfg.rule, cfg.validators),\n\n        /**\n         * @cfgproperty {boolean} [validation=true]\n         * Toggle data validation using this.\n         */\n        validation: NGN.coalesce(cfg.validation, true),\n\n        /**\n         * @cfg {boolean} [autoid=false]\n         * If the NGN.DATA.Model#IdentificationField/id is not provided for a record,\n         * a unique ID will be automatically generated for it.\n         *\n         * An NGN.DATA.Store using a model with this set to `true` will never\n         * have a duplicate record, since the #id or #IdentificationField will always\n         * be unique.\n         */\n        autoid: NGN.coalesce(cfg.autoid, false),\n\n        /**\n         * @cfg {String} [IdentificationField='id']\n         * Setting this allows an attribute of the object to be used as the ID.\n         * For example, if an email is the ID of a user, this would be set to\n         * `email`.\n         */\n        IdentificationField: NGN.coalesce(cfg.IdentificationField, cfg.idField, 'id'),\n\n        /**\n         * @cfgproperty {Date|Number} [expires]\n         * When this is set to a date/time, the model record will be marked\n         * as expired at the specified time/date. If a number is specified\n         * (milliseconds), the record will be marked as expired after the\n         * specified time period has elapsed. When a record/model is marked as\n         * \"expired\", it triggers the `expired` event. By default, expired\n         * records/models within an NGN.DATA.Store will be removed from the store.\n         *\n         * Setting this to any value less than `0` disables expiration.\n         * @fires expired\n         * Triggered when the model/record expires.\n         */\n        expiration: null,\n\n        // Holds a setTimeout method for expiration events.\n        expirationTimeout: null,\n\n        created: Date.now(),\n        store: null,\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: false,\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: function (change) {\n          if (change.hasOwnProperty('cursor')) {\n            me.METADATA.AUDITLOG.commit(me.METADATA.getAuditMap())\n          }\n        },\n\n        EVENTS: new Set([\n          'field.update',\n          'field.create',\n          'field.remove',\n          'field.invalid',\n          'field.valid',\n          'field.hidden',\n          'field.unhidden',\n          'field.rule.add',\n          'field.rule.remove',\n          'rule.add',\n          'rule.remove',\n          'relationship.create',\n          'relationship.remove',\n          'expired',\n          'deleted',\n          'reset',\n          'load'\n        ]),\n\n        /**\n         * An internal method used to apply field definitions to the model.\n         * @param  {string} fieldname\n         * Name of the field (as applied to the model).\n         * @param  {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\n         * The configuration to apply. See #addField for details.\n         * @param  {Boolean} [suppressEvents=false]\n         * Optionally suppress the `field.create` event.\n         * @private\n         */\n        applyField: (field, fieldcfg = null, suppressEvents = false) => {\n          // Prevent duplicate fields\n          if (this.METADATA.knownFieldNames.has(field)) {\n            return NGN.WARN(`Duplicate field \"${field}\" detected.`)\n          }\n\n          // Prevent reserved words\n          if (this.hasOwnProperty(field) && field.toLowerCase() !== 'id') {\n            throw new ReservedWordError(`\"${field}\" cannot be used as a field name (reserved word).`)\n          }\n\n          // If the field config isn't already an NGN.DATA.Field, create it.\n          if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            if (fieldcfg instanceof NGN.DATA.Store || fieldcfg instanceof NGN.DATA.Model) {\n              if (this.METADATA.IdentificationField === field) {\n                throw new InvalidConfigurationError(`\"${field}\" cannot be an ID. Relationship fields cannot be an identification field/attribute.`)\n              }\n\n              this.METADATA.fields[field] = new NGN.DATA.Relationship({\n                name: field,\n                record: fieldcfg,\n                model: this\n              })\n            } else {\n              switch (NGN.typeof(fieldcfg)) {\n                // Custom config\n                case 'object':\n                  fieldcfg.model = this\n                  fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n                  fieldcfg.name = field\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field(fieldcfg)\n\n                  break\n\n                // Collection of models\n                case 'array':\n                  return this.applyField(field, fieldcfg[0], suppressEvents)\n\n                // Type-based cfg.\n                default:\n                  if (NGN.isFn(fieldcfg) || fieldcfg === null) {\n                    if (NGN.isFn(fieldcfg) && ['string', 'number', 'boolean', 'number', 'symbol', 'regexp', 'date', 'array', 'object'].indexOf(NGN.typeof(fieldcfg)) < 0) {\n                      this.METADATA.fields[field] = new NGN.DATA.VirtualField({\n                        name: field,\n                        identifier: this.METADATA.IdentificationField === field,\n                        model: this,\n                        method: fieldcfg\n                      })\n\n                      break\n                    }\n\n                    this.METADATA.fields[field] = new NGN.DATA.Field({\n                      name: field,\n                      type: fieldcfg,\n                      identifier: this.METADATA.IdentificationField === field,\n                      model: this\n                    })\n\n                    break\n                  }\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field({\n                    name: field,\n                    type: NGN.isFn(fieldcfg) ? fieldcfg : String,\n                    identifier: NGN.isFn(fieldcfg)\n                      ? false\n                      : NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field),\n                    model: this\n                  })\n\n                  break\n              }\n            }\n          } else if (fieldcfg.model === null) {\n            fieldcfg.name = field\n            fieldcfg.identifier = fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n            this.METADATA.fields[field].model = this\n          } else if (fieldcfg.model === this) {\n            fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n          } else if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            return NGN.WARN(`The \"${fieldcfg.name}\" field cannot be applied because model is already specified.`)\n          }\n\n          // Add a direct reference to the model.\n          Object.defineProperty(this, field, {\n            enumerable: true,\n            configurable: true,\n            get: () => this.get(field),\n            set: (value) => this.set(field, value)\n          })\n\n          // Enable auditing if necessary.\n          if (this.METADATA.AUDITABLE) {\n            if (this.METADATA.fields[field].fieldType !== 'virtual') {\n              this.METADATA.fields[field].auditable = true\n              this.METADATA.auditFieldNames.add(field)\n            }\n          }\n\n          // Add the field to the list\n          this.METADATA.knownFieldNames.add(field)\n\n          this.METADATA.fields[field].relay('*', this, 'field.')\n\n          if (!suppressEvents) {\n            this.emit('field.create', this.METADATA.fields[field])\n          }\n\n          return this.METADATA.fields[field]\n        },\n\n        /**\n         * An internal helper method for applying changes to the model.\n         * @param  {String} [type='undo']\n         * This can be `undo` or `redo`.\n         * @param  {Number} [count=1]\n         * The number of cursor indexes to shift\n         * @param  {Boolean} [suppressEvents=false]\n         * Indicates events should be suppressed.\n         * @private\n         */\n        applyChange: (type = 'undo', count = 1, suppressEvents = false) => {\n          if (!this.METADATA.AUDITABLE) {\n            NGN.WARN(`The ${type} operation failed on the ${this.name} model because auditing is disabled.`)\n            return\n          }\n\n          this.METADATA.AUDITLOG[type === 'undo' ? 'rollback' : 'advance'](count)\n\n          let data = this.METADATA.AUDITLOG.currentValue\n\n          if (data) {\n            this.METADATA.auditFieldNames.forEach(fieldname => {\n              let field = this.METADATA.fields[fieldname]\n              let log = field.METADATA.AUDITLOG\n\n              if (log.cursor !== data[fieldname]) {\n                if (typeof data[fieldname] === 'symbol') {\n                  log.cursor = data[fieldname]\n                } else {\n                  log.cursor = null\n                }\n\n                field.METADATA.setValue(NGN.coalesce(log.currentValue, field.default), suppressEvents, true)\n              }\n            })\n          }\n        },\n\n        /**\n         * Generates a key/value representation of the model where\n         * each key represents an auditable field and each value is the\n         * transaction cursor ID.\n         * @return {Object}\n         * @private\n         */\n        getAuditMap: () => {\n          let map = {}\n\n          this.METADATA.auditFieldNames.forEach(field => {\n            map[field] = this.METADATA.fields[field].METADATA.AUDITLOG.cursor\n          })\n\n          return map\n        },\n\n        /**\n         * Restore the model to a specific audit map (i.e. historical state\n         * of multiple fields).\n         * @param {Object} map\n         * The audit map to restore.\n         */\n        // restore: (map) => {\n        //   let keys = Object.keys(map)\n        //\n        //   for (let i = 0; i < keys.length; i++) {\n        //     if (this.METADATA.knownFieldNames.has(keys[i]) && typeof map[keys[i]] === 'symbol') {\n        //       console.log('Has', keys[i])\n        //\n        //     }\n        //   }\n        // },\n\n        // Deprecations\n        setSilent: NGN.deprecate(this.setSilentFieldValue, 'setSilent has been deprecated. Use setSilentFieldValue instead.'),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        DATAMAP: null\n      })",
          "start": {
            "line": 43,
            "column": 6
          },
          "end": {
            "line": 427,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "MAP": {
          "type": "property",
          "label": "MAP",
          "description": null,
          "code": "MAP: NGN.get(() => {\n        return NGN.coalesce(\n          this.METADATA.DATAMAP,\n          this.METADATA.store instanceof NGN.DATA.Store\n            ? this.METADATA.store.map\n            : null\n        )\n      })",
          "start": {
            "line": 429,
            "column": 6
          },
          "end": {
            "line": 436,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "auditable": {
          "type": "property",
          "label": "auditable",
          "description": null,
          "code": "set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n      this.METADATA.auditFieldNames = value ? new Set() : null\n\n      // Set each field to an auditable state (or not).\n      this.METADATA.knownFieldNames.forEach(fieldname => {\n        if (!this.METADATA.fields[fieldname].virtual) {\n          this.METADATA.fields[fieldname].auditable = value\n\n          if (value) {\n            this.METADATA.auditFieldNames.add(fieldname)\n          }\n        }\n      })\n\n      if (value) {\n        // Track Changes (if auditing enabled)\n        this.on('field.transaction.*', (id) => {\n          this.METADATA.AUDIT_HANDLER({ cursor: id })\n        })\n      } else {\n        this.METADATA.auditFieldNames.clear()\n\n        this.off('field.transaction.*')\n      }\n    }\n  }",
          "start": {
            "line": 526,
            "column": 2
          },
          "end": {
            "line": 556,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "name": {
          "type": "property",
          "label": "name",
          "description": null,
          "code": "get name () {\n    return this.METADATA.name\n  }",
          "start": {
            "line": 522,
            "column": 2
          },
          "end": {
            "line": 524,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "id": {
          "type": "property",
          "label": "id",
          "description": null,
          "code": "set id (value) {\n    this.set('id', value)\n  }",
          "start": {
            "line": 566,
            "column": 2
          },
          "end": {
            "line": 568,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "ID": {
          "type": "property",
          "label": "ID",
          "description": null,
          "code": "set ID (value) {\n    this.set('id', value)\n  }",
          "start": {
            "line": 578,
            "column": 2
          },
          "end": {
            "line": 580,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "changelog": {
          "type": "property",
          "label": "changelog",
          "description": null,
          "code": "get changelog () {\n    return this.METADATA.AUDITLOG.log.map(entry => {\n      let result = {\n        timestamp: entry.timestamp,\n        activeCursor: entry.activeCursor,\n        value: {}\n      }\n\n      let data = entry.value\n      let field = Object.keys(data)\n\n      for (let i = 0; i < field.length; i++) {\n        if (typeof data[field[i]] === 'symbol') {\n          result.value[field[i]] = NGN.coalesce(\n            this.METADATA.fields[field[i]].METADATA.AUDITLOG.getCommit(data[field[i]]).value,\n            this.METADATA.fields[field[i]].default\n          )\n        } else {\n          result.value[field[i]] = NGN.coalesce(this.METADATA.fields[field[i]].default)\n        }\n      }\n\n      return result\n    })\n  }",
          "start": {
            "line": 587,
            "column": 2
          },
          "end": {
            "line": 611,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "createDate": {
          "type": "property",
          "label": "createDate",
          "description": null,
          "code": "get createDate () {\n    return this.METADATA.created\n  }",
          "start": {
            "line": 617,
            "column": 2
          },
          "end": {
            "line": 619,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "data": {
          "type": "property",
          "label": "data",
          "description": null,
          "code": "get data () {\n    if (this.MAP) {\n      return this.MAP.applyInverseMap(this.serializeFields())\n    }\n\n    return this.serializeFields()\n  }",
          "start": {
            "line": 627,
            "column": 2
          },
          "end": {
            "line": 633,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "unmappedData": {
          "type": "property",
          "label": "unmappedData",
          "description": null,
          "code": "get unmappedData () {\n    return this.serializeFields()\n  }",
          "start": {
            "line": 639,
            "column": 2
          },
          "end": {
            "line": 641,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "representation": {
          "type": "property",
          "label": "representation",
          "description": null,
          "code": "get representation () {\n    if (this.MAP) {\n      return this.MAP.applyInverseMap(this.serializeFields(false, false))\n    }\n\n    return this.serializeFields(false, false)\n  }",
          "start": {
            "line": 648,
            "column": 2
          },
          "end": {
            "line": 654,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "unmappedRepresentation": {
          "type": "property",
          "label": "unmappedRepresentation",
          "description": null,
          "code": "get unmappedRepresentation () {\n    return this.serializeFields(false, false)\n  }",
          "start": {
            "line": 660,
            "column": 2
          },
          "end": {
            "line": 662,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "checksum": {
          "type": "property",
          "label": "checksum",
          "description": null,
          "code": "get checksum () {\n    this.METADATA.checksum = NGN.coalesce(this.METADATA.checksum, NGN.DATA.UTILITY.checksum(JSON.stringify(this.data)))\n\n    return this.METADATA.checksum\n  }",
          "start": {
            "line": 672,
            "column": 2
          },
          "end": {
            "line": 676,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "expires": {
          "type": "property",
          "label": "expires",
          "description": null,
          "code": "set expires (value) {\n    if (value === null) {\n      clearTimeout(this.METADATA.expirationTimeout)\n      this.METADATA.expiration = null\n      return\n    }\n\n    let now = new Date()\n\n    if (!isNaN(value) && !(value instanceof Date)) {\n      // Handle numeric (millisecond) expiration\n      if (value < 0) {\n        this.METADATA.expiration = null\n\n        return\n      }\n\n      if (value === 0) {\n        this.METADATA.expiration = now\n        this.emit('expire')\n\n        return\n      }\n\n      this.METADATA.expiration = new Date()\n      this.METADATA.expiration.setTime(now.getTime() + value)\n    } else if (!(value instanceof Date) || value <= now) {\n      throw new Error(`${this.name} expiration (TTL) value must be a positive number (milliseconds) or future date.`)\n    } else {\n      // Handle date-based expiration\n      this.METADATA.expiration = value\n    }\n\n    clearTimeout(this.METADATA.expirationTimeout)\n\n    this.METADATA.expirationTimeout = setTimeout(() => this.emit('expire'), this.METADATA.expiration.getTime() - now.getTime())\n  }",
          "start": {
            "line": 693,
            "column": 2
          },
          "end": {
            "line": 729,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "expired": {
          "type": "property",
          "label": "expired",
          "description": null,
          "code": "get expired () {\n    if (this.METADATA.expiration === null) {\n      return false\n    }\n\n    return this.METADATA.expiration <= (new Date())\n  }",
          "start": {
            "line": 731,
            "column": 2
          },
          "end": {
            "line": 737,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "fieldDefinitions": {
          "type": "property",
          "label": "fieldDefinitions",
          "description": null,
          "code": "get fieldDefinitions () {\n    return this.METADATA.fields\n    // if (this.METADATA.knownFieldNames.size === 0) {\n    //   return {}\n    // }\n    //\n    // let fields = this.METADATA.knownFieldNames.keys()\n    // let result = {}\n    // let fieldname = fields.next()\n    //\n    // while (!fieldname.done) {\n    //   let field = this.METADATA.fields[fieldname.value]\n    //\n    //   if ((\n    //     field.value === undefined ||\n    //     (ignoreID && fieldname.value === this.IdentificationField) ||\n    //     (!field.virtual || (!ignoreVirtualFields && field.virtual))\n    //   )) {\n    //     // Do not serialize hidden values or virtuals\n    //     if (!field.hidden) {\n    //       switch (NGN.typeof(field.value)) {\n    //         case 'array':\n    //         case 'object':\n    //           result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\n    //           break\n    //\n    //         default:\n    //           result[fieldname.value] = field.value\n    //       }\n    //     }\n    //   }\n    // }\n  }",
          "start": {
            "line": 739,
            "column": 2
          },
          "end": {
            "line": 771,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "url": {
          "type": "property",
          "label": "url",
          "description": "The URL where the request will be sent.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "crossOriginRequest": {
          "type": "property",
          "label": "crossOriginRequest",
          "description": "Indicates the request will be made to a domain outside of the\none hosting the request.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "boolean",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "username": {
          "type": "property",
          "label": "username",
          "description": "The username that will be used in any basic authentication operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "password": {
          "type": "property",
          "label": "password",
          "description": "It is possible to set a password for any basic authentication operations,\nbut it is not possible to read a password.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "accessToken": {
          "type": "property",
          "label": "accessToken",
          "description": "Supply a bearer access token for basic authenticaiton operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (cfg) {\n    cfg = NGN.coalesce(cfg, {})\n\n    super()\n\n    if (cfg.dataMap) {\n      cfg.fieldmap = cfg.dataMap\n      NGN.WARN('\"dataMap\" is deprecated. Use \"map\" instead.')\n    }\n\n    if (cfg.idAttribute) {\n      cfg.IdentificationField = cfg.idAttribute\n      NGN.WARN('\"idAttribute\" is deprecated. Use \"IdentificationField\" instead.')\n    }\n\n    const me = this\n\n    // Create private attributes & data placeholders\n    Object.defineProperties(this, {\n      /**\n       * @property {Symbol} OID\n       * A unique object ID assigned to the model. This is an\n       * internal readon-only reference.\n       * @private\n       */\n      OID: NGN.private(Symbol('model.id')),\n\n      METADATA: NGN.privateconst({\n        /**\n         * @cfg {string} [name]\n         * A descriptive name for the model. This is typically used for\n         * debugging, logging, schema defintions, and (sometimes) data proxies.\n         */\n        name: NGN.coalesce(cfg.name, 'Untitled Model'),\n\n        /**\n         * @cfg {string} [description]\n         * A description of the model. This is typically used for\n         * debugging, logging, schema definitions, and (sometimes) data proxies.\n         */\n        description: NGN.coalesce(cfg.description, cfg.name, 'Generic Data Model'),\n\n        /**\n         * @cfg {object} fields\n         * A private object containing the data fields of the model.\n         * Each key contains the field name, while each value can be one of\n         * the following:\n         *\n         * - Primitive (String, Number, RegExp, Boolean)\n         * - Standard Type (Array, Object, Date)\n         * - Custom Class\n         * - NGN.DATA.Field\n         * - An NGN.DATA.Field configuration\n         * - `null` (Defaults to String primitive)\n         *\n         * ```js\n         * fields: {\n         *   a: String,\n         *   b: Date,\n         *   c: MyCustomClass,\n         *   d: new NGN.DATA.Field({\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   }),\n         *   e: {\n         *     required: true,\n         *     type: String,\n         *     default: 'some default value'\n         *   },\n         *   f: null // Uses default field config (String)\n         * }\n         * ```\n         *\n         * Extensions of the NGN.DATA.Field are also supported,\n         * such as NGN.DATA.VirtualField and NGN.DATA.Relationship.\n         */\n        fields: Object.assign({}, NGN.coalesce(cfg.fields, {})),\n        knownFieldNames: new Set(),\n        invalidFieldNames: new Set(),\n        auditFieldNames: NGN.coalesce(cfg.audit, false) ? new Set() : null,\n\n        /**\n         * @property {[NGN.DATA.Rule]|Object}\n         * Custom validation rules used to verify the integrity of the entire\n         * model. This only applies to the full model. Individual data fields\n         * may have their own validators.\n         *\n         * If an object is specified, it should contain simple key/value pairs,\n         * where the key is the descriptive name of the rule and the value is\n         * a synchronous callback function that returns a `true`/`false` value.\n         * For instance, assume the fields called `price`, `items`, and `tax` exist\n         * in the example model below. :\n         *\n         * ```js\n         * {\n         *   'Positive Sale': function () {\n         *      return (this.price * this.items) > 0\n         *   },\n         *   'Taxes Applied': function () {\n         *      return this.tax > 0\n         *   }\n         * }\n         * ```\n         *\n         * Alternatively, an array of NGN.DATA.Rule instances may be provided.\n         */\n        validators: NGN.coalesce(cfg.rules, cfg.rule, cfg.validators),\n\n        /**\n         * @cfgproperty {boolean} [validation=true]\n         * Toggle data validation using this.\n         */\n        validation: NGN.coalesce(cfg.validation, true),\n\n        /**\n         * @cfg {boolean} [autoid=false]\n         * If the NGN.DATA.Model#IdentificationField/id is not provided for a record,\n         * a unique ID will be automatically generated for it.\n         *\n         * An NGN.DATA.Store using a model with this set to `true` will never\n         * have a duplicate record, since the #id or #IdentificationField will always\n         * be unique.\n         */\n        autoid: NGN.coalesce(cfg.autoid, false),\n\n        /**\n         * @cfg {String} [IdentificationField='id']\n         * Setting this allows an attribute of the object to be used as the ID.\n         * For example, if an email is the ID of a user, this would be set to\n         * `email`.\n         */\n        IdentificationField: NGN.coalesce(cfg.IdentificationField, cfg.idField, 'id'),\n\n        /**\n         * @cfgproperty {Date|Number} [expires]\n         * When this is set to a date/time, the model record will be marked\n         * as expired at the specified time/date. If a number is specified\n         * (milliseconds), the record will be marked as expired after the\n         * specified time period has elapsed. When a record/model is marked as\n         * \"expired\", it triggers the `expired` event. By default, expired\n         * records/models within an NGN.DATA.Store will be removed from the store.\n         *\n         * Setting this to any value less than `0` disables expiration.\n         * @fires expired\n         * Triggered when the model/record expires.\n         */\n        expiration: null,\n\n        // Holds a setTimeout method for expiration events.\n        expirationTimeout: null,\n\n        created: Date.now(),\n        store: null,\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: false,\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: function (change) {\n          if (change.hasOwnProperty('cursor')) {\n            me.METADATA.AUDITLOG.commit(me.METADATA.getAuditMap())\n          }\n        },\n\n        EVENTS: new Set([\n          'field.update',\n          'field.create',\n          'field.remove',\n          'field.invalid',\n          'field.valid',\n          'field.hidden',\n          'field.unhidden',\n          'field.rule.add',\n          'field.rule.remove',\n          'rule.add',\n          'rule.remove',\n          'relationship.create',\n          'relationship.remove',\n          'expired',\n          'deleted',\n          'reset',\n          'load'\n        ]),\n\n        /**\n         * An internal method used to apply field definitions to the model.\n         * @param  {string} fieldname\n         * Name of the field (as applied to the model).\n         * @param  {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\n         * The configuration to apply. See #addField for details.\n         * @param  {Boolean} [suppressEvents=false]\n         * Optionally suppress the `field.create` event.\n         * @private\n         */\n        applyField: (field, fieldcfg = null, suppressEvents = false) => {\n          // Prevent duplicate fields\n          if (this.METADATA.knownFieldNames.has(field)) {\n            return NGN.WARN(`Duplicate field \"${field}\" detected.`)\n          }\n\n          // Prevent reserved words\n          if (this.hasOwnProperty(field) && field.toLowerCase() !== 'id') {\n            throw new ReservedWordError(`\"${field}\" cannot be used as a field name (reserved word).`)\n          }\n\n          // If the field config isn't already an NGN.DATA.Field, create it.\n          if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            if (fieldcfg instanceof NGN.DATA.Store || fieldcfg instanceof NGN.DATA.Model) {\n              if (this.METADATA.IdentificationField === field) {\n                throw new InvalidConfigurationError(`\"${field}\" cannot be an ID. Relationship fields cannot be an identification field/attribute.`)\n              }\n\n              this.METADATA.fields[field] = new NGN.DATA.Relationship({\n                name: field,\n                record: fieldcfg,\n                model: this\n              })\n            } else {\n              switch (NGN.typeof(fieldcfg)) {\n                // Custom config\n                case 'object':\n                  fieldcfg.model = this\n                  fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n                  fieldcfg.name = field\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field(fieldcfg)\n\n                  break\n\n                // Collection of models\n                case 'array':\n                  return this.applyField(field, fieldcfg[0], suppressEvents)\n\n                // Type-based cfg.\n                default:\n                  if (NGN.isFn(fieldcfg) || fieldcfg === null) {\n                    if (NGN.isFn(fieldcfg) && ['string', 'number', 'boolean', 'number', 'symbol', 'regexp', 'date', 'array', 'object'].indexOf(NGN.typeof(fieldcfg)) < 0) {\n                      this.METADATA.fields[field] = new NGN.DATA.VirtualField({\n                        name: field,\n                        identifier: this.METADATA.IdentificationField === field,\n                        model: this,\n                        method: fieldcfg\n                      })\n\n                      break\n                    }\n\n                    this.METADATA.fields[field] = new NGN.DATA.Field({\n                      name: field,\n                      type: fieldcfg,\n                      identifier: this.METADATA.IdentificationField === field,\n                      model: this\n                    })\n\n                    break\n                  }\n\n                  this.METADATA.fields[field] = new NGN.DATA.Field({\n                    name: field,\n                    type: NGN.isFn(fieldcfg) ? fieldcfg : String,\n                    identifier: NGN.isFn(fieldcfg)\n                      ? false\n                      : NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field),\n                    model: this\n                  })\n\n                  break\n              }\n            }\n          } else if (fieldcfg.model === null) {\n            fieldcfg.name = field\n            fieldcfg.identifier = fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n            this.METADATA.fields[field].model = this\n          } else if (fieldcfg.model === this) {\n            fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\n\n            this.METADATA.fields[field] = fieldcfg\n          } else if (!(fieldcfg instanceof NGN.DATA.Field)) {\n            return NGN.WARN(`The \"${fieldcfg.name}\" field cannot be applied because model is already specified.`)\n          }\n\n          // Add a direct reference to the model.\n          Object.defineProperty(this, field, {\n            enumerable: true,\n            configurable: true,\n            get: () => this.get(field),\n            set: (value) => this.set(field, value)\n          })\n\n          // Enable auditing if necessary.\n          if (this.METADATA.AUDITABLE) {\n            if (this.METADATA.fields[field].fieldType !== 'virtual') {\n              this.METADATA.fields[field].auditable = true\n              this.METADATA.auditFieldNames.add(field)\n            }\n          }\n\n          // Add the field to the list\n          this.METADATA.knownFieldNames.add(field)\n\n          this.METADATA.fields[field].relay('*', this, 'field.')\n\n          if (!suppressEvents) {\n            this.emit('field.create', this.METADATA.fields[field])\n          }\n\n          return this.METADATA.fields[field]\n        },\n\n        /**\n         * An internal helper method for applying changes to the model.\n         * @param  {String} [type='undo']\n         * This can be `undo` or `redo`.\n         * @param  {Number} [count=1]\n         * The number of cursor indexes to shift\n         * @param  {Boolean} [suppressEvents=false]\n         * Indicates events should be suppressed.\n         * @private\n         */\n        applyChange: (type = 'undo', count = 1, suppressEvents = false) => {\n          if (!this.METADATA.AUDITABLE) {\n            NGN.WARN(`The ${type} operation failed on the ${this.name} model because auditing is disabled.`)\n            return\n          }\n\n          this.METADATA.AUDITLOG[type === 'undo' ? 'rollback' : 'advance'](count)\n\n          let data = this.METADATA.AUDITLOG.currentValue\n\n          if (data) {\n            this.METADATA.auditFieldNames.forEach(fieldname => {\n              let field = this.METADATA.fields[fieldname]\n              let log = field.METADATA.AUDITLOG\n\n              if (log.cursor !== data[fieldname]) {\n                if (typeof data[fieldname] === 'symbol') {\n                  log.cursor = data[fieldname]\n                } else {\n                  log.cursor = null\n                }\n\n                field.METADATA.setValue(NGN.coalesce(log.currentValue, field.default), suppressEvents, true)\n              }\n            })\n          }\n        },\n\n        /**\n         * Generates a key/value representation of the model where\n         * each key represents an auditable field and each value is the\n         * transaction cursor ID.\n         * @return {Object}\n         * @private\n         */\n        getAuditMap: () => {\n          let map = {}\n\n          this.METADATA.auditFieldNames.forEach(field => {\n            map[field] = this.METADATA.fields[field].METADATA.AUDITLOG.cursor\n          })\n\n          return map\n        },\n\n        /**\n         * Restore the model to a specific audit map (i.e. historical state\n         * of multiple fields).\n         * @param {Object} map\n         * The audit map to restore.\n         */\n        // restore: (map) => {\n        //   let keys = Object.keys(map)\n        //\n        //   for (let i = 0; i < keys.length; i++) {\n        //     if (this.METADATA.knownFieldNames.has(keys[i]) && typeof map[keys[i]] === 'symbol') {\n        //       console.log('Has', keys[i])\n        //\n        //     }\n        //   }\n        // },\n\n        // Deprecations\n        setSilent: NGN.deprecate(this.setSilentFieldValue, 'setSilent has been deprecated. Use setSilentFieldValue instead.'),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        DATAMAP: null\n      }),\n\n      MAP: NGN.get(() => {\n        return NGN.coalesce(\n          this.METADATA.DATAMAP,\n          this.METADATA.store instanceof NGN.DATA.Store\n            ? this.METADATA.store.map\n            : null\n        )\n      })\n    })\n\n    if (cfg.fieldmap instanceof NGN.DATA.FieldMap) {\n      this.METADATA.DATAMAP = cfg.fieldmap\n    } else if (NGN.typeof(cfg.fieldmap) === 'object') {\n      this.METADATA.DATAMAP = new NGN.DATA.FieldMap(cfg.fieldmap)\n    }\n\n    // Bubble events to the BUS\n    // this.relay('*', NGN.BUS, 'record.')\n\n    // Add data fields.\n    let fields = Object.keys(this.METADATA.fields)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i]\n\n      if (this.METADATA.knownFieldNames.has(name)) {\n        NGN.WARN(`Duplicate field \"${name}\" detected.`)\n      } else {\n        // Configure a data field for each configuration.\n        this.METADATA.applyField(name, this.METADATA.fields[name], true)\n      }\n    }\n\n    // Apply automatic ID's when applicable\n    if (this.METADATA.autoid) {\n      let autoIdValue = null\n\n      Object.defineProperty(this.METADATA, 'IdentificationValue', NGN.get(() => {\n        if (autoIdValue === null) {\n          autoIdValue = NGN.DATA.UTILITY.UUID()\n        }\n\n        return autoIdValue\n      }))\n    }\n\n    // Apply auditing if configured\n    this.auditable = NGN.coalesce(cfg.audit, false)\n\n    // Clear any cached checksums when the model changes.\n    this.on(['field.update', 'field.create', 'field.delete', 'field.hidden', 'field.unhidden'], () => {\n      if (this.METADATA.checksum) {\n        this.METADATA.checksum = null\n      }\n    })\n\n    // Configure TTL/Expiration\n    if (cfg.expires) {\n      this.expires = cfg.expires\n    }\n\n    // Configure model-level validation rules\n    if (this.METADATA.validators !== null) {\n      switch (NGN.typeof(this.METADATA.validators)) {\n        // Support key/value objects where the key is the name and value is a function.\n        case 'object':\n          let keys = Object.keys(this.METADATA.validators)\n          let rules = []\n\n          for (let i = 0; i < keys.length; i++) {\n            rules.push(new NGN.DATA.Rule(this.METADATA.validators[keys[i]], keys[i], this))\n          }\n\n          break\n\n        // Support an array of existing data rules.\n        case 'array':\n          for (let i = 0; i < this.METADATA.validators.length; i++) {\n            if (this.METADATA.validators[i].hasOwnProperty('RULE')) {\n              this.METADATA.validators[i].RULE.scope = this\n            } else {\n              throw new Error(`Invalid data rule configuration for ${this.name} model. Rule #${i} is not a valid NGN.DATA.Rule instance.`)\n            }\n          }\n\n          break\n\n        // Diasllow any other kinds of rules.\n        default:\n          throw new Error(`Invalid data rule configuration for ${this.name} model. Expected an object or array of NGN.DATA.Rule instances. Received \"${NGN.typeof(this.METADATA.validators)}\"`)\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 16,
            "column": 2
          },
          "end": {
            "line": 520,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg",
              "start": {
                "line": 16,
                "column": 15
              },
              "end": {
                "line": 16,
                "column": 18
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "serializeFields": {
          "type": "method",
          "label": "serializeFields",
          "description": null,
          "code": "serializeFields (ignoreID = false, ignoreVirtualFields = true) {\n    if (this.METADATA.knownFieldNames.size === 0) {\n      return {}\n    }\n\n    let fields = this.METADATA.knownFieldNames.keys()\n    let result = {}\n    let fieldname = fields.next()\n\n    while (!fieldname.done) {\n      let field = this.METADATA.fields[fieldname.value]\n\n      // Ignore unserializable fields\n      if ((\n        field.value === undefined ||\n        (ignoreID && fieldname.value === this.IdentificationField) ||\n        (!field.virtual || (!ignoreVirtualFields && field.virtual))\n      )) {\n        // Do not serialize hidden values or virtuals\n        if (!field.hidden) {\n          switch (NGN.typeof(field.value)) {\n            case 'array':\n            case 'object':\n              result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\n              break\n\n            default:\n              result[fieldname.value] = field.value\n          }\n        }\n      }\n\n      fieldname = fields.next()\n    }\n\n    return result\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 773,
            "column": 2
          },
          "end": {
            "line": 809,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "ignoreID": {
              "type": "argument",
              "label": "ignoreID",
              "description": null,
              "code": "ignoreID = false",
              "start": {
                "line": 773,
                "column": 19
              },
              "end": {
                "line": 773,
                "column": 35
              },
              "flags": [],
              "default": false,
              "datatype": "boolean",
              "required": false,
              "enum": null
            },
            "ignoreVirtualFields": {
              "type": "argument",
              "label": "ignoreVirtualFields",
              "description": null,
              "code": "ignoreVirtualFields = true",
              "start": {
                "line": 773,
                "column": 37
              },
              "end": {
                "line": 773,
                "column": 63
              },
              "flags": [],
              "default": true,
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "serialize": {
          "type": "method",
          "label": "serialize",
          "description": null,
          "code": "serialize () {\n    return NGN.deprecate(this.serializeFields, 'serialize is now serializeFields. Use NGN.DATA.UTILITY.serialize for generic object serialization.')\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 811,
            "column": 2
          },
          "end": {
            "line": 813,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "fieldExists": {
          "type": "method",
          "label": "fieldExists",
          "description": "Determines whether a field exists in the model or not.\n  \n  Name of the field to check for.",
          "code": "fieldExists (field) {\n    return this.METADATA.knownFieldNames.has(field)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 821,
            "column": 2
          },
          "end": {
            "line": 823,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "field": {
              "type": "argument",
              "label": "field",
              "description": "Name of the field to check for.",
              "code": "@param  {string} field\nName of the field to check for.",
              "start": {
                "line": 821,
                "column": 2
              },
              "end": {
                "line": 823,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "boolean",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "get": {
          "type": "method",
          "label": "get",
          "description": "Retrieve the value of the specified field.\n  \n  Name of the field whose value should be returned.\n  \n  Returns the value of the field.",
          "code": "get (field) {\n    if (field === 'id' || field === 'ID' || field === this.METADATA.IdentificationField) {\n      field = this.METADATA.IdentificationField\n\n      if (this.METADATA.autoid) {\n        if (!this.METADATA.knownFieldNames.has(field)) {\n          return this.METADATA.IdentificationValue\n        } else {\n          return NGN.coalesce(this.METADATA.fields[field].value, this.METADATA.IdentificationValue)\n        }\n      }\n    }\n\n    if (this.METADATA.knownFieldNames.has(field)) {\n      return this.METADATA.fields[field].value\n    } else {\n      NGN.WARN(`Cannot get \"${field}\". The field is not part of the model.`)\n      return undefined\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 832,
            "column": 2
          },
          "end": {
            "line": 851,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "field": {
              "type": "argument",
              "label": "field",
              "description": "Name of the field whose value should be returned.",
              "code": "@param  {string} field\nName of the field whose value should be returned.",
              "start": {
                "line": 832,
                "column": 2
              },
              "end": {
                "line": 851,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "any",
          "returnDescription": "null Returns the value of the field.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "set": {
          "type": "method",
          "label": "set",
          "description": "Set a new value for the specified field.\n  \n  Name of the field whose value will be changed.\n  \n  The new value of the field.",
          "code": "set (field, value) {\n    if (field === 'id' || field === 'ID') {\n      field = this.METADATA.IdentificationField\n    }\n\n    if (this.METADATA.knownFieldNames.has(field)) {\n      this.METADATA.fields[field].value = value\n    } else {\n      NGN.WARN(`Cannot set \"${field}\". Unrecognized field name.`)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 860,
            "column": 2
          },
          "end": {
            "line": 870,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "field": {
              "type": "argument",
              "label": "field",
              "description": null,
              "code": "field",
              "start": {
                "line": 860,
                "column": 7
              },
              "end": {
                "line": 860,
                "column": 12
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "value": {
              "type": "argument",
              "label": "value",
              "description": "The new value of the field.",
              "code": "@param {any} value\nThe new value of the field.",
              "start": {
                "line": 860,
                "column": 2
              },
              "end": {
                "line": 870,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "addField": {
          "type": "method",
          "label": "addField",
          "description": "Add a data field after the initial model definition.\n  \n  The name of the field.\n  \n  The field configuration (see cfg#fields for syntax).\n  \n  Set to `true` to prevent events from firing when the field is added.",
          "code": "addField (name, fieldConfiguration = null, suppressEvents = false) {\n    if (name instanceof NGN.DATA.Field) {\n      fieldConfiguration = name\n      name = fieldConfiguration.name\n    } else if (typeof name !== 'string') {\n      throw new Error('Cannot add a non-string based field.')\n    }\n\n    this.METADATA.applyField(name, fieldConfiguration, suppressEvents)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 881,
            "column": 2
          },
          "end": {
            "line": 890,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "name": {
              "type": "argument",
              "label": "name",
              "description": null,
              "code": "name",
              "start": {
                "line": 881,
                "column": 12
              },
              "end": {
                "line": 881,
                "column": 16
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "fieldConfiguration": {
              "type": "argument",
              "label": "fieldname",
              "description": "The name of the field.",
              "code": "fieldConfiguration = null",
              "start": {
                "line": 881,
                "column": 18
              },
              "end": {
                "line": 881,
                "column": 43
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": "Set to `true` to prevent events from firing when the field is added.",
              "code": "@param {boolean} [suppressEvents=false]\nSet to `true` to prevent events from firing when the field is added.",
              "start": {
                "line": 881,
                "column": 2
              },
              "end": {
                "line": 890,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeField": {
          "type": "method",
          "label": "removeField",
          "description": "Remove a field from the data model.",
          "code": "removeField (name, suppressEvents = false) {\n    if (this.METADATA.knownFieldNames.has(name)) {\n      this.METADATA.knownFieldNames.delete(name)\n      this.METADATA.invalidFieldNames.delete(name)\n\n      const field = this.METADATA.fields[name]\n\n      delete this[name]\n      delete this.METADATA.fields[name] // eslint-disable-line no-undef\n\n      // let change = {\n      //   action: 'delete',\n      //   field: field.name,\n      //   value: field,\n      //   join: field instanceof NGN.DATA.Relationship\n      // }\n\n      if (!suppressEvents) {\n        this.emit('field.remove', field)\n      }\n\n      if (this.METADATA.store !== null) {\n        this.METADATA.store.emit(this.METADATA.store.PRIVATE.EVENT.DELETE_RECORD_FIELD, {\n          record: this,\n          field\n        })\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 900,
            "column": 2
          },
          "end": {
            "line": 928,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "name": {
              "type": "argument",
              "label": "name",
              "description": null,
              "code": "name",
              "start": {
                "line": 900,
                "column": 15
              },
              "end": {
                "line": 900,
                "column": 19
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": "Set to `true` to prevent events from firing when the field is removed.",
              "code": "@param {boolean} [suppressEvents=false]\nSet to `true` to prevent events from firing when the field is removed.",
              "start": {
                "line": 900,
                "column": 2
              },
              "end": {
                "line": 928,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getField": {
          "type": "method",
          "label": "getField",
          "description": "Returns the NGN.DATA.Field object for the specified field.\n  \n  Name of the field to retrieve.\n  \n  The raw field.",
          "code": "getField (name) {\n    if (name.toLowerCase() === 'id' && !this.METADATA.fields.hasOwnProperty(name) && this.METADATA.fields.hasOwnProperty(this.METADATA.IdentificationField)) {\n      return this.METADATA.fields[this.METADATA.IdentificationField]\n    }\n\n    return this.METADATA.fields[name]\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 937,
            "column": 2
          },
          "end": {
            "line": 943,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "name": {
              "type": "argument",
              "label": "name",
              "description": null,
              "code": "name",
              "start": {
                "line": 937,
                "column": 12
              },
              "end": {
                "line": 937,
                "column": 16
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "fieldName": {
              "type": "argument",
              "label": "fieldName",
              "description": "Name of the field to retrieve.",
              "code": "@param  {string} fieldName\nName of the field to retrieve.",
              "start": {
                "line": 937,
                "column": 2
              },
              "end": {
                "line": 943,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "NGN.DATA.Field",
          "returnDescription": "null The raw field.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setSilent": {
          "type": "method",
          "label": "setSilent",
          "description": "A method to set a field value without triggering an update event.\nThis is designed primarily for use with live update proxies to prevent\nendless event loops.",
          "code": "setSilentFieldValue (field, value) {\n    this.METADATA.fields[field].silentValue = value\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 956,
            "column": 2
          },
          "end": {
            "line": 958,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "field": {
              "type": "argument",
              "label": "field",
              "description": null,
              "code": "field",
              "start": {
                "line": 956,
                "column": 23
              },
              "end": {
                "line": 956,
                "column": 28
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "value": {
              "type": "argument",
              "label": "value",
              "description": "The new value of the field.",
              "code": "@param {any} value\nThe new value of the field.",
              "start": {
                "line": 956,
                "column": 2
              },
              "end": {
                "line": 958,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "undo": {
          "type": "method",
          "label": "undo",
          "description": "A rollback function to undo changes. This operation affects\nthe changelog . To \"undo\" an \"undo\", use #redo.",
          "code": "undo (count = 1, suppressEvents = false) {\n    this.METADATA.applyChange('undo', ...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 970,
            "column": 2
          },
          "end": {
            "line": 972,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "count": {
              "type": "argument",
              "label": "count",
              "description": null,
              "code": "count = 1",
              "start": {
                "line": 970,
                "column": 8
              },
              "end": {
                "line": 970,
                "column": 17
              },
              "flags": [],
              "default": 1,
              "datatype": "number",
              "required": false,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": "Set to `true` to quietly update the value (prevents `update` event from\nfiring).",
              "code": "@param {boolean} [suppressEvents=false]\nSet to `true` to quietly update the value (prevents `update` event from\nfiring).",
              "start": {
                "line": 970,
                "column": 2
              },
              "end": {
                "line": 972,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "redo": {
          "type": "method",
          "label": "redo",
          "description": "A function to reapply known changes. This operation affects\nthe changelog .\n\nThe redo operation only works after an undo operation, but before a new\nvalue is committed to the transaction log. In other words, `undo -> redo`\nwill work, but `undo -> update -> redo` will not. For details, see how\nthe NGN.DATA.TransactionLog cursor system works.",
          "code": "redo (count = 1, suppressEvents = false) {\n    this.METADATA.applyChange('redo', ...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 989,
            "column": 2
          },
          "end": {
            "line": 991,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "count": {
              "type": "argument",
              "label": "count",
              "description": null,
              "code": "count = 1",
              "start": {
                "line": 989,
                "column": 8
              },
              "end": {
                "line": 989,
                "column": 17
              },
              "flags": [],
              "default": 1,
              "datatype": "number",
              "required": false,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": "Set to `true` to quietly update the value (prevents `update` event from\nfiring).",
              "code": "@param {boolean} [suppressEvents=false]\nSet to `true` to quietly update the value (prevents `update` event from\nfiring).",
              "start": {
                "line": 989,
                "column": 2
              },
              "end": {
                "line": 991,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "load": {
          "type": "method",
          "label": "load",
          "description": "Load a data record.",
          "code": "load (data, suppressEvents = false) {\n    if (this.MAP) {\n      data = this.MAP.applyMap(data)\n    }\n\n    let keys = Object.keys(data)\n\n    for (let i = 0; i < keys.length; i++) {\n      if (this.METADATA.knownFieldNames.has(keys[i])) {\n        this.METADATA.fields[keys[i]].METADATA.setValue(data[keys[i]], suppressEvents)\n      } else {\n        NGN.WARN(`Failed to load ${keys[i]} field of ${this.name} model. \"${keys[i]}\" is not a recognized field.`)\n      }\n    }\n\n    if (!suppressEvents) {\n      this.emit('load')\n    }\n\n    return this\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1001,
            "column": 2
          },
          "end": {
            "line": 1021,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "data": {
              "type": "argument",
              "label": "data",
              "description": null,
              "code": "data",
              "start": {
                "line": 1001,
                "column": 8
              },
              "end": {
                "line": 1001,
                "column": 12
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": "Do not emit a change event when the data is loaded.",
              "code": "@param {boolean} [suppressEvents=false]\nDo not emit a change event when the data is loaded.",
              "start": {
                "line": 1001,
                "column": 2
              },
              "end": {
                "line": 1021,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "next": {
          "type": "method",
          "label": "next",
          "description": "called on a model that is not part of a store, the model itself will be\n  returned.\n    Retrieve the next record (after this one) from the store.\n  This can be used to iterate through a store by calling `model.next()`.\n  This is operation acts as a linked list iterator.\n  \n  The number of records to retrieve. For example, `1` retrieves the next record.\n  `2` retrieves the second record after this one. A negative number will\n  automatically use the #previous method to retrieve prior records. Setting this\n  to `0` will return the current record (i.e. no change).\n  \n  If this `next` is called on the last record, it will fail. Setting `cycle` to\n  `true` will automatically restart the iteration, returning the first record in\n  the store.\n  \n  Returns the next model in the store (after this one.)",
          "code": "next (count = 1, cycle = false) {\n    if (count === 0) {\n      return this\n    }\n\n    if (this.METADATA.store) {\n      if (typeof count === 'boolean') {\n        cycle = count\n        count = 1\n      }\n\n      return this.METADATA.store.getRecordSibling(this, count, cycle)\n    } else {\n      NGN.WARN('Attempted to call next() on a model that does not belong to a store.')\n      return this\n    }\n  }",
          "tags": {
            "info": {
              "tag": "info",
              "name": "This",
              "optional": false,
              "description": "method only works on records within a store. If this method is\ncalled on a model that is not part of a store, the model itself will be\nreturned.\n\nRetrieve the next record  from the store.\nThis can be used to iterate through a store by calling `model.next()`.\nThis is operation acts as a linked list iterator.",
              "type": "",
              "line": 1,
              "source": "@info This method only works on records within a store. If this method is\ncalled on a model that is not part of a store, the model itself will be\nreturned.\n\nRetrieve the next record (after this one) from the store.\nThis can be used to iterate through a store by calling `model.next()`.\nThis is operation acts as a linked list iterator.",
              "options": [
                "after this one"
              ]
            }
          },
          "exceptions": {},
          "start": {
            "line": 1043,
            "column": 2
          },
          "end": {
            "line": 1059,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "count": {
              "type": "argument",
              "label": "count",
              "description": null,
              "code": "count = 1",
              "start": {
                "line": 1043,
                "column": 8
              },
              "end": {
                "line": 1043,
                "column": 17
              },
              "flags": [],
              "default": 1,
              "datatype": "number",
              "required": false,
              "enum": null
            },
            "cycle": {
              "type": "argument",
              "label": "cycle",
              "description": "[description]\nIf this `next` is called on the last record, it will fail. Setting `cycle` to\n`true` will automatically restart the iteration, returning the first record in\nthe store.",
              "code": "@param  {Boolean}  [cycle=false] [description]\nIf this `next` is called on the last record, it will fail. Setting `cycle` to\n`true` will automatically restart the iteration, returning the first record in\nthe store.",
              "start": {
                "line": 1043,
                "column": 2
              },
              "end": {
                "line": 1059,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "NGN.DATA.Model",
          "returnDescription": "null Returns the next model in the store",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "previous": {
          "type": "method",
          "label": "previous",
          "description": "Retrieve the previous record (before this one) from the store.\n  This can be used to iterate through a store in reverse by calling\n  `model.previous()`. This is operation acts as a doubly linked list iterator.\n    \n  called on a model that is not part of a store, the model itself will be\n  returned.\n  \n  The number of records to retrieve. For example, `1` retrieves the prior record.\n  `2` retrieves the second record before this one. A negative number will\n  automatically use the #next method to retrieve forward records. Setting this\n  to `0` will return the current record (i.e. no change).\n  \n  If this `next` is called on the first record, it will fail. Setting `cycle` to\n  `true` will automatically restart the iteration, returning the last record in\n  the store.\n  \n  Returns the previous model in the store (before this one.)",
          "code": "previous (count = 1, cycle = false) {\n    if (count === 0) {\n      return this\n    }\n\n    if (this.METADATA.store) {\n      if (typeof count === 'boolean') {\n        cycle = count\n        count = 1\n      }\n\n      return this.METADATA.store.getRecordSibling(this, 0 - count, cycle)\n    } else {\n      NGN.WARN('Attempted to call previous() on a model that does not belong to a store.')\n      return this\n    }\n  }",
          "tags": {
            "info": {
              "tag": "info",
              "name": "This",
              "optional": false,
              "description": "method only works on records within a store. If this method is\ncalled on a model that is not part of a store, the model itself will be\nreturned.",
              "type": "",
              "line": 5,
              "source": "@info This method only works on records within a store. If this method is\ncalled on a model that is not part of a store, the model itself will be\nreturned.",
              "options": null
            }
          },
          "exceptions": {},
          "start": {
            "line": 1081,
            "column": 2
          },
          "end": {
            "line": 1097,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "count": {
              "type": "argument",
              "label": "count",
              "description": null,
              "code": "count = 1",
              "start": {
                "line": 1081,
                "column": 12
              },
              "end": {
                "line": 1081,
                "column": 21
              },
              "flags": [],
              "default": 1,
              "datatype": "number",
              "required": false,
              "enum": null
            },
            "cycle": {
              "type": "argument",
              "label": "cycle",
              "description": "[description]\nIf this `next` is called on the first record, it will fail. Setting `cycle` to\n`true` will automatically restart the iteration, returning the last record in\nthe store.",
              "code": "@param  {Boolean}  [cycle=false] [description]\nIf this `next` is called on the first record, it will fail. Setting `cycle` to\n`true` will automatically restart the iteration, returning the last record in\nthe store.",
              "start": {
                "line": 1081,
                "column": 2
              },
              "end": {
                "line": 1097,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "NGN.DATA.Model",
          "returnDescription": "null Returns the previous model in the store",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "destroy": {
          "type": "method",
          "label": "destroy",
          "description": "Remove this model from the NGN.DATA.Store it is a part of.\n    \n  called on a model that is not part of a store, nothing will happen.",
          "code": "destroy () {\n    if (this.METADATA.store) {\n      this.METADATA.store.remove(this.OID)\n    } else {\n      NGN.WARN('Attempted to call remove() on a model that does not belong to a store.')\n    }\n  }",
          "tags": {
            "info": {
              "tag": "info",
              "name": "This",
              "optional": false,
              "description": "method only works on records within a store. If this method is\ncalled on a model that is not part of a store, nothing will happen.",
              "type": "",
              "line": 3,
              "source": "@info This method only works on records within a store. If this method is\ncalled on a model that is not part of a store, nothing will happen.",
              "options": null
            }
          },
          "exceptions": {},
          "start": {
            "line": 1105,
            "column": 2
          },
          "end": {
            "line": 1111,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "hash": {
          "type": "method",
          "label": "hash",
          "description": "The hash part of the URL .",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setHeader": {
          "type": "method",
          "label": "setHeader",
          "description": "Add a header to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getHeader": {
          "type": "method",
          "label": "getHeader",
          "description": "",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeHeader": {
          "type": "method",
          "label": "removeHeader",
          "description": "Removes a header from the request. Nothing happens if the header does\nnot exist.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setQueryParameter": {
          "type": "method",
          "label": "setQueryParameter",
          "description": "Add a query parameter to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeQueryParameter": {
          "type": "method",
          "label": "removeQueryParameter",
          "description": "Remove a query parameter from the request URI.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "send": {
          "type": "method",
          "label": "send",
          "description": "Send the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.Representation": {
      "type": "class",
      "label": "NGN.DATA.Representation",
      "description": "This is a test",
      "code": "// [PARTIAL]\n\n/**\n * @class NGN.DATA.Representation\n * A data representation is a customized view of a model or\n * a store. Representations exist to format data from a model\n * or store in a manner suitable for a particular purpose.\n *\n * For example, a representation may need to calculate data\n * attributes differently for different purposes, such as API\n * output for a system or a website. Many API's utilize an `href`\n * data attribute that contains the base URL of the server plus\n * the ID of a model. The URL may only be known at runtime, making\n * it difficult to represent this attribute as a generic virtual\n * field.\n *\n * Representations can also be used to change the format entirely,\n * such as outputting data as XML instead of JSON.\n */\nclass NGNDataRepresentation extends NGN.EventEmitter { // eslint-disable-line\n  /**\n   * @method constructor\n   * Create a new representation\n   * @param {Object} [cfg={}]\n   * The config contains stuff.\n   * @param {Boolean} [bb=true] (test,blah)\n   * das boolean\n   * @fires {Object,test:String} eventguy\n   * This is a strange name for an event.\n   * @fires {String|Object} blerg\n   * This is a strange name for an event.\n   * @todo This buds for you\n   * @todo This turd's for you\n   * @todo This buds for you too\n   * @todo This turd's for you two\n   */\n  constructor (cfg) {\n    super()\n\n    this.blahblah = true\n\n    Object.defineProperties(this, {\n      /**\n       * @cfgproperty\n       * X is a config value\n       */\n      x: NGN.public(true),\n      /**\n       * @property {boolean} nanananan\n       * Batman!\n       */\n      y: NGN.define(true, false, false, 'test'),\n\n      o: {\n        enumerable: false,\n        writable: true,\n        configurable: false,\n        value: 'obj'\n      }\n    })\n\n    /**\n     * @property {number} doesnotexist\n     * This is a test\n     */\n    Object.defineProperty(this, {\n      /**\n       * @property {boolean} hot\n       * dog\n       */\n      z: NGN.define(true, false, false, 'another test')\n    })\n\n    return 1\n  }\n\n  get mofo () {\n    return false\n  }\n\n  /**\n   * anotherFn description\n   * @param {function} callback\n   * This is an example callback.\n   * @param {boolean} callback.a\n   * The first element is a.\n   * @param {boolean} callback.b (possible,values)\n   * The next element is b.\n   * @param somethingswonderful\n   * something else\n   */\n  anotherFn () {\n    this.emit('blerg', {some: 'value'})\nlet x = 'test'\n    this.delayEmit('ablergy', 200, x)\nNGN.BUS.emit('yo')\n    this.emit(Symbol('test'), x)\n\n\n    this.funnel(['a', 'b', 'c'], 'd')\n    this.threshold('d', 3, 'THOLD', {blah: 1})\n\n    this.deprecate('nomore', 'blerg')\n    return\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "eventguy": {
          "type": "event",
          "label": "eventguy",
          "description": "This is a strange name for an event.",
          "code": "@fires {Object,test:String} eventguy\nThis is a strange name for an event.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "object",
              "required": false,
              "enum": null
            },
            "test": {
              "type": "argument",
              "label": "test",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "string",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "blerg": {
          "type": "event",
          "label": "blerg",
          "description": "Replacement for nomore",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {},
          "deprecated": false,
          "deprecationReplacement": null
        },
        "ablergy": {
          "type": "event",
          "label": "ablergy",
          "description": "Event triggered after 200 milliseconds.",
          "code": "this.delayEmit('ablergy', 200, x)",
          "start": {
            "line": 95,
            "column": 4
          },
          "end": {
            "line": 95,
            "column": 37
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": "200",
              "start": {
                "line": 95,
                "column": 30
              },
              "end": {
                "line": 95,
                "column": 33
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "x": {
              "type": "argument",
              "label": "x",
              "description": null,
              "code": "x",
              "start": {
                "line": 95,
                "column": 35
              },
              "end": {
                "line": 95,
                "column": 36
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "d": {
          "type": "event",
          "label": "d",
          "description": null,
          "code": "this.funnel(['a', 'b', 'c'], 'd')",
          "start": {
            "line": 100,
            "column": 4
          },
          "end": {
            "line": 100,
            "column": 37
          },
          "flags": [],
          "parameters": {},
          "deprecated": false,
          "deprecationReplacement": null
        },
        "THOLD": {
          "type": "event",
          "label": "THOLD",
          "description": "Triggered after `d` is fired 3 times.",
          "code": "this.threshold('d', 3, 'THOLD', {blah: 1})",
          "start": {
            "line": 101,
            "column": 4
          },
          "end": {
            "line": 101,
            "column": 46
          },
          "flags": [],
          "parameters": {
            "payload2": {
              "type": "argument",
              "label": "payload2",
              "description": null,
              "code": "{blah: 1}",
              "start": {
                "line": 101,
                "column": 36
              },
              "end": {
                "line": 101,
                "column": 45
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "nomore": {
          "type": "event",
          "label": "nomore",
          "description": null,
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {},
          "deprecated": true,
          "deprecationReplacement": "blerg"
        }
      },
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 106,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/Representation.js",
      "extends": "NGN.EventEmitter",
      "configuration": {
        "x": {
          "type": "property",
          "label": "x",
          "description": "X is a config value",
          "code": "x: NGN.public(true)",
          "start": {
            "line": 47,
            "column": 6
          },
          "end": {
            "line": 47,
            "column": 25
          },
          "flags": [],
          "default": null,
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        }
      },
      "properties": {
        "blahblah": {
          "type": "property",
          "label": "blahblah",
          "description": null,
          "code": "this.blahblah = true",
          "start": {
            "line": 40,
            "column": 9
          },
          "end": {
            "line": 40,
            "column": 17
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "x": {
          "type": "property",
          "label": "x",
          "description": "X is a config value",
          "code": "x: NGN.public(true)",
          "start": {
            "line": 47,
            "column": 6
          },
          "end": {
            "line": 47,
            "column": 25
          },
          "flags": [],
          "default": null,
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        },
        "nanananan": {
          "type": "property",
          "label": "nanananan",
          "description": "Batman!",
          "code": "y: NGN.define(true, false, false, 'test')",
          "start": {
            "line": 52,
            "column": 6
          },
          "end": {
            "line": 52,
            "column": 47
          },
          "flags": [],
          "default": null,
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "o": {
          "type": "property",
          "label": "o",
          "description": null,
          "code": "o: {\n        enumerable: false,\n        writable: true,\n        configurable: false,\n        value: 'obj'\n      }",
          "start": {
            "line": 54,
            "column": 6
          },
          "end": {
            "line": 59,
            "column": 7
          },
          "flags": [],
          "default": "obj",
          "datatype": "string",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "hot": {
          "type": "property",
          "label": "hot",
          "description": "dog",
          "code": "z: NGN.define(true, false, false, 'another test')",
          "start": {
            "line": 71,
            "column": 6
          },
          "end": {
            "line": 71,
            "column": 55
          },
          "flags": [],
          "default": null,
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "mofo": {
          "type": "property",
          "label": "mofo",
          "description": null,
          "code": "get mofo () {\n    return false\n  }",
          "start": {
            "line": 77,
            "column": 2
          },
          "end": {
            "line": 79,
            "column": 3
          },
          "flags": [],
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "Create a new representation",
          "code": "constructor (cfg) {\n    super()\n\n    this.blahblah = true\n\n    Object.defineProperties(this, {\n      /**\n       * @cfgproperty\n       * X is a config value\n       */\n      x: NGN.public(true),\n      /**\n       * @property {boolean} nanananan\n       * Batman!\n       */\n      y: NGN.define(true, false, false, 'test'),\n\n      o: {\n        enumerable: false,\n        writable: true,\n        configurable: false,\n        value: 'obj'\n      }\n    })\n\n    /**\n     * @property {number} doesnotexist\n     * This is a test\n     */\n    Object.defineProperty(this, {\n      /**\n       * @property {boolean} hot\n       * dog\n       */\n      z: NGN.define(true, false, false, 'another test')\n    })\n\n    return 1\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 37,
            "column": 2
          },
          "end": {
            "line": 75,
            "column": 3
          },
          "flags": [],
          "todo": [
            "This buds for you",
            "This turd's for you",
            "This buds for you too",
            "This turd's for you two"
          ],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": "The config contains stuff.",
              "code": "@param {Object} [cfg={}]\nThe config contains stuff.",
              "start": {
                "line": 37,
                "column": 2
              },
              "end": {
                "line": 75,
                "column": 3
              },
              "flags": [],
              "default": "{}",
              "datatype": "object",
              "required": false,
              "enum": null
            },
            "bb": {
              "type": "argument",
              "label": "bb",
              "description": "das boolean",
              "code": "@param {Boolean} [bb=true] (test,blah)\ndas boolean",
              "start": {
                "line": 37,
                "column": 2
              },
              "end": {
                "line": 75,
                "column": 3
              },
              "flags": [],
              "default": "true",
              "datatype": "boolean",
              "required": false,
              "enum": [
                "test",
                "blah"
              ]
            }
          },
          "returnType": "number",
          "returnDescription": "",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "anotherFn": {
          "type": "method",
          "label": "anotherFn",
          "description": "anotherFn description\n  \n  This is an example callback.\n  \n  The first element is a.\n  \n  The next element is b.\n  \n  something else",
          "code": "anotherFn () {\n    this.emit('blerg', {some: 'value'})\nlet x = 'test'\n    this.delayEmit('ablergy', 200, x)\nNGN.BUS.emit('yo')\n    this.emit(Symbol('test'), x)\n\n\n    this.funnel(['a', 'b', 'c'], 'd')\n    this.threshold('d', 3, 'THOLD', {blah: 1})\n\n    this.deprecate('nomore', 'blerg')\n    return\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 92,
            "column": 2
          },
          "end": {
            "line": 105,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "This is an example callback.",
              "code": "@param {function} callback\nThis is an example callback.",
              "start": {
                "line": 92,
                "column": 2
              },
              "end": {
                "line": 105,
                "column": 3
              },
              "flags": [],
              "arguments": {
                "a": {
                  "type": "argument",
                  "label": "a",
                  "description": "The first element is a.",
                  "code": "@param {boolean} callback.a\nThe first element is a.",
                  "start": {
                    "line": 92,
                    "column": 2
                  },
                  "end": {
                    "line": 105,
                    "column": 3
                  },
                  "flags": [],
                  "default": null,
                  "datatype": "boolean",
                  "required": true,
                  "enum": null
                },
                "b": {
                  "type": "argument",
                  "label": "b",
                  "description": "The next element is b.",
                  "code": "@param {boolean} callback.b (possible,values)\nThe next element is b.",
                  "start": {
                    "line": 92,
                    "column": 2
                  },
                  "end": {
                    "line": 105,
                    "column": 3
                  },
                  "flags": [],
                  "default": null,
                  "datatype": "boolean",
                  "required": true,
                  "enum": [
                    "possible",
                    "values"
                  ]
                }
              },
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            },
            "somethingswonderful": {
              "type": "argument",
              "label": "somethingswonderful",
              "description": "something else",
              "code": "@param somethingswonderful\nsomething else",
              "start": {
                "line": 92,
                "column": 2
              },
              "end": {
                "line": 105,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.Store": {
      "type": "class",
      "label": "NGN.DATA.Store",
      "description": "An array of the field names for which the store maintains indexes.",
      "code": "class NGNDataStore extends EventEmitter { // eslint-disable-line\n  constructor (cfg = {}) {\n    if (NGN.typeof(cfg) === 'model') {\n      cfg = { model: cfg }\n    } else if (!cfg.model || NGN.typeof(cfg.model) !== 'model') {\n      throw new InvalidConfigurationError('Missing or invalid \"model\" configuration property.')\n    }\n\n    super()\n\n    const me = this\n\n    Object.defineProperties(this, {\n      /**\n       * @cfgproperty {string} [name]\n       * A descriptive name for the store. This is typically used for\n       * debugging, logging, and (somtimes) data proxies.\n       */\n      name: NGN.const(NGN.coalesce(cfg.name, 'Untitled Data Store')),\n\n      METADATA: NGN.private({\n        // Holds the models/records\n        records: [],\n\n        /**\n         * @cfgproperty {NGN.DATA.Model} model\n         * An NGN Data Model to which data records conform.\n         */\n        Model: NGN.coalesce(cfg.model),\n\n        /**\n         * @cfg {boolean} [allowDuplicates=true]\n         * Set to `false` to prevent duplicate records from being added.\n         * If a duplicate record is added, it will be ignored and an\n         * error will be thrown.\n         *\n         * **Identifying duplicates _may_ be slow** on data sets with 200+ records.\n         * Uniqueness is determined by a checksum of the current NGN.DATA.Model#data\n         * of a record. The amount of time required to generate a checksum can range\n         * from 3ms to 150ms per record depending on data complexity.\n         *\n         * In most scenarios, the performance impact will be negligible/indistinguishable\n         * to the naked eye. However; if an application experiences slow data\n         * load or processing times, setting this to `false` may help.\n         */\n        allowDuplicates: NGN.coalesce(cfg.allowDuplicates, true),\n\n        /**\n         * @cfg {boolean} [errorOnDuplicate=false]\n         * Set to `true` to throw an error when a duplicate record is detected.\n         * If this is not set, it will default to the value of #allowDuplicates.\n         * If #allowDuplicates is not defined either, this will be `true`\n         */\n        errorOnDuplicate: NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, false),\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * Allow invalid records to be added to the store.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {boolean} [errorOnInvalid=false]\n         * Set to `true` to throw an error when an attempt is made to add an\n         * invalid record.\n         */\n        errorOnInvalid: NGN.coalesce(cfg.errorOnInvalid, cfg.allowInvalid, false),\n\n        /**\n         * @cfgproperty {boolean} [autoRemoveExpiredRecords=true]\n         * When set to `true`, the store will automatically delete expired records.\n         */\n        autoRemoveExpiredRecords: NGN.coalesce(cfg.autoRemoveExpiredRecords, true),\n\n        /**\n         * @cfg {boolean} [softDelete=false]\n         * When set to `true`, the store makes a copy of a record before removing\n         * it from the store. The store will still emit a `record.delete` event,\n         * and it will still behanve as though the record has been completely\n         * removed. However; the record copy can be retrieved using the #restore\n         * method.\n         *\n         * Since it is not always desirable to store a copy of every deleted\n         * record indefinitely, it is possible to expire and permanently remove\n         * records by setting the #softDeleteTtl.\n         *\n         * ```js\n         * var People = new NGN.DATA.Store({\n         *   model: Person,\n         *   softDelete: true,\n         *   softDeleteTtl: 10000\n         * })\n         *\n         * People.add(somePerson)\n         *\n         * var removedRecordId\n         * People.once('record.delete', function (record) {\n         *   removedRecordId = record.id\n         * })\n         *\n         * People.remove(somePerson)\n         *\n         * setTimeout(function () {\n         *   People.restore(removedRecordId)\n         * }, 5000)\n         *\n         * ```\n         *\n         * The code above creates a new store and adds a person to it.\n         * Then a placeholder variable (`removedRecordId`) is created.\n         * Next, a one-time event listener is added to the store, specifically\n         * for handling the removal of a record. Then the record is removed,\n         * which triggers the `record.delete` event, which populates\n         * `removedRecordId` with the ID of the record that was deleted.\n         * Finally, the code waits for 5 seconds, then restores the record. If\n         * the #restore method _wasn't_ called, the record would be purged\n         * from memory after 10 seconds (because `softDeleteTtl` is set to 10000\n         * milliseconds).\n         */\n        softDelete: NGN.coalesce(cfg.softDelete, false),\n\n        /**\n         * @cfg {number} [softDeleteTtl=-1]\n         * This is the number of milliseconds the store waits before purging a\n         * soft-deleted record from memory. `-1` = Infinite (no TTL).\n         */\n        softDeleteTtl: NGN.coalesce(cfg.softDeleteTtl, -1),\n\n        // ARCHIVE contains soft deleted records\n\n        /**\n         * @cfg {Number} [FIFO=-1]\n         * Configures the store to use \"**F**irst **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the oldest record (i.e. the 1st). This guarantees the\n         * store will never have more than 10 records at any given time and it\n         * will always maintain the latest records.\n         *\n         * FIFO and LIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. FIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        fifo: NGN.coalesce(cfg.FIFO, -1),\n\n        /**\n         * @cfg {Number} [LIFO=-1]\n         * Configures the store to use \"**L**ast **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * This methos acts in the opposite manner as #FIFO. However; for\n         * all intents and purposes, this merely replaces the last record in\n         * the store when a new record is added.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the latest record (i.e. the 10th). This guarantees the\n         * store will never have more than 10 records at any given time. Every\n         * time a new record is added (assuming the store already has the maximum\n         * allowable records), it replaces the last record (10th) with the new\n         * record.\n         *\n         * LIFO and FIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. LIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        lifo: NGN.coalesce(cfg.LIFO, -1),\n\n        /**\n         * @cfg {Number} [maxRecords=-1]\n         * Setting this will prevent new records from being added past this limit.\n         * Attempting to add a record to the store beyond it's maximum will throw\n         * an error.\n         */\n        maxRecords: NGN.coalesce(cfg.maxRecords, -1),\n\n        /**\n         * @cfg {Number} [minRecords=0]\n         * Setting this will prevent removal of records if the removal would\n         * decrease the count below this limit.\n         * Attempting to remove a record below the store's minimum will throw\n         * an error.\n         */\n        minRecords: NGN.coalesce(cfg.minRecords, 0),\n\n        /**\n         * @cfg {Number} [autocompact=50000]\n         * Identify the number of deletions that should occur before\n         * the store is compacted. See #compact. Set this to any value\n         * below `100` (the minimum) to disable autocompact.\n         */\n        autocompact: NGN.coalesce(cfg.autocompact, 50000),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        MAP: NGN.coalesce(cfg.fieldmap),\n\n        EVENTS: new Set([\n          'record.duplicate',\n          'record.create',\n          'record.update',\n          'record.delete',\n          'record.restored',\n          'record.purged',\n          'record.move',\n          'record.invalid',\n          'record.valid',\n          'clear',\n          'filter.create',\n          'filter.delete',\n          'index.create',\n          'index.delete',\n          'compact.start',\n          'compact.complete'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: (change) => {\n          if (change.hasOwnProperty('cursor')) {\n            this.METADATA.AUDITLOG.commit(this.METADATA.getAuditMap())\n          }\n        },\n\n        // The first and last indexes are maintained to determine which active\n        // record is considered first/last. Sometimes data is filtered out,\n        // so the first/last active record is not guaranteed to represent the\n        // first/last actual record. These indexes are maintained to prevent\n        // unnecessary iteration in large data sets.\n        FIRSTRECORDINDEX: 0,\n        LASTRECORDINDEX: 0,\n\n        /**\n         * @cfg {array} [index]\n         * An array of #model fields that will be indexed.\n         * See NGN.DATA.Index for details.\n         */\n        INDEX: null\n      }),\n\n      // Internal attributes that should not be extended.\n      PRIVATE: NGN.privateconst({\n        STUB: Symbol('record.stub'),\n\n        // A private indexing method\n        INDEX: function (record, delta) {\n          if (typeof this.event === 'symbol') {\n            switch (this.event) {\n              case me.PRIVATE.EVENT.CREATE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(record[field], record.OID))\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].remove(record.OID, record[field]))\n                break\n\n              case me.PRIVATE.EVENT.LOAD_RECORDS:\n                for (let i = 0; i < me.METADATA.records.length; i++) {\n                  me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(me.METADATA.records[i][field], me.METADATA.records[i].OID))\n                }\n\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD_FIELD:\n                if (me.METADATA.INDEXFIELDS.has(record.field.name)) {\n                  me.METADATA.INDEX[record.field.name].remove(record.record.OID, record.field.value)\n                }\n\n                break\n            }\n          } else {\n            switch (this.event) {\n              case 'record.update':\n                if (me.METADATA.INDEXFIELDS.has(delta.field.name)) {\n                  me.METADATA.INDEX[delta.field.name].update(record.OID, delta.old, delta.new)\n                }\n                break\n\n              case 'clear':\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].reset())\n                break\n            }\n          }\n        },\n\n        // Contains a map of all records\n        RECORDMAP: new Map(),\n\n        // A reference to active records\n        ACTIVERECORDMAP: null,\n\n        // A reference to filtered records (non-active/non-deleted)\n        FILTEREDRECORDMAP: null,\n\n        // Internal events\n        EVENT: {\n          CREATE_RECORD: Symbol('record.create'),\n          DELETE_RECORD: Symbol('record.delete'),\n          DELETE_RECORD_FIELD: Symbol('records.field.delete'),\n          LOAD_RECORDS: Symbol('records.load')\n        },\n\n        // Makes sure the model configuration specifies a valid and indexable field.\n        checkModelIndexField: (field) => {\n          let metaconfig = this.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields && metaconfig.fields.hasOwnProperty(field)) {\n            if (metaconfig.fields[field] !== null) {\n              if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(metaconfig.fields[field])) >= 0) {\n                throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n              } else if (NGN.typeof(metaconfig.fields[field]) === 'object') {\n                if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(NGN.coalesce(metaconfig.fields[field].type))) >= 0) {\n                  throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n                }\n              }\n            }\n          } else {\n            throw new Error(`Cannot create index for unrecognized field \"${field}\".`)\n          }\n        },\n\n        // Get the type of field from the model definition\n        getModelFieldType: (field) => {\n          let metaconfig = this.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields[field] === null) {\n            return NGN.typeof(metaconfig.fields[field])\n          }\n\n          if (metaconfig.fields[field].type) {\n            return NGN.typeof(metaconfig.fields[field].type)\n          }\n\n          if (metaconfig.fields[field].default) {\n            return NGN.typeof(metaconfig.fields[field].default)\n          }\n\n          return NGN.typeof(NGN.coalesce(metaconfig.fields[field]))\n        },\n\n        // Add a record\n        addRecord: (data, suppressEvents = false) => {\n          const record = new me.METADATA.Model(data)\n\n          if (!(record instanceof NGN.DATA.Entity)) {\n            throw new Error(`Only a NGN.DATA.Model or JSON object may be used in NGN.DATA.Store#add. Received a \"${NGN.typeof(data)}\" value.`)\n          }\n\n          // Prevent invalid record addition (if configured)\n          if (!me.METADATA.allowInvalid && !record.valid) {\n            NGN.WARN(`An attempt to add invalid data to the \"${this.name}\" store was prevented. The following fields are invalid: ${Array.from(record.METADATA.invalidFieldNames.keys()).join(', ')}`)\n\n            if (!suppressEvents) {\n              this.emit('record.invalid', record)\n            }\n\n            if (this.METADATA.errorOnInvalid) {\n              throw new Error(`Invalid data cannot be added to the \"${this.name}\" store.`)\n            }\n          }\n\n          // If duplicates are prevented, check the new data.\n          if (!me.METADATA.allowDuplicates) {\n            for (let i = 0; i < this.METADATA.records.length; i++) {\n              if (this.METADATA.records[i].checksum === record.checksum) {\n                NGN.WARN(`An attempt to add a duplicate record to the \"${this.name}\" store was prevented.`)\n\n                if (!suppressEvents) {\n                  this.emit('record.duplicate', record)\n                }\n\n                if (this.METADATA.errorOnDuplicate) {\n                  throw new Error(`Duplicate records are not allowed in the \"${this.name}\" data store.`)\n                }\n\n                break\n              }\n            }\n          }\n\n          // Handle special record count processing (LIFO/FIFO support)\n          if (me.METADATA.lifo > 0 && me.METADATA.records.length + 1 > me.METADATA.lifo) {\n            me.remove(me.METADATA.records.length - 1, suppressEvents)\n          } else if (this.METADATA.fifo > 0 && me.METADATA.records.length + 1 > me.METADATA.fifo) {\n            me.remove(0, suppressEvents)\n          }\n\n          // Relay model events to this store.\n          // record.relay('*', this, 'record.')\n          record.on('*', function () {\n            switch (this.event) {\n              // case 'field.update':\n              // case 'field.delete':\n              //   // TODO: Update indices\n              //   return\n\n              case 'field.invalid':\n              case 'field.valid':\n                return me.emit(this.event.replace('field.', 'record.'), record)\n\n              case 'expired':\n                // TODO: Handle expiration\n            }\n          })\n\n          delete record.METADATA.store\n          Object.defineProperty(record.METADATA, 'store', NGN.get(() => me))\n\n          // Indexing is handled in an internal event handler\n          me.METADATA.records.push(record)\n\n          // Add the record to the map for efficient retrievel by OID\n          me.PRIVATE.RECORDMAP.set(record.OID, me.METADATA.records.length - 1)\n\n          return record\n        },\n\n        convertStubToRecord: (index, record) => {\n          if (record.hasOwnProperty(this.PRIVATE.STUB)) {\n            let newRecord = this.PRIVATE.addRecord(record.metadata, false)\n            newRecord.OID = record.OID\n\n            this.METADATA.records[index] = newRecord\n\n            return newRecord\n          } else {\n            return record\n          }\n        }\n      }),\n\n      // Create a convenience alias for the remove method.\n      delete: NGN.const(NGN.deprecate(this.remove, 'Store.delete is deprecated. Use Store.remove instead.'))\n    })\n\n    // Create a smart reference to record lists\n    Object.defineProperties(this.PRIVATE, {\n      ACTIVERECORDS: NGN.get(() => {\n        if (this.PRIVATE.ACTIVERECORDMAP === null) {\n          return this.PRIVATE.RECORDMAP\n        }\n\n        return this.PRIVATE.ACTIVERECORDMAP\n      }),\n\n      FILTEREDRECORDS: NGN.get(() => {\n        if (this.PRIVATE.FILTEREDRECORDMAP === null) {\n          return this.PRIVATE.RECORDMAP\n        }\n\n        return this.PRIVATE.FILTEREDRECORDMAP\n      })\n    })\n\n    // Disallow modification of internal events\n    Object.freeze(this.PRIVATE.EVENT)\n\n    // Support LIFO (Last In First Out) & FIFO(First In First Out)\n    if (this.METADATA.lifo > 0 && this.METADATA.fifo > 0) {\n      throw new InvalidConfigurationError('NGN.DATA.Store can be configured to use FIFO or LIFO, but not both simultaneously.')\n    }\n\n    // If LIFO/FIFO is used, disable alternative record count limitations.\n    if (this.METADATA.lifo > 0 || this.METADATA.fifo > 0) {\n      this.METADATA.minRecords = 0\n      this.METADATA.maxRecords = -1\n    } else {\n      this.METADATA.minRecords = this.METADATA.minRecords < 0 ? 0 : this.METADATA.minRecords\n    }\n\n    // Bubble events to the BUS\n    // this.relay('*', NGN.BUS, 'store.')\n\n    // Configure Indices\n    if (NGN.coalesce(cfg.index) && NGN.typeof(this.METADATA.Model.prototype.CONFIGURATION.fields) === 'object') {\n      this.createIndex(cfg.index)\n    }\n\n    // Setup auto-compact\n    if (this.METADATA.autocompact < 100) {\n      this.METADATA.DELETECOUNT = 0\n      this.on(this.PRIVATE.EVENTS.DELETE_RECORD, () => {\n        this.METADATA.DELETECOUNT++\n\n        if (this.METADATA >= this.METADATA.autocompact) {\n          this.METADATA.DELETECOUNT = 0\n          this.compact()\n        }\n      })\n    }\n  }\n\n  /**\n   * @property {array} snapshots\n   * Contains the data snapshot of the entire store.\n   * @readonly\n   * @private\n   */\n  get snapshots () {\n    return NGN.coalesce(this.snapshotarchive, [])\n  }\n\n  // Deprecation notice\n  get history () {\n    NGN.WARN('history is deprecated. Use NGN.DATA.Store#changelog instead.')\n    return this.changelog\n  }\n\n  // Deprecation notice\n  get recordCount () {\n    NGN.WARN('recordCount is deprecated. Use NGN.DATA.Store#size instead.')\n    return this.size\n  }\n\n  /**\n   * @property {number} count\n   * The total number of **active** records contained in the store.\n   * Active records are any records that aren't filtered out.\n   */\n  get size () {\n    return this.PRIVATE.ACTIVERECORDS.size\n  }\n\n  /**\n   * @property {number} length\n   * The total number of records contained in the store.\n   * This value does not include any soft-deleted/volatile records.\n   */\n  get length () {\n    return this.METADATA.records.length\n  }\n\n  /**\n   * @property {NGN.DATA.Model} first\n   * Return the first active record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get first () {\n    let record = NGN.coalesce(this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n\n    return this.PRIVATE.convertStubToRecord(this.METADATA.FIRSTRECORDINDEX, record)\n    // return NGN.coalesce(this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n  }\n\n  /**\n   * @property {NGN.DATA.Model} last\n   * Return the last active record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get last () {\n    let record = NGN.coalesce(this.METADATA.records[this.METADATA.LASTRECORDINDEX])\n\n    return this.PRIVATE.convertStubToRecord(this.METADATA.LASTRECORDINDEX, record)\n  }\n\n  /**\n   * @property {object} data\n   * A serialized version of the data represented by the store. This\n   * only includes non-virtual fields. See #representation to use\n   * a representation of data containing virtual fields.\n   */\n  get data () {\n    const recordList = this.PRIVATE.ACTIVERECORDS\n\n    // If no records exist, skip\n    if (recordList.size === 0) {\n      return []\n    }\n\n    let rec = this.PRIVATE.convertStubToRecord(this.METADATA.FIRSTRECORDINDEX, this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n\n    if (this.METADATA.MAP === null) {\n      this.METADATA.MAP = NGN.coalesce(rec.MAP)\n    }\n\n    let defaults = null\n\n    if (rec instanceof NGN.DATA.Entity) {\n      let fieldDefinitions = rec.fieldDefinitions\n      let fields = Object.keys(fieldDefinitions)\n\n      defaults = {}\n\n      fields.forEach(field => {\n        if (!fieldDefinitions[field].hidden && !fieldDefinitions[field].virtual) {\n          defaults[field] = fieldDefinitions[field].default\n        }\n      })\n    }\n\n    const result = []\n    // const fields = defaults !== null ? Object.keys(defaults) : []\n\n    // Iterate through set\n    recordList.forEach(index => {\n      if (this.METADATA.records[index] !== null) {\n        // If the value is a stub, map it.\n        if (this.METADATA.records[index].hasOwnProperty(this.PRIVATE.STUB)) {\n          let applicableData = Object.assign({}, defaults)\n          let data = Object.assign(applicableData, this.METADATA.records[index].metadata)\n\n          if (this.METADATA.MAP !== null) {\n            result.push(this.METADATA.MAP.applyInverseMap(data))\n          } else {\n            result.push(data)\n          }\n        } else {\n          result.push(this.METADATA.records[index].data)\n        }\n      }\n    })\n\n    return result\n  }\n\n  /**\n   * @property {array} representation\n   * The complete and unfiltered underlying representation dataset\n   * (data + virtuals of each model).\n   */\n  get representation () {\n    const result = []\n    const recordList = this.PRIVATE.ACTIVERECORDS\n\n    recordList.forEach(index => {\n      if (this.METADATA.records[index] !== null) {\n        result.push(this.METADATA.records[index].representation)\n      }\n    })\n\n    return result\n  }\n\n  get auditable () {\n    return this.METADATA.AUDITABLE\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n    }\n  }\n\n  get model () {\n    return this.METADATA.Model\n  }\n\n  // set model (value) {\n  //   if (value !== this.METADATA.Model) {\n  //     if (NGN.typeof(value) !== 'model') {\n  //       throw new InvalidConfigurationError(`\"${this.name}\" model could not be set because the value is a ${NGN.typeof(value)} type (requires NGN.DATA.Model).`)\n  //     }\n  //\n  //     this.METADATA.Model = value\n  //   }\n  // }\n\n  get map () {\n    return this.METADATA.MAP\n  }\n\n  /**\n   * @property {array} indexedFieldNames\n   * An array of the field names for which the store maintains indexes.\n   */\n  get indexedFieldNames () {\n    if (this.METADATA.INDEXFIELDS) {\n      return Array.from(this.METADATA.INDEXFIELDS)\n    } else {\n      return []\n    }\n  }\n\n  /**\n   * @method add\n   * Append a data record to the store. This adds the record to the end of the list.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in #model.\n   * @param {boolean} [suppressEvents=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  add (data, suppressEvents = false) {\n    // Support array input\n    if (NGN.typeof(data) === 'array') {\n      let result = new Array(data.length)\n\n      for (let i = 0; i < data.length; i++) {\n        result[i] = this.add(data[i], suppressEvents)\n      }\n\n      return result\n    }\n\n    // Prevent creation if it will exceed maximum record count.\n    if (this.METADATA.maxRecords > 0 && this.METADATA.records.length + 1 > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    if (!(data instanceof this.METADATA.Model)) {\n      // Force a data model\n      if (NGN.typeof(data) === 'string') {\n        data = JSON.parse(data)\n      }\n\n      if (typeof data !== 'object') {\n        throw new Error(`${NGN.typeof(data)} is an invalid data type (must be an object conforming to the ${this.METADATA.Model.name} field configuration).`)\n      }\n    } else {\n      data = data.data\n    }\n\n    const record = this.PRIVATE.addRecord(data)\n\n    // TODO: Apply filters to new record before identifying the last record.\n    this.METADATA.LASTRECORDINDEX = this.METADATA.records.length - 1\n\n    this.emit(this.PRIVATE.EVENT.CREATE_RECORD, record)\n\n    if (!suppressEvents) {\n      this.emit('record.create', record)\n    }\n\n    return record\n  }\n\n  /**\n   * @method remove\n   * Remove a record.\n   * @param {NGN.DATA.Model|number|Symbol} record\n   * Accepts an existing NGN Data Model or index number.\n   * Using a model is slower than using an index number.\n   * This may also be the NGN.DATA.Model#OID value (for\n   * advanced use cases).\n   * @fires record.delete\n   * The record delete event sends 2 arguments to handler methods:\n   * `record` and `index`. The record refers to the model that was\n   * removed. The `index` refers to the position of the record within\n   * the store's data list. **NOTICE** the `index` refers to where\n   * the record _used to be_.\n   * @returns {NGN.DATA.Model}\n   * Returns the data model that was just removed. If a model\n   * is unavailable (i.e. remove didn't find the specified record),\n   * this will return `null`.\n   */\n  remove (record, suppressEvents = false) {\n    // Short-circuit processing if there are no records.\n    if (this.METADATA.records.length === 0) {\n      NGN.INFO(`\"${this.name}\" store called remove(), but the store contains no records.`)\n      return\n    }\n\n    // Support removal of simultaneously removing multiple records\n    if (NGN.typeof(record) === 'array') {\n      let result = new Array(record.length)\n\n      for (let i = 0; i < record.length; i++) {\n        result[i] = this.remove(record[i])\n      }\n\n      return result\n    }\n\n    // Prevent removal if it will exceed minimum record count.\n    if (this.minRecords > 0 && this.METADATA.records.length - 1 < this.minRecords) {\n      throw new Error('Removing this record would violate the minimum record count.')\n    }\n\n    // Identify which record will be removed.\n    let index\n\n    switch (NGN.typeof(record)) {\n      case 'number':\n        if (record < 0 || !this.METADATA.records[record]) {\n          NGN.ERROR(`Record removal failed (record not found at index ${(record || 'undefined').toString()}).`)\n          return null\n        }\n\n        index = record\n\n        break\n\n      // The default case comes before the symbol case specifically\n      // so the record can be converted to an OID value (for use with\n      // the RECORDMAP lookup).\n      default:\n        if (!(record instanceof NGN.DATA.Entity)) {\n          NGN.ERROR('Invalid record value passed to Store.remove() method.')\n          return null\n        }\n\n        record = record.OID\n\n      case 'symbol': // eslint-disable-line no-fallthrough\n        index = this.PRIVATE.ACTIVERECORDS.get(record)\n\n        if (index < 0) {\n          NGN.ERROR(`Record removal failed. Record OID not found (\"${record.toString()}\").`)\n          return null\n        }\n\n        break\n    }\n\n    // If nothing has been deleted yet, create an active record map.\n    // The active record map contains Model OID values with a reference\n    // to the actual record index.\n    if (this.PRIVATE.ACTIVERECORDMAP === null) {\n      // Copy the record map to initialize the active records\n      this.PRIVATE.ACTIVERECORDMAP = new Map(this.PRIVATE.RECORDMAP)\n    }\n\n    // Identify the record to be removed.\n    const removedRecord = this.METADATA.records[index]\n\n    // If the record isn't among the active records, do not remove it.\n    if (removedRecord === null) {\n      NGN.WARN('Specified record does not exist.')\n      return null\n    }\n\n    let activeIndex = this.PRIVATE.ACTIVERECORDS.get(removedRecord.OID)\n\n    if (isNaN(activeIndex)) {\n      NGN.WARN(`Record not found for \"${removedRecord.OID.toString()}\".`)\n      return null\n    }\n\n    this.PRIVATE.ACTIVERECORDS.delete(removedRecord.OID)\n\n    // If the store is configured to soft-delete,\n    // don't actually remove it until it expires.\n    if (this.METADATA.softDelete) {\n      if (this.METADATA.softDeleteTtl >= 0) {\n        removedRecord.once('expired', () => {\n          this.METADATA.records[this.PRIVATE.RECORDMAP.get(removedRecord.OID)] = null\n          this.PRIVATE.RECORDMAP.delete(removedRecord.OID)\n\n          if (!suppressEvents) {\n            this.emit('record.purge', removedRecord)\n          }\n        })\n\n        removedRecord.expires = this.METADATA.softDeleteTtl\n      }\n    } else {\n      this.METADATA.records[this.PRIVATE.RECORDMAP.get(removedRecord.OID)] = null\n      this.PRIVATE.RECORDMAP.delete(removedRecord.OID)\n    }\n\n    // Update cursor indexes (to quickly reference first and last active records)\n    if (this.METADATA.LASTRECORDINDEX === activeIndex) {\n      if (this.PRIVATE.ACTIVERECORDS.size <= 1) {\n        this.METADATA.LASTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.values().next().value\n        this.METADATA.FIRSTRECORDINDEX = this.METADATA.LASTRECORDINDEX\n      } else if (activeIndex !== 0) {\n        for (let i = (activeIndex - 1); i >= 0; i--) {\n          if (i === 0) {\n            this.METADATA.LASTRECORDINDEX = 0\n            break\n          }\n\n          const examinedRecord = this.METADATA.records[i]\n\n          if (examinedRecord !== null) {\n            if (this.PRIVATE.ACTIVERECORDS.has(examinedRecord.OID)) {\n              this.METADATA.LASTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.get(examinedRecord.OID)\n              break\n            }\n          }\n        }\n      }\n    } else if (this.METADATA.FIRSTRECORDINDEX === activeIndex) {\n      let totalSize = this.PRIVATE.ACTIVERECORDS.size\n\n      for (let i = (activeIndex + 1); i < totalSize; i++) {\n        const examinedRecord = this.METADATA.records[i]\n\n        if (examinedRecord !== null) {\n          if (this.PRIVATE.ACTIVERECORDS.has(examinedRecord.OID)) {\n            this.METADATA.FIRSTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.get(examinedRecord.OID)\n            break\n          }\n        }\n      }\n    }\n\n    this.emit(this.PRIVATE.EVENT.DELETE_RECORD, removedRecord)\n\n    if (!suppressEvents) {\n      this.emit('record.delete', removedRecord)\n    }\n\n    return removedRecord\n  }\n\n  /**\n   * Create a new index on the store.\n   * @param  {string} field\n   * The name of the field to index.\n   * @fires index.create\n   * Triggered when an index is created. The name of field is passed\n   * as the only argument.\n   */\n  createIndex (field) {\n    // Support multiple indexes\n    if (NGN.typeof(field) === 'array') {\n      for (let i = 0; i < field.length; i++) {\n        this.createIndex(field[i])\n      }\n\n      return\n    }\n\n    // Make sure index fields are known to the store\n    if (!this.METADATA.INDEXFIELDS) {\n      this.METADATA.INDEXFIELDS = new Set()\n\n      // this.on('record.*', this.PRIVATE.INDEX)\n      this.on([\n        this.PRIVATE.EVENT.CREATE_RECORD,\n        this.PRIVATE.EVENT.DELETE_RECORD,\n        this.PRIVATE.EVENT.LOAD_RECORDS,\n        this.PRIVATE.EVENT.DELETE_RECORD_FIELD,\n        'clear'\n      ], this.PRIVATE.INDEX)\n    }\n\n    // In an index already exists, ignore it.\n    if (this.METADATA.INDEXFIELDS.has(field)) {\n      return\n    }\n\n    // Guarantee the existance of the index list\n    this.METADATA.INDEX = NGN.coalesce(this.METADATA.INDEX, {})\n\n    this.PRIVATE.checkModelIndexField(field)\n\n    this.METADATA.INDEXFIELDS.add(field)\n\n    // Identify BTree\n    let btree = ['number', 'date'].indexOf(this.PRIVATE.getModelFieldType(field)) >= 0\n\n    this.METADATA.INDEX[field] = new NGN.DATA.Index(btree, `${field.toUpperCase()} ${btree ? 'BTREE ' : ''}INDEX`)\n\n    // Apply to any existing records\n    if (this.METADATA.records.length > 0) {\n      this.PRIVATE.INDEX.apply({ event: this.PRIVATE.EVENT.LOAD_RECORDS })\n    }\n\n    this.emit('index.created', field)\n  }\n\n  /**\n   * Remove an existing index from the store.\n   * @param  {string} [field=null]\n   * The name of the indexed field. Set this to `null` (or leave blank) to\n   * remove all existing indexes.\n   * @fires index.delete\n   * Triggered when an index is removed. The name of field is passed\n   * as the only argument.\n   */\n  removeIndex (field = null) {\n    if (!this.METADATA.INDEXFIELDS) {\n      return\n    }\n\n    if (NGN.coalesce(field) === null) {\n      field = this.indexedFieldNames\n    }\n\n    // Support multiple indexes\n    if (NGN.typeof(field) === 'array') {\n      for (let i = 0; i < field.length; i++) {\n        this.removeIndex(field[i])\n      }\n\n      return\n    }\n\n    // Remove the specific index.\n    this.METADATA.INDEXFIELDS.delete(field)\n    delete this.METADATA.INDEX[field]\n    this.emit('index.delete', field)\n\n    // When there are no more indexes, clear out event\n    // listeners and fields.\n    if (this.METADATA.INDEXFIELDS.size === 0) {\n      this.METADATA.INDEX = null\n      delete this.METADATA.INDEXFIELDS\n\n      this.off([\n        this.PRIVATE.EVENT.CREATE_RECORD,\n        this.PRIVATE.EVENT.DELETE_RECORD,\n        this.PRIVATE.EVENT.LOAD_RECORDS,\n        this.PRIVATE.EVENT.DELETE_RECORD_FIELD\n      ], this.PRIVATE.INDEX)\n    }\n  }\n\n  /**\n   * Retrieve a record based on it's relative position to another\n   * record. This method is used by NGN.DATA.Model#next and NGN.DATA.Model#previous\n   * to support \"doubly linked list\" approach to record iteration.\n   * @param  {[type]}  currentRecord [description]\n   * @param  {Number}  [count=1]     [description]\n   * @param  {Boolean} [cycle=false] [description]\n   * @return {[type]}                [description]\n   */\n  getRecordSibling (currentRecord, count = 1, cycle = false) {\n    let size = this.size\n\n    if (size === 0) {\n      NGN.WARN('Attempted to execute getRecordSibling with no active records.')\n      return null\n    }\n\n    // Make sure the iterator fits within the range\n    if (Math.abs(count) > size) {\n      count = count % size\n    }\n\n    if (size === 1 || count === 0) {\n      return currentRecord\n    }\n\n    let ActiveRecords = Array.from(this.PRIVATE.ACTIVERECORDS)\n    let currentIndex = ActiveRecords.findIndex(item => currentRecord.OID === item[0])\n\n    if (currentIndex < 0) {\n      throw new Error('Record not found.')\n    }\n\n    currentIndex += count\n\n    // Support cycling through records.\n    if ((currentIndex >= ActiveRecords.length || currentIndex < 0) && cycle) {\n      // Cycle forwards\n      if (count > 0) {\n        currentIndex = currentIndex % ActiveRecords.length\n      } else {\n        // Cycle Backwards\n        currentIndex = ActiveRecords.length - Math.abs(currentIndex)\n      }\n    }\n\n    if (currentIndex < 0 || currentIndex >= ActiveRecords.length) {\n      return null\n    }\n\n    return this.METADATA.records[ActiveRecords[currentIndex][1]]\n  }\n\n  /**\n   * Returns the index number of the model. If the same\n   * model exists more than once (duplicate records), only\n   * the first index is returned.\n   * @param  {NGN.DATA.Model} model\n   * The model/record to retrieve an index number for.\n   * @return {number}\n   * The zero-based index number of the model.\n   */\n  indexOf (record) {\n    return this.PRIVATE.RECORDMAP.get(record.OID)\n  }\n\n  /**\n   * Determine whether the store contains a record.\n   * This only checks the active record set (ignores filtered records).\n   * @param  {NGN.DATA.Model} record\n   * The record to test for inclusion.\n   * @return {boolean}\n   */\n  contains (record) {\n    return this.PRIVATE.ACTIVERECORDS.has(record.OID)\n  }\n\n  /**\n   * Get the list of records for the given value.\n   * @param {string} fieldName\n   * The name of the indexed field.\n   * @param  {any} fieldValue\n   * The value of the index field. This is used to lookup\n   * the list of records/models whose field is equal to\n   * the specified value.\n   * @return {NGN.DATA.Model[]}\n   * Returns an array of models/records within the index for\n   * the given value.\n   */\n  getIndexRecords (field, value) {\n    if (this.METADATA.INDEX && this.METADATA.INDEX.hasOwnProperty(field)) {\n      let oid = this.METADATA.INDEX[field].recordsFor(value)\n      let result = new Array(oid.length)\n\n      for (let i = 0; i < oid.length; i++) {\n        result[i] = this.METADATA.records[this.PRIVATE.RECORDMAP.get(oid[i])]\n      }\n\n      return result\n    }\n\n    return []\n  }\n\n  /**\n   * Retrieve an active record by index number (0-based, similar to an array).\n   * @param  {number} [index=0]\n   * The index of the record to retrieve.\n   */\n  getRecord (index = 0) {\n    if (typeof index === 'symbol') {\n      index = this.PRIVATE.ACTIVERECORDS.get(index)\n    }\n\n    if (index < 0) {\n      NGN.WARN('Cannot retrieve a record for a negative index.')\n      return null\n    }\n\n    if (index >= this.PRIVATE.ACTIVERECORDS.size) {\n      NGN.WARN('Cannot retrieve a record for an out-of-scope index (index greater than total record count.)')\n      return null\n    }\n\n    return this.METADATA.records[Array.from(this.PRIVATE.ACTIVERECORDS)[index][1]]\n  }\n\n  /**\n   * @method clear\n   * Removes all data. If auditing is enabled, the transaction log is reset.\n   * @param {boolean} [purgeSoftDelete=true]\n   * Purge soft deleted records from memory.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from triggering when this method is run.\n   * @fires clear\n   * Fired when all data is removed\n   */\n  clear (purge = true, suppressEvents = false) {\n    if (this.METADATA.ARCHIVE) {\n      if (!purge) {\n        this.METADATA.ARCHIVE = this.records\n      } else {\n        delete this.METADATA.ARCHIVE\n      }\n    }\n\n    this.METADATA.records = []\n    this.PRIVATE.RECORDMAP = new Map()\n    this.PRIVATE.ACTIVERECORDMAP = null\n    this.PRIVATE.FILTEREDRECORDMAP = null\n    this.METADATA.LASTRECORDINDEX = 0\n    this.METADATA.FIRSTRECORDINDEX = 0\n\n    if (this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITLOG.reset()\n    }\n\n    // Indexes updated automatically (listening for 'clear' event)\n\n    if (!suppressEvents) {\n      this.emit('clear')\n    }\n  }\n\n  /**\n   * A special method to clear events from the underlying event emitter.\n   * This exists because #clear has a special meaning in a data store (removing\n   * all data records vs removing all events).\n   * @private\n   */\n  clearEvents () {\n    super.clear(...arguments)\n  }\n\n  /**\n   * Replace a model.\n   * @deprecated 2.0.0\n   * @param  {NGN.DATA.Model} newModel\n   * The new model.\n   */\n  replaceModel (newModel) {\n    NGN.deprecate(\n      () => { this.model = newModel },\n      'replaceModel has been deprected. Set the model directly instead.'\n    )\n  }\n\n  /**\n   * @method snapshot\n   * Add a snapshot of the current store to the #snapshot archive.\n   * This can potentially be a computationally/memory-expensive operation.\n   * The method creates a copy of all data in the store along with checksums\n   * of each element and holds the snapshot in RAM. Large stores may consume\n   * large amounts of RAM until the snapshots are released/cleared.\n   * Snapshots are most commonly used with data proxies to calculate\n   * differences in a data set before persisting them to a database.\n   * @fires snapshot\n   * Triggered when a new snapshot is created. The snapshot dataset is\n   * passed as the only argument to event handlers.\n   * @returns {object}\n   * Returns an object containing the following fields:\n   *\n   * ```js\n   * {\n   *   timestamp: 'ex: 2018-01-19T16:43:03.279Z',\n   *   checksum: 'snapshotchecksum',\n   *   modelChecksums: [\n   *     'record1_checksum',\n   *     'record2_checksum'\n   *   ],\n   *   data: { ... } // Actual data at the time of the snapshot\n   * }\n   * ```\n   */\n  snapshot () {\n    this.METADATA.snapshotarchive = NGN.coalesce(this.METADATA.snapshotarchive, [])\n\n    let data = this.data\n    let dataset = {\n      id: NGN.DATA.UTILITY.GUID(),\n      timestamp: (new Date()).toISOString(),\n      checksum: NGN.DATA.UTILITY.checksum(JSON.stringify(data)).toString(),\n      modelChecksums: this.data.map((item) => {\n        return NGN.DATA.UTILITY.checksum(JSON.stringify(item)).toString()\n      }),\n      data: data\n    }\n\n    this.METADATA.snapshotarchive.unshift(dataset)\n    this.emit('snapshot', dataset)\n\n    return dataset\n  }\n\n  /**\n   * @method clearSnapshots\n   * Remove all archived snapshots.\n   */\n  clearSnapshots () {\n    this.snapshotarchive = null\n  }\n\n  load (data) {\n    console.time('load')\n    let insertableData\n\n    // Guarantee unique records amongst only the new records\n    if (!this.METADATA.allowDuplicates) {\n      let uniqueValues = new Set()\n\n      insertableData = []\n\n      for (let i = 0; i < data.length; i++) {\n        if (!uniqueValues.has(JSON.stringify(data[i]))) {\n          uniqueValues.add(JSON.stringify(data[i]))\n          insertableData.push(data[i])\n        } else if (this.METADATA.errorOnDuplicate) {\n          throw new NGNDuplicateRecordError()\n        }\n      }\n    } else {\n      insertableData = data\n    }\n\n    let newRecordCount = insertableData.length + this.METADATA.records.length\n\n    // Don't exceed the maximum record count if it exists.\n    if (this.METADATA.maxRecords > 0 && newRecordCount > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    if (newRecordCount > 4000000) {\n      throw new Error('Maximum load size exceeded. A store may contain a maximum of 4M records.')\n    }\n\n    for (let i = 0; i < insertableData.length; i++) {\n      let oid = Symbol('model.id')\n      this.METADATA.records.push({\n        [this.PRIVATE.STUB]: true,\n        OID: oid,\n        metadata: insertableData[i]\n      })\n\n      // Add the record to the map for efficient retrievel by OID\n      this.PRIVATE.RECORDMAP.set(oid, this.METADATA.records.length - 1)\n    }\n\n    // TODO: Apply filters to new record before identifying the last record.\n    this.METADATA.LASTRECORDINDEX = this.METADATA.records.length - 1\n\n    // this.emit(this.PRIVATE.EVENT.LOAD_RECORDS)\n  }\n\n  /**\n   * This rebuilds the local index of records, removing any dead records.\n   * While deleted records are destroyed (in accordance to #softDeleteTtl),\n   * the active record table contains a `null` or `undefined` value for each\n   * deleted/dead record. This method removes such records, akin in nature to\n   * the common JavaScript garbage collection process.\n   *\n   * This method almost never needs to be run, since stores\n   * attempt to manage this process for themselves automatically. However; if\n   * large volume deletions occur rapidly (50K+), it's possible (though not assured)\n   * performance could be negatively impacted. Compacting the store can\n   * improve performance in these cases. However; running this too often or\n   * excessively may degrade performance since it is essentially rewriting\n   * the store data each time.\n   *\n   * When in doubt, *don't* use this method.\n   * @info This method will not run when fewer than 100 cumulative records have\n   * existed in the store, due to the inefficient nature at such low volume.\n   * @fires compact.start\n   * Triggered when the compact process begins.\n   * @fires compact.complete\n   * Triggered when the compact process completes.\n   */\n  compact () {\n    this.emit('compact.start')\n\n    if (this.METADATA.records.length < 100) {\n      this.emit('compact.complete')\n\n      if (this.METADATA.records.length !== 0) {\n        NGN.WARN(`compact() called on ${this.name} with fewer than 100 elements.`)\n      }\n\n      return\n    }\n\n    let ranges = []\n    let currentRange = []\n    let empty = 0\n\n    // Identify null ranges (dead records)\n    for (let i = 0; i < this.METADATA.records.length; i++) {\n      if (this.METADATA.records[i] === null) {\n        empty++\n\n        if (currentRange.length === 0) {\n          currentRange.push(i)\n        }\n      } else {\n        // Identify new index values for remaining records\n        if (empty > 0) {\n          this.PRIVATE.RECORDMAP.set(this.METADATA.records[i].OID, i - empty)\n\n          if (this.METADATA.FIRSTRECORDINDEX === i) {\n            this.METADATA.FIRSTRECORDINDEX = i - empty\n          }\n\n          if (this.METADATA.LASTRECORDINDEX === i) {\n            this.METADATA.LASTRECORDINDEX = i - empty\n          }\n        }\n\n        if (currentRange.length === 1) {\n          currentRange.push(i - 1)\n          ranges.push(currentRange)\n          currentRange = []\n        }\n      }\n    }\n\n    // Clear null ranges\n    empty = 0\n    while (ranges.length > 0) {\n      this.METADATA.records.splice(ranges[0][0] - empty, ranges[0][1] - ranges[0][0] + 1)\n      empty += ranges[0][1] - ranges[0][0] + 1\n      ranges.shift()\n    }\n\n    // Reset the active record map\n    this.PRIVATE.ACTIVERECORDMAP = null\n\n    this.emit('compact.complete')\n  }\n\n  /**\n   * Performs executes the callback method on each active record\n   * within the store. For example:\n   *\n   * ```js\n   * Store.forEach(function (record) {\n   *   // Do Something\n   * })\n   * ```\n   * @param  {Function} callback\n   * The callback method is applied to each record.\n   */\n  forEach (fn) {\n    if (!NGN.isFn(fn)) {\n      throw new Error(`A ${NGN.typeof(fn)} was applied to ${this.name}'s each() method when a function was expected.`)\n    }\n\n    this.PRIVATE.ACTIVERECORDS.forEach((value, key, map) => {\n      fn(this.METADATA.records[value])\n    })\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "record.invalid": {
          "type": "event",
          "label": "record.invalid",
          "description": null,
          "code": "this.emit('record.invalid', record)",
          "start": {
            "line": 412,
            "column": 14
          },
          "end": {
            "line": 412,
            "column": 49
          },
          "flags": [],
          "parameters": {
            "record": {
              "type": "argument",
              "label": "record",
              "description": null,
              "code": "record",
              "start": {
                "line": 412,
                "column": 42
              },
              "end": {
                "line": 412,
                "column": 48
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "record.duplicate": {
          "type": "event",
          "label": "record.duplicate",
          "description": null,
          "code": "this.emit('record.duplicate', record)",
          "start": {
            "line": 427,
            "column": 18
          },
          "end": {
            "line": 427,
            "column": 55
          },
          "flags": [],
          "parameters": {
            "record": {
              "type": "argument",
              "label": "record",
              "description": null,
              "code": "record",
              "start": {
                "line": 427,
                "column": 48
              },
              "end": {
                "line": 427,
                "column": 54
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "record.create": {
          "type": "event",
          "label": "record.create",
          "description": null,
          "code": "this.emit('record.create', record)",
          "start": {
            "line": 786,
            "column": 6
          },
          "end": {
            "line": 786,
            "column": 40
          },
          "flags": [],
          "parameters": {
            "record": {
              "type": "argument",
              "label": "record",
              "description": null,
              "code": "record",
              "start": {
                "line": 786,
                "column": 33
              },
              "end": {
                "line": 786,
                "column": 39
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "record.purge": {
          "type": "event",
          "label": "record.purge",
          "description": null,
          "code": "this.emit('record.purge', removedRecord)",
          "start": {
            "line": 905,
            "column": 12
          },
          "end": {
            "line": 905,
            "column": 52
          },
          "flags": [],
          "parameters": {
            "removedRecord": {
              "type": "argument",
              "label": "removedRecord",
              "description": null,
              "code": "removedRecord",
              "start": {
                "line": 905,
                "column": 38
              },
              "end": {
                "line": 905,
                "column": 51
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "record.delete": {
          "type": "event",
          "label": "record.delete",
          "description": "The record delete event sends 2 arguments to handler methods:\n`record` and `index`. The record refers to the model that was\nremoved. The `index` refers to the position of the record within\nthe store's data list. **NOTICE** the `index` refers to where\nthe record _used to be_.",
          "code": "@fires record.delete\nThe record delete event sends 2 arguments to handler methods:\n`record` and `index`. The record refers to the model that was\nremoved. The `index` refers to the position of the record within\nthe store's data list. **NOTICE** the `index` refers to where\nthe record _used to be_.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "index.created": {
          "type": "event",
          "label": "index.created",
          "description": null,
          "code": "this.emit('index.created', field)",
          "start": {
            "line": 1016,
            "column": 4
          },
          "end": {
            "line": 1016,
            "column": 37
          },
          "flags": [],
          "parameters": {
            "field": {
              "type": "argument",
              "label": "field",
              "description": null,
              "code": "field",
              "start": {
                "line": 1016,
                "column": 31
              },
              "end": {
                "line": 1016,
                "column": 36
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "index.create": {
          "type": "event",
          "label": "index.create",
          "description": "Triggered when an index is created. The name of field is passed\nas the only argument.",
          "code": "@fires index.create\nTriggered when an index is created. The name of field is passed\nas the only argument.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "index.delete": {
          "type": "event",
          "label": "index.delete",
          "description": "Triggered when an index is removed. The name of field is passed\nas the only argument.",
          "code": "@fires index.delete\nTriggered when an index is removed. The name of field is passed\nas the only argument.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "clear": {
          "type": "event",
          "label": "clear",
          "description": "Fired when all data is removed",
          "code": "@fires clear\nFired when all data is removed",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "snapshot": {
          "type": "event",
          "label": "snapshot",
          "description": "Triggered when a new snapshot is created. The snapshot dataset is\npassed as the only argument to event handlers.",
          "code": "@fires snapshot\nTriggered when a new snapshot is created. The snapshot dataset is\npassed as the only argument to event handlers.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "compact.start": {
          "type": "event",
          "label": "compact.start",
          "description": "Triggered when the compact process begins.",
          "code": "@fires compact.start\nTriggered when the compact process begins.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "compact.complete": {
          "type": "event",
          "label": "compact.complete",
          "description": "Triggered when the compact process completes.",
          "code": "@fires compact.complete\nTriggered when the compact process completes.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 32,
        "column": 15
      },
      "end": {
        "line": 1464,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/Store.js",
      "extends": "EventEmitter",
      "configuration": {
        "name": {
          "type": "property",
          "label": "name",
          "description": "A descriptive name for the store. This is typically used for\ndebugging, logging, and  data proxies.",
          "code": "name: NGN.const(NGN.coalesce(cfg.name, 'Untitled Data Store'))",
          "start": {
            "line": 50,
            "column": 6
          },
          "end": {
            "line": 50,
            "column": 68
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        }
      },
      "properties": {
        "name": {
          "type": "property",
          "label": "name",
          "description": "A descriptive name for the store. This is typically used for\ndebugging, logging, and  data proxies.",
          "code": "name: NGN.const(NGN.coalesce(cfg.name, 'Untitled Data Store'))",
          "start": {
            "line": 50,
            "column": 6
          },
          "end": {
            "line": 50,
            "column": 68
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        },
        "METADATA": {
          "type": "property",
          "label": "METADATA",
          "description": null,
          "code": "METADATA: NGN.private({\n        // Holds the models/records\n        records: [],\n\n        /**\n         * @cfgproperty {NGN.DATA.Model} model\n         * An NGN Data Model to which data records conform.\n         */\n        Model: NGN.coalesce(cfg.model),\n\n        /**\n         * @cfg {boolean} [allowDuplicates=true]\n         * Set to `false` to prevent duplicate records from being added.\n         * If a duplicate record is added, it will be ignored and an\n         * error will be thrown.\n         *\n         * **Identifying duplicates _may_ be slow** on data sets with 200+ records.\n         * Uniqueness is determined by a checksum of the current NGN.DATA.Model#data\n         * of a record. The amount of time required to generate a checksum can range\n         * from 3ms to 150ms per record depending on data complexity.\n         *\n         * In most scenarios, the performance impact will be negligible/indistinguishable\n         * to the naked eye. However; if an application experiences slow data\n         * load or processing times, setting this to `false` may help.\n         */\n        allowDuplicates: NGN.coalesce(cfg.allowDuplicates, true),\n\n        /**\n         * @cfg {boolean} [errorOnDuplicate=false]\n         * Set to `true` to throw an error when a duplicate record is detected.\n         * If this is not set, it will default to the value of #allowDuplicates.\n         * If #allowDuplicates is not defined either, this will be `true`\n         */\n        errorOnDuplicate: NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, false),\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * Allow invalid records to be added to the store.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {boolean} [errorOnInvalid=false]\n         * Set to `true` to throw an error when an attempt is made to add an\n         * invalid record.\n         */\n        errorOnInvalid: NGN.coalesce(cfg.errorOnInvalid, cfg.allowInvalid, false),\n\n        /**\n         * @cfgproperty {boolean} [autoRemoveExpiredRecords=true]\n         * When set to `true`, the store will automatically delete expired records.\n         */\n        autoRemoveExpiredRecords: NGN.coalesce(cfg.autoRemoveExpiredRecords, true),\n\n        /**\n         * @cfg {boolean} [softDelete=false]\n         * When set to `true`, the store makes a copy of a record before removing\n         * it from the store. The store will still emit a `record.delete` event,\n         * and it will still behanve as though the record has been completely\n         * removed. However; the record copy can be retrieved using the #restore\n         * method.\n         *\n         * Since it is not always desirable to store a copy of every deleted\n         * record indefinitely, it is possible to expire and permanently remove\n         * records by setting the #softDeleteTtl.\n         *\n         * ```js\n         * var People = new NGN.DATA.Store({\n         *   model: Person,\n         *   softDelete: true,\n         *   softDeleteTtl: 10000\n         * })\n         *\n         * People.add(somePerson)\n         *\n         * var removedRecordId\n         * People.once('record.delete', function (record) {\n         *   removedRecordId = record.id\n         * })\n         *\n         * People.remove(somePerson)\n         *\n         * setTimeout(function () {\n         *   People.restore(removedRecordId)\n         * }, 5000)\n         *\n         * ```\n         *\n         * The code above creates a new store and adds a person to it.\n         * Then a placeholder variable (`removedRecordId`) is created.\n         * Next, a one-time event listener is added to the store, specifically\n         * for handling the removal of a record. Then the record is removed,\n         * which triggers the `record.delete` event, which populates\n         * `removedRecordId` with the ID of the record that was deleted.\n         * Finally, the code waits for 5 seconds, then restores the record. If\n         * the #restore method _wasn't_ called, the record would be purged\n         * from memory after 10 seconds (because `softDeleteTtl` is set to 10000\n         * milliseconds).\n         */\n        softDelete: NGN.coalesce(cfg.softDelete, false),\n\n        /**\n         * @cfg {number} [softDeleteTtl=-1]\n         * This is the number of milliseconds the store waits before purging a\n         * soft-deleted record from memory. `-1` = Infinite (no TTL).\n         */\n        softDeleteTtl: NGN.coalesce(cfg.softDeleteTtl, -1),\n\n        // ARCHIVE contains soft deleted records\n\n        /**\n         * @cfg {Number} [FIFO=-1]\n         * Configures the store to use \"**F**irst **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the oldest record (i.e. the 1st). This guarantees the\n         * store will never have more than 10 records at any given time and it\n         * will always maintain the latest records.\n         *\n         * FIFO and LIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. FIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        fifo: NGN.coalesce(cfg.FIFO, -1),\n\n        /**\n         * @cfg {Number} [LIFO=-1]\n         * Configures the store to use \"**L**ast **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * This methos acts in the opposite manner as #FIFO. However; for\n         * all intents and purposes, this merely replaces the last record in\n         * the store when a new record is added.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the latest record (i.e. the 10th). This guarantees the\n         * store will never have more than 10 records at any given time. Every\n         * time a new record is added (assuming the store already has the maximum\n         * allowable records), it replaces the last record (10th) with the new\n         * record.\n         *\n         * LIFO and FIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. LIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        lifo: NGN.coalesce(cfg.LIFO, -1),\n\n        /**\n         * @cfg {Number} [maxRecords=-1]\n         * Setting this will prevent new records from being added past this limit.\n         * Attempting to add a record to the store beyond it's maximum will throw\n         * an error.\n         */\n        maxRecords: NGN.coalesce(cfg.maxRecords, -1),\n\n        /**\n         * @cfg {Number} [minRecords=0]\n         * Setting this will prevent removal of records if the removal would\n         * decrease the count below this limit.\n         * Attempting to remove a record below the store's minimum will throw\n         * an error.\n         */\n        minRecords: NGN.coalesce(cfg.minRecords, 0),\n\n        /**\n         * @cfg {Number} [autocompact=50000]\n         * Identify the number of deletions that should occur before\n         * the store is compacted. See #compact. Set this to any value\n         * below `100` (the minimum) to disable autocompact.\n         */\n        autocompact: NGN.coalesce(cfg.autocompact, 50000),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        MAP: NGN.coalesce(cfg.fieldmap),\n\n        EVENTS: new Set([\n          'record.duplicate',\n          'record.create',\n          'record.update',\n          'record.delete',\n          'record.restored',\n          'record.purged',\n          'record.move',\n          'record.invalid',\n          'record.valid',\n          'clear',\n          'filter.create',\n          'filter.delete',\n          'index.create',\n          'index.delete',\n          'compact.start',\n          'compact.complete'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: (change) => {\n          if (change.hasOwnProperty('cursor')) {\n            this.METADATA.AUDITLOG.commit(this.METADATA.getAuditMap())\n          }\n        },\n\n        // The first and last indexes are maintained to determine which active\n        // record is considered first/last. Sometimes data is filtered out,\n        // so the first/last active record is not guaranteed to represent the\n        // first/last actual record. These indexes are maintained to prevent\n        // unnecessary iteration in large data sets.\n        FIRSTRECORDINDEX: 0,\n        LASTRECORDINDEX: 0,\n\n        /**\n         * @cfg {array} [index]\n         * An array of #model fields that will be indexed.\n         * See NGN.DATA.Index for details.\n         */\n        INDEX: null\n      })",
          "start": {
            "line": 52,
            "column": 6
          },
          "end": {
            "line": 297,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "PRIVATE": {
          "type": "property",
          "label": "PRIVATE",
          "description": null,
          "code": "PRIVATE: NGN.privateconst({\n        STUB: Symbol('record.stub'),\n\n        // A private indexing method\n        INDEX: function (record, delta) {\n          if (typeof this.event === 'symbol') {\n            switch (this.event) {\n              case me.PRIVATE.EVENT.CREATE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(record[field], record.OID))\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].remove(record.OID, record[field]))\n                break\n\n              case me.PRIVATE.EVENT.LOAD_RECORDS:\n                for (let i = 0; i < me.METADATA.records.length; i++) {\n                  me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(me.METADATA.records[i][field], me.METADATA.records[i].OID))\n                }\n\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD_FIELD:\n                if (me.METADATA.INDEXFIELDS.has(record.field.name)) {\n                  me.METADATA.INDEX[record.field.name].remove(record.record.OID, record.field.value)\n                }\n\n                break\n            }\n          } else {\n            switch (this.event) {\n              case 'record.update':\n                if (me.METADATA.INDEXFIELDS.has(delta.field.name)) {\n                  me.METADATA.INDEX[delta.field.name].update(record.OID, delta.old, delta.new)\n                }\n                break\n\n              case 'clear':\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].reset())\n                break\n            }\n          }\n        },\n\n        // Contains a map of all records\n        RECORDMAP: new Map(),\n\n        // A reference to active records\n        ACTIVERECORDMAP: null,\n\n        // A reference to filtered records (non-active/non-deleted)\n        FILTEREDRECORDMAP: null,\n\n        // Internal events\n        EVENT: {\n          CREATE_RECORD: Symbol('record.create'),\n          DELETE_RECORD: Symbol('record.delete'),\n          DELETE_RECORD_FIELD: Symbol('records.field.delete'),\n          LOAD_RECORDS: Symbol('records.load')\n        },\n\n        // Makes sure the model configuration specifies a valid and indexable field.\n        checkModelIndexField: (field) => {\n          let metaconfig = this.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields && metaconfig.fields.hasOwnProperty(field)) {\n            if (metaconfig.fields[field] !== null) {\n              if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(metaconfig.fields[field])) >= 0) {\n                throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n              } else if (NGN.typeof(metaconfig.fields[field]) === 'object') {\n                if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(NGN.coalesce(metaconfig.fields[field].type))) >= 0) {\n                  throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n                }\n              }\n            }\n          } else {\n            throw new Error(`Cannot create index for unrecognized field \"${field}\".`)\n          }\n        },\n\n        // Get the type of field from the model definition\n        getModelFieldType: (field) => {\n          let metaconfig = this.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields[field] === null) {\n            return NGN.typeof(metaconfig.fields[field])\n          }\n\n          if (metaconfig.fields[field].type) {\n            return NGN.typeof(metaconfig.fields[field].type)\n          }\n\n          if (metaconfig.fields[field].default) {\n            return NGN.typeof(metaconfig.fields[field].default)\n          }\n\n          return NGN.typeof(NGN.coalesce(metaconfig.fields[field]))\n        },\n\n        // Add a record\n        addRecord: (data, suppressEvents = false) => {\n          const record = new me.METADATA.Model(data)\n\n          if (!(record instanceof NGN.DATA.Entity)) {\n            throw new Error(`Only a NGN.DATA.Model or JSON object may be used in NGN.DATA.Store#add. Received a \"${NGN.typeof(data)}\" value.`)\n          }\n\n          // Prevent invalid record addition (if configured)\n          if (!me.METADATA.allowInvalid && !record.valid) {\n            NGN.WARN(`An attempt to add invalid data to the \"${this.name}\" store was prevented. The following fields are invalid: ${Array.from(record.METADATA.invalidFieldNames.keys()).join(', ')}`)\n\n            if (!suppressEvents) {\n              this.emit('record.invalid', record)\n            }\n\n            if (this.METADATA.errorOnInvalid) {\n              throw new Error(`Invalid data cannot be added to the \"${this.name}\" store.`)\n            }\n          }\n\n          // If duplicates are prevented, check the new data.\n          if (!me.METADATA.allowDuplicates) {\n            for (let i = 0; i < this.METADATA.records.length; i++) {\n              if (this.METADATA.records[i].checksum === record.checksum) {\n                NGN.WARN(`An attempt to add a duplicate record to the \"${this.name}\" store was prevented.`)\n\n                if (!suppressEvents) {\n                  this.emit('record.duplicate', record)\n                }\n\n                if (this.METADATA.errorOnDuplicate) {\n                  throw new Error(`Duplicate records are not allowed in the \"${this.name}\" data store.`)\n                }\n\n                break\n              }\n            }\n          }\n\n          // Handle special record count processing (LIFO/FIFO support)\n          if (me.METADATA.lifo > 0 && me.METADATA.records.length + 1 > me.METADATA.lifo) {\n            me.remove(me.METADATA.records.length - 1, suppressEvents)\n          } else if (this.METADATA.fifo > 0 && me.METADATA.records.length + 1 > me.METADATA.fifo) {\n            me.remove(0, suppressEvents)\n          }\n\n          // Relay model events to this store.\n          // record.relay('*', this, 'record.')\n          record.on('*', function () {\n            switch (this.event) {\n              // case 'field.update':\n              // case 'field.delete':\n              //   // TODO: Update indices\n              //   return\n\n              case 'field.invalid':\n              case 'field.valid':\n                return me.emit(this.event.replace('field.', 'record.'), record)\n\n              case 'expired':\n                // TODO: Handle expiration\n            }\n          })\n\n          delete record.METADATA.store\n          Object.defineProperty(record.METADATA, 'store', NGN.get(() => me))\n\n          // Indexing is handled in an internal event handler\n          me.METADATA.records.push(record)\n\n          // Add the record to the map for efficient retrievel by OID\n          me.PRIVATE.RECORDMAP.set(record.OID, me.METADATA.records.length - 1)\n\n          return record\n        },\n\n        convertStubToRecord: (index, record) => {\n          if (record.hasOwnProperty(this.PRIVATE.STUB)) {\n            let newRecord = this.PRIVATE.addRecord(record.metadata, false)\n            newRecord.OID = record.OID\n\n            this.METADATA.records[index] = newRecord\n\n            return newRecord\n          } else {\n            return record\n          }\n        }\n      })",
          "start": {
            "line": 300,
            "column": 6
          },
          "end": {
            "line": 488,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "delete": {
          "type": "property",
          "label": "delete",
          "description": null,
          "code": "delete: NGN.const(NGN.deprecate(this.remove, 'Store.delete is deprecated. Use Store.remove instead.'))",
          "start": {
            "line": 491,
            "column": 6
          },
          "end": {
            "line": 491,
            "column": 108
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "snapshots": {
          "type": "property",
          "label": "snapshots",
          "description": null,
          "code": "get snapshots () {\n    return NGN.coalesce(this.snapshotarchive, [])\n  }",
          "start": {
            "line": 557,
            "column": 2
          },
          "end": {
            "line": 559,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "history": {
          "type": "property",
          "label": "history",
          "description": null,
          "code": "get history () {\n    NGN.WARN('history is deprecated. Use NGN.DATA.Store#changelog instead.')\n    return this.changelog\n  }",
          "start": {
            "line": 562,
            "column": 2
          },
          "end": {
            "line": 565,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "recordCount": {
          "type": "property",
          "label": "recordCount",
          "description": null,
          "code": "get recordCount () {\n    NGN.WARN('recordCount is deprecated. Use NGN.DATA.Store#size instead.')\n    return this.size\n  }",
          "start": {
            "line": 568,
            "column": 2
          },
          "end": {
            "line": 571,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "size": {
          "type": "property",
          "label": "size",
          "description": null,
          "code": "get size () {\n    return this.PRIVATE.ACTIVERECORDS.size\n  }",
          "start": {
            "line": 578,
            "column": 2
          },
          "end": {
            "line": 580,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "length": {
          "type": "property",
          "label": "length",
          "description": null,
          "code": "get length () {\n    return this.METADATA.records.length\n  }",
          "start": {
            "line": 587,
            "column": 2
          },
          "end": {
            "line": 589,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "first": {
          "type": "property",
          "label": "first",
          "description": null,
          "code": "get first () {\n    let record = NGN.coalesce(this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n\n    return this.PRIVATE.convertStubToRecord(this.METADATA.FIRSTRECORDINDEX, record)\n    // return NGN.coalesce(this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n  }",
          "start": {
            "line": 596,
            "column": 2
          },
          "end": {
            "line": 601,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "last": {
          "type": "property",
          "label": "last",
          "description": null,
          "code": "get last () {\n    let record = NGN.coalesce(this.METADATA.records[this.METADATA.LASTRECORDINDEX])\n\n    return this.PRIVATE.convertStubToRecord(this.METADATA.LASTRECORDINDEX, record)\n  }",
          "start": {
            "line": 608,
            "column": 2
          },
          "end": {
            "line": 612,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "data": {
          "type": "property",
          "label": "data",
          "description": null,
          "code": "get data () {\n    const recordList = this.PRIVATE.ACTIVERECORDS\n\n    // If no records exist, skip\n    if (recordList.size === 0) {\n      return []\n    }\n\n    let rec = this.PRIVATE.convertStubToRecord(this.METADATA.FIRSTRECORDINDEX, this.METADATA.records[this.METADATA.FIRSTRECORDINDEX])\n\n    if (this.METADATA.MAP === null) {\n      this.METADATA.MAP = NGN.coalesce(rec.MAP)\n    }\n\n    let defaults = null\n\n    if (rec instanceof NGN.DATA.Entity) {\n      let fieldDefinitions = rec.fieldDefinitions\n      let fields = Object.keys(fieldDefinitions)\n\n      defaults = {}\n\n      fields.forEach(field => {\n        if (!fieldDefinitions[field].hidden && !fieldDefinitions[field].virtual) {\n          defaults[field] = fieldDefinitions[field].default\n        }\n      })\n    }\n\n    const result = []\n    // const fields = defaults !== null ? Object.keys(defaults) : []\n\n    // Iterate through set\n    recordList.forEach(index => {\n      if (this.METADATA.records[index] !== null) {\n        // If the value is a stub, map it.\n        if (this.METADATA.records[index].hasOwnProperty(this.PRIVATE.STUB)) {\n          let applicableData = Object.assign({}, defaults)\n          let data = Object.assign(applicableData, this.METADATA.records[index].metadata)\n\n          if (this.METADATA.MAP !== null) {\n            result.push(this.METADATA.MAP.applyInverseMap(data))\n          } else {\n            result.push(data)\n          }\n        } else {\n          result.push(this.METADATA.records[index].data)\n        }\n      }\n    })\n\n    return result\n  }",
          "start": {
            "line": 620,
            "column": 2
          },
          "end": {
            "line": 672,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "representation": {
          "type": "property",
          "label": "representation",
          "description": null,
          "code": "get representation () {\n    const result = []\n    const recordList = this.PRIVATE.ACTIVERECORDS\n\n    recordList.forEach(index => {\n      if (this.METADATA.records[index] !== null) {\n        result.push(this.METADATA.records[index].representation)\n      }\n    })\n\n    return result\n  }",
          "start": {
            "line": 679,
            "column": 2
          },
          "end": {
            "line": 690,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "auditable": {
          "type": "property",
          "label": "auditable",
          "description": null,
          "code": "set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n    }\n  }",
          "start": {
            "line": 696,
            "column": 2
          },
          "end": {
            "line": 703,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "model": {
          "type": "property",
          "label": "model",
          "description": null,
          "code": "get model () {\n    return this.METADATA.Model\n  }",
          "start": {
            "line": 705,
            "column": 2
          },
          "end": {
            "line": 707,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "map": {
          "type": "property",
          "label": "map",
          "description": null,
          "code": "get map () {\n    return this.METADATA.MAP\n  }",
          "start": {
            "line": 719,
            "column": 2
          },
          "end": {
            "line": 721,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "indexedFieldNames": {
          "type": "property",
          "label": "indexedFieldNames",
          "description": null,
          "code": "get indexedFieldNames () {\n    if (this.METADATA.INDEXFIELDS) {\n      return Array.from(this.METADATA.INDEXFIELDS)\n    } else {\n      return []\n    }\n  }",
          "start": {
            "line": 727,
            "column": 2
          },
          "end": {
            "line": 733,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "url": {
          "type": "property",
          "label": "url",
          "description": "The URL where the request will be sent.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "crossOriginRequest": {
          "type": "property",
          "label": "crossOriginRequest",
          "description": "Indicates the request will be made to a domain outside of the\none hosting the request.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "boolean",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "username": {
          "type": "property",
          "label": "username",
          "description": "The username that will be used in any basic authentication operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "password": {
          "type": "property",
          "label": "password",
          "description": "It is possible to set a password for any basic authentication operations,\nbut it is not possible to read a password.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "accessToken": {
          "type": "property",
          "label": "accessToken",
          "description": "Supply a bearer access token for basic authenticaiton operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (cfg = {}) {\n    if (NGN.typeof(cfg) === 'model') {\n      cfg = { model: cfg }\n    } else if (!cfg.model || NGN.typeof(cfg.model) !== 'model') {\n      throw new InvalidConfigurationError('Missing or invalid \"model\" configuration property.')\n    }\n\n    super()\n\n    const me = this\n\n    Object.defineProperties(this, {\n      /**\n       * @cfgproperty {string} [name]\n       * A descriptive name for the store. This is typically used for\n       * debugging, logging, and (somtimes) data proxies.\n       */\n      name: NGN.const(NGN.coalesce(cfg.name, 'Untitled Data Store')),\n\n      METADATA: NGN.private({\n        // Holds the models/records\n        records: [],\n\n        /**\n         * @cfgproperty {NGN.DATA.Model} model\n         * An NGN Data Model to which data records conform.\n         */\n        Model: NGN.coalesce(cfg.model),\n\n        /**\n         * @cfg {boolean} [allowDuplicates=true]\n         * Set to `false` to prevent duplicate records from being added.\n         * If a duplicate record is added, it will be ignored and an\n         * error will be thrown.\n         *\n         * **Identifying duplicates _may_ be slow** on data sets with 200+ records.\n         * Uniqueness is determined by a checksum of the current NGN.DATA.Model#data\n         * of a record. The amount of time required to generate a checksum can range\n         * from 3ms to 150ms per record depending on data complexity.\n         *\n         * In most scenarios, the performance impact will be negligible/indistinguishable\n         * to the naked eye. However; if an application experiences slow data\n         * load or processing times, setting this to `false` may help.\n         */\n        allowDuplicates: NGN.coalesce(cfg.allowDuplicates, true),\n\n        /**\n         * @cfg {boolean} [errorOnDuplicate=false]\n         * Set to `true` to throw an error when a duplicate record is detected.\n         * If this is not set, it will default to the value of #allowDuplicates.\n         * If #allowDuplicates is not defined either, this will be `true`\n         */\n        errorOnDuplicate: NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, false),\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * Allow invalid records to be added to the store.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {boolean} [errorOnInvalid=false]\n         * Set to `true` to throw an error when an attempt is made to add an\n         * invalid record.\n         */\n        errorOnInvalid: NGN.coalesce(cfg.errorOnInvalid, cfg.allowInvalid, false),\n\n        /**\n         * @cfgproperty {boolean} [autoRemoveExpiredRecords=true]\n         * When set to `true`, the store will automatically delete expired records.\n         */\n        autoRemoveExpiredRecords: NGN.coalesce(cfg.autoRemoveExpiredRecords, true),\n\n        /**\n         * @cfg {boolean} [softDelete=false]\n         * When set to `true`, the store makes a copy of a record before removing\n         * it from the store. The store will still emit a `record.delete` event,\n         * and it will still behanve as though the record has been completely\n         * removed. However; the record copy can be retrieved using the #restore\n         * method.\n         *\n         * Since it is not always desirable to store a copy of every deleted\n         * record indefinitely, it is possible to expire and permanently remove\n         * records by setting the #softDeleteTtl.\n         *\n         * ```js\n         * var People = new NGN.DATA.Store({\n         *   model: Person,\n         *   softDelete: true,\n         *   softDeleteTtl: 10000\n         * })\n         *\n         * People.add(somePerson)\n         *\n         * var removedRecordId\n         * People.once('record.delete', function (record) {\n         *   removedRecordId = record.id\n         * })\n         *\n         * People.remove(somePerson)\n         *\n         * setTimeout(function () {\n         *   People.restore(removedRecordId)\n         * }, 5000)\n         *\n         * ```\n         *\n         * The code above creates a new store and adds a person to it.\n         * Then a placeholder variable (`removedRecordId`) is created.\n         * Next, a one-time event listener is added to the store, specifically\n         * for handling the removal of a record. Then the record is removed,\n         * which triggers the `record.delete` event, which populates\n         * `removedRecordId` with the ID of the record that was deleted.\n         * Finally, the code waits for 5 seconds, then restores the record. If\n         * the #restore method _wasn't_ called, the record would be purged\n         * from memory after 10 seconds (because `softDeleteTtl` is set to 10000\n         * milliseconds).\n         */\n        softDelete: NGN.coalesce(cfg.softDelete, false),\n\n        /**\n         * @cfg {number} [softDeleteTtl=-1]\n         * This is the number of milliseconds the store waits before purging a\n         * soft-deleted record from memory. `-1` = Infinite (no TTL).\n         */\n        softDeleteTtl: NGN.coalesce(cfg.softDeleteTtl, -1),\n\n        // ARCHIVE contains soft deleted records\n\n        /**\n         * @cfg {Number} [FIFO=-1]\n         * Configures the store to use \"**F**irst **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the oldest record (i.e. the 1st). This guarantees the\n         * store will never have more than 10 records at any given time and it\n         * will always maintain the latest records.\n         *\n         * FIFO and LIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. FIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        fifo: NGN.coalesce(cfg.FIFO, -1),\n\n        /**\n         * @cfg {Number} [LIFO=-1]\n         * Configures the store to use \"**L**ast **I**n **F**irst **O**ut\"\n         * record processing when it reaches a maximum number of records.\n         *\n         * This methos acts in the opposite manner as #FIFO. However; for\n         * all intents and purposes, this merely replaces the last record in\n         * the store when a new record is added.\n         *\n         * For example, assume `FIFO=10`. When the 11th record is added, it\n         * will replace the latest record (i.e. the 10th). This guarantees the\n         * store will never have more than 10 records at any given time. Every\n         * time a new record is added (assuming the store already has the maximum\n         * allowable records), it replaces the last record (10th) with the new\n         * record.\n         *\n         * LIFO and FIFO cannot be applied at the same time.\n         *\n         * **BE CAREFUL** when using this in combination with #insert,\n         * #insertBefore, or #insertAfter. LIFO is applied _after_ the record\n         * is added to the store but _before_ it is moved to the desired index.\n         */\n        lifo: NGN.coalesce(cfg.LIFO, -1),\n\n        /**\n         * @cfg {Number} [maxRecords=-1]\n         * Setting this will prevent new records from being added past this limit.\n         * Attempting to add a record to the store beyond it's maximum will throw\n         * an error.\n         */\n        maxRecords: NGN.coalesce(cfg.maxRecords, -1),\n\n        /**\n         * @cfg {Number} [minRecords=0]\n         * Setting this will prevent removal of records if the removal would\n         * decrease the count below this limit.\n         * Attempting to remove a record below the store's minimum will throw\n         * an error.\n         */\n        minRecords: NGN.coalesce(cfg.minRecords, 0),\n\n        /**\n         * @cfg {Number} [autocompact=50000]\n         * Identify the number of deletions that should occur before\n         * the store is compacted. See #compact. Set this to any value\n         * below `100` (the minimum) to disable autocompact.\n         */\n        autocompact: NGN.coalesce(cfg.autocompact, 50000),\n\n        /**\n         * @cfgproperty {object} fieldmap\n         * An object mapping model attribute names to data storage field names.\n         *\n         * _Example_\n         * ```\n         * {\n         *   ModelFieldName: 'inputName',\n         *   father: 'dad',\n         *   email: 'eml',\n         *   image: 'img',\n         *   displayName: 'dn',\n         *   firstName: 'gn',\n         *   lastName: 'sn',\n         *   middleName: 'mn',\n         *   gender: 'sex',\n         *   dob: 'bd'\n         * }\n         * ```\n         */\n        MAP: NGN.coalesce(cfg.fieldmap),\n\n        EVENTS: new Set([\n          'record.duplicate',\n          'record.create',\n          'record.update',\n          'record.delete',\n          'record.restored',\n          'record.purged',\n          'record.move',\n          'record.invalid',\n          'record.valid',\n          'clear',\n          'filter.create',\n          'filter.delete',\n          'index.create',\n          'index.delete',\n          'compact.start',\n          'compact.complete'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\n        AUDIT_HANDLER: (change) => {\n          if (change.hasOwnProperty('cursor')) {\n            this.METADATA.AUDITLOG.commit(this.METADATA.getAuditMap())\n          }\n        },\n\n        // The first and last indexes are maintained to determine which active\n        // record is considered first/last. Sometimes data is filtered out,\n        // so the first/last active record is not guaranteed to represent the\n        // first/last actual record. These indexes are maintained to prevent\n        // unnecessary iteration in large data sets.\n        FIRSTRECORDINDEX: 0,\n        LASTRECORDINDEX: 0,\n\n        /**\n         * @cfg {array} [index]\n         * An array of #model fields that will be indexed.\n         * See NGN.DATA.Index for details.\n         */\n        INDEX: null\n      }),\n\n      // Internal attributes that should not be extended.\n      PRIVATE: NGN.privateconst({\n        STUB: Symbol('record.stub'),\n\n        // A private indexing method\n        INDEX: function (record, delta) {\n          if (typeof this.event === 'symbol') {\n            switch (this.event) {\n              case me.PRIVATE.EVENT.CREATE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(record[field], record.OID))\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD:\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].remove(record.OID, record[field]))\n                break\n\n              case me.PRIVATE.EVENT.LOAD_RECORDS:\n                for (let i = 0; i < me.METADATA.records.length; i++) {\n                  me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].add(me.METADATA.records[i][field], me.METADATA.records[i].OID))\n                }\n\n                break\n\n              case me.PRIVATE.EVENT.DELETE_RECORD_FIELD:\n                if (me.METADATA.INDEXFIELDS.has(record.field.name)) {\n                  me.METADATA.INDEX[record.field.name].remove(record.record.OID, record.field.value)\n                }\n\n                break\n            }\n          } else {\n            switch (this.event) {\n              case 'record.update':\n                if (me.METADATA.INDEXFIELDS.has(delta.field.name)) {\n                  me.METADATA.INDEX[delta.field.name].update(record.OID, delta.old, delta.new)\n                }\n                break\n\n              case 'clear':\n                me.METADATA.INDEXFIELDS.forEach(field => me.METADATA.INDEX[field].reset())\n                break\n            }\n          }\n        },\n\n        // Contains a map of all records\n        RECORDMAP: new Map(),\n\n        // A reference to active records\n        ACTIVERECORDMAP: null,\n\n        // A reference to filtered records (non-active/non-deleted)\n        FILTEREDRECORDMAP: null,\n\n        // Internal events\n        EVENT: {\n          CREATE_RECORD: Symbol('record.create'),\n          DELETE_RECORD: Symbol('record.delete'),\n          DELETE_RECORD_FIELD: Symbol('records.field.delete'),\n          LOAD_RECORDS: Symbol('records.load')\n        },\n\n        // Makes sure the model configuration specifies a valid and indexable field.\n        checkModelIndexField: (field) => {\n          let metaconfig = this.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields && metaconfig.fields.hasOwnProperty(field)) {\n            if (metaconfig.fields[field] !== null) {\n              if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(metaconfig.fields[field])) >= 0) {\n                throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n              } else if (NGN.typeof(metaconfig.fields[field]) === 'object') {\n                if (['model', 'store', 'entity', 'function'].indexOf(NGN.typeof(NGN.coalesce(metaconfig.fields[field].type))) >= 0) {\n                  throw new Error(`Cannot create index for \"${field}\" field. Only basic NGN.DATA.Field types can be indexed. Relationship and virtual fields cannot be indexed.`)\n                }\n              }\n            }\n          } else {\n            throw new Error(`Cannot create index for unrecognized field \"${field}\".`)\n          }\n        },\n\n        // Get the type of field from the model definition\n        getModelFieldType: (field) => {\n          let metaconfig = this.METADATA.Model.prototype.CONFIGURATION\n\n          if (metaconfig.fields[field] === null) {\n            return NGN.typeof(metaconfig.fields[field])\n          }\n\n          if (metaconfig.fields[field].type) {\n            return NGN.typeof(metaconfig.fields[field].type)\n          }\n\n          if (metaconfig.fields[field].default) {\n            return NGN.typeof(metaconfig.fields[field].default)\n          }\n\n          return NGN.typeof(NGN.coalesce(metaconfig.fields[field]))\n        },\n\n        // Add a record\n        addRecord: (data, suppressEvents = false) => {\n          const record = new me.METADATA.Model(data)\n\n          if (!(record instanceof NGN.DATA.Entity)) {\n            throw new Error(`Only a NGN.DATA.Model or JSON object may be used in NGN.DATA.Store#add. Received a \"${NGN.typeof(data)}\" value.`)\n          }\n\n          // Prevent invalid record addition (if configured)\n          if (!me.METADATA.allowInvalid && !record.valid) {\n            NGN.WARN(`An attempt to add invalid data to the \"${this.name}\" store was prevented. The following fields are invalid: ${Array.from(record.METADATA.invalidFieldNames.keys()).join(', ')}`)\n\n            if (!suppressEvents) {\n              this.emit('record.invalid', record)\n            }\n\n            if (this.METADATA.errorOnInvalid) {\n              throw new Error(`Invalid data cannot be added to the \"${this.name}\" store.`)\n            }\n          }\n\n          // If duplicates are prevented, check the new data.\n          if (!me.METADATA.allowDuplicates) {\n            for (let i = 0; i < this.METADATA.records.length; i++) {\n              if (this.METADATA.records[i].checksum === record.checksum) {\n                NGN.WARN(`An attempt to add a duplicate record to the \"${this.name}\" store was prevented.`)\n\n                if (!suppressEvents) {\n                  this.emit('record.duplicate', record)\n                }\n\n                if (this.METADATA.errorOnDuplicate) {\n                  throw new Error(`Duplicate records are not allowed in the \"${this.name}\" data store.`)\n                }\n\n                break\n              }\n            }\n          }\n\n          // Handle special record count processing (LIFO/FIFO support)\n          if (me.METADATA.lifo > 0 && me.METADATA.records.length + 1 > me.METADATA.lifo) {\n            me.remove(me.METADATA.records.length - 1, suppressEvents)\n          } else if (this.METADATA.fifo > 0 && me.METADATA.records.length + 1 > me.METADATA.fifo) {\n            me.remove(0, suppressEvents)\n          }\n\n          // Relay model events to this store.\n          // record.relay('*', this, 'record.')\n          record.on('*', function () {\n            switch (this.event) {\n              // case 'field.update':\n              // case 'field.delete':\n              //   // TODO: Update indices\n              //   return\n\n              case 'field.invalid':\n              case 'field.valid':\n                return me.emit(this.event.replace('field.', 'record.'), record)\n\n              case 'expired':\n                // TODO: Handle expiration\n            }\n          })\n\n          delete record.METADATA.store\n          Object.defineProperty(record.METADATA, 'store', NGN.get(() => me))\n\n          // Indexing is handled in an internal event handler\n          me.METADATA.records.push(record)\n\n          // Add the record to the map for efficient retrievel by OID\n          me.PRIVATE.RECORDMAP.set(record.OID, me.METADATA.records.length - 1)\n\n          return record\n        },\n\n        convertStubToRecord: (index, record) => {\n          if (record.hasOwnProperty(this.PRIVATE.STUB)) {\n            let newRecord = this.PRIVATE.addRecord(record.metadata, false)\n            newRecord.OID = record.OID\n\n            this.METADATA.records[index] = newRecord\n\n            return newRecord\n          } else {\n            return record\n          }\n        }\n      }),\n\n      // Create a convenience alias for the remove method.\n      delete: NGN.const(NGN.deprecate(this.remove, 'Store.delete is deprecated. Use Store.remove instead.'))\n    })\n\n    // Create a smart reference to record lists\n    Object.defineProperties(this.PRIVATE, {\n      ACTIVERECORDS: NGN.get(() => {\n        if (this.PRIVATE.ACTIVERECORDMAP === null) {\n          return this.PRIVATE.RECORDMAP\n        }\n\n        return this.PRIVATE.ACTIVERECORDMAP\n      }),\n\n      FILTEREDRECORDS: NGN.get(() => {\n        if (this.PRIVATE.FILTEREDRECORDMAP === null) {\n          return this.PRIVATE.RECORDMAP\n        }\n\n        return this.PRIVATE.FILTEREDRECORDMAP\n      })\n    })\n\n    // Disallow modification of internal events\n    Object.freeze(this.PRIVATE.EVENT)\n\n    // Support LIFO (Last In First Out) & FIFO(First In First Out)\n    if (this.METADATA.lifo > 0 && this.METADATA.fifo > 0) {\n      throw new InvalidConfigurationError('NGN.DATA.Store can be configured to use FIFO or LIFO, but not both simultaneously.')\n    }\n\n    // If LIFO/FIFO is used, disable alternative record count limitations.\n    if (this.METADATA.lifo > 0 || this.METADATA.fifo > 0) {\n      this.METADATA.minRecords = 0\n      this.METADATA.maxRecords = -1\n    } else {\n      this.METADATA.minRecords = this.METADATA.minRecords < 0 ? 0 : this.METADATA.minRecords\n    }\n\n    // Bubble events to the BUS\n    // this.relay('*', NGN.BUS, 'store.')\n\n    // Configure Indices\n    if (NGN.coalesce(cfg.index) && NGN.typeof(this.METADATA.Model.prototype.CONFIGURATION.fields) === 'object') {\n      this.createIndex(cfg.index)\n    }\n\n    // Setup auto-compact\n    if (this.METADATA.autocompact < 100) {\n      this.METADATA.DELETECOUNT = 0\n      this.on(this.PRIVATE.EVENTS.DELETE_RECORD, () => {\n        this.METADATA.DELETECOUNT++\n\n        if (this.METADATA >= this.METADATA.autocompact) {\n          this.METADATA.DELETECOUNT = 0\n          this.compact()\n        }\n      })\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 33,
            "column": 2
          },
          "end": {
            "line": 549,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg = {}",
              "start": {
                "line": 33,
                "column": 15
              },
              "end": {
                "line": 33,
                "column": 23
              },
              "flags": [],
              "default": "{}",
              "datatype": "object",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "add": {
          "type": "method",
          "label": "add",
          "description": "Append a data record to the store. This adds the record to the end of the list.",
          "code": "add (data, suppressEvents = false) {\n    // Support array input\n    if (NGN.typeof(data) === 'array') {\n      let result = new Array(data.length)\n\n      for (let i = 0; i < data.length; i++) {\n        result[i] = this.add(data[i], suppressEvents)\n      }\n\n      return result\n    }\n\n    // Prevent creation if it will exceed maximum record count.\n    if (this.METADATA.maxRecords > 0 && this.METADATA.records.length + 1 > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    if (!(data instanceof this.METADATA.Model)) {\n      // Force a data model\n      if (NGN.typeof(data) === 'string') {\n        data = JSON.parse(data)\n      }\n\n      if (typeof data !== 'object') {\n        throw new Error(`${NGN.typeof(data)} is an invalid data type (must be an object conforming to the ${this.METADATA.Model.name} field configuration).`)\n      }\n    } else {\n      data = data.data\n    }\n\n    const record = this.PRIVATE.addRecord(data)\n\n    // TODO: Apply filters to new record before identifying the last record.\n    this.METADATA.LASTRECORDINDEX = this.METADATA.records.length - 1\n\n    this.emit(this.PRIVATE.EVENT.CREATE_RECORD, record)\n\n    if (!suppressEvents) {\n      this.emit('record.create', record)\n    }\n\n    return record\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 748,
            "column": 2
          },
          "end": {
            "line": 790,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "data": {
              "type": "argument",
              "label": "data",
              "description": null,
              "code": "data",
              "start": {
                "line": 748,
                "column": 7
              },
              "end": {
                "line": 748,
                "column": 11
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": "Set this to `true` to prevent the `record.create` event\nfrom firing.",
              "code": "@param {boolean} [suppressEvents=false]\nSet this to `true` to prevent the `record.create` event\nfrom firing.",
              "start": {
                "line": 748,
                "column": 2
              },
              "end": {
                "line": 790,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "NGN.DATA.Model",
          "returnDescription": "null Returns the new record.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "remove": {
          "type": "method",
          "label": "remove",
          "description": "Remove a record.",
          "code": "remove (record, suppressEvents = false) {\n    // Short-circuit processing if there are no records.\n    if (this.METADATA.records.length === 0) {\n      NGN.INFO(`\"${this.name}\" store called remove(), but the store contains no records.`)\n      return\n    }\n\n    // Support removal of simultaneously removing multiple records\n    if (NGN.typeof(record) === 'array') {\n      let result = new Array(record.length)\n\n      for (let i = 0; i < record.length; i++) {\n        result[i] = this.remove(record[i])\n      }\n\n      return result\n    }\n\n    // Prevent removal if it will exceed minimum record count.\n    if (this.minRecords > 0 && this.METADATA.records.length - 1 < this.minRecords) {\n      throw new Error('Removing this record would violate the minimum record count.')\n    }\n\n    // Identify which record will be removed.\n    let index\n\n    switch (NGN.typeof(record)) {\n      case 'number':\n        if (record < 0 || !this.METADATA.records[record]) {\n          NGN.ERROR(`Record removal failed (record not found at index ${(record || 'undefined').toString()}).`)\n          return null\n        }\n\n        index = record\n\n        break\n\n      // The default case comes before the symbol case specifically\n      // so the record can be converted to an OID value (for use with\n      // the RECORDMAP lookup).\n      default:\n        if (!(record instanceof NGN.DATA.Entity)) {\n          NGN.ERROR('Invalid record value passed to Store.remove() method.')\n          return null\n        }\n\n        record = record.OID\n\n      case 'symbol': // eslint-disable-line no-fallthrough\n        index = this.PRIVATE.ACTIVERECORDS.get(record)\n\n        if (index < 0) {\n          NGN.ERROR(`Record removal failed. Record OID not found (\"${record.toString()}\").`)\n          return null\n        }\n\n        break\n    }\n\n    // If nothing has been deleted yet, create an active record map.\n    // The active record map contains Model OID values with a reference\n    // to the actual record index.\n    if (this.PRIVATE.ACTIVERECORDMAP === null) {\n      // Copy the record map to initialize the active records\n      this.PRIVATE.ACTIVERECORDMAP = new Map(this.PRIVATE.RECORDMAP)\n    }\n\n    // Identify the record to be removed.\n    const removedRecord = this.METADATA.records[index]\n\n    // If the record isn't among the active records, do not remove it.\n    if (removedRecord === null) {\n      NGN.WARN('Specified record does not exist.')\n      return null\n    }\n\n    let activeIndex = this.PRIVATE.ACTIVERECORDS.get(removedRecord.OID)\n\n    if (isNaN(activeIndex)) {\n      NGN.WARN(`Record not found for \"${removedRecord.OID.toString()}\".`)\n      return null\n    }\n\n    this.PRIVATE.ACTIVERECORDS.delete(removedRecord.OID)\n\n    // If the store is configured to soft-delete,\n    // don't actually remove it until it expires.\n    if (this.METADATA.softDelete) {\n      if (this.METADATA.softDeleteTtl >= 0) {\n        removedRecord.once('expired', () => {\n          this.METADATA.records[this.PRIVATE.RECORDMAP.get(removedRecord.OID)] = null\n          this.PRIVATE.RECORDMAP.delete(removedRecord.OID)\n\n          if (!suppressEvents) {\n            this.emit('record.purge', removedRecord)\n          }\n        })\n\n        removedRecord.expires = this.METADATA.softDeleteTtl\n      }\n    } else {\n      this.METADATA.records[this.PRIVATE.RECORDMAP.get(removedRecord.OID)] = null\n      this.PRIVATE.RECORDMAP.delete(removedRecord.OID)\n    }\n\n    // Update cursor indexes (to quickly reference first and last active records)\n    if (this.METADATA.LASTRECORDINDEX === activeIndex) {\n      if (this.PRIVATE.ACTIVERECORDS.size <= 1) {\n        this.METADATA.LASTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.values().next().value\n        this.METADATA.FIRSTRECORDINDEX = this.METADATA.LASTRECORDINDEX\n      } else if (activeIndex !== 0) {\n        for (let i = (activeIndex - 1); i >= 0; i--) {\n          if (i === 0) {\n            this.METADATA.LASTRECORDINDEX = 0\n            break\n          }\n\n          const examinedRecord = this.METADATA.records[i]\n\n          if (examinedRecord !== null) {\n            if (this.PRIVATE.ACTIVERECORDS.has(examinedRecord.OID)) {\n              this.METADATA.LASTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.get(examinedRecord.OID)\n              break\n            }\n          }\n        }\n      }\n    } else if (this.METADATA.FIRSTRECORDINDEX === activeIndex) {\n      let totalSize = this.PRIVATE.ACTIVERECORDS.size\n\n      for (let i = (activeIndex + 1); i < totalSize; i++) {\n        const examinedRecord = this.METADATA.records[i]\n\n        if (examinedRecord !== null) {\n          if (this.PRIVATE.ACTIVERECORDS.has(examinedRecord.OID)) {\n            this.METADATA.FIRSTRECORDINDEX = this.PRIVATE.ACTIVERECORDS.get(examinedRecord.OID)\n            break\n          }\n        }\n      }\n    }\n\n    this.emit(this.PRIVATE.EVENT.DELETE_RECORD, removedRecord)\n\n    if (!suppressEvents) {\n      this.emit('record.delete', removedRecord)\n    }\n\n    return removedRecord\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 811,
            "column": 2
          },
          "end": {
            "line": 960,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "record": {
              "type": "argument",
              "label": "record",
              "description": null,
              "code": "record",
              "start": {
                "line": 811,
                "column": 10
              },
              "end": {
                "line": 811,
                "column": 16
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "record",
              "description": "Accepts an existing NGN Data Model or index number.\nUsing a model is slower than using an index number.\nThis may also be the NGN.DATA.Model#OID value (for\nadvanced use cases).",
              "code": "suppressEvents = false",
              "start": {
                "line": 811,
                "column": 18
              },
              "end": {
                "line": 811,
                "column": 40
              },
              "flags": [],
              "default": null,
              "datatype": "ngn.data.model|number|symbol",
              "required": true,
              "enum": null
            }
          },
          "returnType": "NGN.DATA.Model",
          "returnDescription": "null Returns the data model that was just removed. If a model\nis unavailable ,\nthis will return `null`.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "createIndex": {
          "type": "method",
          "label": "createIndex",
          "description": "Create a new index on the store.\n  \n  The name of the field to index.\n  \n  Triggered when an index is created. The name of field is passed\n  as the only argument.",
          "code": "createIndex (field) {\n    // Support multiple indexes\n    if (NGN.typeof(field) === 'array') {\n      for (let i = 0; i < field.length; i++) {\n        this.createIndex(field[i])\n      }\n\n      return\n    }\n\n    // Make sure index fields are known to the store\n    if (!this.METADATA.INDEXFIELDS) {\n      this.METADATA.INDEXFIELDS = new Set()\n\n      // this.on('record.*', this.PRIVATE.INDEX)\n      this.on([\n        this.PRIVATE.EVENT.CREATE_RECORD,\n        this.PRIVATE.EVENT.DELETE_RECORD,\n        this.PRIVATE.EVENT.LOAD_RECORDS,\n        this.PRIVATE.EVENT.DELETE_RECORD_FIELD,\n        'clear'\n      ], this.PRIVATE.INDEX)\n    }\n\n    // In an index already exists, ignore it.\n    if (this.METADATA.INDEXFIELDS.has(field)) {\n      return\n    }\n\n    // Guarantee the existance of the index list\n    this.METADATA.INDEX = NGN.coalesce(this.METADATA.INDEX, {})\n\n    this.PRIVATE.checkModelIndexField(field)\n\n    this.METADATA.INDEXFIELDS.add(field)\n\n    // Identify BTree\n    let btree = ['number', 'date'].indexOf(this.PRIVATE.getModelFieldType(field)) >= 0\n\n    this.METADATA.INDEX[field] = new NGN.DATA.Index(btree, `${field.toUpperCase()} ${btree ? 'BTREE ' : ''}INDEX`)\n\n    // Apply to any existing records\n    if (this.METADATA.records.length > 0) {\n      this.PRIVATE.INDEX.apply({ event: this.PRIVATE.EVENT.LOAD_RECORDS })\n    }\n\n    this.emit('index.created', field)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 970,
            "column": 2
          },
          "end": {
            "line": 1017,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "field": {
              "type": "argument",
              "label": "field",
              "description": "The name of the field to index.",
              "code": "@param  {string} field\nThe name of the field to index.",
              "start": {
                "line": 970,
                "column": 2
              },
              "end": {
                "line": 1017,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeIndex": {
          "type": "method",
          "label": "removeIndex",
          "description": "Remove an existing index from the store.\n  \n  The name of the indexed field. Set this to `null` (or leave blank) to\n  remove all existing indexes.\n  \n  Triggered when an index is removed. The name of field is passed\n  as the only argument.",
          "code": "removeIndex (field = null) {\n    if (!this.METADATA.INDEXFIELDS) {\n      return\n    }\n\n    if (NGN.coalesce(field) === null) {\n      field = this.indexedFieldNames\n    }\n\n    // Support multiple indexes\n    if (NGN.typeof(field) === 'array') {\n      for (let i = 0; i < field.length; i++) {\n        this.removeIndex(field[i])\n      }\n\n      return\n    }\n\n    // Remove the specific index.\n    this.METADATA.INDEXFIELDS.delete(field)\n    delete this.METADATA.INDEX[field]\n    this.emit('index.delete', field)\n\n    // When there are no more indexes, clear out event\n    // listeners and fields.\n    if (this.METADATA.INDEXFIELDS.size === 0) {\n      this.METADATA.INDEX = null\n      delete this.METADATA.INDEXFIELDS\n\n      this.off([\n        this.PRIVATE.EVENT.CREATE_RECORD,\n        this.PRIVATE.EVENT.DELETE_RECORD,\n        this.PRIVATE.EVENT.LOAD_RECORDS,\n        this.PRIVATE.EVENT.DELETE_RECORD_FIELD\n      ], this.PRIVATE.INDEX)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1028,
            "column": 2
          },
          "end": {
            "line": 1064,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "field": {
              "type": "argument",
              "label": "field",
              "description": "The name of the indexed field. Set this to `null`  to\nremove all existing indexes.",
              "code": "@param  {string} [field=null]\nThe name of the indexed field. Set this to `null` (or leave blank) to\nremove all existing indexes.",
              "start": {
                "line": 1028,
                "column": 2
              },
              "end": {
                "line": 1064,
                "column": 3
              },
              "flags": [],
              "default": "null",
              "datatype": "string",
              "required": false,
              "enum": [
                "or leave blank"
              ]
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getRecordSibling": {
          "type": "method",
          "label": "getRecordSibling",
          "description": "Retrieve a record based on it's relative position to another\n  record. This method is used by NGN.DATA.Model#next and NGN.DATA.Model#previous\n  to support \"doubly linked list\" approach to record iteration.",
          "code": "getRecordSibling (currentRecord, count = 1, cycle = false) {\n    let size = this.size\n\n    if (size === 0) {\n      NGN.WARN('Attempted to execute getRecordSibling with no active records.')\n      return null\n    }\n\n    // Make sure the iterator fits within the range\n    if (Math.abs(count) > size) {\n      count = count % size\n    }\n\n    if (size === 1 || count === 0) {\n      return currentRecord\n    }\n\n    let ActiveRecords = Array.from(this.PRIVATE.ACTIVERECORDS)\n    let currentIndex = ActiveRecords.findIndex(item => currentRecord.OID === item[0])\n\n    if (currentIndex < 0) {\n      throw new Error('Record not found.')\n    }\n\n    currentIndex += count\n\n    // Support cycling through records.\n    if ((currentIndex >= ActiveRecords.length || currentIndex < 0) && cycle) {\n      // Cycle forwards\n      if (count > 0) {\n        currentIndex = currentIndex % ActiveRecords.length\n      } else {\n        // Cycle Backwards\n        currentIndex = ActiveRecords.length - Math.abs(currentIndex)\n      }\n    }\n\n    if (currentIndex < 0 || currentIndex >= ActiveRecords.length) {\n      return null\n    }\n\n    return this.METADATA.records[ActiveRecords[currentIndex][1]]\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1075,
            "column": 2
          },
          "end": {
            "line": 1117,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "currentRecord": {
              "type": "argument",
              "label": "currentRecord",
              "description": null,
              "code": "currentRecord",
              "start": {
                "line": 1075,
                "column": 20
              },
              "end": {
                "line": 1075,
                "column": 33
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "count": {
              "type": "argument",
              "label": "currentRecord",
              "description": "[description]",
              "code": "count = 1",
              "start": {
                "line": 1075,
                "column": 35
              },
              "end": {
                "line": 1075,
                "column": 44
              },
              "flags": [],
              "default": null,
              "datatype": "[type]",
              "required": true,
              "enum": null
            },
            "cycle": {
              "type": "argument",
              "label": "cycle",
              "description": "[description]",
              "code": "@param  {Boolean} [cycle=false] [description]",
              "start": {
                "line": 1075,
                "column": 2
              },
              "end": {
                "line": 1117,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "[type]",
          "returnDescription": "description",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "indexOf": {
          "type": "method",
          "label": "indexOf",
          "description": "Returns the index number of the model. If the same\n  model exists more than once (duplicate records), only\n  the first index is returned.\n  \n  The model/record to retrieve an index number for.\n  \n  The zero-based index number of the model.",
          "code": "indexOf (record) {\n    return this.PRIVATE.RECORDMAP.get(record.OID)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1128,
            "column": 2
          },
          "end": {
            "line": 1130,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "record": {
              "type": "argument",
              "label": "record",
              "description": null,
              "code": "record",
              "start": {
                "line": 1128,
                "column": 11
              },
              "end": {
                "line": 1128,
                "column": 17
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "model": {
              "type": "argument",
              "label": "model",
              "description": "The model/record to retrieve an index number for.",
              "code": "@param  {NGN.DATA.Model} model\nThe model/record to retrieve an index number for.",
              "start": {
                "line": 1128,
                "column": 2
              },
              "end": {
                "line": 1130,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "ngn.data.model",
              "required": true,
              "enum": null
            }
          },
          "returnType": "number",
          "returnDescription": "null The zero-based index number of the model.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "contains": {
          "type": "method",
          "label": "contains",
          "description": "Determine whether the store contains a record.\n  This only checks the active record set (ignores filtered records).\n  \n  The record to test for inclusion.",
          "code": "contains (record) {\n    return this.PRIVATE.ACTIVERECORDS.has(record.OID)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1139,
            "column": 2
          },
          "end": {
            "line": 1141,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "record": {
              "type": "argument",
              "label": "record",
              "description": "The record to test for inclusion.",
              "code": "@param  {NGN.DATA.Model} record\nThe record to test for inclusion.",
              "start": {
                "line": 1139,
                "column": 2
              },
              "end": {
                "line": 1141,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "ngn.data.model",
              "required": true,
              "enum": null
            }
          },
          "returnType": "boolean",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getIndexRecords": {
          "type": "method",
          "label": "getIndexRecords",
          "description": "Get the list of records for the given value.\n  \n  The name of the indexed field.\n  \n  The value of the index field. This is used to lookup\n  the list of records/models whose field is equal to\n  the specified value.\n  \n  Returns an array of models/records within the index for\n  the given value.",
          "code": "getIndexRecords (field, value) {\n    if (this.METADATA.INDEX && this.METADATA.INDEX.hasOwnProperty(field)) {\n      let oid = this.METADATA.INDEX[field].recordsFor(value)\n      let result = new Array(oid.length)\n\n      for (let i = 0; i < oid.length; i++) {\n        result[i] = this.METADATA.records[this.PRIVATE.RECORDMAP.get(oid[i])]\n      }\n\n      return result\n    }\n\n    return []\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1155,
            "column": 2
          },
          "end": {
            "line": 1168,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "field": {
              "type": "argument",
              "label": "field",
              "description": null,
              "code": "field",
              "start": {
                "line": 1155,
                "column": 19
              },
              "end": {
                "line": 1155,
                "column": 24
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "value": {
              "type": "argument",
              "label": "fieldName",
              "description": "The name of the indexed field.",
              "code": "value",
              "start": {
                "line": 1155,
                "column": 26
              },
              "end": {
                "line": 1155,
                "column": 31
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "fieldValue": {
              "type": "argument",
              "label": "fieldValue",
              "description": "The value of the index field. This is used to lookup\nthe list of records/models whose field is equal to\nthe specified value.",
              "code": "@param  {any} fieldValue\nThe value of the index field. This is used to lookup\nthe list of records/models whose field is equal to\nthe specified value.",
              "start": {
                "line": 1155,
                "column": 2
              },
              "end": {
                "line": 1168,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "NGN.DATA.Model[]",
          "returnDescription": "null Returns an array of models/records within the index for\nthe given value.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getRecord": {
          "type": "method",
          "label": "getRecord",
          "description": "Retrieve an active record by index number (0-based, similar to an array).\n  \n  The index of the record to retrieve.",
          "code": "getRecord (index = 0) {\n    if (typeof index === 'symbol') {\n      index = this.PRIVATE.ACTIVERECORDS.get(index)\n    }\n\n    if (index < 0) {\n      NGN.WARN('Cannot retrieve a record for a negative index.')\n      return null\n    }\n\n    if (index >= this.PRIVATE.ACTIVERECORDS.size) {\n      NGN.WARN('Cannot retrieve a record for an out-of-scope index (index greater than total record count.)')\n      return null\n    }\n\n    return this.METADATA.records[Array.from(this.PRIVATE.ACTIVERECORDS)[index][1]]\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1175,
            "column": 2
          },
          "end": {
            "line": 1191,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "index": {
              "type": "argument",
              "label": "index",
              "description": "The index of the record to retrieve.",
              "code": "@param  {number} [index=0]\nThe index of the record to retrieve.",
              "start": {
                "line": 1175,
                "column": 2
              },
              "end": {
                "line": 1191,
                "column": 3
              },
              "flags": [],
              "default": "0",
              "datatype": "number",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "clear": {
          "type": "method",
          "label": "clear",
          "description": "Removes all data. If auditing is enabled, the transaction log is reset.",
          "code": "clear (purge = true, suppressEvents = false) {\n    if (this.METADATA.ARCHIVE) {\n      if (!purge) {\n        this.METADATA.ARCHIVE = this.records\n      } else {\n        delete this.METADATA.ARCHIVE\n      }\n    }\n\n    this.METADATA.records = []\n    this.PRIVATE.RECORDMAP = new Map()\n    this.PRIVATE.ACTIVERECORDMAP = null\n    this.PRIVATE.FILTEREDRECORDMAP = null\n    this.METADATA.LASTRECORDINDEX = 0\n    this.METADATA.FIRSTRECORDINDEX = 0\n\n    if (this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITLOG.reset()\n    }\n\n    // Indexes updated automatically (listening for 'clear' event)\n\n    if (!suppressEvents) {\n      this.emit('clear')\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1203,
            "column": 2
          },
          "end": {
            "line": 1228,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "purge": {
              "type": "argument",
              "label": "purge",
              "description": null,
              "code": "purge = true",
              "start": {
                "line": 1203,
                "column": 9
              },
              "end": {
                "line": 1203,
                "column": 21
              },
              "flags": [],
              "default": true,
              "datatype": "boolean",
              "required": false,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": "Set to `true` to prevent events from triggering when this method is run.",
              "code": "@param {boolean} [suppressEvents=false]\nSet to `true` to prevent events from triggering when this method is run.",
              "start": {
                "line": 1203,
                "column": 2
              },
              "end": {
                "line": 1228,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "clearEvents": {
          "type": "method",
          "label": "clearEvents",
          "description": "A special method to clear events from the underlying event emitter.\n  This exists because #clear has a special meaning in a data store (removing\n  all data records vs removing all events).",
          "code": "clearEvents () {\n    super.clear(...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1236,
            "column": 2
          },
          "end": {
            "line": 1238,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "2.0.0": {
          "type": "method",
          "label": "2.0.0",
          "description": "Replace a model.\n  \n  \n  The new model.",
          "code": "replaceModel (newModel) {\n    NGN.deprecate(\n      () => { this.model = newModel },\n      'replaceModel has been deprected. Set the model directly instead.'\n    )\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1246,
            "column": 2
          },
          "end": {
            "line": 1251,
            "column": 3
          },
          "flags": [
            "2.0.0"
          ],
          "arguments": {
            "newModel": {
              "type": "argument",
              "label": "newModel",
              "description": "The new model.",
              "code": "@param  {NGN.DATA.Model} newModel\nThe new model.",
              "start": {
                "line": 1246,
                "column": 2
              },
              "end": {
                "line": 1251,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "ngn.data.model",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "snapshot": {
          "type": "method",
          "label": "snapshot",
          "description": "Add a snapshot of the current store to the #snapshot archive.\nThis can potentially be a computationally/memory-expensive operation.\nThe method creates a copy of all data in the store along with checksums\nof each element and holds the snapshot in RAM. Large stores may consume\nlarge amounts of RAM until the snapshots are released/cleared.\nSnapshots are most commonly used with data proxies to calculate\ndifferences in a data set before persisting them to a database.",
          "code": "snapshot () {\n    this.METADATA.snapshotarchive = NGN.coalesce(this.METADATA.snapshotarchive, [])\n\n    let data = this.data\n    let dataset = {\n      id: NGN.DATA.UTILITY.GUID(),\n      timestamp: (new Date()).toISOString(),\n      checksum: NGN.DATA.UTILITY.checksum(JSON.stringify(data)).toString(),\n      modelChecksums: this.data.map((item) => {\n        return NGN.DATA.UTILITY.checksum(JSON.stringify(item)).toString()\n      }),\n      data: data\n    }\n\n    this.METADATA.snapshotarchive.unshift(dataset)\n    this.emit('snapshot', dataset)\n\n    return dataset\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1280,
            "column": 2
          },
          "end": {
            "line": 1298,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "object",
          "returnDescription": "null Returns an object containing the following fields:\n\n```js\n{\ntimestamp: 'ex: 2018-01-19T16:43:03.279Z',\nchecksum: 'snapshotchecksum',\nmodelChecksums: [\n'record1_checksum',\n'record2_checksum'\n],\ndata: { ... } // Actual data at the time of the snapshot\n}\n```",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "clearSnapshots": {
          "type": "method",
          "label": "clearSnapshots",
          "description": "Remove all archived snapshots.",
          "code": "clearSnapshots () {\n    this.snapshotarchive = null\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1304,
            "column": 2
          },
          "end": {
            "line": 1306,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "load": {
          "type": "method",
          "label": "load",
          "description": null,
          "code": "load (data) {\n    console.time('load')\n    let insertableData\n\n    // Guarantee unique records amongst only the new records\n    if (!this.METADATA.allowDuplicates) {\n      let uniqueValues = new Set()\n\n      insertableData = []\n\n      for (let i = 0; i < data.length; i++) {\n        if (!uniqueValues.has(JSON.stringify(data[i]))) {\n          uniqueValues.add(JSON.stringify(data[i]))\n          insertableData.push(data[i])\n        } else if (this.METADATA.errorOnDuplicate) {\n          throw new NGNDuplicateRecordError()\n        }\n      }\n    } else {\n      insertableData = data\n    }\n\n    let newRecordCount = insertableData.length + this.METADATA.records.length\n\n    // Don't exceed the maximum record count if it exists.\n    if (this.METADATA.maxRecords > 0 && newRecordCount > this.METADATA.maxRecords) {\n      throw new Error('Maximum record count exceeded.')\n    }\n\n    if (newRecordCount > 4000000) {\n      throw new Error('Maximum load size exceeded. A store may contain a maximum of 4M records.')\n    }\n\n    for (let i = 0; i < insertableData.length; i++) {\n      let oid = Symbol('model.id')\n      this.METADATA.records.push({\n        [this.PRIVATE.STUB]: true,\n        OID: oid,\n        metadata: insertableData[i]\n      })\n\n      // Add the record to the map for efficient retrievel by OID\n      this.PRIVATE.RECORDMAP.set(oid, this.METADATA.records.length - 1)\n    }\n\n    // TODO: Apply filters to new record before identifying the last record.\n    this.METADATA.LASTRECORDINDEX = this.METADATA.records.length - 1\n\n    // this.emit(this.PRIVATE.EVENT.LOAD_RECORDS)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1308,
            "column": 2
          },
          "end": {
            "line": 1357,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "data": {
              "type": "argument",
              "label": "data",
              "description": null,
              "code": "data",
              "start": {
                "line": 1308,
                "column": 8
              },
              "end": {
                "line": 1308,
                "column": 12
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "compact": {
          "type": "method",
          "label": "compact",
          "description": "This rebuilds the local index of records, removing any dead records.\n  While deleted records are destroyed (in accordance to #softDeleteTtl),\n  the active record table contains a `null` or `undefined` value for each\n  deleted/dead record. This method removes such records, akin in nature to\n  the common JavaScript garbage collection process.\n    This method almost never needs to be run, since stores\n  attempt to manage this process for themselves automatically. However; if\n  large volume deletions occur rapidly (50K+), it's possible (though not assured)\n  performance could be negatively impacted. Compacting the store can\n  improve performance in these cases. However; running this too often or\n  excessively may degrade performance since it is essentially rewriting\n  the store data each time.\n    When in doubt,don'tuse this method.\n  \n  existed in the store, due to the inefficient nature at such low volume.\n  \n  Triggered when the compact process begins.\n  \n  Triggered when the compact process completes.",
          "code": "compact () {\n    this.emit('compact.start')\n\n    if (this.METADATA.records.length < 100) {\n      this.emit('compact.complete')\n\n      if (this.METADATA.records.length !== 0) {\n        NGN.WARN(`compact() called on ${this.name} with fewer than 100 elements.`)\n      }\n\n      return\n    }\n\n    let ranges = []\n    let currentRange = []\n    let empty = 0\n\n    // Identify null ranges (dead records)\n    for (let i = 0; i < this.METADATA.records.length; i++) {\n      if (this.METADATA.records[i] === null) {\n        empty++\n\n        if (currentRange.length === 0) {\n          currentRange.push(i)\n        }\n      } else {\n        // Identify new index values for remaining records\n        if (empty > 0) {\n          this.PRIVATE.RECORDMAP.set(this.METADATA.records[i].OID, i - empty)\n\n          if (this.METADATA.FIRSTRECORDINDEX === i) {\n            this.METADATA.FIRSTRECORDINDEX = i - empty\n          }\n\n          if (this.METADATA.LASTRECORDINDEX === i) {\n            this.METADATA.LASTRECORDINDEX = i - empty\n          }\n        }\n\n        if (currentRange.length === 1) {\n          currentRange.push(i - 1)\n          ranges.push(currentRange)\n          currentRange = []\n        }\n      }\n    }\n\n    // Clear null ranges\n    empty = 0\n    while (ranges.length > 0) {\n      this.METADATA.records.splice(ranges[0][0] - empty, ranges[0][1] - ranges[0][0] + 1)\n      empty += ranges[0][1] - ranges[0][0] + 1\n      ranges.shift()\n    }\n\n    // Reset the active record map\n    this.PRIVATE.ACTIVERECORDMAP = null\n\n    this.emit('compact.complete')\n  }",
          "tags": {
            "info": {
              "tag": "info",
              "name": "This",
              "optional": false,
              "description": "method will not run when fewer than 100 cumulative records have\nexisted in the store, due to the inefficient nature at such low volume.",
              "type": "",
              "line": 16,
              "source": "@info This method will not run when fewer than 100 cumulative records have\nexisted in the store, due to the inefficient nature at such low volume.",
              "options": null
            }
          },
          "exceptions": {},
          "start": {
            "line": 1382,
            "column": 2
          },
          "end": {
            "line": 1441,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "forEach": {
          "type": "method",
          "label": "forEach",
          "description": "Performs executes the callback method on each active record\n  within the store. For example:\n    ```js\n  Store.forEach(function (record) {\n    // Do Something\n  })\n  ```\n  \n  The callback method is applied to each record.",
          "code": "forEach (fn) {\n    if (!NGN.isFn(fn)) {\n      throw new Error(`A ${NGN.typeof(fn)} was applied to ${this.name}'s each() method when a function was expected.`)\n    }\n\n    this.PRIVATE.ACTIVERECORDS.forEach((value, key, map) => {\n      fn(this.METADATA.records[value])\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 1455,
            "column": 2
          },
          "end": {
            "line": 1463,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "fn": {
              "type": "argument",
              "label": "fn",
              "description": null,
              "code": "fn",
              "start": {
                "line": 1455,
                "column": 11
              },
              "end": {
                "line": 1455,
                "column": 13
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "The callback method is applied to each record.",
              "code": "@param  {Function} callback\nThe callback method is applied to each record.",
              "start": {
                "line": 1455,
                "column": 2
              },
              "end": {
                "line": 1463,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "hash": {
          "type": "method",
          "label": "hash",
          "description": "The hash part of the URL .",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setHeader": {
          "type": "method",
          "label": "setHeader",
          "description": "Add a header to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getHeader": {
          "type": "method",
          "label": "getHeader",
          "description": "",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeHeader": {
          "type": "method",
          "label": "removeHeader",
          "description": "Removes a header from the request. Nothing happens if the header does\nnot exist.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setQueryParameter": {
          "type": "method",
          "label": "setQueryParameter",
          "description": "Add a query parameter to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeQueryParameter": {
          "type": "method",
          "label": "removeQueryParameter",
          "description": "Remove a query parameter from the request URI.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "send": {
          "type": "method",
          "label": "send",
          "description": "Send the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.TransactionLog": {
      "type": "class",
      "label": "NGN.DATA.TransactionLog",
      "description": "Returns the entire log, in ascending historical order (oldest first).\n  This may be a time-consuming operation if the log is large.\n    Example:    ```js\n  [{\n    timestamp: Date,\n    value: 'some value'\n  },{\n    timestamp: Date,\n    value: 'some other value'\n  }]",
      "code": "class NGNTransactionLog extends EventEmitter { // eslint-disable-line\n  /**\n   * Create a new transaction log.\n   * @param  {number} [maxEntryCount=10]\n   * The maximum number of entries to keep in the log. Set this to `-1` to keep\n   * an unlimited number of logs.\n   */\n  constructor (maxEntryCount) {\n    super()\n\n    Object.defineProperties(this, {\n      METADATA: NGN.private({\n        transaction: {},\n        changeOrder: [],\n        cursor: null,\n        max: NGN.coalesce(maxEntryCount, 10)\n      })\n    })\n  }\n\n  get length () {\n    return this.METADATA.changeOrder.length\n  }\n\n  /**\n   * @property {Symbol} cursor\n   * The active cursor of the log.\n   */\n  get cursor () {\n    return this.METADATA.cursor\n  }\n\n  set cursor (value) {\n    if (value !== null && !this.METADATA.transaction.hasOwnProperty(value)) {\n      throw new Error('Cannot set cursor for transaction log (does not exist).')\n    }\n\n    this.METADATA.cursor = value\n  }\n\n  /**\n   * @property {any} currentValue\n   * Returns the value at the current cursor position.\n   */\n  get currentValue () {\n    if (this.METADATA.cursor === null) {\n      return undefined\n    }\n\n    return this.getCommit(this.METADATA.cursor).value\n  }\n\n  /**\n   * @property {Number}\n   * The index of the log entry at the current cursor position.\n   */\n  get cursorIndex () {\n    if (this.METADATA.cursor === null) {\n      return undefined\n    }\n\n    return this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n  }\n\n  /**\n   * Add a new value to the transaction log.\n   * @param {Any} value\n   * The value to assign to the log (record).\n   * @return {Number}\n   * Returns the transaction number\n   * @fires log {Symbol}\n   * Fires a log event with the transaction ID (symbol) for reference.\n   */\n  commit (value) {\n    let id = typeof value === 'symbol' ? Symbol(String(value)) : Symbol(NGN.coalesce(value, NGN.typeof(value)).toString())\n\n    this.METADATA.transaction[id] = [\n      new Date(),\n      value\n    ]\n\n    this.flush()\n\n    this.METADATA.changeOrder.push(id)\n    this.METADATA.cursor = id\n\n    if (this.METADATA.max > 0 && this.METADATA.changeOrder.length > this.METADATA.max) {\n      let removedId = this.METADATA.changeOrder.shift()\n      delete this.METADATA.transaction[removedId]\n    }\n\n    this.emit('commit', id, null)\n\n    return id\n  }\n\n  /**\n   * Return the entry for the specified commit ID.\n   * @param  {Symbol} id\n   * The transaction ID.\n   * @return {Object}\n   * Returns an object with `timestamp` and `value` keys.\n   */\n  getCommit (id = null) {\n    if (!this.METADATA.transaction.hasOwnProperty(id)) {\n      return undefined\n    }\n\n    return {\n      timestamp: this.METADATA.transaction[id][0],\n      value: this.METADATA.transaction[id][1]\n    }\n  }\n\n  /**\n   * Remove all transaction log entries from the current cursor onward.\n   */\n  flush () {\n    if (this.METADATA.cursor === null) {\n      return\n    }\n\n    let position = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n\n    // If the whole log is cleared, reset it silently.\n    if (position === 0) {\n      return\n    }\n\n    let removedEntries = this.METADATA.changeOrder.splice(position + 1)\n\n    for (let i = 0; i < removedEntries.length; i++) {\n      delete this.METADATA.transaction[removedEntries[i]]\n    }\n\n    this.METADATA.cursor = this.METADATA.changeOrder[this.METADATA.changeOrder.length - 1]\n  }\n\n  /**\n   * Rollback the log to the specified index/cursor.\n   * @param  {Number|Symbol} [index=1]\n   * The index may be a number or a commit ID (symbol).\n   *\n   * **Specifying a number** will rollback the log by the specified number of\n   * commits. By default, the index is `1`, which is the equivalent of a simple\n   * \"undo\" operation. Specifying `2` would \"undo\" two operations. Values less\n   * than or equal to zero are ignored. Values greater than the total number of\n   * committed transactions trigger a reset.\n   *\n   * **Specifying a symbol** will rollback the log to the specified commit log\n   * (the symbol is the commit log ID).\n   * @fires rollback {Object}\n   * This fires a `rollback` event containing the active cursor.\n   * @return {Symbol}\n   * Returns the active cursor upon completion of rollback.\n   */\n  rollback (index = 1) {\n    // If the log is empty, ignore the rollback\n    if (this.METADATA.changeOrder.length === 0) {\n      return null\n    }\n\n    if (typeof index === 'symbol') {\n      this.cursor = index\n      return index\n    }\n\n    if (index >= this.METADATA.changeOrder.length) {\n      this.METADATA.cursor = this.METADATA.changeOrder[0]\n    } else {\n      // Make sure the index is a symbol\n      if (typeof index === 'number') {\n        if (index <= 0) {\n          return this.METADATA.cursor\n        }\n\n        let currentPosition = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n        currentPosition -= index\n\n        if (currentPosition <= 0) {\n          currentPosition = 0\n        }\n\n        index = this.METADATA.changeOrder[currentPosition]\n      }\n\n      this.METADATA.cursor = index\n    }\n\n    this.emit('rollback', this.METADATA.cursor, null)\n\n    return this.METADATA.cursor\n  }\n\n  /**\n   * Advance the log to the specified index/cursor.\n   * @param  {Number|Symbol} [index=1]\n   * The index may be a number or a commit ID (symbol).\n   *\n   * **Specifying a number** will advance the log by the specified number of\n   * commits. By default, the index is `1`, which is the equivalent of a simple\n   * \"redo\" operation. Specifying `2` would \"redo\" two operations. Values less\n   * than or equal to zero are ignored. Values greater than the total number of\n   * committed transactions will advance the cursor to the last entry.\n   *\n   * **Specifying a symbol** will advance the log to the specified commit log\n   * record (the symbol is the commit log ID).\n   * @fires advance {Object}\n   * This fires a `advance` event containing the active cursor.\n   * @return {Symbol}\n   * Returns the active cursor upon completion of rollback.\n   */\n  advance (index = 1) {\n    // If the log is empty, ignore the rollback\n    if (this.METADATA.changeOrder.length === 0) {\n      return null\n    }\n\n    // Make sure the index is a symbol\n    if (typeof index === 'number') {\n      if (index <= 0) {\n        return this.METADATA.cursor\n      }\n\n      let currentPosition = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n      currentPosition += index\n\n      if (currentPosition >= this.METADATA.changeOrder.length) {\n        currentPosition = this.METADATA.changeOrder.length - 1\n      }\n\n      index = this.METADATA.changeOrder[currentPosition]\n    }\n\n    this.METADATA.cursor = index\n\n    this.emit('advance', this.METADATA.cursor, null)\n\n    return this.METADATA.cursor\n  }\n\n  /**\n   * Clear the transaction log.\n   */\n  reset (suppressEvents = false) {\n    this.METADATA.transaction = {}\n    this.METADATA.changeOrder = []\n    this.METADATA.cursor = null\n\n    if (!suppressEvents) {\n      this.emit('reset')\n    }\n  }\n\n  /**\n   * @property {Array} log\n   * Returns the entire log, in ascending historical order (oldest first).\n   * This may be a time-consuming operation if the log is large.\n   *\n   * **Example:**\n   *\n   * ```js\n   * [{\n   *   timestamp: Date,\n   *   value: 'some value'\n   * },{\n   *   timestamp: Date,\n   *   value: 'some other value'\n   * }]\n   */\n  get log () {\n    return this.METADATA.changeOrder.map(entry => {\n      return {\n        timestamp: this.METADATA.transaction[entry][0],\n        value: this.METADATA.transaction[entry][1],\n        activeCursor: this.METADATA.cursor === entry\n      }\n    })\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "commit": {
          "type": "event",
          "label": "commit",
          "description": null,
          "code": "this.emit('commit', id, null)",
          "start": {
            "line": 144,
            "column": 4
          },
          "end": {
            "line": 144,
            "column": 33
          },
          "flags": [],
          "parameters": {
            "id": {
              "type": "argument",
              "label": "id",
              "description": null,
              "code": "id",
              "start": {
                "line": 144,
                "column": 24
              },
              "end": {
                "line": 144,
                "column": 26
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "payload2": {
              "type": "argument",
              "label": "payload2",
              "description": null,
              "code": "null",
              "start": {
                "line": 144,
                "column": 28
              },
              "end": {
                "line": 144,
                "column": 32
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "log": {
          "type": "event",
          "label": "log",
          "description": "{Symbol}\nFires a log event with the transaction ID  for reference.",
          "code": "@fires log {Symbol}\nFires a log event with the transaction ID (symbol) for reference.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "rollback": {
          "type": "event",
          "label": "rollback",
          "description": "{Object}\nThis fires a `rollback` event containing the active cursor.",
          "code": "@fires rollback {Object}\nThis fires a `rollback` event containing the active cursor.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "advance": {
          "type": "event",
          "label": "advance",
          "description": "{Object}\nThis fires a `advance` event containing the active cursor.",
          "code": "@fires advance {Object}\nThis fires a `advance` event containing the active cursor.",
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": null,
              "start": {
                "line": 0,
                "column": 0
              },
              "end": {
                "line": 0,
                "column": 0
              },
              "flags": [],
              "datatype": "",
              "required": false,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "reset": {
          "type": "event",
          "label": "reset",
          "description": null,
          "code": "this.emit('reset')",
          "start": {
            "line": 303,
            "column": 6
          },
          "end": {
            "line": 303,
            "column": 24
          },
          "flags": [],
          "parameters": {},
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 53,
        "column": 15
      },
      "end": {
        "line": 332,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/TransactionLog.js",
      "extends": "EventEmitter",
      "configuration": {},
      "properties": {
        "METADATA": {
          "type": "property",
          "label": "METADATA",
          "description": null,
          "code": "METADATA: NGN.private({\n        transaction: {},\n        changeOrder: [],\n        cursor: null,\n        max: NGN.coalesce(maxEntryCount, 10)\n      })",
          "start": {
            "line": 64,
            "column": 6
          },
          "end": {
            "line": 69,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "length": {
          "type": "property",
          "label": "length",
          "description": null,
          "code": "get length () {\n    return this.METADATA.changeOrder.length\n  }",
          "start": {
            "line": 73,
            "column": 2
          },
          "end": {
            "line": 75,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "cursor": {
          "type": "property",
          "label": "cursor",
          "description": null,
          "code": "set cursor (value) {\n    if (value !== null && !this.METADATA.transaction.hasOwnProperty(value)) {\n      throw new Error('Cannot set cursor for transaction log (does not exist).')\n    }\n\n    this.METADATA.cursor = value\n  }",
          "start": {
            "line": 85,
            "column": 2
          },
          "end": {
            "line": 91,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "currentValue": {
          "type": "property",
          "label": "currentValue",
          "description": null,
          "code": "get currentValue () {\n    if (this.METADATA.cursor === null) {\n      return undefined\n    }\n\n    return this.getCommit(this.METADATA.cursor).value\n  }",
          "start": {
            "line": 97,
            "column": 2
          },
          "end": {
            "line": 103,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "cursorIndex": {
          "type": "property",
          "label": "cursorIndex",
          "description": null,
          "code": "get cursorIndex () {\n    if (this.METADATA.cursor === null) {\n      return undefined\n    }\n\n    return this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n  }",
          "start": {
            "line": 109,
            "column": 2
          },
          "end": {
            "line": 115,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "log": {
          "type": "property",
          "label": "log",
          "description": null,
          "code": "get log () {\n    return this.METADATA.changeOrder.map(entry => {\n      return {\n        timestamp: this.METADATA.transaction[entry][0],\n        value: this.METADATA.transaction[entry][1],\n        activeCursor: this.METADATA.cursor === entry\n      }\n    })\n  }",
          "start": {
            "line": 323,
            "column": 2
          },
          "end": {
            "line": 331,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "Create a new transaction log.\n  \n  The maximum number of entries to keep in the log. Set this to `-1` to keep\n  an unlimited number of logs.",
          "code": "constructor (maxEntryCount) {\n    super()\n\n    Object.defineProperties(this, {\n      METADATA: NGN.private({\n        transaction: {},\n        changeOrder: [],\n        cursor: null,\n        max: NGN.coalesce(maxEntryCount, 10)\n      })\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 60,
            "column": 2
          },
          "end": {
            "line": 71,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "maxEntryCount": {
              "type": "argument",
              "label": "maxEntryCount",
              "description": "The maximum number of entries to keep in the log. Set this to `-1` to keep\nan unlimited number of logs.",
              "code": "@param  {number} [maxEntryCount=10]\nThe maximum number of entries to keep in the log. Set this to `-1` to keep\nan unlimited number of logs.",
              "start": {
                "line": 60,
                "column": 2
              },
              "end": {
                "line": 71,
                "column": 3
              },
              "flags": [],
              "default": "10",
              "datatype": "number",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "commit": {
          "type": "method",
          "label": "commit",
          "description": "Add a new value to the transaction log.\n  \n  The value to assign to the log (record).\n  \n  Returns the transaction number\n  \n  Fires a log event with the transaction ID (symbol) for reference.",
          "code": "commit (value) {\n    let id = typeof value === 'symbol' ? Symbol(String(value)) : Symbol(NGN.coalesce(value, NGN.typeof(value)).toString())\n\n    this.METADATA.transaction[id] = [\n      new Date(),\n      value\n    ]\n\n    this.flush()\n\n    this.METADATA.changeOrder.push(id)\n    this.METADATA.cursor = id\n\n    if (this.METADATA.max > 0 && this.METADATA.changeOrder.length > this.METADATA.max) {\n      let removedId = this.METADATA.changeOrder.shift()\n      delete this.METADATA.transaction[removedId]\n    }\n\n    this.emit('commit', id, null)\n\n    return id\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 126,
            "column": 2
          },
          "end": {
            "line": 147,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": "The value to assign to the log .",
              "code": "@param {Any} value\nThe value to assign to the log (record).",
              "start": {
                "line": 126,
                "column": 2
              },
              "end": {
                "line": 147,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": [
                "record"
              ]
            }
          },
          "returnType": "Number",
          "returnDescription": "null Returns the transaction number",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getCommit": {
          "type": "method",
          "label": "getCommit",
          "description": "Return the entry for the specified commit ID.\n  \n  The transaction ID.\n  \n  Returns an object with `timestamp` and `value` keys.",
          "code": "getCommit (id = null) {\n    if (!this.METADATA.transaction.hasOwnProperty(id)) {\n      return undefined\n    }\n\n    return {\n      timestamp: this.METADATA.transaction[id][0],\n      value: this.METADATA.transaction[id][1]\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 156,
            "column": 2
          },
          "end": {
            "line": 165,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "id": {
              "type": "argument",
              "label": "id",
              "description": "The transaction ID.",
              "code": "@param  {Symbol} id\nThe transaction ID.",
              "start": {
                "line": 156,
                "column": 2
              },
              "end": {
                "line": 165,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "symbol",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Object",
          "returnDescription": "null Returns an object with `timestamp` and `value` keys.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "flush": {
          "type": "method",
          "label": "flush",
          "description": "Remove all transaction log entries from the current cursor onward.",
          "code": "flush () {\n    if (this.METADATA.cursor === null) {\n      return\n    }\n\n    let position = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n\n    // If the whole log is cleared, reset it silently.\n    if (position === 0) {\n      return\n    }\n\n    let removedEntries = this.METADATA.changeOrder.splice(position + 1)\n\n    for (let i = 0; i < removedEntries.length; i++) {\n      delete this.METADATA.transaction[removedEntries[i]]\n    }\n\n    this.METADATA.cursor = this.METADATA.changeOrder[this.METADATA.changeOrder.length - 1]\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 170,
            "column": 2
          },
          "end": {
            "line": 189,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "rollback": {
          "type": "method",
          "label": "rollback",
          "description": "Rollback the log to the specified index/cursor.\n  \n  The index may be a number or a commit ID (symbol).\n    Specifying a numberwill rollback the log by the specified number of\n  commits. By default, the index is `1`, which is the equivalent of a simple\n  \"undo\" operation. Specifying `2` would \"undo\" two operations. Values less\n  than or equal to zero are ignored. Values greater than the total number of\n  committed transactions trigger a reset.\n    Specifying a symbolwill rollback the log to the specified commit log\n  (the symbol is the commit log ID).\n  \n  This fires a `rollback` event containing the active cursor.\n  \n  Returns the active cursor upon completion of rollback.",
          "code": "rollback (index = 1) {\n    // If the log is empty, ignore the rollback\n    if (this.METADATA.changeOrder.length === 0) {\n      return null\n    }\n\n    if (typeof index === 'symbol') {\n      this.cursor = index\n      return index\n    }\n\n    if (index >= this.METADATA.changeOrder.length) {\n      this.METADATA.cursor = this.METADATA.changeOrder[0]\n    } else {\n      // Make sure the index is a symbol\n      if (typeof index === 'number') {\n        if (index <= 0) {\n          return this.METADATA.cursor\n        }\n\n        let currentPosition = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n        currentPosition -= index\n\n        if (currentPosition <= 0) {\n          currentPosition = 0\n        }\n\n        index = this.METADATA.changeOrder[currentPosition]\n      }\n\n      this.METADATA.cursor = index\n    }\n\n    this.emit('rollback', this.METADATA.cursor, null)\n\n    return this.METADATA.cursor\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 209,
            "column": 2
          },
          "end": {
            "line": 245,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "index": {
              "type": "argument",
              "label": "index",
              "description": "The index may be a number or a commit ID .\n\n**Specifying a number** will rollback the log by the specified number of\ncommits. By default, the index is `1`, which is the equivalent of a simple\n\"undo\" operation. Specifying `2` would \"undo\" two operations. Values less\nthan or equal to zero are ignored. Values greater than the total number of\ncommitted transactions trigger a reset.\n\n**Specifying a symbol** will rollback the log to the specified commit log\n(the symbol is the commit log ID).",
              "code": "@param  {Number|Symbol} [index=1]\nThe index may be a number or a commit ID (symbol).\n\n**Specifying a number** will rollback the log by the specified number of\ncommits. By default, the index is `1`, which is the equivalent of a simple\n\"undo\" operation. Specifying `2` would \"undo\" two operations. Values less\nthan or equal to zero are ignored. Values greater than the total number of\ncommitted transactions trigger a reset.\n\n**Specifying a symbol** will rollback the log to the specified commit log\n(the symbol is the commit log ID).",
              "start": {
                "line": 209,
                "column": 2
              },
              "end": {
                "line": 245,
                "column": 3
              },
              "flags": [],
              "default": "1",
              "datatype": "number|symbol",
              "required": false,
              "enum": [
                "symbol"
              ]
            }
          },
          "returnType": "Symbol",
          "returnDescription": "null Returns the active cursor upon completion of rollback.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "advance": {
          "type": "method",
          "label": "advance",
          "description": "Advance the log to the specified index/cursor.\n  \n  The index may be a number or a commit ID (symbol).\n    Specifying a numberwill advance the log by the specified number of\n  commits. By default, the index is `1`, which is the equivalent of a simple\n  \"redo\" operation. Specifying `2` would \"redo\" two operations. Values less\n  than or equal to zero are ignored. Values greater than the total number of\n  committed transactions will advance the cursor to the last entry.\n    Specifying a symbolwill advance the log to the specified commit log\n  record (the symbol is the commit log ID).\n  \n  This fires a `advance` event containing the active cursor.\n  \n  Returns the active cursor upon completion of rollback.",
          "code": "advance (index = 1) {\n    // If the log is empty, ignore the rollback\n    if (this.METADATA.changeOrder.length === 0) {\n      return null\n    }\n\n    // Make sure the index is a symbol\n    if (typeof index === 'number') {\n      if (index <= 0) {\n        return this.METADATA.cursor\n      }\n\n      let currentPosition = this.METADATA.changeOrder.indexOf(this.METADATA.cursor)\n      currentPosition += index\n\n      if (currentPosition >= this.METADATA.changeOrder.length) {\n        currentPosition = this.METADATA.changeOrder.length - 1\n      }\n\n      index = this.METADATA.changeOrder[currentPosition]\n    }\n\n    this.METADATA.cursor = index\n\n    this.emit('advance', this.METADATA.cursor, null)\n\n    return this.METADATA.cursor\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 265,
            "column": 2
          },
          "end": {
            "line": 292,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "index": {
              "type": "argument",
              "label": "index",
              "description": "The index may be a number or a commit ID .\n\n**Specifying a number** will advance the log by the specified number of\ncommits. By default, the index is `1`, which is the equivalent of a simple\n\"redo\" operation. Specifying `2` would \"redo\" two operations. Values less\nthan or equal to zero are ignored. Values greater than the total number of\ncommitted transactions will advance the cursor to the last entry.\n\n**Specifying a symbol** will advance the log to the specified commit log\nrecord (the symbol is the commit log ID).",
              "code": "@param  {Number|Symbol} [index=1]\nThe index may be a number or a commit ID (symbol).\n\n**Specifying a number** will advance the log by the specified number of\ncommits. By default, the index is `1`, which is the equivalent of a simple\n\"redo\" operation. Specifying `2` would \"redo\" two operations. Values less\nthan or equal to zero are ignored. Values greater than the total number of\ncommitted transactions will advance the cursor to the last entry.\n\n**Specifying a symbol** will advance the log to the specified commit log\nrecord (the symbol is the commit log ID).",
              "start": {
                "line": 265,
                "column": 2
              },
              "end": {
                "line": 292,
                "column": 3
              },
              "flags": [],
              "default": "1",
              "datatype": "number|symbol",
              "required": false,
              "enum": [
                "symbol"
              ]
            }
          },
          "returnType": "Symbol",
          "returnDescription": "null Returns the active cursor upon completion of rollback.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "reset": {
          "type": "method",
          "label": "reset",
          "description": "Clear the transaction log.",
          "code": "reset (suppressEvents = false) {\n    this.METADATA.transaction = {}\n    this.METADATA.changeOrder = []\n    this.METADATA.cursor = null\n\n    if (!suppressEvents) {\n      this.emit('reset')\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 297,
            "column": 2
          },
          "end": {
            "line": 305,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": null,
              "code": "suppressEvents = false",
              "start": {
                "line": 297,
                "column": 9
              },
              "end": {
                "line": 297,
                "column": 31
              },
              "flags": [],
              "default": false,
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.UTILITY": {
      "type": "class",
      "label": "NGN.DATA.UTILITY",
      "description": "A utility library of functions relevant to data management.",
      "code": "class Utility { // eslint-disable-line\n  static diff () {\n    return ObjectDiff.compare(...arguments) // eslint-disable-line no-undef\n  }\n\n  /**\n   * @method checksum\n   * Create the checksum of the specified string.\n   * @param  {string} content\n   * The content to generate a checksum for.\n   * @return {string}\n   * Generates a checksum value.\n   */\n  static checksum (str) {\n    if (typeof str === 'object') {\n      str = JSON.stringify(this.serialize(str))\n    }\n\n    if (!crcTable) {\n      crcTable = makeCRCTable()\n    }\n\n    let crc = 0 ^ (-1)\n\n    for (let i = 0; i < str.length; i++) {\n      crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF]\n    }\n\n    return (crc ^ (-1)) >>> 0\n  }\n\n  /**\n   * @method UUID\n   * Generate a universally unique identifier (v4).\n   *\n   * This is a \"fast\" UUID generator, designed to work in the browser.\n   * This will generate a UUID in less than 20ms on Chrome, as of Nov 6, 2017.\n   * Code courtesy of @broofa on StackOverflow.\n   *\n   * While this method cannot absolutely guarantee there will be no collisions\n   * (duplicates), the chances are 1:5.3x10^^36 (1 in over 100 quadrillion).\n   * You are over 30 _octillion_ times more likely to win the Powerball than to\n   * generate two identical \"random\" UUIDs using the version 4 scheme.\n   * @return {string}\n   * Returns a [V4 GUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29).\n   */\n  static UUID () {\n    /* node-only */\n    return this.GUID()\n    /* end-node-only */\n    /* browser-only */\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => // eslint-disable-line\n      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16) // eslint-disable-line\n    )\n    /* end-browser-only */\n  }\n\n  /**\n   * @method GUID\n   * Generate a globally unique identifier. A GUID is the Microsoft\n   * implementation of a UUIDv4.\n   *\n   * The likelihood of an ID collision, according to the original author (Jeff\n   * Ward) is 1:3.26x10^15 (1 in 3.26 quadrillion). Results are generated between\n   * approximately 105ms (Desktop) and 726ms (Android) as of May 2016.\n   * @return {string} [description]\n   */\n  static GUID () {\n    let lut = []\n\n    for (let i = 0; i < 256; i++) {\n      lut[i] = (i < 16 ? '0' : '') + (i).toString(16)\n    }\n\n    const d0 = Math.random() * 0xffffffff | 0\n    const d1 = Math.random() * 0xffffffff | 0\n    const d2 = Math.random() * 0xffffffff | 0\n    const d3 = Math.random() * 0xffffffff | 0\n\n    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] +\n      '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] +\n      lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' +\n      lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] +\n      lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff]\n  }\n\n  /**\n   * @method serialize\n   * Creates a JSON data object with no functions. Only uses enumerable\n   * attributes of the object.\n   *\n   * Functions & Setters are always ignored. Getters are evaluated recursively\n   * until a simple object type is found or there are no further nested\n   * attributes.\n   * @param {object|array} object\n   * Supports an object or array.\n   */\n  static serialize (data) {\n    if (typeof data !== 'object') {\n      throw new Error(`Cannot serialize ${NGN.typeof(data)} value. Must be an object.`)\n    }\n\n    // Force an object for parsing\n    let SERIALIZED_ARRAY_DATA = Symbol('array.data')\n\n    if (NGN.typeof(data) === 'array') {\n      data = {\n        [SERIALIZED_ARRAY_DATA]: data\n      }\n    }\n\n    let result = {}\n    let attribute = Object.keys(data)\n\n    for (let i = 0; i < attribute.length; i++) {\n      if (data[attribute[i]] !== undefined) {\n        switch (NGN.typeof(data[attribute[i]])) {\n          case 'object':\n            Object.defineProperty(\n              result,\n              attribute[i],\n              NGN.public(NGN.DATA.UTIL.serialize(data[attribute[i]]))\n            )\n\n            break\n\n          case 'array':\n            result[attribute[i]] = []\n\n            for (let a = 0; a < data[attribute[i]].length; a++) {\n              result[attribute[i]].push(NGN.DATA.UTIL.serialize(data[attribute[i]]))\n            }\n\n            break\n\n          case 'date':\n            Object.defineProperty(result, attribute[i], NGN.public(data[attribute[i]].toISOString()))\n\n            break\n\n          case 'symbol':\n            if (SERIALIZED_ARRAY_DATA !== attribute[i]) {\n              result[attribute[i]] = data[attribute[i]].toString()\n            }\n\n            break\n\n          case 'regexp':\n            Object.defineProperty(result, attribute[i], NGN.public(data[attribute[i]].toString()))\n\n            break\n\n          case 'weakmap':\n          case 'map':\n            let mapResult = {}\n\n            data[attribute[i]].forEach((value, key) => {\n              mapResult[key.toString()] = this.serialize(value)\n            })\n\n            result[attribute[i]] = mapResult\n\n            break\n\n          case 'weakset':\n          case 'set':\n            if (data[attribute[i]].size === 0) {\n              result[attribute[i]] = []\n              break\n            }\n\n            result[attribute[i]] = this.serialize(Array.from(data[attribute[i]].values()))\n\n            break\n\n          case 'function':\n            break\n\n          default:\n            result[attribute[i]] = data[attribute[i]]\n        }\n      }\n    }\n\n    return result[SERIALIZED_ARRAY_DATA] !== undefined ? result[SERIALIZED_ARRAY_DATA] : result\n  }\n\n  // /**\n  //  * @method objectByteSize\n  //  * Calculates the _estimated_ size (in bytes) of primitive key/value objects,\n  //  * meaning those that do not contain functions, accessors (getters/setters),\n  //  * or other attributes other than `String`, `Number`, or `Boolean` values.\n  //  * NGN treats dates as `String` values.\n  //  *\n  //  * JavaScript engines differ in how they manage memory, but most do not\n  //  * calculate the size of functions. If a value of type `function` is found in\n  //  * the object, NGN will calculate the size of it's `String` representation.\n  //  * This is a weak measure of function size since most JavaScript engines\n  //  * do not expose enough realtime heap data to know calculate with accuracy at\n  //  * any given point in time.\n  //  *\n  //  * This method attempts to implement similar principles to C's `sizeOf` method.\n  //  *\n  //  * Consider this method to provide a **best guess based on the available data**.\n  //  *\n  //  * @param {Object} object\n  //  * The primitive key/value object upon which the bytesize estimation will be made.\n  //  * @param {Boolean} [ignoreFunctionEstimate=false]\n  //  * By default, NGN will calculate the `String` representation of any functions\n  //  * it encounters in the key/value object. Setting this to `true` will prevent\n  //  * this behavior, effectively using a `0` to calculate function size.\n  //  */\n  // static objectByteSize (obj, ignore=false) {\n  //   switch (typeof obj) {\n  //     case null:\n  //       return 4\n  //\n  //     case 'string':\n  //       return obj.length * 2\n  //\n  //     case 'boolean':\n  //       return 4\n  //\n  //     case 'number':\n  //       return 8\n  //\n  //     case 'function':\n  //       if (!ignore) {\n  //         return obj.toString().length * 2\n  //       }\n  //\n  //       return 0\n  //   }\n  //\n  //   let list = []\n  //   let stack = [obj]\n  //   let bytes = 0\n  //\n  //   while (stack.length) {\n  //     let value = stack.pop()\n  //\n  //     if (typeof value === 'object') {\n  //       if (list.indexOf(value) < 0) {\n  //         list.push(value)\n  //\n  //         // If the object is not an array, add key sizes\n  //         const isArray = !Array.isArray(value)\n  //\n  //         for (let key in value) {\n  //           if (!isArray) {\n  //             bytes += (2 * key.length) + NGN.DATA.util(value[key])\n  //             stack.push(value[key])\n  //           } else {\n  //\n  //           }\n  //         }\n  //       }\n  //     } else {\n  //       bytes += NGN.DATA.UTILITY.objectByteSize(value)\n  //     }\n  //   }\n  //\n  //   return bytes\n  // }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 33,
        "column": 15
      },
      "end": {
        "line": 297,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/Utility.js",
      "extends": null,
      "configuration": {},
      "properties": {},
      "methods": {
        "diff": {
          "type": "method",
          "label": "diff",
          "description": null,
          "code": "static diff () {\n    return ObjectDiff.compare(...arguments) // eslint-disable-line no-undef\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 34,
            "column": 2
          },
          "end": {
            "line": 36,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "checksum": {
          "type": "method",
          "label": "checksum",
          "description": "Create the checksum of the specified string.",
          "code": "static checksum (str) {\n    if (typeof str === 'object') {\n      str = JSON.stringify(this.serialize(str))\n    }\n\n    if (!crcTable) {\n      crcTable = makeCRCTable()\n    }\n\n    let crc = 0 ^ (-1)\n\n    for (let i = 0; i < str.length; i++) {\n      crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF]\n    }\n\n    return (crc ^ (-1)) >>> 0\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 46,
            "column": 2
          },
          "end": {
            "line": 62,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "str": {
              "type": "argument",
              "label": "str",
              "description": null,
              "code": "str",
              "start": {
                "line": 46,
                "column": 19
              },
              "end": {
                "line": 46,
                "column": 22
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "content": {
              "type": "argument",
              "label": "content",
              "description": "The content to generate a checksum for.",
              "code": "@param  {string} content\nThe content to generate a checksum for.",
              "start": {
                "line": 46,
                "column": 2
              },
              "end": {
                "line": 62,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "string",
          "returnDescription": "null Generates a checksum value.",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "UUID": {
          "type": "method",
          "label": "UUID",
          "description": "Generate a universally unique identifier .\n\nThis is a \"fast\" UUID generator, designed to work in the browser.\nThis will generate a UUID in less than 20ms on Chrome, as of Nov 6, 2017.\nCode courtesy of @broofa on StackOverflow.\n\nWhile this method cannot absolutely guarantee there will be no collisions\n(duplicates), the chances are 1:5.3x10^^36 (1 in over 100 quadrillion).\nYou are over 30 _octillion_ times more likely to win the Powerball than to\ngenerate two identical \"random\" UUIDs using the version 4 scheme.",
          "code": "static UUID () {\n    /* node-only */\n    return this.GUID()\n    /* end-node-only */\n    /* browser-only */\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => // eslint-disable-line\n      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16) // eslint-disable-line\n    )\n    /* end-browser-only */\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 79,
            "column": 2
          },
          "end": {
            "line": 88,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "string",
          "returnDescription": "null Returns a [V4 GUID].",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "GUID": {
          "type": "method",
          "label": "GUID",
          "description": "Generate a globally unique identifier. A GUID is the Microsoft\nimplementation of a UUIDv4.\n\nThe likelihood of an ID collision, according to the original author (Jeff\nWard) is 1:3.26x10^15 . Results are generated between\napproximately 105ms (Desktop) and 726ms (Android) as of May 2016.",
          "code": "static GUID () {\n    let lut = []\n\n    for (let i = 0; i < 256; i++) {\n      lut[i] = (i < 16 ? '0' : '') + (i).toString(16)\n    }\n\n    const d0 = Math.random() * 0xffffffff | 0\n    const d1 = Math.random() * 0xffffffff | 0\n    const d2 = Math.random() * 0xffffffff | 0\n    const d3 = Math.random() * 0xffffffff | 0\n\n    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] +\n      '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] +\n      lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' +\n      lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] +\n      lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff]\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 100,
            "column": 2
          },
          "end": {
            "line": 117,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "string",
          "returnDescription": "description",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "serialize": {
          "type": "method",
          "label": "serialize",
          "description": "Creates a JSON data object with no functions. Only uses enumerable\nattributes of the object.\n\nFunctions & Setters are always ignored. Getters are evaluated recursively\nuntil a simple object type is found or there are no further nested\nattributes.",
          "code": "static serialize (data) {\n    if (typeof data !== 'object') {\n      throw new Error(`Cannot serialize ${NGN.typeof(data)} value. Must be an object.`)\n    }\n\n    // Force an object for parsing\n    let SERIALIZED_ARRAY_DATA = Symbol('array.data')\n\n    if (NGN.typeof(data) === 'array') {\n      data = {\n        [SERIALIZED_ARRAY_DATA]: data\n      }\n    }\n\n    let result = {}\n    let attribute = Object.keys(data)\n\n    for (let i = 0; i < attribute.length; i++) {\n      if (data[attribute[i]] !== undefined) {\n        switch (NGN.typeof(data[attribute[i]])) {\n          case 'object':\n            Object.defineProperty(\n              result,\n              attribute[i],\n              NGN.public(NGN.DATA.UTIL.serialize(data[attribute[i]]))\n            )\n\n            break\n\n          case 'array':\n            result[attribute[i]] = []\n\n            for (let a = 0; a < data[attribute[i]].length; a++) {\n              result[attribute[i]].push(NGN.DATA.UTIL.serialize(data[attribute[i]]))\n            }\n\n            break\n\n          case 'date':\n            Object.defineProperty(result, attribute[i], NGN.public(data[attribute[i]].toISOString()))\n\n            break\n\n          case 'symbol':\n            if (SERIALIZED_ARRAY_DATA !== attribute[i]) {\n              result[attribute[i]] = data[attribute[i]].toString()\n            }\n\n            break\n\n          case 'regexp':\n            Object.defineProperty(result, attribute[i], NGN.public(data[attribute[i]].toString()))\n\n            break\n\n          case 'weakmap':\n          case 'map':\n            let mapResult = {}\n\n            data[attribute[i]].forEach((value, key) => {\n              mapResult[key.toString()] = this.serialize(value)\n            })\n\n            result[attribute[i]] = mapResult\n\n            break\n\n          case 'weakset':\n          case 'set':\n            if (data[attribute[i]].size === 0) {\n              result[attribute[i]] = []\n              break\n            }\n\n            result[attribute[i]] = this.serialize(Array.from(data[attribute[i]].values()))\n\n            break\n\n          case 'function':\n            break\n\n          default:\n            result[attribute[i]] = data[attribute[i]]\n        }\n      }\n    }\n\n    return result[SERIALIZED_ARRAY_DATA] !== undefined ? result[SERIALIZED_ARRAY_DATA] : result\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 130,
            "column": 2
          },
          "end": {
            "line": 218,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "data": {
              "type": "argument",
              "label": "data",
              "description": null,
              "code": "data",
              "start": {
                "line": 130,
                "column": 20
              },
              "end": {
                "line": 130,
                "column": 24
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "object": {
              "type": "argument",
              "label": "object",
              "description": "Supports an object or array.",
              "code": "@param {object|array} object\nSupports an object or array.",
              "start": {
                "line": 130,
                "column": 2
              },
              "end": {
                "line": 218,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "object|array",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        }
      }
    },
    "NGNDateField": {
      "type": "class",
      "label": "NGNDateField",
      "description": "NGN.DATA.DateField\nDates are complex, and while JavaScript supports a date object, it does not\ncontain a date primitive. The date field can be used to define a date and\nrespond to many nuances within the context of data management.\nThis should not be used for traditional date manipulation. If you merely\nwant to manage a single date, please use NGNX.DateTime instead.",
      "code": "class NGNDateField extends NGNDataField { // eslint-disable-line\n  constructor (cfg = {}) {\n    cfg.type = Date\n\n    super(cfg)\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 10,
        "column": 15
      },
      "end": {
        "line": 16,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/field/DateField.js",
      "extends": "NGNDataField",
      "configuration": {},
      "properties": {
        "type": {
          "type": "property",
          "label": "type",
          "description": null,
          "code": "cfg.type = Date",
          "start": {
            "line": 12,
            "column": 8
          },
          "end": {
            "line": 12,
            "column": 12
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (cfg = {}) {\n    cfg.type = Date\n\n    super(cfg)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 11,
            "column": 2
          },
          "end": {
            "line": 15,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg = {}",
              "start": {
                "line": 11,
                "column": 15
              },
              "end": {
                "line": 11,
                "column": 23
              },
              "flags": [],
              "default": "{}",
              "datatype": "object",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.Field": {
      "type": "class",
      "label": "NGN.DATA.Field",
      "description": "The changelog returns the underlying NGN.DATA.TransactionLog#log if\n  auditing is available. The array will be empty if auditing is disabled.",
      "code": "class NGNDataField extends EventEmitter { // eslint-disable-line\n  /**\n   * @param {string|object} configuration\n   * Accepts an object with all configuration objects, or a string representing\n   * the name of the field.\n   */\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    if (typeof cfg === 'string') {\n      cfg = {\n        name: cfg\n      }\n    }\n\n    // Validate field configuration values\n    if (cfg.hasOwnProperty('pattern') && NGN.typeof(cfg.pattern) !== 'regexp') {\n      throw new Error('Invalid data field configuration. Pattern must be a valid JavaScript regular expression (RegExp).')\n    }\n\n    if (cfg.type === undefined) {\n      if (cfg.default) {\n        cfg.type = NGN.getType(NGN.typeof(cfg.default), String)\n      }\n    }\n\n    super(cfg)\n\n    const EMPTYDATA = Symbol('empty')\n\n    Object.defineProperties(this, {\n      METADATA: NGN.privateconst({\n        /**\n         * @cfg {boolean} [required=false]\n         * Indicates the value is required.\n         */\n        required: NGN.coalesce(cfg.required, false),\n\n        /**\n         * @cfgproperty {boolean} [hidden=false]\n         * Indicates the field is hidden (metadata).\n         */\n        hidden: NGN.coalesce(cfg.hidden, false),\n\n        // Identifies the property as a standard data attribute.\n        // Alternative options include `data`, `key`, `join`, `virtual`.\n        fieldType: NGN.coalesce(cfg.identifier, false) ? 'key' : 'data',\n\n        isIdentifier: NGN.coalesce(cfg.identifier, false),\n\n        /**\n         * @cfg {boolean} [autocorrectInput=true]\n         * Attempt to automatically correct data type values. For example,\n         * a numeric field receiving a value of `'10'` will automatically\n         * convert the input to `10`. Only arrays, numbers, and booleans are\n         * supported. See NGN#forceArray, NGN#forceBoolean, and NGN#forceNumber\n         * for details.\n         */\n        autocorrectInput: NGN.coalesce(cfg.autocorrectInput, false),\n\n        /**\n         * @cfg {RegExp} [pattern]\n         * A pattern, as defined by a standard RegExp, that the data must match.\n         */\n        pattern: NGN.coalesceb(cfg.pattern),\n\n        /**\n         * @cfgproperty {string} name\n         * The field name.\n         */\n        name: NGN.coalesce(cfg.name),\n\n        /**\n         * @cfgproperty {string} description\n         * This is a metadata field, primarily used for documentation\n         * or schema generation purposes.\n         */\n        description: NGN.coalesce(cfg.description, `${NGN.typeof(cfg.type)} field`),\n\n        /**\n         * @cfgproperty {string} [sourceName]\n         * A source name represents the physical name of an attribute as it\n         * would be recognized in a system of record. For example, a field\n         * named `firstname` may need to be written to disk/memory as `gn`\n         * (commonly used as shorthand for givenName in LDAP environments\n         * and relational databases).\n         *\n         * By specifying `firstname` as the field name and `gn` as the source\n         * name, the field will automatically map values from the source\n         * to model name and vice versa.\n         *\n         * For instance, a JSON input may look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"John\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         *\n         * When this data is applied to the field (or loaded in a\n         * NGN.DATA.Model), the field #value for `firstname` would be `John`.\n         * If the field #value is changed to `Jill` (i.e.\n         * `firstname.value = 'Jill'`), the resulting data set would look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"Jill\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         */\n        sourceName: NGN.coalesce(cfg.sourceName),\n\n        /**\n         * @cfg {any} default\n         * The default value of the field when no value is specified.\n         */\n        default: NGN.coalesce(cfg.default),\n\n        lastValue: Symbol('no.value'),\n\n        /**\n         * @cfg {Primitive} [type=String]\n         * The JS primitive representing the type of data represented\n         * by the field.\n         */\n        dataType: NGN.coalesce(cfg.type, String),\n\n        /**\n         * @cfg {function} [rule[]]\n         * A function, or an array of functions, which determine whether the\n         * field value is valid or not. These functions receive a single argument\n         * (the data value) and must return a Boolean value.\n         */\n        rules: NGN.coalesce(cfg.rule, cfg.rules, cfg.validators, []),\n        violatedRule: null,\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * If this is set to `false`, invalid values will throw an error.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {function} transformer\n         * A synchronous transformation function will be applied each time\n         * the field value is set. This can be used to modify data _before_ it\n         * is stored as a field value. The returned value from the function\n         * will be the new value of the field.\n         *\n         * The transformation function will receive the input as it's only\n         * aregument. For example:\n         *\n         * ```js\n         * let field = new NGN.DATA.Field({\n         *   name: 'testfield',\n         *   transformer: function (input) {\n         *     return input + '_test'\n         *   }\n         * })\n         *\n         * field.value = 'a'\n         *\n         * console.log(field.value) // Outputs \"a_test\"\n         * ```\n         *\n         * **Transformations can affect performance.** In small data sets,\n         * transformations are typically negligible, only adding a few\n         * milliseconds to processing time. This may affect large data sets,\n         * particularly data stores using defauly bulk recod loading.\n         */\n        TRANSFORM: NGN.coalesce(cfg.transformer),\n\n        RAWDATAPLACEHOLDER: EMPTYDATA,\n        RAW: EMPTYDATA,\n        ENUMERABLE_VALUES: null,\n        REVERSE_ENUMERABLE_VALUES: null,\n        IS_NEW: true,\n\n        EVENTS: new Set([\n          'hidden',\n          'unhidden',\n          'update',\n          'invalid',\n          'valid',\n          'rule.add',\n          'rule.remove'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n\n        /**\n         * @cfg {Number} [auditMaxEntries=20]\n         * The maximum number of historical records to maintain for the field.\n         * See NGN.DATA.TransactionLog#constructor for details.\n         */\n        AUDITLOG: NGN.coalesce(cfg.audit, false)\n          ? new NGN.DATA.TransactionLog(NGN.coalesce(cfg.auditMaxEntries, 10))\n          : null,\n\n        /**\n         * @cfg {NGN.DATA.Model} [model]\n         * Optionally specify the parent model.\n         */\n        model: null,\n\n        // Set the value using a configuration.\n        setValue: (value, suppressEvents = false, ignoreAudit = false) => {\n          // Preprocessing (transform input)\n          if (this.METADATA.TRANSFORM !== null && NGN.isFn(this.METADATA.TRANSFORM)) {\n            value = this.METADATA.TRANSFORM.call(this, value)\n          }\n\n          // Attempt to auto-correct input when possible.\n          if (this.METADATA.autocorrectInput && this.type !== NGN.typeof(value)) {\n            value = this.autoCorrectValue(value)\n          }\n\n          // Ignore changes when the value hasn't been modified.\n          if (value === this.value) {\n            return\n          }\n\n          let change = {\n            field: this,\n            old: typeof this.METADATA.RAW === 'symbol' ? undefined : this.METADATA.RAW,\n            new: value\n          }\n\n          let priorValueIsValid = this.valid\n\n          this.METADATA.RAW = value\n\n          // Notify when an invalid value is detected.\n          if (!this.valid) {\n            // If invalid values are explicitly prohibited, throw an error.\n            // The value is rolled back before throwing the error so developers may\n            // catch the error and continue processing.\n            if (!this.METADATA.allowInvalid) {\n              this.METADATA.RAW = change.old\n              throw new Error(`\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`)\n            } else {\n              change.reason = `\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`\n              NGN.WARN(change.reason)\n            }\n\n            this.emit('invalid', change)\n          } else if (!suppressEvents && priorValueIsValid !== null && priorValueIsValid) {\n            // If the field BECAME valid (compared to prior value),\n            // emit an event.\n            this.emit('valid', change)\n          }\n\n          if (typeof this.METADATA.lastValue === 'symbol') {\n            this.METADATA.lastValue = value\n          }\n\n          // If auditing is enabled and not explicitly ignored by an internal\n          // operation, commit the change.\n          if (!ignoreAudit && !this.virtual && this.METADATA.AUDITABLE) {\n            change.cursor = this.METADATA.AUDITLOG.commit(this.METADATA.RAW)\n          }\n\n          // Notify when the update is complete.\n          if (!suppressEvents) {\n            this.emit('update', change)\n          }\n\n          // Mark unnecessary code for garbage collection.\n          priorValueIsValid = null\n          change = null\n        },\n\n        // Submit the payload to the parent model (if applicable).\n        commitPayload: (payload) => {\n          if (this.METADATA.model) {\n            payload.action = 'update'\n            payload.join = true\n\n            this.increaseMaxListeners(3)\n            this.METADATA.model.emit(\n              [\n                'update',\n                `${payload.field}.update`,\n                `update.${payload.field}`\n              ],\n              payload\n            )\n\n            payload = null // Mark for garbage collection\n          }\n        }\n      })\n    })\n\n    // Apply common rules\n    if (NGN.typeof(this.METADATA.rules) !== 'array') {\n      this.METADATA.rules = NGN.forceArray(this.METADATA.rules)\n    }\n\n    if (this.METADATA.rules.length > 0) {\n      for (let i = 0; i < this.METADATA.rules.length; i++) {\n        if (NGN.isFn(this.METADATA.rules[i]) && !(this.METADATA.rules[i] instanceof NGN.DATA.Rule)) {\n          this.METADATA.rules[i] = new NGN.DATA.Rule(this.METADATA.rules[i], `Custom Rule #${i + 1}`)\n        }\n      }\n    }\n\n    // Apply pattern validation if specified.\n    if (this.METADATA.dataType === String) {\n      if (this.METADATA.pattern !== null) {\n        this.METADATA.rules.unshift(new NGN.DATA.Rule(cfg.pattern, `Pattern Match (${cfg.pattern.toString()})`))\n      }\n\n      /**\n       * @cfg {Boolean} [nonempty]\n       * @info This validation attribute applies to #String fields only.\n       * Validates a value is not blank, `null`, or `undefined`.\n       */\n      if (cfg.nonempty) {\n        this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n          return value.trim().length > 0\n        }, `No Blanks (${cfg.pattern.toString()})`))\n      }\n    }\n\n    /**\n     * @cfg {Number} [min]\n     * @info This validation attribute applies to #Array, #String, and #Number fields only.\n     * Specify a minimum value:\n     *\n     * - For string values, this is a minimum number of characters.\n     * - For numeric values, this is a minimum inclusive value (i.e. value must be greater than\n     * or equal to the minimum).\n     * - For arrays, this is a minimum number of items that must exist in the array.\n     */\n    /**\n     * @cfg {Number} [max]\n     * @info This validation attribute applies to #Array, #String, and #Number fields only.\n     * Specify a maximum value:\n     *\n     * - For string values, this is a maximum number of characters.\n     * - For numeric values, this is a maximum inclusive value (i.e. value must be less than\n     * or equal to the maximum).\n     * - For arrays, this is a maximum number of items that may exist in the array.\n     */\n\n    // Apply number-specific validations.\n    if (this.METADATA.dataType === Number || this.METADATA.dataType === Date || this.METADATA.dataType === String) {\n      // Support minimum/maximum range\n      if (NGN.objectHasAny(cfg, 'min', 'minimum', 'max', 'maximum')) {\n        cfg.range = NGN.forceArray(NGN.coalesce(cfg.range))\n        cfg.range.push([NGN.coalesce(cfg.min, cfg.minimum), NGN.coalesce(cfg.max, cfg.maximum)])\n      }\n\n      /**\n       * @cfg {Number} [range]\n       * @info This validation attribute applies to #String and #Number fields only.\n       * Specify a range of acceptable values:\n       *\n       * - For numbers, this implies inclusive ranges. For example, `1-10` means \"between 1 and 10, where both 1 and 10 are valid.\"\n       * - For strings, this implies inclusive ranges just like numbers, where the number is the character count.\n       */\n      if (cfg.hasOwnProperty('range')) {\n        this.METADATA.rules.unshift(new NGN.DATA.RangeRule('Numeric Range', cfg.range))\n      }\n\n      if (this.METADATA.dataType === Number) {\n        // Support numeric patterns (i.e. support for integers)\n        if (NGN.coalesce(cfg.pattern)) {\n          this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n            return cfg.pattern.test(value.toString())\n          }, `Numeric Pattern (${cfg.pattern.toString().substr(0, 15) + (cfg.pattern.toString().length > 15 ? '...' : '')})`))\n        }\n\n        /**\n         * @cfg {Number} [multipleOf]\n         * @info This validation attribute applies to #Number fields only.\n         * Insures the field value is a multiple of this number. For example,\n         * if the multiple is `10` and the value is `100`, it is valid.\n         * If the multiple is `10` and the value is `101`, it is invalid.\n         */\n        if (NGN.typeof(cfg.multipleOf) === 'number') {\n          this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n            return Math.abs(value % cfg.multipleOf) === 0\n          }, `Numeric Multiple of ${cfg.multipleOf}`))\n        }\n      }\n    }\n\n    // Apply array-specific native validations\n    if (this.METADATA.dataType === Array) {\n      // Enforce minimum number of array items\n      if (NGN.objectHasAny(cfg, 'min', 'minimum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => value.length >= NGN.coalesce(cfg.min, cfg.minimum), `${NGN.coalesce(cfg.min, cfg.minimum)} count minimum`))\n      }\n\n      // Enforce maximum number of array items\n      if (NGN.objectHasAny(cfg, 'max', 'maximum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => value.length <= NGN.coalesce(cfg.max, cfg.maximum), `${NGN.coalesce(cfg.max, cfg.maximum)} count maximum`))\n      }\n\n      /**\n       * @cfg {Array} [unique]\n       * @info This validation attribute applies to #Array fields only.\n       * @warning This is a computationally expensive validation when used in NGN Data Stores.\n       * Validates that all items are unique.\n       */\n      if (NGN.coalesce(cfg.unique, false)) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => NGN.dedupe(value).length === value.length, 'Unique value constraint'))\n      }\n\n      /**\n       * @cfg {any} [listType]\n       * @info This validation attribute applies to #Array fields only.\n       * Require each element of the array to conform to the specified data\n       * type. For example, setting `listType: Number` will validate that\n       * each element of the array is a number.\n       *\n       * ```js\n       * [1, 2, 3, 4, 5] // Valid\n       * [1, 2, 'three', 4, 5] // Invalid\n       * ```\n       */\n      if (cfg.hasOwnProperty('listType')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          for (let i = 0; i < value.length; i++) {\n            if (NGN.typeof(value[i]) !== NGN.typeof(cfg.listType)) {\n              return false\n            }\n          }\n\n          return true\n        }, `${NGN.typeof(cfg.listType).toUpperCase()} list type constraint`))\n      }\n\n      // Support enumerations in array values\n      if (cfg.hasOwnProperty('enum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          return cfg.enum.indexOf(value) >= 0\n        }))\n      }\n\n      /**\n       * @cfg {Array} [tuples]\n       * @info This validation attribute applies to #Array fields only.\n       * @warning This is a computationally expensive validation when used in NGN Data Stores.\n       * Validate each item of an array according to a unique schema.\n       * Each item is a key value object, which supports only the `type` and\n       * `enum` validations.\n       *\n       * For example:\n       *\n       * ```js\n       * {\n       *   tuples: [{\n       *     type: Number\n       *   }, {\n       *     type: String,\n       *     enum: ['a', 'b', 'c']\n       *   }, {\n       *     enum: ['d', 1]\n       *   }]\n       * }\n       * ```\n       * The configuration above will make sure the first array item is a number,\n       * while the second is either `a`, `b`, or `c`, and the third is either\n       * the letter `d` or the number `1`. Only the first three items of the\n       * array will be checked, but there must be at least 3 items.\n       */\n      if (cfg.hasOwnProperty('tuples')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          if (value.length < cfg.tuples.length) {\n            return false\n          }\n\n          for (let i = 0; i < cfg.tuples.length; i++) {\n            if (cfg.tuples[i].hasOwnProperty('type')) {\n              if (NGN.typeof(value[i]) !== NGN.typeof(cfg.tuples[i].type)) {\n                return false\n              }\n            }\n\n            if (cfg.tuples[i].hasOwnProperty('enum')) {\n              if (cfg.tuples[i].enum.indexOf(value[i]) < 0) {\n                return false\n              }\n            }\n          }\n\n          return true\n        }, 'Tuple constraint'))\n      }\n    }\n\n    /**\n     * @cfg {Array} [enum]\n     * An enumeration of available values this field is allowed to have.\n     */\n    if (NGN.objectHasAny(cfg, 'enum', 'enumeration')) {\n      this.METADATA.ENUMERABLE_VALUES = new Set(NGN.forceArray(NGN.coalesce(cfg.enum, cfg.enumeration)))\n      this.METADATA.rules.push(new NGN.DATA.Rule((value) => this.METADATA.ENUMERABLE_VALUES.has(value), 'Enumerable Values'))\n    }\n\n    /**\n     * @cfg {Array} [not]\n     * A \"reverse\" enumeration, i.e. a list of values this field is **not** allowed to be.\n     */\n    if (NGN.objectHasAny(cfg, 'not', 'notin')) {\n      this.METADATA.REVERSE_ENUMERABLE_VALUES = new Set(NGN.forceArray(NGN.coalesce(cfg.not, cfg.notin)))\n      this.METADATA.rules.push(new NGN.DATA.Rule((value) => !this.METADATA.REVERSE_ENUMERABLE_VALUES.has(value), 'Rejected Values'))\n    }\n\n    // Check if the field type is an array, which indicates multiple\n    // data types are considered valid.\n    if (cfg.type instanceof Array) {\n      // If the array has no values, assume the user meant to create an \"Array\" data type.\n      // Warn them, in case this was not the intention.\n      if (cfg.type.length === 0) {\n        NGN.WARN(`No data type specified for ${this.name} field. Autoconverted to an array.`)\n        cfg.type = Array\n      } else if (cfg.type.length === 1) {\n        // If there is only one data type, the array is extraneous and standard\n        // datatype validation can be used.\n        cfg.type = cfg.type[0]\n      }\n    }\n\n    /**\n     * @cfg {Primitive|Array} [type=String]\n     * The type should be a JavaScript primitive, class, or constructor.\n     * For example, `String`, `Number`, `Boolean`, `RegExp`, `Array`, or `Date`.\n     * This can also be an array of primitive values. For example, `[String, Number]`\n     * indicates the field could be a string or a numeric value.\n     */\n    if (cfg.type instanceof Array) {\n      let typeList = cfg.type.map(type => NGN.typeof(type))\n\n      this.METADATA.rules.unshift(\n        new NGN.DATA.Rule(\n          (value) => typeList.indexOf(NGN.typeof(value)) >= 0,\n          `${this.type.toUpperCase()} Multitype Check`\n        )\n      )\n    } else {\n      this.METADATA.rules.unshift(\n        new NGN.DATA.Rule(\n          (value) => NGN.typeof(value) === NGN.typeof(this.METADATA.dataType),\n          `${this.type.toUpperCase()} Type Check`\n        )\n      )\n    }\n\n    // Associate a model if one is defined.\n    if (NGN.coalesce(cfg.model) !== null) {\n      this.model = cfg.model\n    }\n  }\n\n  get sourceName () {\n    return this.METADATA.sourceName\n  }\n\n  get auditable () {\n    return this.METADATA.AUDITABLE\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n      this.METADATA.AUDITLOG.relay('*', this, 'transaction.')\n    }\n  }\n\n  /**\n   * @property {NGN.DATA.Model} model\n   * Represents the model/record the field is associated to.\n   * The model may be configured once, after which this property\n   * becomes read-only. This will also be read-only if #model is set\n   * to a valid value.\n   */\n  get model () {\n    return this.METADATA.model\n  }\n\n  set model (value) {\n    if (this.METADATA.model === null) {\n      if (value instanceof NGN.DATA.Entity) {\n        this.METADATA.model = value\n\n        // let events = Array.from(this.METADATA.EVENTS.values())\n        // events.splice(events.indexOf('update'), 1)\n        //\n        this.on('update', (payload) => this.METADATA.commitPayload(payload))\n        //\n        // for (let i = 0; i < events.length; i++) {\n        //   this.on(events[i], () => this.METADATA.model.emit(`field.${events[i]}`, ...arguments))\n        // }\n      } else {\n        NGN.WARN('Invalid model.')\n      }\n    } else {\n      NGN.WARN('Cannot set model multiple times.')\n    }\n  }\n\n  /**\n   * @property {string} fieldType\n   * The type of field.\n   */\n  get fieldType () {\n    return this.METADATA.fieldType\n  }\n\n  /**\n   * @property {boolean} required\n   * Indicates the field must have a non-null value.\n   */\n  get required () {\n    return this.METADATA.required\n  }\n\n  set required (value) {\n    this.METADATA.required = NGN.forceBoolean(value)\n  }\n\n  /**\n   * @property {string} type\n   * The type of data in string format.\n   */\n  get type () {\n    return NGN.typeof(this.METADATA.dataType)\n  }\n\n  /**\n   * @property {boolean} hidden\n   * Indicates the field should be considered hidden.\n   */\n  get hidden () {\n    return this.METADATA.hidden\n  }\n\n  set hidden (value) {\n    let originallyHidden = this.hidden\n    let currentlyHidden = NGN.forceBoolean(value)\n\n    if (originallyHidden !== currentlyHidden) {\n      this.METADATA.hidden = currentlyHidden\n      this.emit(originallyHidden ? 'unhidden' : 'hidden')\n    }\n  }\n\n  /**\n   * @property {boolean} virtual\n   * Indicates the field should be considered virtual.\n   */\n  get virtual () {\n    return this.METADATA.fieldType === 'virtual'\n  }\n\n  /**\n   * @property {boolean} identifier\n   * Indicates the field is considered an identifier.\n   */\n  get identifier () {\n    return this.METADATA.isIdentifier\n  }\n\n  set identifier (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.isIdentifier) {\n      this.METADATA.isIdentifier = value\n      this.emit('keystatus.changed', this)\n    }\n  }\n\n  get name () {\n    return this.METADATA.name\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates the model is new or does not exist according to the persistence store.\n   * @private\n   * @readonly\n   */\n  get isNew () {\n    return this.METADATA.IS_NEW\n  }\n\n  /**\n   * @property {Any} default\n   * The default field value.\n   */\n  get default () {\n    if (this.isIdentifier) {\n      return NGN.coalesce(this.METADATA.autoid, this.METADATA.default)\n    }\n\n    if (NGN.isFn(this.METADATA.default) && this.type !== 'function') {\n      return this.METADATA.default.apply(this)\n    }\n\n    return this.METADATA.default\n  }\n\n  /**\n   * @property {Any} value\n   * The value of the field.\n   */\n  get value () {\n    if (typeof this.METADATA.RAW !== 'symbol') {\n      return this.METADATA.RAW\n    }\n\n    return this.METADATA.default\n  }\n\n  set value (value) {\n    this.METADATA.setValue(value)\n  }\n\n  /**\n   * @property silentValue\n   * A write-only attribute to set the value without triggering an update event.\n   * This is designed primarily for use with live update proxies to prevent\n   * endless event loops.\n   * @param {any} value\n   * The new value of the field.\n   * @private\n   * @writeonly\n   */\n  set silentValue (value) {\n    this.METADATA.setValue(value, true)\n  }\n\n  get modified () {\n    if (typeof this.META.lastValue === 'symbol') {\n      return false\n    }\n\n    return this.METADATA.lastValue !== this.value\n  }\n\n  /**\n   * @property {boolean} valid\n   * Indicates the field value is valid.\n   */\n  get valid () {\n    if (this.required && NGN.coalesce(this.METADATA.RAW) === null) {\n      this.METADATA.violatedRule = 'Data Required'\n      NGN.WARN(`${this.METADATA.name} is a required field.`)\n      return false\n    }\n\n    if (this.METADATA.rules.length > 0) {\n      for (let rule = 0; rule < this.METADATA.rules.length; rule++) {\n        if (!this.METADATA.rules[rule].test(this.METADATA.RAW)) {\n          this.METADATA.violatedRule = this.METADATA.rules[rule].name\n          return false\n        }\n      }\n    }\n\n    this.METADATA.violatedRule = null\n\n    return true\n  }\n\n  /**\n   * @property {String}\n   * Name of the rule which was violated.\n   */\n  get violatedRule () {\n    return NGN.coalesce(this.METADATA.violatedRule, 'None')\n  }\n\n  /**\n   * @property {Array} changelog\n   * The changelog returns the underlying NGN.DATA.TransactionLog#log if\n   * auditing is available. The array will be empty if auditing is disabled.\n   */\n  get changelog () {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The changelog for the ${this.name} field is empty because auditing is disabled.`)\n      return []\n    }\n\n    return this.METADATA.AUDITLOG.log\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog (transaction log). To \"undo\" an \"undo\", use #redo.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  undo (count = 1, suppressEvents = false) {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The undo operation failed on the ${this.name} field because auditing is disabled.`)\n      return\n    }\n\n    let id = this.METADATA.AUDITLOG.rollback(count)\n\n    // Silently set the value to an older value.\n    this.METADATA.setValue(this.METADATA.AUDITLOG.getCommit(id).value, suppressEvents, true)\n  }\n\n  /**\n   * @method redo\n   * A function to reapply known changes. This operation affects\n   * the changelog (transaction log).\n   *\n   * The redo operation only works after an undo operation, but before a new\n   * value is committed to the transaction log. In other words, `undo -> redo`\n   * will work, but `undo -> update -> redo` will not. For details, see how\n   * the NGN.DATA.TransactionLog cursor system works.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to quietly update the value (prevents `update` event from\n   * firing).\n   */\n  redo (count = 1, suppressEvents = false) {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The redo operation failed on the ${this.name} field because auditing is disabled.`)\n      return\n    }\n\n    let id = this.METADATA.AUDITLOG.advance(count)\n\n    // Silently set the value to a newer value.\n    this.METADATA.setValue(this.METADATA.AUDITLOG.getCommit(id).value, suppressEvents, true)\n  }\n\n  /**\n   * Hide the field.\n   */\n  hide () {\n    this.hidden = true\n  }\n\n  /**\n   * Unhide the field.\n   */\n  unhide () {\n    this.hidden = false\n  }\n\n  /**\n   * Do not throw errors whan a value is marked as invalid.\n   */\n  allowInvalid () {\n    this.METADATA.allowInvalid = true\n  }\n\n  /**\n   * Throw errors whan a value is marked as invalid.\n   */\n  disallowInvalid () {\n    this.METADATA.allowInvalid = false\n  }\n\n  /**\n   * Attempt to automatically correct a value according to the\n   * field's data type.\n   * @param  {Any} value\n   * The value to attempt to autocorrect.\n   * @return {Any}\n   * Returns the value after attempting to autocorrect the value.\n   */\n  autoCorrectValue (value) {\n    try {\n      switch (this.type) {\n        case 'number':\n          value = NGN.forceNumber(value)\n          break\n\n        case 'boolean':\n          value = NGN.forceBoolean(value)\n          break\n\n        case 'array':\n          value = NGN.forceArray(value)\n          break\n\n        case 'string':\n          value = value.toString()\n          break\n\n        case 'date':\n          let valueType = NGN.typeof(value)\n\n          if (valueType !== 'date') {\n            if (valueType === 'number') {\n              let dt = new Date()\n              dt.setTime(value)\n\n              value = dt\n            } else {\n              value = new Date(Date.parse(value))\n            }\n          }\n\n          break\n      }\n    } finally {\n      return value // eslint-disable-line no-unsafe-finally\n    }\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "invalid": {
          "type": "event",
          "label": "invalid",
          "description": null,
          "code": "this.emit('invalid', change)",
          "start": {
            "line": 286,
            "column": 12
          },
          "end": {
            "line": 286,
            "column": 40
          },
          "flags": [],
          "parameters": {
            "change": {
              "type": "argument",
              "label": "change",
              "description": null,
              "code": "change",
              "start": {
                "line": 286,
                "column": 33
              },
              "end": {
                "line": 286,
                "column": 39
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "valid": {
          "type": "event",
          "label": "valid",
          "description": null,
          "code": "this.emit('valid', change)",
          "start": {
            "line": 290,
            "column": 12
          },
          "end": {
            "line": 290,
            "column": 38
          },
          "flags": [],
          "parameters": {
            "change": {
              "type": "argument",
              "label": "change",
              "description": null,
              "code": "change",
              "start": {
                "line": 290,
                "column": 31
              },
              "end": {
                "line": 290,
                "column": 37
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "update": {
          "type": "event",
          "label": "update",
          "description": null,
          "code": "this.emit('update', change)",
          "start": {
            "line": 305,
            "column": 12
          },
          "end": {
            "line": 305,
            "column": 39
          },
          "flags": [],
          "parameters": {
            "change": {
              "type": "argument",
              "label": "change",
              "description": null,
              "code": "change",
              "start": {
                "line": 305,
                "column": 32
              },
              "end": {
                "line": 305,
                "column": 38
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 34,
        "column": 15
      },
      "end": {
        "line": 959,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/field/Field.js",
      "extends": "EventEmitter",
      "configuration": {},
      "properties": {
        "METADATA": {
          "type": "property",
          "label": "METADATA",
          "description": null,
          "code": "METADATA: NGN.privateconst({\n        /**\n         * @cfg {boolean} [required=false]\n         * Indicates the value is required.\n         */\n        required: NGN.coalesce(cfg.required, false),\n\n        /**\n         * @cfgproperty {boolean} [hidden=false]\n         * Indicates the field is hidden (metadata).\n         */\n        hidden: NGN.coalesce(cfg.hidden, false),\n\n        // Identifies the property as a standard data attribute.\n        // Alternative options include `data`, `key`, `join`, `virtual`.\n        fieldType: NGN.coalesce(cfg.identifier, false) ? 'key' : 'data',\n\n        isIdentifier: NGN.coalesce(cfg.identifier, false),\n\n        /**\n         * @cfg {boolean} [autocorrectInput=true]\n         * Attempt to automatically correct data type values. For example,\n         * a numeric field receiving a value of `'10'` will automatically\n         * convert the input to `10`. Only arrays, numbers, and booleans are\n         * supported. See NGN#forceArray, NGN#forceBoolean, and NGN#forceNumber\n         * for details.\n         */\n        autocorrectInput: NGN.coalesce(cfg.autocorrectInput, false),\n\n        /**\n         * @cfg {RegExp} [pattern]\n         * A pattern, as defined by a standard RegExp, that the data must match.\n         */\n        pattern: NGN.coalesceb(cfg.pattern),\n\n        /**\n         * @cfgproperty {string} name\n         * The field name.\n         */\n        name: NGN.coalesce(cfg.name),\n\n        /**\n         * @cfgproperty {string} description\n         * This is a metadata field, primarily used for documentation\n         * or schema generation purposes.\n         */\n        description: NGN.coalesce(cfg.description, `${NGN.typeof(cfg.type)} field`),\n\n        /**\n         * @cfgproperty {string} [sourceName]\n         * A source name represents the physical name of an attribute as it\n         * would be recognized in a system of record. For example, a field\n         * named `firstname` may need to be written to disk/memory as `gn`\n         * (commonly used as shorthand for givenName in LDAP environments\n         * and relational databases).\n         *\n         * By specifying `firstname` as the field name and `gn` as the source\n         * name, the field will automatically map values from the source\n         * to model name and vice versa.\n         *\n         * For instance, a JSON input may look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"John\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         *\n         * When this data is applied to the field (or loaded in a\n         * NGN.DATA.Model), the field #value for `firstname` would be `John`.\n         * If the field #value is changed to `Jill` (i.e.\n         * `firstname.value = 'Jill'`), the resulting data set would look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"Jill\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         */\n        sourceName: NGN.coalesce(cfg.sourceName),\n\n        /**\n         * @cfg {any} default\n         * The default value of the field when no value is specified.\n         */\n        default: NGN.coalesce(cfg.default),\n\n        lastValue: Symbol('no.value'),\n\n        /**\n         * @cfg {Primitive} [type=String]\n         * The JS primitive representing the type of data represented\n         * by the field.\n         */\n        dataType: NGN.coalesce(cfg.type, String),\n\n        /**\n         * @cfg {function} [rule[]]\n         * A function, or an array of functions, which determine whether the\n         * field value is valid or not. These functions receive a single argument\n         * (the data value) and must return a Boolean value.\n         */\n        rules: NGN.coalesce(cfg.rule, cfg.rules, cfg.validators, []),\n        violatedRule: null,\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * If this is set to `false`, invalid values will throw an error.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {function} transformer\n         * A synchronous transformation function will be applied each time\n         * the field value is set. This can be used to modify data _before_ it\n         * is stored as a field value. The returned value from the function\n         * will be the new value of the field.\n         *\n         * The transformation function will receive the input as it's only\n         * aregument. For example:\n         *\n         * ```js\n         * let field = new NGN.DATA.Field({\n         *   name: 'testfield',\n         *   transformer: function (input) {\n         *     return input + '_test'\n         *   }\n         * })\n         *\n         * field.value = 'a'\n         *\n         * console.log(field.value) // Outputs \"a_test\"\n         * ```\n         *\n         * **Transformations can affect performance.** In small data sets,\n         * transformations are typically negligible, only adding a few\n         * milliseconds to processing time. This may affect large data sets,\n         * particularly data stores using defauly bulk recod loading.\n         */\n        TRANSFORM: NGN.coalesce(cfg.transformer),\n\n        RAWDATAPLACEHOLDER: EMPTYDATA,\n        RAW: EMPTYDATA,\n        ENUMERABLE_VALUES: null,\n        REVERSE_ENUMERABLE_VALUES: null,\n        IS_NEW: true,\n\n        EVENTS: new Set([\n          'hidden',\n          'unhidden',\n          'update',\n          'invalid',\n          'valid',\n          'rule.add',\n          'rule.remove'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n\n        /**\n         * @cfg {Number} [auditMaxEntries=20]\n         * The maximum number of historical records to maintain for the field.\n         * See NGN.DATA.TransactionLog#constructor for details.\n         */\n        AUDITLOG: NGN.coalesce(cfg.audit, false)\n          ? new NGN.DATA.TransactionLog(NGN.coalesce(cfg.auditMaxEntries, 10))\n          : null,\n\n        /**\n         * @cfg {NGN.DATA.Model} [model]\n         * Optionally specify the parent model.\n         */\n        model: null,\n\n        // Set the value using a configuration.\n        setValue: (value, suppressEvents = false, ignoreAudit = false) => {\n          // Preprocessing (transform input)\n          if (this.METADATA.TRANSFORM !== null && NGN.isFn(this.METADATA.TRANSFORM)) {\n            value = this.METADATA.TRANSFORM.call(this, value)\n          }\n\n          // Attempt to auto-correct input when possible.\n          if (this.METADATA.autocorrectInput && this.type !== NGN.typeof(value)) {\n            value = this.autoCorrectValue(value)\n          }\n\n          // Ignore changes when the value hasn't been modified.\n          if (value === this.value) {\n            return\n          }\n\n          let change = {\n            field: this,\n            old: typeof this.METADATA.RAW === 'symbol' ? undefined : this.METADATA.RAW,\n            new: value\n          }\n\n          let priorValueIsValid = this.valid\n\n          this.METADATA.RAW = value\n\n          // Notify when an invalid value is detected.\n          if (!this.valid) {\n            // If invalid values are explicitly prohibited, throw an error.\n            // The value is rolled back before throwing the error so developers may\n            // catch the error and continue processing.\n            if (!this.METADATA.allowInvalid) {\n              this.METADATA.RAW = change.old\n              throw new Error(`\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`)\n            } else {\n              change.reason = `\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`\n              NGN.WARN(change.reason)\n            }\n\n            this.emit('invalid', change)\n          } else if (!suppressEvents && priorValueIsValid !== null && priorValueIsValid) {\n            // If the field BECAME valid (compared to prior value),\n            // emit an event.\n            this.emit('valid', change)\n          }\n\n          if (typeof this.METADATA.lastValue === 'symbol') {\n            this.METADATA.lastValue = value\n          }\n\n          // If auditing is enabled and not explicitly ignored by an internal\n          // operation, commit the change.\n          if (!ignoreAudit && !this.virtual && this.METADATA.AUDITABLE) {\n            change.cursor = this.METADATA.AUDITLOG.commit(this.METADATA.RAW)\n          }\n\n          // Notify when the update is complete.\n          if (!suppressEvents) {\n            this.emit('update', change)\n          }\n\n          // Mark unnecessary code for garbage collection.\n          priorValueIsValid = null\n          change = null\n        },\n\n        // Submit the payload to the parent model (if applicable).\n        commitPayload: (payload) => {\n          if (this.METADATA.model) {\n            payload.action = 'update'\n            payload.join = true\n\n            this.increaseMaxListeners(3)\n            this.METADATA.model.emit(\n              [\n                'update',\n                `${payload.field}.update`,\n                `update.${payload.field}`\n              ],\n              payload\n            )\n\n            payload = null // Mark for garbage collection\n          }\n        }\n      })",
          "start": {
            "line": 65,
            "column": 6
          },
          "end": {
            "line": 332,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "sourceName": {
          "type": "property",
          "label": "sourceName",
          "description": null,
          "code": "get sourceName () {\n    return this.METADATA.sourceName\n  }",
          "start": {
            "line": 599,
            "column": 2
          },
          "end": {
            "line": 601,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "auditable": {
          "type": "property",
          "label": "auditable",
          "description": null,
          "code": "set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\n      this.METADATA.AUDITLOG.relay('*', this, 'transaction.')\n    }\n  }",
          "start": {
            "line": 607,
            "column": 2
          },
          "end": {
            "line": 615,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "model": {
          "type": "property",
          "label": "model",
          "description": null,
          "code": "set model (value) {\n    if (this.METADATA.model === null) {\n      if (value instanceof NGN.DATA.Entity) {\n        this.METADATA.model = value\n\n        // let events = Array.from(this.METADATA.EVENTS.values())\n        // events.splice(events.indexOf('update'), 1)\n        //\n        this.on('update', (payload) => this.METADATA.commitPayload(payload))\n        //\n        // for (let i = 0; i < events.length; i++) {\n        //   this.on(events[i], () => this.METADATA.model.emit(`field.${events[i]}`, ...arguments))\n        // }\n      } else {\n        NGN.WARN('Invalid model.')\n      }\n    } else {\n      NGN.WARN('Cannot set model multiple times.')\n    }\n  }",
          "start": {
            "line": 628,
            "column": 2
          },
          "end": {
            "line": 647,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "fieldType": {
          "type": "property",
          "label": "fieldType",
          "description": null,
          "code": "get fieldType () {\n    return this.METADATA.fieldType\n  }",
          "start": {
            "line": 653,
            "column": 2
          },
          "end": {
            "line": 655,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "required": {
          "type": "property",
          "label": "required",
          "description": null,
          "code": "set required (value) {\n    this.METADATA.required = NGN.forceBoolean(value)\n  }",
          "start": {
            "line": 665,
            "column": 2
          },
          "end": {
            "line": 667,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "type": {
          "type": "property",
          "label": "type",
          "description": null,
          "code": "get type () {\n    return NGN.typeof(this.METADATA.dataType)\n  }",
          "start": {
            "line": 673,
            "column": 2
          },
          "end": {
            "line": 675,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "hidden": {
          "type": "property",
          "label": "hidden",
          "description": null,
          "code": "set hidden (value) {\n    let originallyHidden = this.hidden\n    let currentlyHidden = NGN.forceBoolean(value)\n\n    if (originallyHidden !== currentlyHidden) {\n      this.METADATA.hidden = currentlyHidden\n      this.emit(originallyHidden ? 'unhidden' : 'hidden')\n    }\n  }",
          "start": {
            "line": 685,
            "column": 2
          },
          "end": {
            "line": 693,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "virtual": {
          "type": "property",
          "label": "virtual",
          "description": null,
          "code": "get virtual () {\n    return this.METADATA.fieldType === 'virtual'\n  }",
          "start": {
            "line": 699,
            "column": 2
          },
          "end": {
            "line": 701,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "identifier": {
          "type": "property",
          "label": "identifier",
          "description": null,
          "code": "set identifier (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.isIdentifier) {\n      this.METADATA.isIdentifier = value\n      this.emit('keystatus.changed', this)\n    }\n  }",
          "start": {
            "line": 711,
            "column": 2
          },
          "end": {
            "line": 718,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "name": {
          "type": "property",
          "label": "name",
          "description": null,
          "code": "get name () {\n    return this.METADATA.name\n  }",
          "start": {
            "line": 720,
            "column": 2
          },
          "end": {
            "line": 722,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "isNew": {
          "type": "property",
          "label": "isNew",
          "description": null,
          "code": "get isNew () {\n    return this.METADATA.IS_NEW\n  }",
          "start": {
            "line": 730,
            "column": 2
          },
          "end": {
            "line": 732,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "default": {
          "type": "property",
          "label": "default",
          "description": null,
          "code": "get default () {\n    if (this.isIdentifier) {\n      return NGN.coalesce(this.METADATA.autoid, this.METADATA.default)\n    }\n\n    if (NGN.isFn(this.METADATA.default) && this.type !== 'function') {\n      return this.METADATA.default.apply(this)\n    }\n\n    return this.METADATA.default\n  }",
          "start": {
            "line": 738,
            "column": 2
          },
          "end": {
            "line": 748,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "value": {
          "type": "property",
          "label": "value",
          "description": null,
          "code": "set value (value) {\n    this.METADATA.setValue(value)\n  }",
          "start": {
            "line": 762,
            "column": 2
          },
          "end": {
            "line": 764,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "silentValue": {
          "type": "property",
          "label": "silentValue",
          "description": null,
          "code": "set silentValue (value) {\n    this.METADATA.setValue(value, true)\n  }",
          "start": {
            "line": 776,
            "column": 2
          },
          "end": {
            "line": 778,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "modified": {
          "type": "property",
          "label": "modified",
          "description": null,
          "code": "get modified () {\n    if (typeof this.META.lastValue === 'symbol') {\n      return false\n    }\n\n    return this.METADATA.lastValue !== this.value\n  }",
          "start": {
            "line": 780,
            "column": 2
          },
          "end": {
            "line": 786,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "valid": {
          "type": "property",
          "label": "valid",
          "description": null,
          "code": "get valid () {\n    if (this.required && NGN.coalesce(this.METADATA.RAW) === null) {\n      this.METADATA.violatedRule = 'Data Required'\n      NGN.WARN(`${this.METADATA.name} is a required field.`)\n      return false\n    }\n\n    if (this.METADATA.rules.length > 0) {\n      for (let rule = 0; rule < this.METADATA.rules.length; rule++) {\n        if (!this.METADATA.rules[rule].test(this.METADATA.RAW)) {\n          this.METADATA.violatedRule = this.METADATA.rules[rule].name\n          return false\n        }\n      }\n    }\n\n    this.METADATA.violatedRule = null\n\n    return true\n  }",
          "start": {
            "line": 792,
            "column": 2
          },
          "end": {
            "line": 811,
            "column": 3
          },
          "flags": [],
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "violatedRule": {
          "type": "property",
          "label": "violatedRule",
          "description": null,
          "code": "get violatedRule () {\n    return NGN.coalesce(this.METADATA.violatedRule, 'None')\n  }",
          "start": {
            "line": 817,
            "column": 2
          },
          "end": {
            "line": 819,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "changelog": {
          "type": "property",
          "label": "changelog",
          "description": null,
          "code": "get changelog () {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The changelog for the ${this.name} field is empty because auditing is disabled.`)\n      return []\n    }\n\n    return this.METADATA.AUDITLOG.log\n  }",
          "start": {
            "line": 826,
            "column": 2
          },
          "end": {
            "line": 833,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "url": {
          "type": "property",
          "label": "url",
          "description": "The URL where the request will be sent.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "crossOriginRequest": {
          "type": "property",
          "label": "crossOriginRequest",
          "description": "Indicates the request will be made to a domain outside of the\none hosting the request.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "boolean",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "username": {
          "type": "property",
          "label": "username",
          "description": "The username that will be used in any basic authentication operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "password": {
          "type": "property",
          "label": "password",
          "description": "It is possible to set a password for any basic authentication operations,\nbut it is not possible to read a password.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "accessToken": {
          "type": "property",
          "label": "accessToken",
          "description": "Supply a bearer access token for basic authenticaiton operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "Accepts an object with all configuration objects, or a string representing\n  the name of the field.",
          "code": "constructor (cfg) {\n    cfg = cfg || {}\n\n    if (typeof cfg === 'string') {\n      cfg = {\n        name: cfg\n      }\n    }\n\n    // Validate field configuration values\n    if (cfg.hasOwnProperty('pattern') && NGN.typeof(cfg.pattern) !== 'regexp') {\n      throw new Error('Invalid data field configuration. Pattern must be a valid JavaScript regular expression (RegExp).')\n    }\n\n    if (cfg.type === undefined) {\n      if (cfg.default) {\n        cfg.type = NGN.getType(NGN.typeof(cfg.default), String)\n      }\n    }\n\n    super(cfg)\n\n    const EMPTYDATA = Symbol('empty')\n\n    Object.defineProperties(this, {\n      METADATA: NGN.privateconst({\n        /**\n         * @cfg {boolean} [required=false]\n         * Indicates the value is required.\n         */\n        required: NGN.coalesce(cfg.required, false),\n\n        /**\n         * @cfgproperty {boolean} [hidden=false]\n         * Indicates the field is hidden (metadata).\n         */\n        hidden: NGN.coalesce(cfg.hidden, false),\n\n        // Identifies the property as a standard data attribute.\n        // Alternative options include `data`, `key`, `join`, `virtual`.\n        fieldType: NGN.coalesce(cfg.identifier, false) ? 'key' : 'data',\n\n        isIdentifier: NGN.coalesce(cfg.identifier, false),\n\n        /**\n         * @cfg {boolean} [autocorrectInput=true]\n         * Attempt to automatically correct data type values. For example,\n         * a numeric field receiving a value of `'10'` will automatically\n         * convert the input to `10`. Only arrays, numbers, and booleans are\n         * supported. See NGN#forceArray, NGN#forceBoolean, and NGN#forceNumber\n         * for details.\n         */\n        autocorrectInput: NGN.coalesce(cfg.autocorrectInput, false),\n\n        /**\n         * @cfg {RegExp} [pattern]\n         * A pattern, as defined by a standard RegExp, that the data must match.\n         */\n        pattern: NGN.coalesceb(cfg.pattern),\n\n        /**\n         * @cfgproperty {string} name\n         * The field name.\n         */\n        name: NGN.coalesce(cfg.name),\n\n        /**\n         * @cfgproperty {string} description\n         * This is a metadata field, primarily used for documentation\n         * or schema generation purposes.\n         */\n        description: NGN.coalesce(cfg.description, `${NGN.typeof(cfg.type)} field`),\n\n        /**\n         * @cfgproperty {string} [sourceName]\n         * A source name represents the physical name of an attribute as it\n         * would be recognized in a system of record. For example, a field\n         * named `firstname` may need to be written to disk/memory as `gn`\n         * (commonly used as shorthand for givenName in LDAP environments\n         * and relational databases).\n         *\n         * By specifying `firstname` as the field name and `gn` as the source\n         * name, the field will automatically map values from the source\n         * to model name and vice versa.\n         *\n         * For instance, a JSON input may look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"John\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         *\n         * When this data is applied to the field (or loaded in a\n         * NGN.DATA.Model), the field #value for `firstname` would be `John`.\n         * If the field #value is changed to `Jill` (i.e.\n         * `firstname.value = 'Jill'`), the resulting data set would look like:\n         *\n         * ```js\n         * {\n         *   \"gn\": \"Jill\",\n         *   \"sn\": \"Doe\"\n         * }\n         * ```\n         */\n        sourceName: NGN.coalesce(cfg.sourceName),\n\n        /**\n         * @cfg {any} default\n         * The default value of the field when no value is specified.\n         */\n        default: NGN.coalesce(cfg.default),\n\n        lastValue: Symbol('no.value'),\n\n        /**\n         * @cfg {Primitive} [type=String]\n         * The JS primitive representing the type of data represented\n         * by the field.\n         */\n        dataType: NGN.coalesce(cfg.type, String),\n\n        /**\n         * @cfg {function} [rule[]]\n         * A function, or an array of functions, which determine whether the\n         * field value is valid or not. These functions receive a single argument\n         * (the data value) and must return a Boolean value.\n         */\n        rules: NGN.coalesce(cfg.rule, cfg.rules, cfg.validators, []),\n        violatedRule: null,\n\n        /**\n         * @cfg {boolean} [allowInvalid=true]\n         * If this is set to `false`, invalid values will throw an error.\n         */\n        allowInvalid: NGN.coalesce(cfg.allowInvalid, true),\n\n        /**\n         * @cfg {function} transformer\n         * A synchronous transformation function will be applied each time\n         * the field value is set. This can be used to modify data _before_ it\n         * is stored as a field value. The returned value from the function\n         * will be the new value of the field.\n         *\n         * The transformation function will receive the input as it's only\n         * aregument. For example:\n         *\n         * ```js\n         * let field = new NGN.DATA.Field({\n         *   name: 'testfield',\n         *   transformer: function (input) {\n         *     return input + '_test'\n         *   }\n         * })\n         *\n         * field.value = 'a'\n         *\n         * console.log(field.value) // Outputs \"a_test\"\n         * ```\n         *\n         * **Transformations can affect performance.** In small data sets,\n         * transformations are typically negligible, only adding a few\n         * milliseconds to processing time. This may affect large data sets,\n         * particularly data stores using defauly bulk recod loading.\n         */\n        TRANSFORM: NGN.coalesce(cfg.transformer),\n\n        RAWDATAPLACEHOLDER: EMPTYDATA,\n        RAW: EMPTYDATA,\n        ENUMERABLE_VALUES: null,\n        REVERSE_ENUMERABLE_VALUES: null,\n        IS_NEW: true,\n\n        EVENTS: new Set([\n          'hidden',\n          'unhidden',\n          'update',\n          'invalid',\n          'valid',\n          'rule.add',\n          'rule.remove'\n        ]),\n\n        /**\n         * @cfg {boolean} [audit=false]\n         * Enable auditing to support #undo/#redo operations. This creates and\n         * manages a NGN.DATA.TransactionLog.\n         */\n        AUDITABLE: NGN.coalesce(cfg.audit, false),\n\n        /**\n         * @cfg {Number} [auditMaxEntries=20]\n         * The maximum number of historical records to maintain for the field.\n         * See NGN.DATA.TransactionLog#constructor for details.\n         */\n        AUDITLOG: NGN.coalesce(cfg.audit, false)\n          ? new NGN.DATA.TransactionLog(NGN.coalesce(cfg.auditMaxEntries, 10))\n          : null,\n\n        /**\n         * @cfg {NGN.DATA.Model} [model]\n         * Optionally specify the parent model.\n         */\n        model: null,\n\n        // Set the value using a configuration.\n        setValue: (value, suppressEvents = false, ignoreAudit = false) => {\n          // Preprocessing (transform input)\n          if (this.METADATA.TRANSFORM !== null && NGN.isFn(this.METADATA.TRANSFORM)) {\n            value = this.METADATA.TRANSFORM.call(this, value)\n          }\n\n          // Attempt to auto-correct input when possible.\n          if (this.METADATA.autocorrectInput && this.type !== NGN.typeof(value)) {\n            value = this.autoCorrectValue(value)\n          }\n\n          // Ignore changes when the value hasn't been modified.\n          if (value === this.value) {\n            return\n          }\n\n          let change = {\n            field: this,\n            old: typeof this.METADATA.RAW === 'symbol' ? undefined : this.METADATA.RAW,\n            new: value\n          }\n\n          let priorValueIsValid = this.valid\n\n          this.METADATA.RAW = value\n\n          // Notify when an invalid value is detected.\n          if (!this.valid) {\n            // If invalid values are explicitly prohibited, throw an error.\n            // The value is rolled back before throwing the error so developers may\n            // catch the error and continue processing.\n            if (!this.METADATA.allowInvalid) {\n              this.METADATA.RAW = change.old\n              throw new Error(`\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`)\n            } else {\n              change.reason = `\"${value}\" did not pass the ${this.METADATA.violatedRule} rule.`\n              NGN.WARN(change.reason)\n            }\n\n            this.emit('invalid', change)\n          } else if (!suppressEvents && priorValueIsValid !== null && priorValueIsValid) {\n            // If the field BECAME valid (compared to prior value),\n            // emit an event.\n            this.emit('valid', change)\n          }\n\n          if (typeof this.METADATA.lastValue === 'symbol') {\n            this.METADATA.lastValue = value\n          }\n\n          // If auditing is enabled and not explicitly ignored by an internal\n          // operation, commit the change.\n          if (!ignoreAudit && !this.virtual && this.METADATA.AUDITABLE) {\n            change.cursor = this.METADATA.AUDITLOG.commit(this.METADATA.RAW)\n          }\n\n          // Notify when the update is complete.\n          if (!suppressEvents) {\n            this.emit('update', change)\n          }\n\n          // Mark unnecessary code for garbage collection.\n          priorValueIsValid = null\n          change = null\n        },\n\n        // Submit the payload to the parent model (if applicable).\n        commitPayload: (payload) => {\n          if (this.METADATA.model) {\n            payload.action = 'update'\n            payload.join = true\n\n            this.increaseMaxListeners(3)\n            this.METADATA.model.emit(\n              [\n                'update',\n                `${payload.field}.update`,\n                `update.${payload.field}`\n              ],\n              payload\n            )\n\n            payload = null // Mark for garbage collection\n          }\n        }\n      })\n    })\n\n    // Apply common rules\n    if (NGN.typeof(this.METADATA.rules) !== 'array') {\n      this.METADATA.rules = NGN.forceArray(this.METADATA.rules)\n    }\n\n    if (this.METADATA.rules.length > 0) {\n      for (let i = 0; i < this.METADATA.rules.length; i++) {\n        if (NGN.isFn(this.METADATA.rules[i]) && !(this.METADATA.rules[i] instanceof NGN.DATA.Rule)) {\n          this.METADATA.rules[i] = new NGN.DATA.Rule(this.METADATA.rules[i], `Custom Rule #${i + 1}`)\n        }\n      }\n    }\n\n    // Apply pattern validation if specified.\n    if (this.METADATA.dataType === String) {\n      if (this.METADATA.pattern !== null) {\n        this.METADATA.rules.unshift(new NGN.DATA.Rule(cfg.pattern, `Pattern Match (${cfg.pattern.toString()})`))\n      }\n\n      /**\n       * @cfg {Boolean} [nonempty]\n       * @info This validation attribute applies to #String fields only.\n       * Validates a value is not blank, `null`, or `undefined`.\n       */\n      if (cfg.nonempty) {\n        this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n          return value.trim().length > 0\n        }, `No Blanks (${cfg.pattern.toString()})`))\n      }\n    }\n\n    /**\n     * @cfg {Number} [min]\n     * @info This validation attribute applies to #Array, #String, and #Number fields only.\n     * Specify a minimum value:\n     *\n     * - For string values, this is a minimum number of characters.\n     * - For numeric values, this is a minimum inclusive value (i.e. value must be greater than\n     * or equal to the minimum).\n     * - For arrays, this is a minimum number of items that must exist in the array.\n     */\n    /**\n     * @cfg {Number} [max]\n     * @info This validation attribute applies to #Array, #String, and #Number fields only.\n     * Specify a maximum value:\n     *\n     * - For string values, this is a maximum number of characters.\n     * - For numeric values, this is a maximum inclusive value (i.e. value must be less than\n     * or equal to the maximum).\n     * - For arrays, this is a maximum number of items that may exist in the array.\n     */\n\n    // Apply number-specific validations.\n    if (this.METADATA.dataType === Number || this.METADATA.dataType === Date || this.METADATA.dataType === String) {\n      // Support minimum/maximum range\n      if (NGN.objectHasAny(cfg, 'min', 'minimum', 'max', 'maximum')) {\n        cfg.range = NGN.forceArray(NGN.coalesce(cfg.range))\n        cfg.range.push([NGN.coalesce(cfg.min, cfg.minimum), NGN.coalesce(cfg.max, cfg.maximum)])\n      }\n\n      /**\n       * @cfg {Number} [range]\n       * @info This validation attribute applies to #String and #Number fields only.\n       * Specify a range of acceptable values:\n       *\n       * - For numbers, this implies inclusive ranges. For example, `1-10` means \"between 1 and 10, where both 1 and 10 are valid.\"\n       * - For strings, this implies inclusive ranges just like numbers, where the number is the character count.\n       */\n      if (cfg.hasOwnProperty('range')) {\n        this.METADATA.rules.unshift(new NGN.DATA.RangeRule('Numeric Range', cfg.range))\n      }\n\n      if (this.METADATA.dataType === Number) {\n        // Support numeric patterns (i.e. support for integers)\n        if (NGN.coalesce(cfg.pattern)) {\n          this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n            return cfg.pattern.test(value.toString())\n          }, `Numeric Pattern (${cfg.pattern.toString().substr(0, 15) + (cfg.pattern.toString().length > 15 ? '...' : '')})`))\n        }\n\n        /**\n         * @cfg {Number} [multipleOf]\n         * @info This validation attribute applies to #Number fields only.\n         * Insures the field value is a multiple of this number. For example,\n         * if the multiple is `10` and the value is `100`, it is valid.\n         * If the multiple is `10` and the value is `101`, it is invalid.\n         */\n        if (NGN.typeof(cfg.multipleOf) === 'number') {\n          this.METADATA.rules.unshift(new NGN.DATA.Rule(value => {\n            return Math.abs(value % cfg.multipleOf) === 0\n          }, `Numeric Multiple of ${cfg.multipleOf}`))\n        }\n      }\n    }\n\n    // Apply array-specific native validations\n    if (this.METADATA.dataType === Array) {\n      // Enforce minimum number of array items\n      if (NGN.objectHasAny(cfg, 'min', 'minimum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => value.length >= NGN.coalesce(cfg.min, cfg.minimum), `${NGN.coalesce(cfg.min, cfg.minimum)} count minimum`))\n      }\n\n      // Enforce maximum number of array items\n      if (NGN.objectHasAny(cfg, 'max', 'maximum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => value.length <= NGN.coalesce(cfg.max, cfg.maximum), `${NGN.coalesce(cfg.max, cfg.maximum)} count maximum`))\n      }\n\n      /**\n       * @cfg {Array} [unique]\n       * @info This validation attribute applies to #Array fields only.\n       * @warning This is a computationally expensive validation when used in NGN Data Stores.\n       * Validates that all items are unique.\n       */\n      if (NGN.coalesce(cfg.unique, false)) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => NGN.dedupe(value).length === value.length, 'Unique value constraint'))\n      }\n\n      /**\n       * @cfg {any} [listType]\n       * @info This validation attribute applies to #Array fields only.\n       * Require each element of the array to conform to the specified data\n       * type. For example, setting `listType: Number` will validate that\n       * each element of the array is a number.\n       *\n       * ```js\n       * [1, 2, 3, 4, 5] // Valid\n       * [1, 2, 'three', 4, 5] // Invalid\n       * ```\n       */\n      if (cfg.hasOwnProperty('listType')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          for (let i = 0; i < value.length; i++) {\n            if (NGN.typeof(value[i]) !== NGN.typeof(cfg.listType)) {\n              return false\n            }\n          }\n\n          return true\n        }, `${NGN.typeof(cfg.listType).toUpperCase()} list type constraint`))\n      }\n\n      // Support enumerations in array values\n      if (cfg.hasOwnProperty('enum')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          return cfg.enum.indexOf(value) >= 0\n        }))\n      }\n\n      /**\n       * @cfg {Array} [tuples]\n       * @info This validation attribute applies to #Array fields only.\n       * @warning This is a computationally expensive validation when used in NGN Data Stores.\n       * Validate each item of an array according to a unique schema.\n       * Each item is a key value object, which supports only the `type` and\n       * `enum` validations.\n       *\n       * For example:\n       *\n       * ```js\n       * {\n       *   tuples: [{\n       *     type: Number\n       *   }, {\n       *     type: String,\n       *     enum: ['a', 'b', 'c']\n       *   }, {\n       *     enum: ['d', 1]\n       *   }]\n       * }\n       * ```\n       * The configuration above will make sure the first array item is a number,\n       * while the second is either `a`, `b`, or `c`, and the third is either\n       * the letter `d` or the number `1`. Only the first three items of the\n       * array will be checked, but there must be at least 3 items.\n       */\n      if (cfg.hasOwnProperty('tuples')) {\n        this.METADATA.rules.push(new NGN.DATA.Rule(value => {\n          if (value.length < cfg.tuples.length) {\n            return false\n          }\n\n          for (let i = 0; i < cfg.tuples.length; i++) {\n            if (cfg.tuples[i].hasOwnProperty('type')) {\n              if (NGN.typeof(value[i]) !== NGN.typeof(cfg.tuples[i].type)) {\n                return false\n              }\n            }\n\n            if (cfg.tuples[i].hasOwnProperty('enum')) {\n              if (cfg.tuples[i].enum.indexOf(value[i]) < 0) {\n                return false\n              }\n            }\n          }\n\n          return true\n        }, 'Tuple constraint'))\n      }\n    }\n\n    /**\n     * @cfg {Array} [enum]\n     * An enumeration of available values this field is allowed to have.\n     */\n    if (NGN.objectHasAny(cfg, 'enum', 'enumeration')) {\n      this.METADATA.ENUMERABLE_VALUES = new Set(NGN.forceArray(NGN.coalesce(cfg.enum, cfg.enumeration)))\n      this.METADATA.rules.push(new NGN.DATA.Rule((value) => this.METADATA.ENUMERABLE_VALUES.has(value), 'Enumerable Values'))\n    }\n\n    /**\n     * @cfg {Array} [not]\n     * A \"reverse\" enumeration, i.e. a list of values this field is **not** allowed to be.\n     */\n    if (NGN.objectHasAny(cfg, 'not', 'notin')) {\n      this.METADATA.REVERSE_ENUMERABLE_VALUES = new Set(NGN.forceArray(NGN.coalesce(cfg.not, cfg.notin)))\n      this.METADATA.rules.push(new NGN.DATA.Rule((value) => !this.METADATA.REVERSE_ENUMERABLE_VALUES.has(value), 'Rejected Values'))\n    }\n\n    // Check if the field type is an array, which indicates multiple\n    // data types are considered valid.\n    if (cfg.type instanceof Array) {\n      // If the array has no values, assume the user meant to create an \"Array\" data type.\n      // Warn them, in case this was not the intention.\n      if (cfg.type.length === 0) {\n        NGN.WARN(`No data type specified for ${this.name} field. Autoconverted to an array.`)\n        cfg.type = Array\n      } else if (cfg.type.length === 1) {\n        // If there is only one data type, the array is extraneous and standard\n        // datatype validation can be used.\n        cfg.type = cfg.type[0]\n      }\n    }\n\n    /**\n     * @cfg {Primitive|Array} [type=String]\n     * The type should be a JavaScript primitive, class, or constructor.\n     * For example, `String`, `Number`, `Boolean`, `RegExp`, `Array`, or `Date`.\n     * This can also be an array of primitive values. For example, `[String, Number]`\n     * indicates the field could be a string or a numeric value.\n     */\n    if (cfg.type instanceof Array) {\n      let typeList = cfg.type.map(type => NGN.typeof(type))\n\n      this.METADATA.rules.unshift(\n        new NGN.DATA.Rule(\n          (value) => typeList.indexOf(NGN.typeof(value)) >= 0,\n          `${this.type.toUpperCase()} Multitype Check`\n        )\n      )\n    } else {\n      this.METADATA.rules.unshift(\n        new NGN.DATA.Rule(\n          (value) => NGN.typeof(value) === NGN.typeof(this.METADATA.dataType),\n          `${this.type.toUpperCase()} Type Check`\n        )\n      )\n    }\n\n    // Associate a model if one is defined.\n    if (NGN.coalesce(cfg.model) !== null) {\n      this.model = cfg.model\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 40,
            "column": 2
          },
          "end": {
            "line": 597,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg",
              "start": {
                "line": 40,
                "column": 15
              },
              "end": {
                "line": 40,
                "column": 18
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "configuration": {
              "type": "argument",
              "label": "configuration",
              "description": "Accepts an object with all configuration objects, or a string representing\nthe name of the field.",
              "code": "@param {string|object} configuration\nAccepts an object with all configuration objects, or a string representing\nthe name of the field.",
              "start": {
                "line": 40,
                "column": 2
              },
              "end": {
                "line": 597,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "undo": {
          "type": "method",
          "label": "undo",
          "description": "A rollback function to undo changes. This operation affects\nthe changelog . To \"undo\" an \"undo\", use #redo.",
          "code": "undo (count = 1, suppressEvents = false) {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The undo operation failed on the ${this.name} field because auditing is disabled.`)\n      return\n    }\n\n    let id = this.METADATA.AUDITLOG.rollback(count)\n\n    // Silently set the value to an older value.\n    this.METADATA.setValue(this.METADATA.AUDITLOG.getCommit(id).value, suppressEvents, true)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 845,
            "column": 2
          },
          "end": {
            "line": 855,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "count": {
              "type": "argument",
              "label": "count",
              "description": null,
              "code": "count = 1",
              "start": {
                "line": 845,
                "column": 8
              },
              "end": {
                "line": 845,
                "column": 17
              },
              "flags": [],
              "default": 1,
              "datatype": "number",
              "required": false,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": "Set to `true` to quietly update the value (prevents `update` event from\nfiring).",
              "code": "@param {boolean} [suppressEvents=false]\nSet to `true` to quietly update the value (prevents `update` event from\nfiring).",
              "start": {
                "line": 845,
                "column": 2
              },
              "end": {
                "line": 855,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "redo": {
          "type": "method",
          "label": "redo",
          "description": "A function to reapply known changes. This operation affects\nthe changelog .\n\nThe redo operation only works after an undo operation, but before a new\nvalue is committed to the transaction log. In other words, `undo -> redo`\nwill work, but `undo -> update -> redo` will not. For details, see how\nthe NGN.DATA.TransactionLog cursor system works.",
          "code": "redo (count = 1, suppressEvents = false) {\n    if (!this.METADATA.AUDITABLE) {\n      NGN.WARN(`The redo operation failed on the ${this.name} field because auditing is disabled.`)\n      return\n    }\n\n    let id = this.METADATA.AUDITLOG.advance(count)\n\n    // Silently set the value to a newer value.\n    this.METADATA.setValue(this.METADATA.AUDITLOG.getCommit(id).value, suppressEvents, true)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 872,
            "column": 2
          },
          "end": {
            "line": 882,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "count": {
              "type": "argument",
              "label": "count",
              "description": null,
              "code": "count = 1",
              "start": {
                "line": 872,
                "column": 8
              },
              "end": {
                "line": 872,
                "column": 17
              },
              "flags": [],
              "default": 1,
              "datatype": "number",
              "required": false,
              "enum": null
            },
            "suppressEvents": {
              "type": "argument",
              "label": "suppressEvents",
              "description": "Set to `true` to quietly update the value (prevents `update` event from\nfiring).",
              "code": "@param {boolean} [suppressEvents=false]\nSet to `true` to quietly update the value (prevents `update` event from\nfiring).",
              "start": {
                "line": 872,
                "column": 2
              },
              "end": {
                "line": 882,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "hide": {
          "type": "method",
          "label": "hide",
          "description": "Hide the field.",
          "code": "hide () {\n    this.hidden = true\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 887,
            "column": 2
          },
          "end": {
            "line": 889,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "unhide": {
          "type": "method",
          "label": "unhide",
          "description": "Unhide the field.",
          "code": "unhide () {\n    this.hidden = false\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 894,
            "column": 2
          },
          "end": {
            "line": 896,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "allowInvalid": {
          "type": "method",
          "label": "allowInvalid",
          "description": "Do not throw errors whan a value is marked as invalid.",
          "code": "allowInvalid () {\n    this.METADATA.allowInvalid = true\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 901,
            "column": 2
          },
          "end": {
            "line": 903,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "disallowInvalid": {
          "type": "method",
          "label": "disallowInvalid",
          "description": "Throw errors whan a value is marked as invalid.",
          "code": "disallowInvalid () {\n    this.METADATA.allowInvalid = false\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 908,
            "column": 2
          },
          "end": {
            "line": 910,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "autoCorrectValue": {
          "type": "method",
          "label": "autoCorrectValue",
          "description": "Attempt to automatically correct a value according to the\n  field's data type.\n  \n  The value to attempt to autocorrect.\n  \n  Returns the value after attempting to autocorrect the value.",
          "code": "autoCorrectValue (value) {\n    try {\n      switch (this.type) {\n        case 'number':\n          value = NGN.forceNumber(value)\n          break\n\n        case 'boolean':\n          value = NGN.forceBoolean(value)\n          break\n\n        case 'array':\n          value = NGN.forceArray(value)\n          break\n\n        case 'string':\n          value = value.toString()\n          break\n\n        case 'date':\n          let valueType = NGN.typeof(value)\n\n          if (valueType !== 'date') {\n            if (valueType === 'number') {\n              let dt = new Date()\n              dt.setTime(value)\n\n              value = dt\n            } else {\n              value = new Date(Date.parse(value))\n            }\n          }\n\n          break\n      }\n    } finally {\n      return value // eslint-disable-line no-unsafe-finally\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 920,
            "column": 2
          },
          "end": {
            "line": 958,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": "The value to attempt to autocorrect.",
              "code": "@param  {Any} value\nThe value to attempt to autocorrect.",
              "start": {
                "line": 920,
                "column": 2
              },
              "end": {
                "line": 958,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Any",
          "returnDescription": "null Returns the value after attempting to autocorrect the value.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "hash": {
          "type": "method",
          "label": "hash",
          "description": "The hash part of the URL .",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setHeader": {
          "type": "method",
          "label": "setHeader",
          "description": "Add a header to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getHeader": {
          "type": "method",
          "label": "getHeader",
          "description": "",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeHeader": {
          "type": "method",
          "label": "removeHeader",
          "description": "Removes a header from the request. Nothing happens if the header does\nnot exist.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setQueryParameter": {
          "type": "method",
          "label": "setQueryParameter",
          "description": "Add a query parameter to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeQueryParameter": {
          "type": "method",
          "label": "removeQueryParameter",
          "description": "Remove a query parameter from the request URI.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "send": {
          "type": "method",
          "label": "send",
          "description": "Send the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.FieldMap": {
      "type": "class",
      "label": "NGN.DATA.FieldMap",
      "description": "A reference to the inversed data map.",
      "code": "class NGNDataFieldMap { // eslint-disable-line\n  constructor (cfg = {}) {\n    Object.defineProperties(this, {\n      originalSource: NGN.privateconst(cfg),\n      sourceMap: NGN.private(null),\n      reverseMap: NGN.private(null),\n      applyData: NGN.privateconst((map = 'map', data) => {\n        if (NGN.typeof(data) !== 'object') {\n          return data\n        }\n\n        let keys = Object.keys(data)\n        map = map === 'map' ? this.inverse : this.map\n\n        for (let i = 0; i < keys.length; i++) {\n          if (map.hasOwnProperty(keys[i])) {\n            data[map[keys[i]]] = data[keys[i]]\n            delete data[keys[i]]\n          }\n        }\n\n        return data\n      })\n    })\n  }\n\n  /**\n   * @property {object} map\n   * A reference to the data mapping object.\n   */\n  get map () {\n    if (this.sourceMap === null) {\n      let keys = Object.keys(this.originalSource)\n\n      this.sourceMap = {}\n\n      for (let i = 0; i < keys.length; i++) {\n        if (NGN.typeof(keys[i]) === 'string' && NGN.typeof(this.originalSource[keys[i]]) === 'string') {\n          this.sourceMap[keys[i]] = this.originalSource[keys[i]]\n        }\n      }\n    }\n\n    return this.sourceMap\n  }\n\n  /**\n   * @property {object} inverse\n   * A reference to the inversed data map.\n   */\n  get inverse () {\n    if (this.reverseMap === null) {\n      let keys = Object.keys(this.originalSource)\n\n      this.reverseMap = {}\n\n      for (let i = 0; i < keys.length; i++) {\n        if (NGN.typeof(keys[i]) === 'string' && NGN.typeof(this.originalSource[keys[i]]) === 'string') {\n          this.reverseMap[this.originalSource[keys[i]]] = keys[i]\n        }\n      }\n    }\n\n    return this.reverseMap\n  }\n\n  /**\n   * Apply the map to an object.\n   * @param  {object} data\n   * @return {object}\n   */\n  applyMap (data) {\n    return this.applyData('map', data)\n  }\n\n  /**\n   * Apply the inversed map to an object.\n   * @param  {object} data\n   * @return {object}\n   */\n  applyInverseMap (data) {\n    return this.applyData('reverse', data)\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 70,
        "column": 15
      },
      "end": {
        "line": 153,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/field/FieldMap.js",
      "extends": null,
      "configuration": {},
      "properties": {
        "originalSource": {
          "type": "property",
          "label": "originalSource",
          "description": null,
          "code": "originalSource: NGN.privateconst(cfg)",
          "start": {
            "line": 73,
            "column": 6
          },
          "end": {
            "line": 73,
            "column": 43
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "sourceMap": {
          "type": "property",
          "label": "sourceMap",
          "description": null,
          "code": "sourceMap: NGN.private(null)",
          "start": {
            "line": 74,
            "column": 6
          },
          "end": {
            "line": 74,
            "column": 34
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "reverseMap": {
          "type": "property",
          "label": "reverseMap",
          "description": null,
          "code": "reverseMap: NGN.private(null)",
          "start": {
            "line": 75,
            "column": 6
          },
          "end": {
            "line": 75,
            "column": 35
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "applyData": {
          "type": "property",
          "label": "applyData",
          "description": null,
          "code": "applyData: NGN.privateconst((map = 'map', data) => {\n        if (NGN.typeof(data) !== 'object') {\n          return data\n        }\n\n        let keys = Object.keys(data)\n        map = map === 'map' ? this.inverse : this.map\n\n        for (let i = 0; i < keys.length; i++) {\n          if (map.hasOwnProperty(keys[i])) {\n            data[map[keys[i]]] = data[keys[i]]\n            delete data[keys[i]]\n          }\n        }\n\n        return data\n      })",
          "start": {
            "line": 76,
            "column": 6
          },
          "end": {
            "line": 92,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "map": {
          "type": "property",
          "label": "map",
          "description": null,
          "code": "get map () {\n    if (this.sourceMap === null) {\n      let keys = Object.keys(this.originalSource)\n\n      this.sourceMap = {}\n\n      for (let i = 0; i < keys.length; i++) {\n        if (NGN.typeof(keys[i]) === 'string' && NGN.typeof(this.originalSource[keys[i]]) === 'string') {\n          this.sourceMap[keys[i]] = this.originalSource[keys[i]]\n        }\n      }\n    }\n\n    return this.sourceMap\n  }",
          "start": {
            "line": 100,
            "column": 2
          },
          "end": {
            "line": 114,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "inverse": {
          "type": "property",
          "label": "inverse",
          "description": null,
          "code": "get inverse () {\n    if (this.reverseMap === null) {\n      let keys = Object.keys(this.originalSource)\n\n      this.reverseMap = {}\n\n      for (let i = 0; i < keys.length; i++) {\n        if (NGN.typeof(keys[i]) === 'string' && NGN.typeof(this.originalSource[keys[i]]) === 'string') {\n          this.reverseMap[this.originalSource[keys[i]]] = keys[i]\n        }\n      }\n    }\n\n    return this.reverseMap\n  }",
          "start": {
            "line": 120,
            "column": 2
          },
          "end": {
            "line": 134,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (cfg = {}) {\n    Object.defineProperties(this, {\n      originalSource: NGN.privateconst(cfg),\n      sourceMap: NGN.private(null),\n      reverseMap: NGN.private(null),\n      applyData: NGN.privateconst((map = 'map', data) => {\n        if (NGN.typeof(data) !== 'object') {\n          return data\n        }\n\n        let keys = Object.keys(data)\n        map = map === 'map' ? this.inverse : this.map\n\n        for (let i = 0; i < keys.length; i++) {\n          if (map.hasOwnProperty(keys[i])) {\n            data[map[keys[i]]] = data[keys[i]]\n            delete data[keys[i]]\n          }\n        }\n\n        return data\n      })\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 71,
            "column": 2
          },
          "end": {
            "line": 94,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg = {}",
              "start": {
                "line": 71,
                "column": 15
              },
              "end": {
                "line": 71,
                "column": 23
              },
              "flags": [],
              "default": "{}",
              "datatype": "object",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "applyMap": {
          "type": "method",
          "label": "applyMap",
          "description": "Apply the map to an object.",
          "code": "applyMap (data) {\n    return this.applyData('map', data)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 141,
            "column": 2
          },
          "end": {
            "line": 143,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "data": {
              "type": "argument",
              "label": "data",
              "description": "",
              "code": "@param  {object} data",
              "start": {
                "line": 141,
                "column": 2
              },
              "end": {
                "line": 143,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "object",
              "required": true,
              "enum": null
            }
          },
          "returnType": "object",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "applyInverseMap": {
          "type": "method",
          "label": "applyInverseMap",
          "description": "Apply the inversed map to an object.",
          "code": "applyInverseMap (data) {\n    return this.applyData('reverse', data)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 150,
            "column": 2
          },
          "end": {
            "line": 152,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "data": {
              "type": "argument",
              "label": "data",
              "description": "",
              "code": "@param  {object} data",
              "start": {
                "line": 150,
                "column": 2
              },
              "end": {
                "line": 152,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "object",
              "required": true,
              "enum": null
            }
          },
          "returnType": "object",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.Relationship": {
      "type": "class",
      "label": "NGN.DATA.Relationship",
      "description": "The manner of relationship. This can be one of 3 values: `store`\n  (NGN.DATA.Store), `model` (NGN.DATA.Model), or `collection`. A collection\n  is a special configuration shortcut used to represent a new store of models.\n    For example, a model may be defined as:\n    ```js\n  let Pet = new NGN.DATA.Model({\n    fields: {\n      name: String,\n      animalType: String\n    }\n  })\n    let Person = new NGN.DATA.Model({\n    fields: {\n      dateOfBirth: Date\n    },\n    relationships: {\n      pets: [Pet]        // <== Collection\n    }\n  })\n  ```",
      "code": "class NGNRelationshipField extends DataField { // eslint-disable-line\n  constructor (cfg = {}) {\n    let type = NGN.typeof(cfg.join)\n\n    // Assure valid configuration\n    if (!cfg.join) {\n      throw new InvalidConfigurationError('Missing \"join\" configuration property.')\n    } else if (\n      ['model', 'store'].indexOf(type) < 0 &&\n      (\n        type !== 'array' ||\n        NGN.typeof(cfg.join[0]) !== 'model'\n      )\n    ) {\n      throw new InvalidConfigurationError(`The join specified is not a valid NGN.DATA.Model, NGN.DATA.Store, or collection. It is a ${NGN.typeof(cfg.join)}\"`)\n    }\n\n    // Create optional cardinality validations\n\n    // Initialize\n    cfg.identifier = false\n    super(cfg)\n\n    this.METADATA.fieldType = 'join'\n    this.METADATA.join = Symbol('relationship')\n\n    // Apply event monitoring to the #record.\n    this.METADATA.applyMonitor = () => {\n      if (this.METADATA.manner === 'model') {\n        // Model Event Relay\n        this.METADATA.join.pool('field.', {\n          create: this.METADATA.commonModelEventHandler('field.create'),\n          update: this.METADATA.commonModelEventHandler('field.update'),\n          remove: this.METADATA.commonModelEventHandler('field.remove'),\n          invalid: (data) => {\n            this.emit(['invalid', `invalid.${this.METADATA.name}.${data.field}`])\n          },\n          valid: (data) => {\n            this.emit(['valid', `valid.${this.METADATA.name}.${data.field}`])\n          }\n        })\n      //   this.METADATA.join.pool('field.', {\n      //     create: this.METADATA.commonModelEventHandler('field.create'),\n      //     update: this.METADATA.commonModelEventHandler('field.update'),\n      //     remove: this.METADATA.commonModelEventHandler('field.remove'),\n      //     invalid: (data) => {\n      //       this.emit(['invalid', `invalid.${this.name}.${data.field}`])\n      //     },\n      //     valid: (data) => {\n      //       this.emit(['valid', `valid.${this.name}.${data.field}`])\n      //     }\n      //   })\n      // } else {\n      //   // Store Event Relay\n      //   this.METADATA.join.pool('record.', {\n      //     create: this.METADATA.commonStoreEventHandler('record.create'),\n      //     update: this.METADATA.commonStoreEventHandler('record.update'),\n      //     remove: this.METADATA.commonStoreEventHandler('record.remove'),\n      //     invalid: (data) => {\n      //       this.emit('invalid', `invalid.${this.name}.${data.field}`)\n      //     },\n      //     valid: (data) => {\n      //       this.emit('valid', `valid.${this.name}.${data.field}`)\n      //     }\n      //   })\n      }\n    }\n\n    // Event handling for nested models.\n    this.METADATA.commonModelEventHandler = (type) => {\n      const me = this\n\n      return function (change) {\n        me.METADATA.commitPayload({\n          field: `${me.name}.${change.field}`,\n          old: NGN.coalesce(change.old),\n          new: NGN.coalesce(change.new),\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: me.METADATA.record\n          }\n        })\n      }\n    }\n\n    // Event handling for nested stores.\n    this.METADATA.commonStoreEventHandler = (type) => {\n      const me = this\n\n      return function (record, change) {\n        let old = change ? NGN.coalesce(change.old) : me.data\n\n        if (this.event === 'record.create') {\n          old.pop()\n        } else if (this.event === 'record.delete') {\n          old.push(record.data)\n        }\n\n        me.METADATA.commitPayload({\n          field: me.name + (change ? `.${change.field}` : ''),\n          old: change ? NGN.coalesce(change.old) : old,\n          new: change ? NGN.coalesce(change.new) : me.data,\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: record\n          }\n        })\n      }\n    }\n\n    // const commitPayload = this.METADATA.commitPayload\n    //\n    // this.METADATA.commitPayload = (payload) => {\n    //   console.log('HERE')\n    //   commitPayload(...arguments)\n    // }\n\n    /**\n     * @cfg join {NGN.DATA.Store|NGN.DATA.Model[]}\n     * A relationship to another model/store is defined by a join.\n     * The join may be a data store or data model. It is also possible\n     * to specify a collection.\n     *\n     * For example, a join may be defined as:\n     *\n     * ```js\n     * // Use of a model\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: new NGN.DATA.Model(...)\n     * })\n     *\n     * // Use of a model collection\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: [new NGN.DATA.Model(...)]\n     * })\n     *\n     * // Use of a store\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: new NGN.DATA.Store(...)\n     * })\n     * ```\n     *\n     * A store and a model collection are both a group of models,\n     * Internally, model collections are converted to data stores.\n     *\n     * By supporting all three formats, it is possible to create complex\n     * data models, such as:\n     *\n     * ```js\n     * let Pet = new NGN.DATA.Model(...)\n     * let Kid = new NGN.DATA.Model(...)\n     * let Kids = new NGN.DATA.Store({\n     *   model: Kid\n     * })\n     *\n     * let Person = new NGN.DATA.Model({\n     *   fields: {\n     *     dateOfBirth: Date,\n     *     spouse: Person,  // <== Join a Model\n     *     kids: Kids,      // <== Join a Store\n     *     pets: [Pet]      // <== Join a Collection\n     *   }\n     * })\n     * ```\n     *\n     * The `pets` field contains a \"collection\". This shorthand notation is used\n     * to help understand real data relationships. In this case, it is easy to\n     * infer that a person may have zero or more pets.\n     */\n    this.value = NGN.coalesce(cfg.join)\n    this.METADATA.AUDITABLE = false\n    this.auditable = NGN.coalesce(cfg.audit, false)\n  }\n\n  /**\n   * @property {string} manner\n   * The manner of relationship. This can be one of 3 values: `store`\n   * (NGN.DATA.Store), `model` (NGN.DATA.Model), or `collection`. A collection\n   * is a special configuration shortcut used to represent a new store of models.\n   *\n   * For example, a model may be defined as:\n   *\n   * ```js\n   * let Pet = new NGN.DATA.Model({\n   *   fields: {\n   *     name: String,\n   *     animalType: String\n   *   }\n   * })\n   *\n   * let Person = new NGN.DATA.Model({\n   *   fields: {\n   *     dateOfBirth: Date\n   *   },\n   *   relationships: {\n   *     pets: [Pet]        // <== Collection\n   *   }\n   * })\n   * ```\n   */\n  get manner () {\n    return NGN.coalesce(this.METADATA.manner, 'unknown')\n  }\n\n  get value () {\n    return this.METADATA.join\n  }\n\n  // Override the default value setter\n  set value (value) {\n    // Short-circuit if the value hasn't changed.\n    let currentValue = this.METADATA.join\n\n    if (currentValue === value) {\n      return\n    }\n\n    let type = NGN.typeof(value)\n\n    if (type === 'array') {\n      if (value.length !== 1) {\n        throw new Error(`${this.METADATA.name} cannot refer to an empty data store/model collection. A record must be provided.`)\n      }\n\n      this.METADATA.manner = 'store'\n      value = new NGN.DATA.Store({\n        model: value[0]\n      })\n    } else if (['model', 'store'].indexOf(type) >= 0) {\n      this.METADATA.manner = type\n    } else {\n      NGN.ERROR(`The \"${this.METADATA.name}\" relationship has an invalid record type. Only instances of NGN.DATA.Store, NGN.DATA.Model, or [NGN.DATA.Model] are supported.\" .`)\n      throw new InvalidConfigurationError(`Invalid record configuration for \"${this.METADATA.name}\" field.`)\n    }\n\n    if (this.manner === 'unknown') {\n      throw new Error('Cannot set a relationship field to anything other than an NGN.DATA.Store, NGN.DATA.Model, or an array of NGN.DATA.Model collections. (Unknown manner of relationship)')\n    }\n\n    this.METADATA.join = type === 'model' ? new value() : value // eslint-disable-line new-cap\n    this.auditable = this.METADATA.AUDITABLE\n    this.METADATA.applyMonitor()\n\n    // Notify listeners of change\n    if (typeof currentValue !== 'symbol') {\n      this.emit('update', {\n        old: currentValue,\n        new: value\n      })\n    }\n  }\n\n  set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.join.auditable = value\n    }\n  }\n\n  // Override the default undo\n  undo () {\n    if (this.METADATA.manner === 'model') {\n      this.METADATA.join.undo(...arguments)\n    }\n  }\n\n  redo () {\n    if (this.METADATA.manner === 'model') {\n      this.METADATA.join.redo(...arguments)\n    }\n  }\n}",
      "tags": {
        "NGN.DATA.Model#validators,": {
          "tag": "NGN.DATA.Model#validators,",
          "name": "so",
          "optional": false,
          "description": "relationship fields defer all validation to\nthe individual record/model.\n\nRelationships using NGN.DATA.Stores behave a little differently, since they\nrepresent a collection of data instead of a single record/model. NGN manages\n[referential integrity]\nusing simplistic\n[cardinality](https://en.wikipedia.org/wiki/Cardinality_(data_modeling)).\n\nReferential integrity & cardinality rules are data modeling principles\ndesigned to enforce data quality standards. The nature of JavaScript objects\nnaturally enforces rudimentary data linking/nesting. NGN data relationships\nbuild upon this, using proven data modeling principles.\n\nThis is done, very simply, by using the @cfg#min and @cfg#max configuration\noptions. However; these options don't always need to be enforced, depending\non what type of cardniality needs to be achieved.\n\nFor more information, see the Data Modeling Guide.\n\n**Note to self, use this next part in the guide:**\n\nThere are five (5) common types of cardinality.\n\n- **1 => 1**: One-to-One\n- **0 => 1**: Zero-or-One\n- **0 => N**: Zero-to-Many\n- **1 => N**: One-to-Many\n- **N => N**: Many-to-Many\n\nThere are also more granular types of cardinality, which are less common in\nweb applications, but often used in data and ETL operations.\n\n- **0,1 => 0,N**: Zero-or-One to Zero-or-More\n- **0,1 => 1,N**: Zero-or-One to One-or-More\n- ... write the rest in the guide...",
          "type": "",
          "line": 12,
          "source": "@NGN.DATA.Model#validators, so relationship fields defer all validation to\nthe individual record/model.\n\nRelationships using NGN.DATA.Stores behave a little differently, since they\nrepresent a collection of data instead of a single record/model. NGN manages\n[referential integrity](https://en.wikipedia.org/wiki/Referential_integrity)\nusing simplistic\n[cardinality](https://en.wikipedia.org/wiki/Cardinality_(data_modeling)).\n\nReferential integrity & cardinality rules are data modeling principles\ndesigned to enforce data quality standards. The nature of JavaScript objects\nnaturally enforces rudimentary data linking/nesting. NGN data relationships\nbuild upon this, using proven data modeling principles.\n\nThis is done, very simply, by using the @cfg#min and @cfg#max configuration\noptions. However; these options don't always need to be enforced, depending\non what type of cardniality needs to be achieved.\n\nFor more information, see the Data Modeling Guide.\n\n**Note to self, use this next part in the guide:**\n\nThere are five (5) common types of cardinality.\n\n- **1 => 1**: One-to-One\n- **0 => 1**: Zero-or-One\n- **0 => N**: Zero-to-Many\n- **1 => N**: One-to-Many\n- **N => N**: Many-to-Many\n\nThere are also more granular types of cardinality, which are less common in\nweb applications, but often used in data and ETL operations.\n\n- **0,1 => 0,N**: Zero-or-One to Zero-or-More\n- **0,1 => 1,N**: Zero-or-One to One-or-More\n- ... write the rest in the guide...",
          "options": [
            "https://en.wikipedia.org/wiki/Referential_integrity"
          ]
        }
      },
      "exceptions": {},
      "events": {},
      "start": {
        "line": 52,
        "column": 15
      },
      "end": {
        "line": 327,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/field/Relationship.js",
      "extends": "DataField",
      "configuration": {
        "join": {
          "type": "property",
          "label": "join",
          "description": "{NGN.DATA.Store|NGN.DATA.Model[]}\nA relationship to another model/store is defined by a join.\nThe join may be a data store or data model. It is also possible\nto specify a collection.\n\nFor example, a join may be defined as:\n\n```js\n// Use of a model\nlet RelationshipField = new NGN.DATA.Relationship({\nrecord: new NGN.DATA.Model\n})\n\n// Use of a model collection\nlet RelationshipField = new NGN.DATA.Relationship({\nrecord: [new NGN.DATA.Model(...)]\n})\n\n// Use of a store\nlet RelationshipField = new NGN.DATA.Relationship({\nrecord: new NGN.DATA.Store(...)\n})\n```\n\nA store and a model collection are both a group of models,\nInternally, model collections are converted to data stores.\n\nBy supporting all three formats, it is possible to create complex\ndata models, such as:\n\n```js\nlet Pet = new NGN.DATA.Model(...)\nlet Kid = new NGN.DATA.Model(...)\nlet Kids = new NGN.DATA.Store({\nmodel: Kid\n})\n\nlet Person = new NGN.DATA.Model({\nfields: {\ndateOfBirth: Date,\nspouse: Person,  // <== Join a Model\nkids: Kids,      // <== Join a Store\npets: [Pet]      // <== Join a Collection\n}\n})\n```\n\nThe `pets` field contains a \"collection\". This shorthand notation is used\nto help understand real data relationships. In this case, it is easy to\ninfer that a person may have zero or more pets.",
          "code": "this.value = NGN.coalesce(cfg.join)",
          "start": {
            "line": 223,
            "column": 9
          },
          "end": {
            "line": 223,
            "column": 14
          },
          "flags": [],
          "default": null,
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        }
      },
      "properties": {
        "identifier": {
          "type": "property",
          "label": "identifier",
          "description": null,
          "code": "cfg.identifier = false",
          "start": {
            "line": 72,
            "column": 8
          },
          "end": {
            "line": 72,
            "column": 18
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "fieldType": {
          "type": "property",
          "label": "fieldType",
          "description": null,
          "code": "this.METADATA.fieldType = 'join'",
          "start": {
            "line": 75,
            "column": 18
          },
          "end": {
            "line": 75,
            "column": 27
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "join": {
          "type": "property",
          "label": "join",
          "description": "{NGN.DATA.Store|NGN.DATA.Model[]}\nA relationship to another model/store is defined by a join.\nThe join may be a data store or data model. It is also possible\nto specify a collection.\n\nFor example, a join may be defined as:\n\n```js\n// Use of a model\nlet RelationshipField = new NGN.DATA.Relationship({\nrecord: new NGN.DATA.Model\n})\n\n// Use of a model collection\nlet RelationshipField = new NGN.DATA.Relationship({\nrecord: [new NGN.DATA.Model(...)]\n})\n\n// Use of a store\nlet RelationshipField = new NGN.DATA.Relationship({\nrecord: new NGN.DATA.Store(...)\n})\n```\n\nA store and a model collection are both a group of models,\nInternally, model collections are converted to data stores.\n\nBy supporting all three formats, it is possible to create complex\ndata models, such as:\n\n```js\nlet Pet = new NGN.DATA.Model(...)\nlet Kid = new NGN.DATA.Model(...)\nlet Kids = new NGN.DATA.Store({\nmodel: Kid\n})\n\nlet Person = new NGN.DATA.Model({\nfields: {\ndateOfBirth: Date,\nspouse: Person,  // <== Join a Model\nkids: Kids,      // <== Join a Store\npets: [Pet]      // <== Join a Collection\n}\n})\n```\n\nThe `pets` field contains a \"collection\". This shorthand notation is used\nto help understand real data relationships. In this case, it is easy to\ninfer that a person may have zero or more pets.",
          "code": "this.value = NGN.coalesce(cfg.join)",
          "start": {
            "line": 223,
            "column": 9
          },
          "end": {
            "line": 223,
            "column": 14
          },
          "flags": [],
          "default": null,
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        },
        "applyMonitor": {
          "type": "property",
          "label": "applyMonitor",
          "description": null,
          "code": "this.METADATA.applyMonitor = () => {\n      if (this.METADATA.manner === 'model') {\n        // Model Event Relay\n        this.METADATA.join.pool('field.', {\n          create: this.METADATA.commonModelEventHandler('field.create'),\n          update: this.METADATA.commonModelEventHandler('field.update'),\n          remove: this.METADATA.commonModelEventHandler('field.remove'),\n          invalid: (data) => {\n            this.emit(['invalid', `invalid.${this.METADATA.name}.${data.field}`])\n          },\n          valid: (data) => {\n            this.emit(['valid', `valid.${this.METADATA.name}.${data.field}`])\n          }\n        })\n      //   this.METADATA.join.pool('field.', {\n      //     create: this.METADATA.commonModelEventHandler('field.create'),\n      //     update: this.METADATA.commonModelEventHandler('field.update'),\n      //     remove: this.METADATA.commonModelEventHandler('field.remove'),\n      //     invalid: (data) => {\n      //       this.emit(['invalid', `invalid.${this.name}.${data.field}`])\n      //     },\n      //     valid: (data) => {\n      //       this.emit(['valid', `valid.${this.name}.${data.field}`])\n      //     }\n      //   })\n      // } else {\n      //   // Store Event Relay\n      //   this.METADATA.join.pool('record.', {\n      //     create: this.METADATA.commonStoreEventHandler('record.create'),\n      //     update: this.METADATA.commonStoreEventHandler('record.update'),\n      //     remove: this.METADATA.commonStoreEventHandler('record.remove'),\n      //     invalid: (data) => {\n      //       this.emit('invalid', `invalid.${this.name}.${data.field}`)\n      //     },\n      //     valid: (data) => {\n      //       this.emit('valid', `valid.${this.name}.${data.field}`)\n      //     }\n      //   })\n      }\n    }",
          "start": {
            "line": 79,
            "column": 18
          },
          "end": {
            "line": 79,
            "column": 30
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "commonModelEventHandler": {
          "type": "property",
          "label": "commonModelEventHandler",
          "description": null,
          "code": "this.METADATA.commonModelEventHandler = (type) => {\n      const me = this\n\n      return function (change) {\n        me.METADATA.commitPayload({\n          field: `${me.name}.${change.field}`,\n          old: NGN.coalesce(change.old),\n          new: NGN.coalesce(change.new),\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: me.METADATA.record\n          }\n        })\n      }\n    }",
          "start": {
            "line": 121,
            "column": 18
          },
          "end": {
            "line": 121,
            "column": 41
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "commonStoreEventHandler": {
          "type": "property",
          "label": "commonStoreEventHandler",
          "description": null,
          "code": "this.METADATA.commonStoreEventHandler = (type) => {\n      const me = this\n\n      return function (record, change) {\n        let old = change ? NGN.coalesce(change.old) : me.data\n\n        if (this.event === 'record.create') {\n          old.pop()\n        } else if (this.event === 'record.delete') {\n          old.push(record.data)\n        }\n\n        me.METADATA.commitPayload({\n          field: me.name + (change ? `.${change.field}` : ''),\n          old: change ? NGN.coalesce(change.old) : old,\n          new: change ? NGN.coalesce(change.new) : me.data,\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: record\n          }\n        })\n      }\n    }",
          "start": {
            "line": 139,
            "column": 18
          },
          "end": {
            "line": 139,
            "column": 41
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "AUDITABLE": {
          "type": "property",
          "label": "AUDITABLE",
          "description": null,
          "code": "this.METADATA.AUDITABLE = false",
          "start": {
            "line": 224,
            "column": 18
          },
          "end": {
            "line": 224,
            "column": 27
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "auditable": {
          "type": "property",
          "label": "auditable",
          "description": null,
          "code": "set auditable (value) {\n    value = NGN.forceBoolean(value)\n\n    if (value !== this.METADATA.AUDITABLE) {\n      this.METADATA.AUDITABLE = value\n      this.METADATA.join.auditable = value\n    }\n  }",
          "start": {
            "line": 306,
            "column": 2
          },
          "end": {
            "line": 313,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "manner": {
          "type": "property",
          "label": "manner",
          "description": null,
          "code": "get manner () {\n    return NGN.coalesce(this.METADATA.manner, 'unknown')\n  }",
          "start": {
            "line": 254,
            "column": 2
          },
          "end": {
            "line": 256,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "value": {
          "type": "property",
          "label": "value",
          "description": null,
          "code": "set value (value) {\n    // Short-circuit if the value hasn't changed.\n    let currentValue = this.METADATA.join\n\n    if (currentValue === value) {\n      return\n    }\n\n    let type = NGN.typeof(value)\n\n    if (type === 'array') {\n      if (value.length !== 1) {\n        throw new Error(`${this.METADATA.name} cannot refer to an empty data store/model collection. A record must be provided.`)\n      }\n\n      this.METADATA.manner = 'store'\n      value = new NGN.DATA.Store({\n        model: value[0]\n      })\n    } else if (['model', 'store'].indexOf(type) >= 0) {\n      this.METADATA.manner = type\n    } else {\n      NGN.ERROR(`The \"${this.METADATA.name}\" relationship has an invalid record type. Only instances of NGN.DATA.Store, NGN.DATA.Model, or [NGN.DATA.Model] are supported.\" .`)\n      throw new InvalidConfigurationError(`Invalid record configuration for \"${this.METADATA.name}\" field.`)\n    }\n\n    if (this.manner === 'unknown') {\n      throw new Error('Cannot set a relationship field to anything other than an NGN.DATA.Store, NGN.DATA.Model, or an array of NGN.DATA.Model collections. (Unknown manner of relationship)')\n    }\n\n    this.METADATA.join = type === 'model' ? new value() : value // eslint-disable-line new-cap\n    this.auditable = this.METADATA.AUDITABLE\n    this.METADATA.applyMonitor()\n\n    // Notify listeners of change\n    if (typeof currentValue !== 'symbol') {\n      this.emit('update', {\n        old: currentValue,\n        new: value\n      })\n    }\n  }",
          "start": {
            "line": 263,
            "column": 2
          },
          "end": {
            "line": 304,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (cfg = {}) {\n    let type = NGN.typeof(cfg.join)\n\n    // Assure valid configuration\n    if (!cfg.join) {\n      throw new InvalidConfigurationError('Missing \"join\" configuration property.')\n    } else if (\n      ['model', 'store'].indexOf(type) < 0 &&\n      (\n        type !== 'array' ||\n        NGN.typeof(cfg.join[0]) !== 'model'\n      )\n    ) {\n      throw new InvalidConfigurationError(`The join specified is not a valid NGN.DATA.Model, NGN.DATA.Store, or collection. It is a ${NGN.typeof(cfg.join)}\"`)\n    }\n\n    // Create optional cardinality validations\n\n    // Initialize\n    cfg.identifier = false\n    super(cfg)\n\n    this.METADATA.fieldType = 'join'\n    this.METADATA.join = Symbol('relationship')\n\n    // Apply event monitoring to the #record.\n    this.METADATA.applyMonitor = () => {\n      if (this.METADATA.manner === 'model') {\n        // Model Event Relay\n        this.METADATA.join.pool('field.', {\n          create: this.METADATA.commonModelEventHandler('field.create'),\n          update: this.METADATA.commonModelEventHandler('field.update'),\n          remove: this.METADATA.commonModelEventHandler('field.remove'),\n          invalid: (data) => {\n            this.emit(['invalid', `invalid.${this.METADATA.name}.${data.field}`])\n          },\n          valid: (data) => {\n            this.emit(['valid', `valid.${this.METADATA.name}.${data.field}`])\n          }\n        })\n      //   this.METADATA.join.pool('field.', {\n      //     create: this.METADATA.commonModelEventHandler('field.create'),\n      //     update: this.METADATA.commonModelEventHandler('field.update'),\n      //     remove: this.METADATA.commonModelEventHandler('field.remove'),\n      //     invalid: (data) => {\n      //       this.emit(['invalid', `invalid.${this.name}.${data.field}`])\n      //     },\n      //     valid: (data) => {\n      //       this.emit(['valid', `valid.${this.name}.${data.field}`])\n      //     }\n      //   })\n      // } else {\n      //   // Store Event Relay\n      //   this.METADATA.join.pool('record.', {\n      //     create: this.METADATA.commonStoreEventHandler('record.create'),\n      //     update: this.METADATA.commonStoreEventHandler('record.update'),\n      //     remove: this.METADATA.commonStoreEventHandler('record.remove'),\n      //     invalid: (data) => {\n      //       this.emit('invalid', `invalid.${this.name}.${data.field}`)\n      //     },\n      //     valid: (data) => {\n      //       this.emit('valid', `valid.${this.name}.${data.field}`)\n      //     }\n      //   })\n      }\n    }\n\n    // Event handling for nested models.\n    this.METADATA.commonModelEventHandler = (type) => {\n      const me = this\n\n      return function (change) {\n        me.METADATA.commitPayload({\n          field: `${me.name}.${change.field}`,\n          old: NGN.coalesce(change.old),\n          new: NGN.coalesce(change.new),\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: me.METADATA.record\n          }\n        })\n      }\n    }\n\n    // Event handling for nested stores.\n    this.METADATA.commonStoreEventHandler = (type) => {\n      const me = this\n\n      return function (record, change) {\n        let old = change ? NGN.coalesce(change.old) : me.data\n\n        if (this.event === 'record.create') {\n          old.pop()\n        } else if (this.event === 'record.delete') {\n          old.push(record.data)\n        }\n\n        me.METADATA.commitPayload({\n          field: me.name + (change ? `.${change.field}` : ''),\n          old: change ? NGN.coalesce(change.old) : old,\n          new: change ? NGN.coalesce(change.new) : me.data,\n          join: true,\n          originalEvent: {\n            event: this.event,\n            record: record\n          }\n        })\n      }\n    }\n\n    // const commitPayload = this.METADATA.commitPayload\n    //\n    // this.METADATA.commitPayload = (payload) => {\n    //   console.log('HERE')\n    //   commitPayload(...arguments)\n    // }\n\n    /**\n     * @cfg join {NGN.DATA.Store|NGN.DATA.Model[]}\n     * A relationship to another model/store is defined by a join.\n     * The join may be a data store or data model. It is also possible\n     * to specify a collection.\n     *\n     * For example, a join may be defined as:\n     *\n     * ```js\n     * // Use of a model\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: new NGN.DATA.Model(...)\n     * })\n     *\n     * // Use of a model collection\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: [new NGN.DATA.Model(...)]\n     * })\n     *\n     * // Use of a store\n     * let RelationshipField = new NGN.DATA.Relationship({\n     *   record: new NGN.DATA.Store(...)\n     * })\n     * ```\n     *\n     * A store and a model collection are both a group of models,\n     * Internally, model collections are converted to data stores.\n     *\n     * By supporting all three formats, it is possible to create complex\n     * data models, such as:\n     *\n     * ```js\n     * let Pet = new NGN.DATA.Model(...)\n     * let Kid = new NGN.DATA.Model(...)\n     * let Kids = new NGN.DATA.Store({\n     *   model: Kid\n     * })\n     *\n     * let Person = new NGN.DATA.Model({\n     *   fields: {\n     *     dateOfBirth: Date,\n     *     spouse: Person,  // <== Join a Model\n     *     kids: Kids,      // <== Join a Store\n     *     pets: [Pet]      // <== Join a Collection\n     *   }\n     * })\n     * ```\n     *\n     * The `pets` field contains a \"collection\". This shorthand notation is used\n     * to help understand real data relationships. In this case, it is easy to\n     * infer that a person may have zero or more pets.\n     */\n    this.value = NGN.coalesce(cfg.join)\n    this.METADATA.AUDITABLE = false\n    this.auditable = NGN.coalesce(cfg.audit, false)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 53,
            "column": 2
          },
          "end": {
            "line": 226,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg = {}",
              "start": {
                "line": 53,
                "column": 15
              },
              "end": {
                "line": 53,
                "column": 23
              },
              "flags": [],
              "default": "{}",
              "datatype": "object",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "undo": {
          "type": "method",
          "label": "undo",
          "description": null,
          "code": "undo () {\n    if (this.METADATA.manner === 'model') {\n      this.METADATA.join.undo(...arguments)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 316,
            "column": 2
          },
          "end": {
            "line": 320,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "redo": {
          "type": "method",
          "label": "redo",
          "description": null,
          "code": "redo () {\n    if (this.METADATA.manner === 'model') {\n      this.METADATA.join.redo(...arguments)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 322,
            "column": 2
          },
          "end": {
            "line": 326,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.VirtualField": {
      "type": "class",
      "label": "NGN.DATA.VirtualField",
      "description": "This will always return the value of the virtual field, but it may only\n  be _set_ to a synchronous function that returns a value.",
      "code": "class NGNVirtualDataField extends DataField { // eslint-disable-line\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    if (!(cfg.model instanceof NGN.DATA.Entity)) {\n      NGN.WARN('No model specified for the virtual field to reference.')\n    }\n\n    // Remove unnecessary config values\n    delete cfg.required\n    delete cfg.default\n    delete cfg.min\n    delete cfg.minimum\n    delete cfg.max\n    delete cfg.maximum\n    delete cfg.range\n    delete cfg.rule\n    delete cfg.rules\n    delete cfg.validators\n    delete cfg.pattern\n\n    super(cfg)\n\n    this.METADATA.AUDITABLE = false\n    this.METADATA.fieldType = 'virtual'\n\n    /**\n     * @cfg {boolean} [cache=true]\n     * By default, virtual fields _associated with a model_ will cache results\n     * to prevent unnecessary function calls. The cache is cleared whenever a\n     * local data field is modified.\n     *\n     * Caching can substantially reduce processing time in large data sets\n     * by calling methods less often. In most use cases, it will provide a\n     * substantial performance gain. However; since virtual fields can also\n     * leverage variables and methods that are not a part of the data model,\n     * caching may prevent the value from updating as expected. While this case\n     * may occur less often, it can occur. If you suspect caching is interfering\n     * with a virtual field value, it can be disabled by setting this to `false`.\n     */\n    this.METADATA.caching = NGN.coalesce(cfg.cache, true)\n\n    /**\n     * @cfg {NGN.DATA.Model|NGN.DATA.Store|Object} scope\n     * The model, store, or object that will be referenceable within the\n     * virtual field #method. The model will be available in the `this` scope.\n     */\n    this.METADATA.scope = NGN.coalesce(cfg.scope, cfg.model, this)\n\n    /**\n     * @cfg {Function} method\n     * The method used to generate a value.\n     * This is an asynchronous method the returns a value (of any type).\n     */\n    const me = this\n    const handlerFn = cfg.method\n\n    this.METADATA.virtualMethod = function () {\n      return handlerFn.apply(me.METADATA.scope, ...arguments)\n    }\n\n    // Add smart-cache support\n    this.METADATA.CACHEKEY = Symbol('no.cache')\n    this.METADATA.cachedValue = this.METADATA.CACHEKEY\n\n    // Only add caching support if a model is associated\n    if (this.METADATA.caching && this.model) {\n      // Create a method for identifying which local data fields\n      // need to be monitored (for caching)\n      const localFieldPattern = /this(\\.(.[^\\W]+)|\\[['\"]{1}(.*)+['\"]{1}\\])/g\n\n      // Returns a Set of fieldnames used in the virtual function.\n      let monitoredFields = new Set()\n      let content = handlerFn.toString()\n      let iterator = localFieldPattern.exec(content)\n\n      while (iterator !== null) {\n        let field = NGN.coalesce(iterator[2], iterator[3])\n\n        if (this.model.METADATA.knownFieldNames.has(field)) {\n          monitoredFields.add(field)\n        }\n\n        content = content.replace(localFieldPattern, '')\n        iterator = localFieldPattern.exec(content)\n      }\n\n      this.METADATA.model.pool('field.', {\n        update: (change) => {\n          if (change.field && monitoredFields.has(change.field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n          }\n        },\n\n        remove: (field) => {\n          if (monitoredFields.has(field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n            NGN.ERROR(`The ${this.name} virtual field uses the ${field.name} field, which was removed. This virtual field may no longer work.`)\n          }\n        },\n\n        create: (field) => {\n          if (monitoredFields.has(field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n            NGN.INFO(`The ${this.name} virtual field uses the ${field.name} field, which was added.`)\n          }\n        }\n      })\n    }\n  }\n\n  get auditable () {\n    NGN.WARN('Virtual fields do not support the auditable property.')\n    return false\n  }\n\n  set auditable (value) {\n    NGN.WARN('Virtual fields do not support the auditable property.')\n  }\n\n  /**\n   * @property {any} value\n   * This will always return the value of the virtual field, but it may only\n   * be _set_ to a synchronous function that returns a value.\n   */\n  get value () {\n    if (this.METADATA.caching) {\n      if (this.METADATA.cachedValue !== this.METADATA.CACHEKEY) {\n        return this.METADATA.cachedValue\n      } else {\n        this.METADATA.cachedValue = this.METADATA.virtualMethod()\n        return this.METADATA.cachedValue\n      }\n    }\n\n    return this.METADATA.virtualMethod()\n  }\n\n  set value (value) {\n    NGN.WARN('Cannot set the value of a virtual field (read only).')\n  }\n\n  get required () {\n    NGN.WARN('Virtual fields do not support the required property.')\n    return false\n  }\n\n  set required (value) {\n    NGN.WARN('Virtual fields do not support the required property.')\n  }\n\n  get isNew () {\n    NGN.WARN('Virtual fields do not support the isNew property.')\n    return false\n  }\n\n  get default () {\n    NGN.WARN('Virtual fields do not have default values.')\n    return undefined\n  }\n\n  set default (value) {\n    NGN.WARN('Virtual fields do not have default values.')\n    return undefined\n  }\n\n  get violatedRule () {\n    return 'None'\n  }\n\n  get valid () {\n    NGN.WARN('Virtual fields are always valid.')\n    return true\n  }\n\n  get modified () {\n    NGN.WARN('modified attribute does nothing on virtual fields.')\n    return false\n  }\n\n  allowInvalid () {\n    NGN.WARN('allowInvalid() unavailable for virtual fields.')\n  }\n\n  disallowInvalid () {\n    NGN.WARN('disallowInvalid() unavailable for virtual fields.')\n  }\n\n  autocorrectInput () {\n    NGN.WARN('autocorrectInput() unavailable for virtual fields.')\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "cache.clear": {
          "type": "event",
          "label": "cache.clear",
          "description": null,
          "code": "this.emit('cache.clear', this)",
          "start": {
            "line": 148,
            "column": 12
          },
          "end": {
            "line": 148,
            "column": 42
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": "this",
              "start": {
                "line": 148,
                "column": 37
              },
              "end": {
                "line": 148,
                "column": 41
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 42,
        "column": 15
      },
      "end": {
        "line": 236,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/field/VirtualField.js",
      "extends": "DataField",
      "configuration": {
        "cache": {
          "type": "property",
          "label": "cache",
          "description": "By default, virtual fields _associated with a model_ will cache results\nto prevent unnecessary function calls. The cache is cleared whenever a\nlocal data field is modified.\n\nCaching can substantially reduce processing time in large data sets\nby calling methods less often. In most use cases, it will provide a\nsubstantial performance gain. However; since virtual fields can also\nleverage variables and methods that are not a part of the data model,\ncaching may prevent the value from updating as expected. While this case\nmay occur less often, it can occur. If you suspect caching is interfering\nwith a virtual field value, it can be disabled by setting this to `false`.",
          "code": "this.METADATA.caching = NGN.coalesce(cfg.cache, true)",
          "start": {
            "line": 82,
            "column": 18
          },
          "end": {
            "line": 82,
            "column": 25
          },
          "flags": [],
          "default": "true",
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        },
        "scope": {
          "type": "property",
          "label": "scope",
          "description": "The model, store, or object that will be referenceable within the\nvirtual field #method. The model will be available in the `this` scope.",
          "code": "this.METADATA.scope = NGN.coalesce(cfg.scope, cfg.model, this)",
          "start": {
            "line": 89,
            "column": 18
          },
          "end": {
            "line": 89,
            "column": 23
          },
          "flags": [],
          "default": null,
          "datatype": "ngn.data.model|ngn.data.store|object",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        }
      },
      "properties": {
        "AUDITABLE": {
          "type": "property",
          "label": "AUDITABLE",
          "description": null,
          "code": "this.METADATA.AUDITABLE = false",
          "start": {
            "line": 65,
            "column": 18
          },
          "end": {
            "line": 65,
            "column": 27
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "fieldType": {
          "type": "property",
          "label": "fieldType",
          "description": null,
          "code": "this.METADATA.fieldType = 'virtual'",
          "start": {
            "line": 66,
            "column": 18
          },
          "end": {
            "line": 66,
            "column": 27
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "cache": {
          "type": "property",
          "label": "cache",
          "description": "By default, virtual fields _associated with a model_ will cache results\nto prevent unnecessary function calls. The cache is cleared whenever a\nlocal data field is modified.\n\nCaching can substantially reduce processing time in large data sets\nby calling methods less often. In most use cases, it will provide a\nsubstantial performance gain. However; since virtual fields can also\nleverage variables and methods that are not a part of the data model,\ncaching may prevent the value from updating as expected. While this case\nmay occur less often, it can occur. If you suspect caching is interfering\nwith a virtual field value, it can be disabled by setting this to `false`.",
          "code": "this.METADATA.caching = NGN.coalesce(cfg.cache, true)",
          "start": {
            "line": 82,
            "column": 18
          },
          "end": {
            "line": 82,
            "column": 25
          },
          "flags": [],
          "default": "true",
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        },
        "scope": {
          "type": "property",
          "label": "scope",
          "description": "The model, store, or object that will be referenceable within the\nvirtual field #method. The model will be available in the `this` scope.",
          "code": "this.METADATA.scope = NGN.coalesce(cfg.scope, cfg.model, this)",
          "start": {
            "line": 89,
            "column": 18
          },
          "end": {
            "line": 89,
            "column": 23
          },
          "flags": [],
          "default": null,
          "datatype": "ngn.data.model|ngn.data.store|object",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        },
        "virtualMethod": {
          "type": "property",
          "label": "virtualMethod",
          "description": null,
          "code": "this.METADATA.virtualMethod = function () {\n      return handlerFn.apply(me.METADATA.scope, ...arguments)\n    }",
          "start": {
            "line": 99,
            "column": 18
          },
          "end": {
            "line": 99,
            "column": 31
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "CACHEKEY": {
          "type": "property",
          "label": "CACHEKEY",
          "description": null,
          "code": "this.METADATA.CACHEKEY = Symbol('no.cache')",
          "start": {
            "line": 104,
            "column": 18
          },
          "end": {
            "line": 104,
            "column": 26
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "cachedValue": {
          "type": "property",
          "label": "cachedValue",
          "description": null,
          "code": "this.METADATA.cachedValue = this.METADATA.CACHEKEY",
          "start": {
            "line": 105,
            "column": 18
          },
          "end": {
            "line": 105,
            "column": 29
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "auditable": {
          "type": "property",
          "label": "auditable",
          "description": null,
          "code": "set auditable (value) {\n    NGN.WARN('Virtual fields do not support the auditable property.')\n  }",
          "start": {
            "line": 161,
            "column": 2
          },
          "end": {
            "line": 163,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "value": {
          "type": "property",
          "label": "value",
          "description": null,
          "code": "set value (value) {\n    NGN.WARN('Cannot set the value of a virtual field (read only).')\n  }",
          "start": {
            "line": 183,
            "column": 2
          },
          "end": {
            "line": 185,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "required": {
          "type": "property",
          "label": "required",
          "description": null,
          "code": "set required (value) {\n    NGN.WARN('Virtual fields do not support the required property.')\n  }",
          "start": {
            "line": 192,
            "column": 2
          },
          "end": {
            "line": 194,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "isNew": {
          "type": "property",
          "label": "isNew",
          "description": null,
          "code": "get isNew () {\n    NGN.WARN('Virtual fields do not support the isNew property.')\n    return false\n  }",
          "start": {
            "line": 196,
            "column": 2
          },
          "end": {
            "line": 199,
            "column": 3
          },
          "flags": [],
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "default": {
          "type": "property",
          "label": "default",
          "description": null,
          "code": "set default (value) {\n    NGN.WARN('Virtual fields do not have default values.')\n    return undefined\n  }",
          "start": {
            "line": 206,
            "column": 2
          },
          "end": {
            "line": 209,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "violatedRule": {
          "type": "property",
          "label": "violatedRule",
          "description": null,
          "code": "get violatedRule () {\n    return 'None'\n  }",
          "start": {
            "line": 211,
            "column": 2
          },
          "end": {
            "line": 213,
            "column": 3
          },
          "flags": [],
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "valid": {
          "type": "property",
          "label": "valid",
          "description": null,
          "code": "get valid () {\n    NGN.WARN('Virtual fields are always valid.')\n    return true\n  }",
          "start": {
            "line": 215,
            "column": 2
          },
          "end": {
            "line": 218,
            "column": 3
          },
          "flags": [],
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "modified": {
          "type": "property",
          "label": "modified",
          "description": null,
          "code": "get modified () {\n    NGN.WARN('modified attribute does nothing on virtual fields.')\n    return false\n  }",
          "start": {
            "line": 220,
            "column": 2
          },
          "end": {
            "line": 223,
            "column": 3
          },
          "flags": [],
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (cfg) {\n    cfg = cfg || {}\n\n    if (!(cfg.model instanceof NGN.DATA.Entity)) {\n      NGN.WARN('No model specified for the virtual field to reference.')\n    }\n\n    // Remove unnecessary config values\n    delete cfg.required\n    delete cfg.default\n    delete cfg.min\n    delete cfg.minimum\n    delete cfg.max\n    delete cfg.maximum\n    delete cfg.range\n    delete cfg.rule\n    delete cfg.rules\n    delete cfg.validators\n    delete cfg.pattern\n\n    super(cfg)\n\n    this.METADATA.AUDITABLE = false\n    this.METADATA.fieldType = 'virtual'\n\n    /**\n     * @cfg {boolean} [cache=true]\n     * By default, virtual fields _associated with a model_ will cache results\n     * to prevent unnecessary function calls. The cache is cleared whenever a\n     * local data field is modified.\n     *\n     * Caching can substantially reduce processing time in large data sets\n     * by calling methods less often. In most use cases, it will provide a\n     * substantial performance gain. However; since virtual fields can also\n     * leverage variables and methods that are not a part of the data model,\n     * caching may prevent the value from updating as expected. While this case\n     * may occur less often, it can occur. If you suspect caching is interfering\n     * with a virtual field value, it can be disabled by setting this to `false`.\n     */\n    this.METADATA.caching = NGN.coalesce(cfg.cache, true)\n\n    /**\n     * @cfg {NGN.DATA.Model|NGN.DATA.Store|Object} scope\n     * The model, store, or object that will be referenceable within the\n     * virtual field #method. The model will be available in the `this` scope.\n     */\n    this.METADATA.scope = NGN.coalesce(cfg.scope, cfg.model, this)\n\n    /**\n     * @cfg {Function} method\n     * The method used to generate a value.\n     * This is an asynchronous method the returns a value (of any type).\n     */\n    const me = this\n    const handlerFn = cfg.method\n\n    this.METADATA.virtualMethod = function () {\n      return handlerFn.apply(me.METADATA.scope, ...arguments)\n    }\n\n    // Add smart-cache support\n    this.METADATA.CACHEKEY = Symbol('no.cache')\n    this.METADATA.cachedValue = this.METADATA.CACHEKEY\n\n    // Only add caching support if a model is associated\n    if (this.METADATA.caching && this.model) {\n      // Create a method for identifying which local data fields\n      // need to be monitored (for caching)\n      const localFieldPattern = /this(\\.(.[^\\W]+)|\\[['\"]{1}(.*)+['\"]{1}\\])/g\n\n      // Returns a Set of fieldnames used in the virtual function.\n      let monitoredFields = new Set()\n      let content = handlerFn.toString()\n      let iterator = localFieldPattern.exec(content)\n\n      while (iterator !== null) {\n        let field = NGN.coalesce(iterator[2], iterator[3])\n\n        if (this.model.METADATA.knownFieldNames.has(field)) {\n          monitoredFields.add(field)\n        }\n\n        content = content.replace(localFieldPattern, '')\n        iterator = localFieldPattern.exec(content)\n      }\n\n      this.METADATA.model.pool('field.', {\n        update: (change) => {\n          if (change.field && monitoredFields.has(change.field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n          }\n        },\n\n        remove: (field) => {\n          if (monitoredFields.has(field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n            NGN.ERROR(`The ${this.name} virtual field uses the ${field.name} field, which was removed. This virtual field may no longer work.`)\n          }\n        },\n\n        create: (field) => {\n          if (monitoredFields.has(field.name)) {\n            this.METADATA.cachedValue = this.METADATA.CACHEKEY\n            this.emit('cache.clear', this)\n            NGN.INFO(`The ${this.name} virtual field uses the ${field.name} field, which was added.`)\n          }\n        }\n      })\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 43,
            "column": 2
          },
          "end": {
            "line": 154,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg",
              "start": {
                "line": 43,
                "column": 15
              },
              "end": {
                "line": 43,
                "column": 18
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "allowInvalid": {
          "type": "method",
          "label": "allowInvalid",
          "description": null,
          "code": "allowInvalid () {\n    NGN.WARN('allowInvalid() unavailable for virtual fields.')\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 225,
            "column": 2
          },
          "end": {
            "line": 227,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "disallowInvalid": {
          "type": "method",
          "label": "disallowInvalid",
          "description": null,
          "code": "disallowInvalid () {\n    NGN.WARN('disallowInvalid() unavailable for virtual fields.')\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 229,
            "column": 2
          },
          "end": {
            "line": 231,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "autocorrectInput": {
          "type": "method",
          "label": "autocorrectInput",
          "description": null,
          "code": "autocorrectInput () {\n    NGN.WARN('autocorrectInput() unavailable for virtual fields.')\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 233,
            "column": 2
          },
          "end": {
            "line": 235,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "TreeNode": {
      "type": "class",
      "label": "TreeNode",
      "description": "Inspired by btree.js (c) 2013 Daniel Wirtz <dcode\nReleased under the Apache License, Version 2.0\nsee: http://github.com/dcodeIO/btree.js for details.\nConverted to ECMASCript 2016 class syntax & modified to use\nNGN conventions. Separated code into multiple classes.\nCopyright (c) 2018, Ecor Ventures LLC.",
      "code": "class TreeNode {\n  constructor (parent = null, leafs = [], nodes = [null]) {\n    Object.defineProperties(this, {\n      parent: NGN.private(parent),\n      leafs: NGN.private(leafs),\n      nodes: NGN.private(nodes),\n\n      METADATA: NGN.private({\n        order: null,\n        minOrder: null,\n\n        /**\n        * Compare two numbers\n        * @param  {number} firstNumber\n        * @param  {number} secondNumber\n        * @return {number}\n        * - Returns `-1` if first number is less than second.\n        * - Returns `0` if numbers are equal.\n        * - Returns `1` if first number is greater than second.\n        */\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })\n    })\n\n    // Associate leafs with parent\n    for (let i = 0; i < this.leafs.length; i++) {\n      this.leafs[i].parent = this\n      // Object.defineProperty(this.leafs[i], 'parent', NGN.get(() => this))\n    }\n\n    // Associate nodes with parent\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (this.nodes[i] !== null) {\n        this.nodes[i].parent = this\n        // Object.defineProperty(this.nodes[i], 'parent', NGN.get(() => this))\n      }\n    }\n  }\n\n  /**\n  * Search for the node that contains the specified key\n  * @param  {any} key\n  * @return {TreeLeaf|TreeNode}\n  */\n  search (key) {\n    if (this.leafs.length > 0) {\n      let a = this.leafs[0]\n\n      if (this.METADATA.compare(a.key, key) === 0) {\n        return {\n          leaf: a,\n          index: 0\n        }\n      }\n\n      if (this.METADATA.compare(key, a.key) < 0) {\n        if (this.nodes[0] !== null) {\n          return this.nodes[0].search(key) // Left\n        }\n\n        return { node: this, index: 0 }\n      }\n\n      let i\n      for (i = 1; i < this.leafs.length; i++) {\n        let b = this.leafs[i]\n\n        if (this.METADATA.compare(b.key, key) === 0) {\n          return {\n            leaf: b,\n            index: i\n          }\n        }\n\n        if (this.METADATA.compare(key, b.key) < 0) {\n          if (this.nodes[i] !== null) {\n            return this.nodes[i].search(key) // Inner\n          }\n\n          return { node: this, index: i }\n        }\n\n        a = b\n      }\n\n      if (this.nodes[i] !== null) {\n        return this.nodes[i].search(key) // Right\n      }\n\n      return { node: this, index: i }\n    }\n\n    return { node: this, index: 0 }\n  }\n\n  /**\n  * Retrieve the value of a key.\n  * @param {number} key\n  * @returns {NGNTreeLeaf}\n  * Returns `undefined` if no leaf is found.\n  */\n  get (key) {\n    let result = this.search(key)\n    return result.leaf ? result.leaf.value : undefined\n  }\n\n  /**\n  * Insert a key/value pair into the node.\n  * @param {number} key\n  * @param {any} value\n  * @param {boolean} [overwrite=true]\n  * Overwrite existing values.\n  */\n  put (key, value, overwrite = true) {\n    let result = this.search(key)\n\n    // Key already exists\n    if (result.leaf) {\n      if (!overwrite) {\n        return\n      }\n\n      result.leaf.value = value\n      return\n    }\n\n    let node = result.node\n    let index = result.index\n\n    node.leafs.splice(index, 0, new TreeLeaf(node, key, value))\n    node.nodes.splice(index + 1, 0, null)\n\n    if (node.leafs.length > this.METADATA.order) {\n      node.split()\n    }\n  }\n\n  /**\n  * Delete key.\n  * @param {number} key\n  */\n  delete (key) {\n    var result = this.search(key)\n\n    if (!result.leaf) {\n      return\n    }\n\n    let leaf = result.leaf\n    let node = leaf.parent\n    let index = result.index\n    let left = node.nodes[index]\n\n    if (left === null) {\n      node.leafs.splice(index, 1)\n      node.nodes.splice(index, 1)\n      node.balance()\n    } else {\n      let max = left.leafs[left.leafs.length - 1]\n\n      left.delete(max.key)\n\n      max.parent = node\n\n      node.leafs.splice(index, 1, max)\n    }\n\n    return true\n  }\n\n  /**\n  * Balance the tree.\n  * @private\n  */\n  balance () {\n    if (this.parent instanceof Tree) {\n      // Root has a single child and no leafs\n      if (this.leafs.length === 0 && this.nodes[0] !== null) {\n        this.parent.root = this.nodes[0]\n        this.parent.root.parent = this.parent\n      }\n\n      return\n    }\n\n    if (this.leafs.length >= this.METADATA.minOrder) {\n      return\n    }\n\n    let index = this.parent.nodes.indexOf(this)\n    let left = index > 0 ? this.parent.nodes[index - 1] : null\n    let right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null\n    let sep\n    let leaf\n    let rest\n\n    if (right !== null && right.leafs.length > this.METADATA.minOrder) {\n      // Append the parent separator\n      sep = this.parent.leafs[index]\n      sep.parent = this\n\n      this.leafs.push(sep)\n\n      // Replace blank with the first right leaf\n      leaf = right.leafs.shift()\n      leaf.parent = this.parent\n\n      this.parent.leafs[index] = leaf\n\n      // Append the right rest\n      rest = right.nodes.shift()\n\n      if (rest !== null) {\n        rest.parent = this\n      }\n\n      this.nodes.push(rest)\n    } else if (left !== null && left.leafs.length > this.METADATA.minOrder) {\n      // Prepend the parent seperator\n      sep = this.parent.leafs[index - 1]\n      sep.parent = this\n\n      this.leafs.unshift(sep)\n\n      // Replace the blank with the last left leaf\n      leaf = left.leafs.pop()\n      leaf.parent = this.parent\n\n      this.parent.leafs[index - 1] = leaf\n\n      // Prepend the left rest to this\n      rest = left.nodes.pop()\n\n      if (rest !== null) {\n        rest.parent = this\n      }\n\n      this.nodes.unshift(rest)\n    } else {\n      let subst\n\n      if (right !== null) {\n        // Combine this + seperator from the parent + right\n        sep = this.parent.leafs[index]\n        subst = new TreeNode(this.parent, this.leafs.concat([sep], right.leafs), this.nodes.concat(right.nodes))\n        subst.METADATA.order = this.METADATA.order\n        subst.METADATA.minOrder = this.METADATA.minOrder\n\n        // Remove the seperator from the parent\n        this.parent.leafs.splice(index, 1)\n\n        // And replace the nodes it seperated with subst\n        this.parent.nodes.splice(index, 2, subst)\n      } else if (left !== null) {\n        // Combine left + seperator from parent + this\n        sep = this.parent.leafs[index - 1]\n        subst = new TreeNode(\n          this.parent,\n          left.leafs.concat([sep], this.leafs),\n          left.nodes.concat(this.nodes)\n        )\n\n        subst.METADATA.minOrder = this.METADATA.minOrder\n        subst.METADATA.order = this.METADATA.order\n\n        // Remove the seperator from the parent\n        this.parent.leafs.splice(index - 1, 1)\n\n        // Replace seperated nodes with subst\n        this.parent.nodes.splice(index - 1, 2, subst)\n      } else {\n        throw new Error(`Internal error: ${this.toString(true)} has neither a left nor a right sibling`)\n      }\n\n      this.parent.balance()\n    }\n  }\n\n  /**\n  * Split the node.\n  */\n  split () {\n    let index = Math.floor(this.leafs.length / 2)\n\n    if (this.parent instanceof Tree) {\n      this.nodes = [\n        new TreeNode(this, this.leafs.slice(0, index), this.nodes.slice(0, index + 1)),\n        new TreeNode(this, this.leafs.slice(index + 1), this.nodes.slice(index + 1))\n      ]\n\n      this.leafs = [this.leafs[index]]\n    } else {\n      let leaf = this.leafs[index]\n      let rest = new TreeNode(\n        this.parent,\n        this.leafs.slice(index + 1),\n        this.nodes.slice(index + 1)\n      )\n\n      this.leafs = this.leafs.slice(0, index)\n      this.nodes = this.nodes.slice(0, index + 1)\n\n      this.parent.unsplit(leaf, rest)\n    }\n  }\n\n  /**\n  * Unsplits a child.\n  * @param {NGNTreeLeaf} leaf\n  * @param {NGNTreeNode} rest\n  * @param {number} [order=52]\n  * @private\n  */\n  unsplit (leaf, rest) {\n    leaf.parent = this\n    rest.parent = this\n\n    let a = this.leafs[0]\n\n    if (this.METADATA.compare(leaf.key, a.key) < 0) {\n      this.leafs.unshift(leaf)\n      this.nodes.splice(1, 0, rest)\n    } else {\n      let i\n      for (i = 1; i < this.leafs.length; i++) {\n        let b = this.leafs[i]\n\n        if (this.METADATA.compare(leaf.key, b.key) < 0) {\n          this.leafs.splice(i, 0, leaf)\n          this.nodes.splice(i + 1, 0, rest)\n          break\n        }\n      }\n\n      if (i === this.leafs.length) {\n        this.leafs.push(leaf)\n        this.nodes.push(rest)\n      }\n    }\n\n    if (this.leafs.length > this.METADATA.order) {\n      this.split()\n    }\n  }\n\n  /**\n  * A string representation of the node.\n  * @param {boolean} [includeNodes=false]\n  * Include sub-nodes\n  * @returns {string}\n  * @private\n  */\n  toString (includeNodes = false) {\n    let value = []\n    let i\n\n    for (i = 0; i < this.leafs.length; i++) {\n      value.push(this.leafs[i].key)\n    }\n\n    let s = `[${value.toString()}]${(this.parent instanceof Tree ? ':*' : ':')}${this.parent}`\n\n    if (includeNodes) {\n      for (i = 0; i < this.nodes.length; i++) {\n        s += ` -> ${this.nodes[i]}`\n      }\n    }\n\n    return s\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 12,
        "column": 0
      },
      "end": {
        "line": 384,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/index/BTree.js",
      "extends": null,
      "configuration": {},
      "properties": {
        "parent": {
          "type": "property",
          "label": "parent",
          "description": null,
          "code": "parent: NGN.private(parent)",
          "start": {
            "line": 15,
            "column": 6
          },
          "end": {
            "line": 15,
            "column": 33
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "leafs": {
          "type": "property",
          "label": "leafs",
          "description": null,
          "code": "leafs: NGN.private(leafs)",
          "start": {
            "line": 16,
            "column": 6
          },
          "end": {
            "line": 16,
            "column": 31
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "nodes": {
          "type": "property",
          "label": "nodes",
          "description": null,
          "code": "nodes: NGN.private(nodes)",
          "start": {
            "line": 17,
            "column": 6
          },
          "end": {
            "line": 17,
            "column": 31
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "METADATA": {
          "type": "property",
          "label": "METADATA",
          "description": null,
          "code": "METADATA: NGN.private({\n        order: null,\n        minOrder: null,\n\n        /**\n        * Compare two numbers\n        * @param  {number} firstNumber\n        * @param  {number} secondNumber\n        * @return {number}\n        * - Returns `-1` if first number is less than second.\n        * - Returns `0` if numbers are equal.\n        * - Returns `1` if first number is greater than second.\n        */\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })",
          "start": {
            "line": 19,
            "column": 6
          },
          "end": {
            "line": 35,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (parent = null, leafs = [], nodes = [null]) {\n    Object.defineProperties(this, {\n      parent: NGN.private(parent),\n      leafs: NGN.private(leafs),\n      nodes: NGN.private(nodes),\n\n      METADATA: NGN.private({\n        order: null,\n        minOrder: null,\n\n        /**\n        * Compare two numbers\n        * @param  {number} firstNumber\n        * @param  {number} secondNumber\n        * @return {number}\n        * - Returns `-1` if first number is less than second.\n        * - Returns `0` if numbers are equal.\n        * - Returns `1` if first number is greater than second.\n        */\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })\n    })\n\n    // Associate leafs with parent\n    for (let i = 0; i < this.leafs.length; i++) {\n      this.leafs[i].parent = this\n      // Object.defineProperty(this.leafs[i], 'parent', NGN.get(() => this))\n    }\n\n    // Associate nodes with parent\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (this.nodes[i] !== null) {\n        this.nodes[i].parent = this\n        // Object.defineProperty(this.nodes[i], 'parent', NGN.get(() => this))\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 13,
            "column": 2
          },
          "end": {
            "line": 51,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "parent": {
              "type": "argument",
              "label": "parent",
              "description": null,
              "code": "parent = null",
              "start": {
                "line": 13,
                "column": 15
              },
              "end": {
                "line": 13,
                "column": 28
              },
              "flags": [],
              "default": null,
              "datatype": "object",
              "required": false,
              "enum": null
            },
            "leafs": {
              "type": "argument",
              "label": "leafs",
              "description": null,
              "code": "leafs = []",
              "start": {
                "line": 13,
                "column": 30
              },
              "end": {
                "line": 13,
                "column": 40
              },
              "flags": [],
              "default": "[]",
              "datatype": "object",
              "required": false,
              "enum": null
            },
            "nodes": {
              "type": "argument",
              "label": "nodes",
              "description": null,
              "code": "nodes = [null]",
              "start": {
                "line": 13,
                "column": 42
              },
              "end": {
                "line": 13,
                "column": 56
              },
              "flags": [],
              "default": "[null]",
              "datatype": "object",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "search": {
          "type": "method",
          "label": "search",
          "description": "Search for the node that contains the specified key",
          "code": "search (key) {\n    if (this.leafs.length > 0) {\n      let a = this.leafs[0]\n\n      if (this.METADATA.compare(a.key, key) === 0) {\n        return {\n          leaf: a,\n          index: 0\n        }\n      }\n\n      if (this.METADATA.compare(key, a.key) < 0) {\n        if (this.nodes[0] !== null) {\n          return this.nodes[0].search(key) // Left\n        }\n\n        return { node: this, index: 0 }\n      }\n\n      let i\n      for (i = 1; i < this.leafs.length; i++) {\n        let b = this.leafs[i]\n\n        if (this.METADATA.compare(b.key, key) === 0) {\n          return {\n            leaf: b,\n            index: i\n          }\n        }\n\n        if (this.METADATA.compare(key, b.key) < 0) {\n          if (this.nodes[i] !== null) {\n            return this.nodes[i].search(key) // Inner\n          }\n\n          return { node: this, index: i }\n        }\n\n        a = b\n      }\n\n      if (this.nodes[i] !== null) {\n        return this.nodes[i].search(key) // Right\n      }\n\n      return { node: this, index: i }\n    }\n\n    return { node: this, index: 0 }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 58,
            "column": 2
          },
          "end": {
            "line": 107,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "key": {
              "type": "argument",
              "label": "key",
              "description": "",
              "code": "@param  {any} key",
              "start": {
                "line": 58,
                "column": 2
              },
              "end": {
                "line": 107,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "TreeLeaf|TreeNode",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "get": {
          "type": "method",
          "label": "get",
          "description": "Retrieve the value of a key.\n \n \n Returns `undefined` if no leaf is found.",
          "code": "get (key) {\n    let result = this.search(key)\n    return result.leaf ? result.leaf.value : undefined\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 115,
            "column": 2
          },
          "end": {
            "line": 118,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "key": {
              "type": "argument",
              "label": "key",
              "description": "",
              "code": "@param {number} key",
              "start": {
                "line": 115,
                "column": 2
              },
              "end": {
                "line": 118,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            }
          },
          "returnType": "NGNTreeLeaf",
          "returnDescription": "null Returns `undefined` if no leaf is found.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "put": {
          "type": "method",
          "label": "put",
          "description": "Insert a key/value pair into the node.\n \n \n \n Overwrite existing values.",
          "code": "put (key, value, overwrite = true) {\n    let result = this.search(key)\n\n    // Key already exists\n    if (result.leaf) {\n      if (!overwrite) {\n        return\n      }\n\n      result.leaf.value = value\n      return\n    }\n\n    let node = result.node\n    let index = result.index\n\n    node.leafs.splice(index, 0, new TreeLeaf(node, key, value))\n    node.nodes.splice(index + 1, 0, null)\n\n    if (node.leafs.length > this.METADATA.order) {\n      node.split()\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 127,
            "column": 2
          },
          "end": {
            "line": 149,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "key": {
              "type": "argument",
              "label": "key",
              "description": null,
              "code": "key",
              "start": {
                "line": 127,
                "column": 7
              },
              "end": {
                "line": 127,
                "column": 10
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "value": {
              "type": "argument",
              "label": "key",
              "description": "",
              "code": "value",
              "start": {
                "line": 127,
                "column": 12
              },
              "end": {
                "line": 127,
                "column": 17
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            },
            "overwrite": {
              "type": "argument",
              "label": "overwrite",
              "description": "Overwrite existing values.",
              "code": "@param {boolean} [overwrite=true]\nOverwrite existing values.",
              "start": {
                "line": 127,
                "column": 2
              },
              "end": {
                "line": 149,
                "column": 3
              },
              "flags": [],
              "default": "true",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "delete": {
          "type": "method",
          "label": "delete",
          "description": "Delete key.",
          "code": "delete (key) {\n    var result = this.search(key)\n\n    if (!result.leaf) {\n      return\n    }\n\n    let leaf = result.leaf\n    let node = leaf.parent\n    let index = result.index\n    let left = node.nodes[index]\n\n    if (left === null) {\n      node.leafs.splice(index, 1)\n      node.nodes.splice(index, 1)\n      node.balance()\n    } else {\n      let max = left.leafs[left.leafs.length - 1]\n\n      left.delete(max.key)\n\n      max.parent = node\n\n      node.leafs.splice(index, 1, max)\n    }\n\n    return true\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 155,
            "column": 2
          },
          "end": {
            "line": 182,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "key": {
              "type": "argument",
              "label": "key",
              "description": "",
              "code": "@param {number} key",
              "start": {
                "line": 155,
                "column": 2
              },
              "end": {
                "line": 182,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            }
          },
          "returnType": "boolean",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "balance": {
          "type": "method",
          "label": "balance",
          "description": "Balance the tree.",
          "code": "balance () {\n    if (this.parent instanceof Tree) {\n      // Root has a single child and no leafs\n      if (this.leafs.length === 0 && this.nodes[0] !== null) {\n        this.parent.root = this.nodes[0]\n        this.parent.root.parent = this.parent\n      }\n\n      return\n    }\n\n    if (this.leafs.length >= this.METADATA.minOrder) {\n      return\n    }\n\n    let index = this.parent.nodes.indexOf(this)\n    let left = index > 0 ? this.parent.nodes[index - 1] : null\n    let right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null\n    let sep\n    let leaf\n    let rest\n\n    if (right !== null && right.leafs.length > this.METADATA.minOrder) {\n      // Append the parent separator\n      sep = this.parent.leafs[index]\n      sep.parent = this\n\n      this.leafs.push(sep)\n\n      // Replace blank with the first right leaf\n      leaf = right.leafs.shift()\n      leaf.parent = this.parent\n\n      this.parent.leafs[index] = leaf\n\n      // Append the right rest\n      rest = right.nodes.shift()\n\n      if (rest !== null) {\n        rest.parent = this\n      }\n\n      this.nodes.push(rest)\n    } else if (left !== null && left.leafs.length > this.METADATA.minOrder) {\n      // Prepend the parent seperator\n      sep = this.parent.leafs[index - 1]\n      sep.parent = this\n\n      this.leafs.unshift(sep)\n\n      // Replace the blank with the last left leaf\n      leaf = left.leafs.pop()\n      leaf.parent = this.parent\n\n      this.parent.leafs[index - 1] = leaf\n\n      // Prepend the left rest to this\n      rest = left.nodes.pop()\n\n      if (rest !== null) {\n        rest.parent = this\n      }\n\n      this.nodes.unshift(rest)\n    } else {\n      let subst\n\n      if (right !== null) {\n        // Combine this + seperator from the parent + right\n        sep = this.parent.leafs[index]\n        subst = new TreeNode(this.parent, this.leafs.concat([sep], right.leafs), this.nodes.concat(right.nodes))\n        subst.METADATA.order = this.METADATA.order\n        subst.METADATA.minOrder = this.METADATA.minOrder\n\n        // Remove the seperator from the parent\n        this.parent.leafs.splice(index, 1)\n\n        // And replace the nodes it seperated with subst\n        this.parent.nodes.splice(index, 2, subst)\n      } else if (left !== null) {\n        // Combine left + seperator from parent + this\n        sep = this.parent.leafs[index - 1]\n        subst = new TreeNode(\n          this.parent,\n          left.leafs.concat([sep], this.leafs),\n          left.nodes.concat(this.nodes)\n        )\n\n        subst.METADATA.minOrder = this.METADATA.minOrder\n        subst.METADATA.order = this.METADATA.order\n\n        // Remove the seperator from the parent\n        this.parent.leafs.splice(index - 1, 1)\n\n        // Replace seperated nodes with subst\n        this.parent.nodes.splice(index - 1, 2, subst)\n      } else {\n        throw new Error(`Internal error: ${this.toString(true)} has neither a left nor a right sibling`)\n      }\n\n      this.parent.balance()\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 188,
            "column": 2
          },
          "end": {
            "line": 290,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "split": {
          "type": "method",
          "label": "split",
          "description": "Split the node.",
          "code": "split () {\n    let index = Math.floor(this.leafs.length / 2)\n\n    if (this.parent instanceof Tree) {\n      this.nodes = [\n        new TreeNode(this, this.leafs.slice(0, index), this.nodes.slice(0, index + 1)),\n        new TreeNode(this, this.leafs.slice(index + 1), this.nodes.slice(index + 1))\n      ]\n\n      this.leafs = [this.leafs[index]]\n    } else {\n      let leaf = this.leafs[index]\n      let rest = new TreeNode(\n        this.parent,\n        this.leafs.slice(index + 1),\n        this.nodes.slice(index + 1)\n      )\n\n      this.leafs = this.leafs.slice(0, index)\n      this.nodes = this.nodes.slice(0, index + 1)\n\n      this.parent.unsplit(leaf, rest)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 295,
            "column": 2
          },
          "end": {
            "line": 318,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "unsplit": {
          "type": "method",
          "label": "unsplit",
          "description": "Unsplits a child.",
          "code": "unsplit (leaf, rest) {\n    leaf.parent = this\n    rest.parent = this\n\n    let a = this.leafs[0]\n\n    if (this.METADATA.compare(leaf.key, a.key) < 0) {\n      this.leafs.unshift(leaf)\n      this.nodes.splice(1, 0, rest)\n    } else {\n      let i\n      for (i = 1; i < this.leafs.length; i++) {\n        let b = this.leafs[i]\n\n        if (this.METADATA.compare(leaf.key, b.key) < 0) {\n          this.leafs.splice(i, 0, leaf)\n          this.nodes.splice(i + 1, 0, rest)\n          break\n        }\n      }\n\n      if (i === this.leafs.length) {\n        this.leafs.push(leaf)\n        this.nodes.push(rest)\n      }\n    }\n\n    if (this.leafs.length > this.METADATA.order) {\n      this.split()\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 327,
            "column": 2
          },
          "end": {
            "line": 357,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "leaf": {
              "type": "argument",
              "label": "leaf",
              "description": null,
              "code": "leaf",
              "start": {
                "line": 327,
                "column": 11
              },
              "end": {
                "line": 327,
                "column": 15
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "rest": {
              "type": "argument",
              "label": "rest",
              "description": "",
              "code": "@param {NGNTreeNode} rest",
              "start": {
                "line": 327,
                "column": 2
              },
              "end": {
                "line": 357,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "ngntreenode",
              "required": true,
              "enum": null
            },
            "order": {
              "type": "argument",
              "label": "order",
              "description": "",
              "code": "@param {number} [order=52]",
              "start": {
                "line": 327,
                "column": 2
              },
              "end": {
                "line": 357,
                "column": 3
              },
              "flags": [],
              "default": "52",
              "datatype": "number",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "toString": {
          "type": "method",
          "label": "toString",
          "description": "A string representation of the node.\n \n Include sub-nodes",
          "code": "toString (includeNodes = false) {\n    let value = []\n    let i\n\n    for (i = 0; i < this.leafs.length; i++) {\n      value.push(this.leafs[i].key)\n    }\n\n    let s = `[${value.toString()}]${(this.parent instanceof Tree ? ':*' : ':')}${this.parent}`\n\n    if (includeNodes) {\n      for (i = 0; i < this.nodes.length; i++) {\n        s += ` -> ${this.nodes[i]}`\n      }\n    }\n\n    return s\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 366,
            "column": 2
          },
          "end": {
            "line": 383,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "includeNodes": {
              "type": "argument",
              "label": "includeNodes",
              "description": "Include sub-nodes",
              "code": "@param {boolean} [includeNodes=false]\nInclude sub-nodes",
              "start": {
                "line": 366,
                "column": 2
              },
              "end": {
                "line": 383,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "string",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "TreeLeaf": {
      "type": "class",
      "label": "TreeLeaf",
      "description": "Constructs a new Leaf containing a value.",
      "code": "class TreeLeaf {\n  constructor (parent, key, value) {\n    Object.defineProperties(this, {\n      parent: NGN.private(parent),\n      key: NGN.private(key),\n      value: NGN.private(value)\n    })\n  }\n\n  toString () {\n    return this.key.toString()\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 393,
        "column": 0
      },
      "end": {
        "line": 405,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/index/BTree.js",
      "extends": null,
      "configuration": {},
      "properties": {
        "parent": {
          "type": "property",
          "label": "parent",
          "description": null,
          "code": "parent: NGN.private(parent)",
          "start": {
            "line": 396,
            "column": 6
          },
          "end": {
            "line": 396,
            "column": 33
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "key": {
          "type": "property",
          "label": "key",
          "description": null,
          "code": "key: NGN.private(key)",
          "start": {
            "line": 397,
            "column": 6
          },
          "end": {
            "line": 397,
            "column": 27
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "value": {
          "type": "property",
          "label": "value",
          "description": null,
          "code": "value: NGN.private(value)",
          "start": {
            "line": 398,
            "column": 6
          },
          "end": {
            "line": 398,
            "column": 31
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (parent, key, value) {\n    Object.defineProperties(this, {\n      parent: NGN.private(parent),\n      key: NGN.private(key),\n      value: NGN.private(value)\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 394,
            "column": 2
          },
          "end": {
            "line": 400,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "parent": {
              "type": "argument",
              "label": "parent",
              "description": null,
              "code": "parent",
              "start": {
                "line": 394,
                "column": 15
              },
              "end": {
                "line": 394,
                "column": 21
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "key": {
              "type": "argument",
              "label": "key",
              "description": null,
              "code": "key",
              "start": {
                "line": 394,
                "column": 23
              },
              "end": {
                "line": 394,
                "column": 26
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "value": {
              "type": "argument",
              "label": "value",
              "description": null,
              "code": "value",
              "start": {
                "line": 394,
                "column": 28
              },
              "end": {
                "line": 394,
                "column": 33
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "toString": {
          "type": "method",
          "label": "toString",
          "description": null,
          "code": "toString () {\n    return this.key.toString()\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 402,
            "column": 2
          },
          "end": {
            "line": 404,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.BTree": {
      "type": "class",
      "label": "NGN.DATA.BTree",
      "description": "Compare two numbers\n       \n       \n       \n       - Returns `-1` if first number is less than second.\n       - Returns `0` if numbers are equal.\n       - Returns `1` if first number is greater than second.",
      "code": "class Tree extends EventEmitter {\n  constructor (order = 52) {\n    super()\n\n    // Sanitize input\n    order = order < 1 ? 1 : order\n\n    Object.defineProperties(this, {\n      root: NGN.private(new TreeNode(this)),\n\n      BTREE: NGN.private({}),\n\n      METADATA: NGN.private({\n        order: order,\n\n        minOrder: order > 1 ? Math.floor(order / 2) : 1,\n\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })\n    })\n\n    this.root.METADATA.minOrder = this.METADATA.minOrder\n    this.root.METADATA.order = this.METADATA.order\n  }\n\n  /**\n   * Validates a node and prints debugging info if something went wrong.\n   * @param {!TreeNode|!Tree} node\n   * @private\n   */\n  validate (node) {\n    if (node instanceof Tree) {\n      return\n    }\n\n    if (node.leafs.length + 1 !== node.nodes.length) {\n      NGN.ERROR(`Illegal leaf/node count in ${node}: ${node.leafs.length}/${node.nodes.length}`)\n    }\n\n    let i\n\n    for (i = 0; i < node.leafs.length; i++) {\n      if (!node.leafs[i]) {\n        NGN.ERROR(`Illegal leaf in ${node} at ${i}: ${node.leafs[i]}`)\n      }\n    }\n\n    for (i = 0; i < node.nodes.length; i++) {\n      if (NGN.typeof(node.nodes[i]) === 'undefined') {\n        NGN.ERROR(`Illegal node in ${node} at ${i}: undefined`)\n      }\n    }\n  }\n\n  /**\n   * Insert a key/value pair into the tree.\n   * @param {number} key\n   * @param {any} value\n   * @param {boolean} [overwrite=true]\n   * Overwrite existing values\n   */\n  put (key, value, overwrite = true) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    if (value === undefined) {\n      throw new Error(`Illegal value: ${value}`)\n    }\n\n    return this.root.put(key, value, overwrite)\n  }\n\n  /**\n   * Retrieve the value for the specified key.\n   * @param {number} key\n   * @returns {any}\n   * If there is no such key, `undefined` is returned.\n   */\n  get (key) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    return this.root.get(key)\n  }\n\n  /**\n   * Delete a key from the tree.\n   * @param {number} key\n   */\n  delete (key) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    return this.root.delete(key)\n  }\n\n  /**\n   * Walk through all keys in ascending order.\n   * @param {number} minKey\n   * If omitted or NULL, starts at the beginning\n   * @param {number} maxKey\n   * If omitted or NULL, walks till the end\n   * @param {function} callback\n   * @param {number} callback.key\n   * The key\n   * @param {any} callback.value\n   * The value.\n   */\n  walk (minKey, maxKey, callback) {\n    if (this.root.leafs.length === 0) {\n      return\n    }\n\n    if (NGN.isFn(minKey)) {\n      callback = minKey\n      minKey = maxKey = null\n    } else if (NGN.isFn(maxKey)) {\n      callback = maxKey\n      maxKey = null\n    }\n\n    minKey = NGN.coalesce(minKey)\n    maxKey = NGN.coalesce(maxKey)\n\n    let ptr\n    let index\n\n    if (minKey === null) {\n      // No minimum limit\n      ptr = this.root\n\n      while (ptr.nodes[0] !== null) {\n        ptr = ptr.nodes[0]\n      }\n\n      index = 0\n    } else {\n      // lookup\n      let result = this.root.search(minKey)\n\n      if (result.leaf) {\n        // Minimum key itself exists\n        ptr = result.leaf.parent\n        index = ptr.leafs.indexOf(result.leaf)\n      } else {\n        // Key does not exist\n        ptr = result.node\n        index = result.index\n\n        if (index >= ptr.leafs.length) {\n          // begin at parent separator in overrun\n          if (ptr.parent instanceof Tree || ptr.parent.nodes.indexOf(ptr) >= ptr.parent.leafs.length) {\n            return\n          }\n\n          ptr = ptr.parent\n        }\n      }\n    }\n\n    // ptr/index points to first result\n    while (true) {\n      if (maxKey !== null && this.METADATA.compare(ptr.leafs[index].key, maxKey) > 0) {\n        break\n      }\n      if (ptr.leafs.length === 0) {\n        break\n      }\n\n      if (callback(ptr.leafs[index].key, ptr.leafs[index].value)) {\n        break\n      }\n\n      if (ptr.nodes[index + 1] !== null) {\n        // Descend Tree\n        ptr = ptr.nodes[index + 1]\n        index = 0\n\n        while (ptr.nodes[0] !== null) {\n          ptr = ptr.nodes[0]\n        }\n      } else if (ptr.leafs.length > index + 1) {\n        // Next\n        index++\n      } else {\n        // Ascend Tree\n        do {\n          if ((ptr.parent instanceof Tree)) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr)\n          ptr = ptr.parent\n        } while (index >= ptr.leafs.length)\n      }\n    }\n  }\n\n  /**\n   * Walks through all keys in descending order.\n   * @param {number} minKey\n   * If omitted or NULL, starts at the beginning\n   * @param {number} maxKey\n   * If omitted or NULL, walks till the end\n   * @param {function} callback\n   * @param {number} callback.key\n   * The key\n   * @param {any} callback.value\n   * The value.\n   */\n  walkDesc (minKey, maxKey, callback) {\n    if (NGN.isFn(minKey)) {\n      callback = minKey\n      minKey = maxKey = null\n    } else if (NGN.isFn(maxKey)) {\n      callback = maxKey\n      maxKey = null\n    }\n\n    minKey = NGN.coalesce(minKey)\n    maxKey = NGN.coalesce(maxKey)\n\n    let ptr\n    let index\n    if (maxKey === null) {\n      // No maximum\n      ptr = this.root\n\n      while (ptr.nodes[ptr.nodes.length - 1] !== null) {\n        ptr = ptr.nodes[ptr.nodes.length - 1]\n      }\n\n      index = ptr.leafs.length - 1\n    } else {\n      // Lookup\n      let result = this.root.search(maxKey)\n\n      if (result.leaf) {\n        // Maximum key exists\n        ptr = result.leaf.parent\n        index = ptr.leafs.indexOf(result.leaf)\n      } else {\n        // Key does not exist\n        ptr = result.node\n        index = result.index - 1\n\n        while (index < 0) {\n          // Begin at parent separator on underrun\n          if (ptr.parent instanceof Tree) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr) - 1\n\n          if (index < 0) {\n            return\n          }\n\n          ptr = ptr.parent\n        }\n      }\n    }\n\n    // ptr/index points to first result\n    while (true) {\n      if (minKey !== null && this.METADATA.compare(ptr.leafs[index].key, minKey) < 0) {\n        break\n      }\n\n      if (callback(ptr.leafs[index].key, ptr.leafs[index].value)) {\n        break\n      }\n\n      if (ptr.nodes[index] !== null) {\n        // Descend Tree\n        ptr = ptr.nodes[index]\n\n        while (ptr.nodes[ptr.nodes.length - 1] !== null) {\n          ptr = ptr.nodes[ptr.nodes.length - 1]\n        }\n\n        index = ptr.leafs.length - 1\n      } else if (index > 0) {\n        // Next\n        index--\n      } else {\n        // Ascend Tree\n        do {\n          if ((ptr.parent instanceof Tree)) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr) - 1\n\n          ptr = ptr.parent\n        } while (index < 0)\n      }\n    }\n  }\n\n  /**\n   * The number of keys between minKey and maxKey (both inclusive).\n   * @param {number} minKey\n   * If omitted, counts from the start\n   * @param {number} maxKey\n   * If omitted, counts till the end\n   * @returns {number}\n   */\n  count (minKey, maxKey) {\n    let n = 0\n\n    this.walk(\n      minKey !== undefined ? minKey : null,\n      maxKey !== undefined ? maxKey : null,\n      (key, value) => { n++ }\n    )\n\n    return n\n  };\n\n  /**\n   * A string representation of the tree.\n   * @returns {string}\n   */\n  toString () {\n    return `Tree(${this.METADATA.order}) ${this.root.toString()}`\n  }\n\n  get length () {\n    return this.count()\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 412,
        "column": 15
      },
      "end": {
        "line": 748,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/index/BTree.js",
      "extends": "EventEmitter",
      "configuration": {},
      "properties": {
        "root": {
          "type": "property",
          "label": "root",
          "description": null,
          "code": "root: NGN.private(new TreeNode(this))",
          "start": {
            "line": 420,
            "column": 6
          },
          "end": {
            "line": 420,
            "column": 43
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "BTREE": {
          "type": "property",
          "label": "BTREE",
          "description": null,
          "code": "BTREE: NGN.private({})",
          "start": {
            "line": 422,
            "column": 6
          },
          "end": {
            "line": 422,
            "column": 28
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "METADATA": {
          "type": "property",
          "label": "METADATA",
          "description": null,
          "code": "METADATA: NGN.private({\n        order: order,\n\n        minOrder: order > 1 ? Math.floor(order / 2) : 1,\n\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })",
          "start": {
            "line": 424,
            "column": 6
          },
          "end": {
            "line": 432,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "minOrder": {
          "type": "property",
          "label": "minOrder",
          "description": null,
          "code": "this.root.METADATA.minOrder = this.METADATA.minOrder",
          "start": {
            "line": 435,
            "column": 23
          },
          "end": {
            "line": 435,
            "column": 31
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "order": {
          "type": "property",
          "label": "order",
          "description": null,
          "code": "this.root.METADATA.order = this.METADATA.order",
          "start": {
            "line": 436,
            "column": 23
          },
          "end": {
            "line": 436,
            "column": 28
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "length": {
          "type": "property",
          "label": "length",
          "description": null,
          "code": "get length () {\n    return this.count()\n  }",
          "start": {
            "line": 745,
            "column": 2
          },
          "end": {
            "line": 747,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "url": {
          "type": "property",
          "label": "url",
          "description": "The URL where the request will be sent.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "crossOriginRequest": {
          "type": "property",
          "label": "crossOriginRequest",
          "description": "Indicates the request will be made to a domain outside of the\none hosting the request.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "boolean",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "username": {
          "type": "property",
          "label": "username",
          "description": "The username that will be used in any basic authentication operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "password": {
          "type": "property",
          "label": "password",
          "description": "It is possible to set a password for any basic authentication operations,\nbut it is not possible to read a password.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "accessToken": {
          "type": "property",
          "label": "accessToken",
          "description": "Supply a bearer access token for basic authenticaiton operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (order = 52) {\n    super()\n\n    // Sanitize input\n    order = order < 1 ? 1 : order\n\n    Object.defineProperties(this, {\n      root: NGN.private(new TreeNode(this)),\n\n      BTREE: NGN.private({}),\n\n      METADATA: NGN.private({\n        order: order,\n\n        minOrder: order > 1 ? Math.floor(order / 2) : 1,\n\n        compare: (firstNumber, secondNumber) => {\n          return firstNumber < secondNumber ? -1 : (firstNumber > secondNumber ? 1 : 0)\n        }\n      })\n    })\n\n    this.root.METADATA.minOrder = this.METADATA.minOrder\n    this.root.METADATA.order = this.METADATA.order\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 413,
            "column": 2
          },
          "end": {
            "line": 437,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "order": {
              "type": "argument",
              "label": "order",
              "description": null,
              "code": "order = 52",
              "start": {
                "line": 413,
                "column": 15
              },
              "end": {
                "line": 413,
                "column": 25
              },
              "flags": [],
              "default": 52,
              "datatype": "number",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "validate": {
          "type": "method",
          "label": "validate",
          "description": "Validates a node and prints debugging info if something went wrong.",
          "code": "validate (node) {\n    if (node instanceof Tree) {\n      return\n    }\n\n    if (node.leafs.length + 1 !== node.nodes.length) {\n      NGN.ERROR(`Illegal leaf/node count in ${node}: ${node.leafs.length}/${node.nodes.length}`)\n    }\n\n    let i\n\n    for (i = 0; i < node.leafs.length; i++) {\n      if (!node.leafs[i]) {\n        NGN.ERROR(`Illegal leaf in ${node} at ${i}: ${node.leafs[i]}`)\n      }\n    }\n\n    for (i = 0; i < node.nodes.length; i++) {\n      if (NGN.typeof(node.nodes[i]) === 'undefined') {\n        NGN.ERROR(`Illegal node in ${node} at ${i}: undefined`)\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 444,
            "column": 2
          },
          "end": {
            "line": 466,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "node": {
              "type": "argument",
              "label": "node",
              "description": "",
              "code": "@param {!TreeNode|!Tree} node",
              "start": {
                "line": 444,
                "column": 2
              },
              "end": {
                "line": 466,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "!treenode|!tree",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "put": {
          "type": "method",
          "label": "put",
          "description": "Insert a key/value pair into the tree.\n  \n  \n  \n  Overwrite existing values",
          "code": "put (key, value, overwrite = true) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    if (value === undefined) {\n      throw new Error(`Illegal value: ${value}`)\n    }\n\n    return this.root.put(key, value, overwrite)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 475,
            "column": 2
          },
          "end": {
            "line": 485,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "key": {
              "type": "argument",
              "label": "key",
              "description": null,
              "code": "key",
              "start": {
                "line": 475,
                "column": 7
              },
              "end": {
                "line": 475,
                "column": 10
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "value": {
              "type": "argument",
              "label": "key",
              "description": "",
              "code": "value",
              "start": {
                "line": 475,
                "column": 12
              },
              "end": {
                "line": 475,
                "column": 17
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            },
            "overwrite": {
              "type": "argument",
              "label": "overwrite",
              "description": "Overwrite existing values",
              "code": "@param {boolean} [overwrite=true]\nOverwrite existing values",
              "start": {
                "line": 475,
                "column": 2
              },
              "end": {
                "line": 485,
                "column": 3
              },
              "flags": [],
              "default": "true",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "get": {
          "type": "method",
          "label": "get",
          "description": "Retrieve the value for the specified key.\n  \n  \n  If there is no such key, `undefined` is returned.",
          "code": "get (key) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    return this.root.get(key)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 493,
            "column": 2
          },
          "end": {
            "line": 499,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "key": {
              "type": "argument",
              "label": "key",
              "description": "",
              "code": "@param {number} key",
              "start": {
                "line": 493,
                "column": 2
              },
              "end": {
                "line": 499,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            }
          },
          "returnType": "any",
          "returnDescription": "null If there is no such key, `undefined` is returned.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "delete": {
          "type": "method",
          "label": "delete",
          "description": "Delete a key from the tree.",
          "code": "delete (key) {\n    if (NGN.typeof(key) !== 'number') {\n      throw new Error(`Illegal key: ${key}`)\n    }\n\n    return this.root.delete(key)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 505,
            "column": 2
          },
          "end": {
            "line": 511,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "key": {
              "type": "argument",
              "label": "key",
              "description": "",
              "code": "@param {number} key",
              "start": {
                "line": 505,
                "column": 2
              },
              "end": {
                "line": 511,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "walk": {
          "type": "method",
          "label": "walk",
          "description": "Walk through all keys in ascending order.\n  \n  If omitted or NULL, starts at the beginning\n  \n  If omitted or NULL, walks till the end\n  \n  \n  The key\n  \n  The value.",
          "code": "walk (minKey, maxKey, callback) {\n    if (this.root.leafs.length === 0) {\n      return\n    }\n\n    if (NGN.isFn(minKey)) {\n      callback = minKey\n      minKey = maxKey = null\n    } else if (NGN.isFn(maxKey)) {\n      callback = maxKey\n      maxKey = null\n    }\n\n    minKey = NGN.coalesce(minKey)\n    maxKey = NGN.coalesce(maxKey)\n\n    let ptr\n    let index\n\n    if (minKey === null) {\n      // No minimum limit\n      ptr = this.root\n\n      while (ptr.nodes[0] !== null) {\n        ptr = ptr.nodes[0]\n      }\n\n      index = 0\n    } else {\n      // lookup\n      let result = this.root.search(minKey)\n\n      if (result.leaf) {\n        // Minimum key itself exists\n        ptr = result.leaf.parent\n        index = ptr.leafs.indexOf(result.leaf)\n      } else {\n        // Key does not exist\n        ptr = result.node\n        index = result.index\n\n        if (index >= ptr.leafs.length) {\n          // begin at parent separator in overrun\n          if (ptr.parent instanceof Tree || ptr.parent.nodes.indexOf(ptr) >= ptr.parent.leafs.length) {\n            return\n          }\n\n          ptr = ptr.parent\n        }\n      }\n    }\n\n    // ptr/index points to first result\n    while (true) {\n      if (maxKey !== null && this.METADATA.compare(ptr.leafs[index].key, maxKey) > 0) {\n        break\n      }\n      if (ptr.leafs.length === 0) {\n        break\n      }\n\n      if (callback(ptr.leafs[index].key, ptr.leafs[index].value)) {\n        break\n      }\n\n      if (ptr.nodes[index + 1] !== null) {\n        // Descend Tree\n        ptr = ptr.nodes[index + 1]\n        index = 0\n\n        while (ptr.nodes[0] !== null) {\n          ptr = ptr.nodes[0]\n        }\n      } else if (ptr.leafs.length > index + 1) {\n        // Next\n        index++\n      } else {\n        // Ascend Tree\n        do {\n          if ((ptr.parent instanceof Tree)) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr)\n          ptr = ptr.parent\n        } while (index >= ptr.leafs.length)\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 525,
            "column": 2
          },
          "end": {
            "line": 613,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "minKey": {
              "type": "argument",
              "label": "minKey",
              "description": null,
              "code": "minKey",
              "start": {
                "line": 525,
                "column": 8
              },
              "end": {
                "line": 525,
                "column": 14
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "maxKey": {
              "type": "argument",
              "label": "maxKey",
              "description": "If omitted or NULL, walks till the end",
              "code": "callback",
              "start": {
                "line": 525,
                "column": 24
              },
              "end": {
                "line": 525,
                "column": 32
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "maxKey",
              "description": "If omitted or NULL, walks till the end",
              "code": "callback",
              "start": {
                "line": 525,
                "column": 24
              },
              "end": {
                "line": 525,
                "column": 32
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "walkDesc": {
          "type": "method",
          "label": "walkDesc",
          "description": "Walks through all keys in descending order.\n  \n  If omitted or NULL, starts at the beginning\n  \n  If omitted or NULL, walks till the end\n  \n  \n  The key\n  \n  The value.",
          "code": "walkDesc (minKey, maxKey, callback) {\n    if (NGN.isFn(minKey)) {\n      callback = minKey\n      minKey = maxKey = null\n    } else if (NGN.isFn(maxKey)) {\n      callback = maxKey\n      maxKey = null\n    }\n\n    minKey = NGN.coalesce(minKey)\n    maxKey = NGN.coalesce(maxKey)\n\n    let ptr\n    let index\n    if (maxKey === null) {\n      // No maximum\n      ptr = this.root\n\n      while (ptr.nodes[ptr.nodes.length - 1] !== null) {\n        ptr = ptr.nodes[ptr.nodes.length - 1]\n      }\n\n      index = ptr.leafs.length - 1\n    } else {\n      // Lookup\n      let result = this.root.search(maxKey)\n\n      if (result.leaf) {\n        // Maximum key exists\n        ptr = result.leaf.parent\n        index = ptr.leafs.indexOf(result.leaf)\n      } else {\n        // Key does not exist\n        ptr = result.node\n        index = result.index - 1\n\n        while (index < 0) {\n          // Begin at parent separator on underrun\n          if (ptr.parent instanceof Tree) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr) - 1\n\n          if (index < 0) {\n            return\n          }\n\n          ptr = ptr.parent\n        }\n      }\n    }\n\n    // ptr/index points to first result\n    while (true) {\n      if (minKey !== null && this.METADATA.compare(ptr.leafs[index].key, minKey) < 0) {\n        break\n      }\n\n      if (callback(ptr.leafs[index].key, ptr.leafs[index].value)) {\n        break\n      }\n\n      if (ptr.nodes[index] !== null) {\n        // Descend Tree\n        ptr = ptr.nodes[index]\n\n        while (ptr.nodes[ptr.nodes.length - 1] !== null) {\n          ptr = ptr.nodes[ptr.nodes.length - 1]\n        }\n\n        index = ptr.leafs.length - 1\n      } else if (index > 0) {\n        // Next\n        index--\n      } else {\n        // Ascend Tree\n        do {\n          if ((ptr.parent instanceof Tree)) {\n            return\n          }\n\n          index = ptr.parent.nodes.indexOf(ptr) - 1\n\n          ptr = ptr.parent\n        } while (index < 0)\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 627,
            "column": 2
          },
          "end": {
            "line": 715,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "minKey": {
              "type": "argument",
              "label": "minKey",
              "description": null,
              "code": "minKey",
              "start": {
                "line": 627,
                "column": 12
              },
              "end": {
                "line": 627,
                "column": 18
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "maxKey": {
              "type": "argument",
              "label": "maxKey",
              "description": "If omitted or NULL, walks till the end",
              "code": "callback",
              "start": {
                "line": 627,
                "column": 28
              },
              "end": {
                "line": 627,
                "column": 36
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "maxKey",
              "description": "If omitted or NULL, walks till the end",
              "code": "callback",
              "start": {
                "line": 627,
                "column": 28
              },
              "end": {
                "line": 627,
                "column": 36
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "count": {
          "type": "method",
          "label": "count",
          "description": "The number of keys between minKey and maxKey (both inclusive).\n  \n  If omitted, counts from the start\n  \n  If omitted, counts till the end",
          "code": "count (minKey, maxKey) {\n    let n = 0\n\n    this.walk(\n      minKey !== undefined ? minKey : null,\n      maxKey !== undefined ? maxKey : null,\n      (key, value) => { n++ }\n    )\n\n    return n\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 725,
            "column": 2
          },
          "end": {
            "line": 735,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "minKey": {
              "type": "argument",
              "label": "minKey",
              "description": null,
              "code": "minKey",
              "start": {
                "line": 725,
                "column": 9
              },
              "end": {
                "line": 725,
                "column": 15
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "maxKey": {
              "type": "argument",
              "label": "maxKey",
              "description": "If omitted, counts till the end",
              "code": "@param {number} maxKey\nIf omitted, counts till the end",
              "start": {
                "line": 725,
                "column": 2
              },
              "end": {
                "line": 735,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            }
          },
          "returnType": "number",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "toString": {
          "type": "method",
          "label": "toString",
          "description": "A string representation of the tree.",
          "code": "toString () {\n    return `Tree(${this.METADATA.order}) ${this.root.toString()}`\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 741,
            "column": 2
          },
          "end": {
            "line": 743,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "string",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "hash": {
          "type": "method",
          "label": "hash",
          "description": "The hash part of the URL .",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setHeader": {
          "type": "method",
          "label": "setHeader",
          "description": "Add a header to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getHeader": {
          "type": "method",
          "label": "getHeader",
          "description": "",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeHeader": {
          "type": "method",
          "label": "removeHeader",
          "description": "Removes a header from the request. Nothing happens if the header does\nnot exist.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setQueryParameter": {
          "type": "method",
          "label": "setQueryParameter",
          "description": "Add a query parameter to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeQueryParameter": {
          "type": "method",
          "label": "removeQueryParameter",
          "description": "Remove a query parameter from the request URI.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "send": {
          "type": "method",
          "label": "send",
          "description": "Send the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.Index": {
      "type": "class",
      "label": "NGN.DATA.Index",
      "description": "Data indexes are a data structure that improves the speed\nof data retrieval from an NGN.DATA.Store, at the cost of\nadditional memory usage. Even though memory usage is increased\nfor each index applied to a store, it tends to be a very small\nfraction of the memory required for storing data.\n\nIndexes help locate data within a store without having to read\nevery record. They will, in the overwhelming majority of cases,\nspeed up queries. However; if overused or misused, they may\nmarginally _increase_ query processing time.\n\nNGN data indexes were designed to be used the same way relational\ndata indexes and graph data vertices are used.",
      "code": "class NGNDataIndex extends EventEmitter { // eslint-disable-line\n  /**\n   * Create a new data index.\n   * @param {Boolean} [BTree=false]\n   * Use a B-Tree index. This is only available for numeric values and dates.\n   * @param {String} [name='Untitled Index']\n   * Optional name for index. This is useful for debugging when multiple\n   * indexes exist.\n   */\n  constructor (btree = false, name = 'Untitled Index') {\n    super()\n\n    Object.defineProperties(this, {\n      // Private constants\n      CREATE_EVENT: NGN.privateconst(Symbol('create')),\n      REMOVE_EVENT: NGN.privateconst(Symbol('delete')),\n      UPDATE_EVENT: NGN.privateconst(Symbol('update')),\n\n      // Private data attributes\n      uniqueValues: NGN.privateconst(new Set()),\n      knownRecords: NGN.privateconst([]), // Linked list of Sets\n      name: NGN.const(name),\n      isBTree: NGN.privateconst(btree)\n    })\n\n    // Bubble up private events when applicable\n    const me = this\n    this.on([\n      this.CREATE_EVENT,\n      this.REMOVE_EVENT,\n      this.UPDATE_EVENT\n    ], function (oid, value, suppressEvent = false) {\n      if (!suppressEvent) {\n        me.emit(this.event.toString().replace(/^Symbol\\(|\\)$/g, ''), oid)\n      }\n    })\n\n    // When all known records for a given value are removed,\n    // clear the unique value index.\n    this.on(this.REMOVE_EVENT, (oid, value) => {\n      if (this.recordsFor(value).length === 0) {\n        let index = this.indexOf(value)\n\n        if (index >= 0) {\n          this.knownRecords.splice(index, 1)\n          this.uniqueValues.delete(value)\n        }\n      }\n    })\n\n    // Support BTree Indexing\n    if (this.isBTree) {\n      Object.defineProperty(this, 'BTREE', NGN.privateconst(new NGN.DATA.BTree(2, name)))\n    }\n  }\n\n  get keys () {\n    if (this.uniqueValues.size === 0) {\n      return []\n    }\n\n    return Array.from(this.uniqueValues.values())\n  }\n\n  /**\n   * Add a field/value to the index.\n   * @param {any} value\n   * The value of the model/record indexed field.\n   * @param {Symbol} oid\n   * The record's object ID (NGN.DATA.Model#OID)\n   */\n  add (value, oid, suppressEvent = false) {\n    let valueIndex = -1\n\n    // Create or identify the index of the unique value\n    if (!this.uniqueValues.has(value)) {\n      this.uniqueValues.add(value)\n      this.knownRecords.push(new Set())\n      valueIndex += this.uniqueValues.size\n    } else {\n      valueIndex = this.indexOf(value)\n    }\n\n    this.knownRecords[valueIndex].add(oid)\n\n    // Add BTree indexing\n    if (this.isBTree) {\n      let btreeValue = value instanceof Date ? value.getTime() : value\n\n      if (this.BTREE.get(btreeValue) === undefined) {\n        this.BTREE.put(btreeValue, valueIndex)\n      }\n    }\n\n    this.emit(this.CREATE_EVENT, oid, value, suppressEvent)\n  }\n\n  /**\n   * Remove a record from the index.\n   * @param  {Symbol} oid\n   * The record's object ID (NGN.DATA.Model#OID)\n   * @param  {any} [value=undefined]\n   * When specified, the field value will be used to identify\n   * the index value. Specifying this value will make the remove\n   * operation faster (uses introspection).\n   */\n  remove (oid, value, suppressEvent = false) {\n    // If a value is specified, attempt to lookup the OID by value.\n    if (value !== undefined) {\n      let index = this.recordsOf(value)\n\n      // If a value index is found, remove the OID\n      if (index) {\n        if (index.delete(oid)) { // Returns false if nothing is actually deleted.\n          if (this.isBTree && (!index || index.size === 0)) {\n            this.BTREE.delete(value instanceof Date ? value.getTime() : value)\n          }\n\n          this.emit(this.REMOVE_EVENT, oid, value, suppressEvent)\n\n          return\n        }\n      }\n\n      NGN.WARN(`Index value \"${value}\" not found in index.`)\n    }\n\n    // Iterate through all index values to remove the OID (slow)\n    let removed = false\n    for (let i = 0; i < this.knownRecords.length; i++) {\n      if (this.knownRecords[i].delete(oid) && !removed) {\n        removed = true\n        value = Array.from(this.uniqueValues.values())[i]\n\n        if (this.isBTree) {\n          this.BTREE.delete(value instanceof Date ? value.getTime() : value)\n        }\n\n        break\n      }\n    }\n\n    if (removed) {\n      this.emit(this.REMOVE_EVENT, oid, value, suppressEvent)\n    }\n  }\n\n  /**\n   * Update an index to reflect an updated value.\n   * @param  {[type]} oid      [description]\n   * @param  {[type]} oldvalue [description]\n   * @param  {[type]} newvalue [description]\n   * @return {[type]}          [description]\n   */\n  update (oid, oldValue, newValue, suppressEvent = false) {\n    if (oldValue !== newValue) {\n      this.remove(oid, oldValue, true)\n      this.add(newValue, oid, true)\n      this.emit(this.UPDATE_EVENT, oid, null, suppressEvent)\n    }\n  }\n\n  /**\n   * Forcibly reset the index (clears everything).\n   */\n  reset () {\n    this.uniqueValues.clear()\n    this.knownRecords.splice(0)\n\n    if (this.isBTree) {\n      this.BTREE.reset()\n    }\n\n    this.emit('reset')\n  }\n\n  /**\n   * Retrieve the index number of known records for the\n   * specified value.\n   * @private\n   * @param  {any} value\n   * The unique value for which records are known.\n   * @return {[numeric]}\n   * The 0-based index of known records. Returns `-1` if no\n   * index exists.\n   */\n  indexOf (value) {\n    return Array.from(this.uniqueValues.keys()).indexOf(value)\n  }\n\n  /**\n   * The records of a particular value.\n   * @private\n   * @param  {any} value\n   * The index field value to use as a lookup.\n   * @return {Set}\n   * An set of object ID's or `null` if none exist.\n   */\n  recordsOf (value) {\n    let valueIndex = this.indexOf(value)\n\n    return valueIndex < 0 ? null : this.knownRecords[valueIndex]\n  }\n\n  /**\n   * Get the list of records for the given value.\n   * @param  {any} value\n   * The value of the index to lookup.\n   * @return {array}\n   * The array contains OID reference values (records).\n   */\n  recordsFor (value) {\n    let index = this.recordsOf(value)\n\n    if (index === null || index.size === 0) {\n      return []\n    }\n\n    return Array.from(index.values())\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "reset": {
          "type": "event",
          "label": "reset",
          "description": null,
          "code": "this.emit('reset')",
          "start": {
            "line": 204,
            "column": 4
          },
          "end": {
            "line": 204,
            "column": 22
          },
          "flags": [],
          "parameters": {},
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 31,
        "column": 15
      },
      "end": {
        "line": 251,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/index/Index.js",
      "extends": "EventEmitter",
      "configuration": {},
      "properties": {
        "CREATE_EVENT": {
          "type": "property",
          "label": "CREATE_EVENT",
          "description": null,
          "code": "CREATE_EVENT: NGN.privateconst(Symbol('create'))",
          "start": {
            "line": 45,
            "column": 6
          },
          "end": {
            "line": 45,
            "column": 54
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "REMOVE_EVENT": {
          "type": "property",
          "label": "REMOVE_EVENT",
          "description": null,
          "code": "REMOVE_EVENT: NGN.privateconst(Symbol('delete'))",
          "start": {
            "line": 46,
            "column": 6
          },
          "end": {
            "line": 46,
            "column": 54
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "UPDATE_EVENT": {
          "type": "property",
          "label": "UPDATE_EVENT",
          "description": null,
          "code": "UPDATE_EVENT: NGN.privateconst(Symbol('update'))",
          "start": {
            "line": 47,
            "column": 6
          },
          "end": {
            "line": 47,
            "column": 54
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "uniqueValues": {
          "type": "property",
          "label": "uniqueValues",
          "description": null,
          "code": "uniqueValues: NGN.privateconst(new Set())",
          "start": {
            "line": 50,
            "column": 6
          },
          "end": {
            "line": 50,
            "column": 47
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "knownRecords": {
          "type": "property",
          "label": "knownRecords",
          "description": null,
          "code": "knownRecords: NGN.privateconst([])",
          "start": {
            "line": 51,
            "column": 6
          },
          "end": {
            "line": 51,
            "column": 40
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "name": {
          "type": "property",
          "label": "name",
          "description": null,
          "code": "name: NGN.const(name)",
          "start": {
            "line": 52,
            "column": 6
          },
          "end": {
            "line": 52,
            "column": 27
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "isBTree": {
          "type": "property",
          "label": "isBTree",
          "description": null,
          "code": "isBTree: NGN.privateconst(btree)",
          "start": {
            "line": 53,
            "column": 6
          },
          "end": {
            "line": 53,
            "column": 38
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "keys": {
          "type": "property",
          "label": "keys",
          "description": null,
          "code": "get keys () {\n    if (this.uniqueValues.size === 0) {\n      return []\n    }\n\n    return Array.from(this.uniqueValues.values())\n  }",
          "start": {
            "line": 87,
            "column": 2
          },
          "end": {
            "line": 93,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "Create a new data index.\n  \n  Use a B-Tree index. This is only available for numeric values and dates.\n  \n  Optional name for index. This is useful for debugging when multiple\n  indexes exist.",
          "code": "constructor (btree = false, name = 'Untitled Index') {\n    super()\n\n    Object.defineProperties(this, {\n      // Private constants\n      CREATE_EVENT: NGN.privateconst(Symbol('create')),\n      REMOVE_EVENT: NGN.privateconst(Symbol('delete')),\n      UPDATE_EVENT: NGN.privateconst(Symbol('update')),\n\n      // Private data attributes\n      uniqueValues: NGN.privateconst(new Set()),\n      knownRecords: NGN.privateconst([]), // Linked list of Sets\n      name: NGN.const(name),\n      isBTree: NGN.privateconst(btree)\n    })\n\n    // Bubble up private events when applicable\n    const me = this\n    this.on([\n      this.CREATE_EVENT,\n      this.REMOVE_EVENT,\n      this.UPDATE_EVENT\n    ], function (oid, value, suppressEvent = false) {\n      if (!suppressEvent) {\n        me.emit(this.event.toString().replace(/^Symbol\\(|\\)$/g, ''), oid)\n      }\n    })\n\n    // When all known records for a given value are removed,\n    // clear the unique value index.\n    this.on(this.REMOVE_EVENT, (oid, value) => {\n      if (this.recordsFor(value).length === 0) {\n        let index = this.indexOf(value)\n\n        if (index >= 0) {\n          this.knownRecords.splice(index, 1)\n          this.uniqueValues.delete(value)\n        }\n      }\n    })\n\n    // Support BTree Indexing\n    if (this.isBTree) {\n      Object.defineProperty(this, 'BTREE', NGN.privateconst(new NGN.DATA.BTree(2, name)))\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 40,
            "column": 2
          },
          "end": {
            "line": 85,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "btree": {
              "type": "argument",
              "label": "btree",
              "description": null,
              "code": "btree = false",
              "start": {
                "line": 40,
                "column": 15
              },
              "end": {
                "line": 40,
                "column": 28
              },
              "flags": [],
              "default": false,
              "datatype": "boolean",
              "required": false,
              "enum": null
            },
            "name": {
              "type": "argument",
              "label": "name",
              "description": "Optional name for index. This is useful for debugging when multiple\nindexes exist.",
              "code": "@param {String} [name='Untitled Index']\nOptional name for index. This is useful for debugging when multiple\nindexes exist.",
              "start": {
                "line": 40,
                "column": 2
              },
              "end": {
                "line": 85,
                "column": 3
              },
              "flags": [],
              "default": "Untitled Index",
              "datatype": "string",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "add": {
          "type": "method",
          "label": "add",
          "description": "Add a field/value to the index.\n  \n  The value of the model/record indexed field.\n  \n  The record's object ID (NGN.DATA.Model#OID)",
          "code": "add (value, oid, suppressEvent = false) {\n    let valueIndex = -1\n\n    // Create or identify the index of the unique value\n    if (!this.uniqueValues.has(value)) {\n      this.uniqueValues.add(value)\n      this.knownRecords.push(new Set())\n      valueIndex += this.uniqueValues.size\n    } else {\n      valueIndex = this.indexOf(value)\n    }\n\n    this.knownRecords[valueIndex].add(oid)\n\n    // Add BTree indexing\n    if (this.isBTree) {\n      let btreeValue = value instanceof Date ? value.getTime() : value\n\n      if (this.BTREE.get(btreeValue) === undefined) {\n        this.BTREE.put(btreeValue, valueIndex)\n      }\n    }\n\n    this.emit(this.CREATE_EVENT, oid, value, suppressEvent)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 102,
            "column": 2
          },
          "end": {
            "line": 126,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": null,
              "code": "value",
              "start": {
                "line": 102,
                "column": 7
              },
              "end": {
                "line": 102,
                "column": 12
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "oid": {
              "type": "argument",
              "label": "value",
              "description": "The value of the model/record indexed field.",
              "code": "oid",
              "start": {
                "line": 102,
                "column": 14
              },
              "end": {
                "line": 102,
                "column": 17
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "suppressEvent": {
              "type": "argument",
              "label": "oid",
              "description": "The record's object ID",
              "code": "suppressEvent = false",
              "start": {
                "line": 102,
                "column": 19
              },
              "end": {
                "line": 102,
                "column": 40
              },
              "flags": [],
              "default": null,
              "datatype": "symbol",
              "required": true,
              "enum": [
                "NGN.DATA.Model#OID"
              ]
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "remove": {
          "type": "method",
          "label": "remove",
          "description": "Remove a record from the index.\n  \n  The record's object ID (NGN.DATA.Model#OID)\n  \n  When specified, the field value will be used to identify\n  the index value. Specifying this value will make the remove\n  operation faster (uses introspection).",
          "code": "remove (oid, value, suppressEvent = false) {\n    // If a value is specified, attempt to lookup the OID by value.\n    if (value !== undefined) {\n      let index = this.recordsOf(value)\n\n      // If a value index is found, remove the OID\n      if (index) {\n        if (index.delete(oid)) { // Returns false if nothing is actually deleted.\n          if (this.isBTree && (!index || index.size === 0)) {\n            this.BTREE.delete(value instanceof Date ? value.getTime() : value)\n          }\n\n          this.emit(this.REMOVE_EVENT, oid, value, suppressEvent)\n\n          return\n        }\n      }\n\n      NGN.WARN(`Index value \"${value}\" not found in index.`)\n    }\n\n    // Iterate through all index values to remove the OID (slow)\n    let removed = false\n    for (let i = 0; i < this.knownRecords.length; i++) {\n      if (this.knownRecords[i].delete(oid) && !removed) {\n        removed = true\n        value = Array.from(this.uniqueValues.values())[i]\n\n        if (this.isBTree) {\n          this.BTREE.delete(value instanceof Date ? value.getTime() : value)\n        }\n\n        break\n      }\n    }\n\n    if (removed) {\n      this.emit(this.REMOVE_EVENT, oid, value, suppressEvent)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 137,
            "column": 2
          },
          "end": {
            "line": 176,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "oid": {
              "type": "argument",
              "label": "oid",
              "description": null,
              "code": "oid",
              "start": {
                "line": 137,
                "column": 10
              },
              "end": {
                "line": 137,
                "column": 13
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "value": {
              "type": "argument",
              "label": "oid",
              "description": "The record's object ID",
              "code": "value",
              "start": {
                "line": 137,
                "column": 15
              },
              "end": {
                "line": 137,
                "column": 20
              },
              "flags": [],
              "default": null,
              "datatype": "symbol",
              "required": true,
              "enum": [
                "NGN.DATA.Model#OID"
              ]
            },
            "suppressEvent": {
              "type": "argument",
              "label": "value",
              "description": "When specified, the field value will be used to identify\nthe index value. Specifying this value will make the remove\noperation faster .",
              "code": "suppressEvent = false",
              "start": {
                "line": 137,
                "column": 22
              },
              "end": {
                "line": 137,
                "column": 43
              },
              "flags": [],
              "default": "undefined",
              "datatype": "any",
              "required": false,
              "enum": [
                "uses introspection"
              ]
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "update": {
          "type": "method",
          "label": "update",
          "description": "Update an index to reflect an updated value.",
          "code": "update (oid, oldValue, newValue, suppressEvent = false) {\n    if (oldValue !== newValue) {\n      this.remove(oid, oldValue, true)\n      this.add(newValue, oid, true)\n      this.emit(this.UPDATE_EVENT, oid, null, suppressEvent)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 185,
            "column": 2
          },
          "end": {
            "line": 191,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "oid": {
              "type": "argument",
              "label": "oid",
              "description": null,
              "code": "oid",
              "start": {
                "line": 185,
                "column": 10
              },
              "end": {
                "line": 185,
                "column": 13
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "oldValue": {
              "type": "argument",
              "label": "oid",
              "description": "[description]",
              "code": "oldValue",
              "start": {
                "line": 185,
                "column": 15
              },
              "end": {
                "line": 185,
                "column": 23
              },
              "flags": [],
              "default": null,
              "datatype": "[type]",
              "required": true,
              "enum": null
            },
            "newValue": {
              "type": "argument",
              "label": "oldvalue",
              "description": "[description]",
              "code": "newValue",
              "start": {
                "line": 185,
                "column": 25
              },
              "end": {
                "line": 185,
                "column": 33
              },
              "flags": [],
              "default": null,
              "datatype": "[type]",
              "required": true,
              "enum": null
            },
            "suppressEvent": {
              "type": "argument",
              "label": "newvalue",
              "description": "[description]",
              "code": "suppressEvent = false",
              "start": {
                "line": 185,
                "column": 35
              },
              "end": {
                "line": 185,
                "column": 56
              },
              "flags": [],
              "default": null,
              "datatype": "[type]",
              "required": true,
              "enum": null
            }
          },
          "returnType": "[type]",
          "returnDescription": "description",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "reset": {
          "type": "method",
          "label": "reset",
          "description": "Forcibly reset the index (clears everything).",
          "code": "reset () {\n    this.uniqueValues.clear()\n    this.knownRecords.splice(0)\n\n    if (this.isBTree) {\n      this.BTREE.reset()\n    }\n\n    this.emit('reset')\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 196,
            "column": 2
          },
          "end": {
            "line": 205,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "indexOf": {
          "type": "method",
          "label": "indexOf",
          "description": "Retrieve the index number of known records for the\n  specified value.\n  \n  \n  The unique value for which records are known.\n  \n  The 0-based index of known records. Returns `-1` if no\n  index exists.",
          "code": "indexOf (value) {\n    return Array.from(this.uniqueValues.keys()).indexOf(value)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 217,
            "column": 2
          },
          "end": {
            "line": 219,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": "The unique value for which records are known.",
              "code": "@param  {any} value\nThe unique value for which records are known.",
              "start": {
                "line": 217,
                "column": 2
              },
              "end": {
                "line": 219,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "[numeric]",
          "returnDescription": "null The 0-based index of known records. Returns `-1` if no\nindex exists.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "recordsOf": {
          "type": "method",
          "label": "recordsOf",
          "description": "The records of a particular value.\n  \n  \n  The index field value to use as a lookup.\n  \n  An set of object ID's or `null` if none exist.",
          "code": "recordsOf (value) {\n    let valueIndex = this.indexOf(value)\n\n    return valueIndex < 0 ? null : this.knownRecords[valueIndex]\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 229,
            "column": 2
          },
          "end": {
            "line": 233,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": "The index field value to use as a lookup.",
              "code": "@param  {any} value\nThe index field value to use as a lookup.",
              "start": {
                "line": 229,
                "column": 2
              },
              "end": {
                "line": 233,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Set",
          "returnDescription": "null An set of object ID's or `null` if none exist.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "recordsFor": {
          "type": "method",
          "label": "recordsFor",
          "description": "Get the list of records for the given value.\n  \n  The value of the index to lookup.\n  \n  The array contains OID reference values (records).",
          "code": "recordsFor (value) {\n    let index = this.recordsOf(value)\n\n    if (index === null || index.size === 0) {\n      return []\n    }\n\n    return Array.from(index.values())\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 242,
            "column": 2
          },
          "end": {
            "line": 250,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": "The value of the index to lookup.",
              "code": "@param  {any} value\nThe value of the index to lookup.",
              "start": {
                "line": 242,
                "column": 2
              },
              "end": {
                "line": 250,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "array",
          "returnDescription": "null The array contains OID reference values .",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.RangeRule": {
      "type": "class",
      "label": "NGN.DATA.RangeRule",
      "description": "A special rule to validate values within one or more ranges.\nSupports numeric ranges, date ranges, and simple string-based\nranges .",
      "code": "class NGNDataRangeValidationRule extends Rule { // eslint-disable-line\n  /**\n   * Create a new range rule.\n   * @param {string} [name]\n   * An optional name for the rule. This can be useful when debugging data issues.\n   * @param {object} [scope=null]\n   * Apply a custom scope to the validation functions (applicable to custom methods only).\n   * @param {Array} [range]\n   * An enumeration of acceptable numeric ranges. For example, if\n   * the value must be between 5-10 or from 25-50, the configuration\n   * would look like:\n   *\n   * ```js\n   * range: [\n   *   [5, 10],\n   *   ['25-50']\n   * ]\n   * ```\n   *\n   * To accept anything below a certain number or anything over a certain\n   * number while also specifying one or more ranges, use a `null` value.\n   *\n   * For example:\n   *\n   * ```js\n   * range: [\n   *   [null, 0],\n   *   [5, 10],\n   *   ['25-50'],\n   *   [100, null]\n   * ]\n   * ```\n   *\n   * The aforementioned example would accept a value less than `zero`,\n   * between `5` and `10`, between `25` and `50`, or over `100`. Therefore,\n   * acceptable values could be `-7`, `7`, `25`, `42`,  `10000`, or anything\n   * else within the ranges. However, the values `3`, `19`, and `62` would\n   * all fail because they're outside the ranges.\n   */\n  constructor (name, scope, range = []) {\n    if (NGN.typeof(scope) === 'array') {\n      range = scope\n      scope = null\n    }\n\n    super(null, name, scope)\n\n    this.RULE.prepareRange = function (value) {\n      // If a simple range is specified (single array), format it for the rule processor.\n      value = NGN.forceArray(value)\n\n      if (NGN.typeof(value[0]) !== 'array') {\n        value = [value]\n      }\n\n      for (let i = 0; i < value.length; i++) {\n        if (value[i].length !== 2) {\n          if (NGN.typeof(value[i][0]) !== 'string') {\n            throw new Error(`Invalid range: \"${value[i].toString()}\"`)\n          }\n\n          value[i] = value[i][0].replace(/[^0-9->]/gi, '').split(/->{1,100}/)\n        }\n\n        if (NGN.typeof(value[i][0]) !== 'number') {\n          value[i][0] = NGN.coalesce(value[i][0], '').replace(/null|none|any/gi, '')\n        }\n\n        if (NGN.typeof(value[i][1]) !== 'number') {\n          value[i][1] = NGN.coalesce(value[i][1], '').replace(/null|none|any/gi, '')\n        }\n      }\n\n      return value\n    }\n\n    // Initialize the range\n    this.RULE.range = new Set()\n    this.range = range\n\n    // Create the validation function.\n    this.RULE.validator = (value) => {\n      let isString = NGN.typeof(value) === 'string'\n      let range = this.range\n\n      for (let i = 0; i < range.length; i++) {\n        let min = NGN.coalesceb(range[i][0], isString ? value.length : value)\n        let max = NGN.coalesceb(range[i][1], isString ? value.length : value)\n\n        if (\n          (isString && value.length >= min && value.length <= max) ||\n          (!isString && value >= min && value <= max)\n        ) {\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n\n  get range () {\n    return Array.from(this.RULE.range.values())\n  }\n\n  set range (value) {\n    this.RULE.range = new Set()\n    this.addRange(value)\n  }\n\n  /**\n   * Add a range to the rule.\n   * @param {array} value\n   * A range can be a single array, such as `[min, max]`. An array of arrays is\n   * also acceptable, such as `[[min1, max1], [min2, max2]]`.\n   */\n  addRange (value) {\n    value = this.RULE.prepareRange(value)\n\n    for (let i = 0; i < value.length; i++) {\n      if (NGN.coalesceb(value[i][0]) !== null && NGN.coalesceb(value[i][1]) !== null && value[i][1] < value[i][0]) {\n        throw new Error(`Invalid value \"${value[i][0].toString()} -> ${value[i][1].toString()}\". Minimum value cannot exceed maximum.`)\n      }\n\n      this.RULE.range.add(value[i])\n    }\n  }\n\n  /**\n   * Remove an existing range from the rule.\n   * @param {array} value\n   * A range can be a single array, such as `[min, max]`. An array of arrays is\n   * also acceptable, such as `[[min1, max1], [min2, max2]]`.\n   */\n  removeRange (value) {\n    let range = this.range\n    value = this.RULE.prepareRange(value)\n\n    for (let i = 0; i < value.length; i++) {\n      for (let x = 0; x < range.length; x++) {\n        if (value[i].toString() === range[x].toString()) {\n          this.RULE.range.delete(range[x])\n        }\n      }\n    }\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 9,
        "column": 15
      },
      "end": {
        "line": 155,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/rule/RangeRule.js",
      "extends": "Rule",
      "configuration": {},
      "properties": {
        "prepareRange": {
          "type": "property",
          "label": "prepareRange",
          "description": null,
          "code": "this.RULE.prepareRange = function (value) {\n      // If a simple range is specified (single array), format it for the rule processor.\n      value = NGN.forceArray(value)\n\n      if (NGN.typeof(value[0]) !== 'array') {\n        value = [value]\n      }\n\n      for (let i = 0; i < value.length; i++) {\n        if (value[i].length !== 2) {\n          if (NGN.typeof(value[i][0]) !== 'string') {\n            throw new Error(`Invalid range: \"${value[i].toString()}\"`)\n          }\n\n          value[i] = value[i][0].replace(/[^0-9->]/gi, '').split(/->{1,100}/)\n        }\n\n        if (NGN.typeof(value[i][0]) !== 'number') {\n          value[i][0] = NGN.coalesce(value[i][0], '').replace(/null|none|any/gi, '')\n        }\n\n        if (NGN.typeof(value[i][1]) !== 'number') {\n          value[i][1] = NGN.coalesce(value[i][1], '').replace(/null|none|any/gi, '')\n        }\n      }\n\n      return value\n    }",
          "start": {
            "line": 56,
            "column": 14
          },
          "end": {
            "line": 56,
            "column": 26
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "range": {
          "type": "property",
          "label": "range",
          "description": null,
          "code": "set range (value) {\n    this.RULE.range = new Set()\n    this.addRange(value)\n  }",
          "start": {
            "line": 114,
            "column": 2
          },
          "end": {
            "line": 117,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "validator": {
          "type": "property",
          "label": "validator",
          "description": null,
          "code": "this.RULE.validator = (value) => {\n      let isString = NGN.typeof(value) === 'string'\n      let range = this.range\n\n      for (let i = 0; i < range.length; i++) {\n        let min = NGN.coalesceb(range[i][0], isString ? value.length : value)\n        let max = NGN.coalesceb(range[i][1], isString ? value.length : value)\n\n        if (\n          (isString && value.length >= min && value.length <= max) ||\n          (!isString && value >= min && value <= max)\n        ) {\n          return true\n        }\n      }\n\n      return false\n    }",
          "start": {
            "line": 90,
            "column": 14
          },
          "end": {
            "line": 90,
            "column": 23
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "Create a new range rule.\n  \n  An optional name for the rule. This can be useful when debugging data issues.\n  \n  Apply a custom scope to the validation functions (applicable to custom methods only).\n  \n  An enumeration of acceptable numeric ranges. For example, if\n  the value must be between 5-10 or from 25-50, the configuration\n  would look like:\n    ```js\n  range: [\n    [5, 10],\n    ['25-50']\n  ]\n  ```\n    To accept anything below a certain number or anything over a certain\n  number while also specifying one or more ranges, use a `null` value.\n    For example:\n    ```js\n  range: [\n    [null, 0],\n    [5, 10],\n    ['25-50'],\n    [100, null]\n  ]\n  ```\n    The aforementioned example would accept a value less than `zero`,\n  between `5` and `10`, between `25` and `50`, or over `100`. Therefore,\n  acceptable values could be `-7`, `7`, `25`, `42`,  `10000`, or anything\n  else within the ranges. However, the values `3`, `19`, and `62` would\n  all fail because they're outside the ranges.",
          "code": "constructor (name, scope, range = []) {\n    if (NGN.typeof(scope) === 'array') {\n      range = scope\n      scope = null\n    }\n\n    super(null, name, scope)\n\n    this.RULE.prepareRange = function (value) {\n      // If a simple range is specified (single array), format it for the rule processor.\n      value = NGN.forceArray(value)\n\n      if (NGN.typeof(value[0]) !== 'array') {\n        value = [value]\n      }\n\n      for (let i = 0; i < value.length; i++) {\n        if (value[i].length !== 2) {\n          if (NGN.typeof(value[i][0]) !== 'string') {\n            throw new Error(`Invalid range: \"${value[i].toString()}\"`)\n          }\n\n          value[i] = value[i][0].replace(/[^0-9->]/gi, '').split(/->{1,100}/)\n        }\n\n        if (NGN.typeof(value[i][0]) !== 'number') {\n          value[i][0] = NGN.coalesce(value[i][0], '').replace(/null|none|any/gi, '')\n        }\n\n        if (NGN.typeof(value[i][1]) !== 'number') {\n          value[i][1] = NGN.coalesce(value[i][1], '').replace(/null|none|any/gi, '')\n        }\n      }\n\n      return value\n    }\n\n    // Initialize the range\n    this.RULE.range = new Set()\n    this.range = range\n\n    // Create the validation function.\n    this.RULE.validator = (value) => {\n      let isString = NGN.typeof(value) === 'string'\n      let range = this.range\n\n      for (let i = 0; i < range.length; i++) {\n        let min = NGN.coalesceb(range[i][0], isString ? value.length : value)\n        let max = NGN.coalesceb(range[i][1], isString ? value.length : value)\n\n        if (\n          (isString && value.length >= min && value.length <= max) ||\n          (!isString && value >= min && value <= max)\n        ) {\n          return true\n        }\n      }\n\n      return false\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 48,
            "column": 2
          },
          "end": {
            "line": 108,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "name": {
              "type": "argument",
              "label": "name",
              "description": null,
              "code": "name",
              "start": {
                "line": 48,
                "column": 15
              },
              "end": {
                "line": 48,
                "column": 19
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "scope": {
              "type": "argument",
              "label": "name",
              "description": "An optional name for the rule. This can be useful when debugging data issues.",
              "code": "scope",
              "start": {
                "line": 48,
                "column": 21
              },
              "end": {
                "line": 48,
                "column": 26
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": false,
              "enum": null
            },
            "range": {
              "type": "argument",
              "label": "range",
              "description": "An enumeration of acceptable numeric ranges. For example, if\nthe value must be between 5-10 or from 25-50, the configuration\nwould look like:\n\n```js\nrange: [\n[5, 10],\n['25-50']\n]\n```\n\nTo accept anything below a certain number or anything over a certain\nnumber while also specifying one or more ranges, use a `null` value.\n\nFor example:\n\n```js\nrange: [\n[null, 0],\n[5, 10],\n['25-50'],\n[100, null]\n]\n```\n\nThe aforementioned example would accept a value less than `zero`,\nbetween `5` and `10`, between `25` and `50`, or over `100`. Therefore,\nacceptable values could be `-7`, `7`, `25`, `42`,  `10000`, or anything\nelse within the ranges. However, the values `3`, `19`, and `62` would\nall fail because they're outside the ranges.",
              "code": "@param {Array} [range]\nAn enumeration of acceptable numeric ranges. For example, if\nthe value must be between 5-10 or from 25-50, the configuration\nwould look like:\n\n```js\nrange: [\n[5, 10],\n['25-50']\n]\n```\n\nTo accept anything below a certain number or anything over a certain\nnumber while also specifying one or more ranges, use a `null` value.\n\nFor example:\n\n```js\nrange: [\n[null, 0],\n[5, 10],\n['25-50'],\n[100, null]\n]\n```\n\nThe aforementioned example would accept a value less than `zero`,\nbetween `5` and `10`, between `25` and `50`, or over `100`. Therefore,\nacceptable values could be `-7`, `7`, `25`, `42`,  `10000`, or anything\nelse within the ranges. However, the values `3`, `19`, and `62` would\nall fail because they're outside the ranges.",
              "start": {
                "line": 48,
                "column": 2
              },
              "end": {
                "line": 108,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "array",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "addRange": {
          "type": "method",
          "label": "addRange",
          "description": "Add a range to the rule.\n  \n  A range can be a single array, such as `[min, max]`. An array of arrays is\n  also acceptable, such as `[[min1, max1], [min2, max2]]`.",
          "code": "addRange (value) {\n    value = this.RULE.prepareRange(value)\n\n    for (let i = 0; i < value.length; i++) {\n      if (NGN.coalesceb(value[i][0]) !== null && NGN.coalesceb(value[i][1]) !== null && value[i][1] < value[i][0]) {\n        throw new Error(`Invalid value \"${value[i][0].toString()} -> ${value[i][1].toString()}\". Minimum value cannot exceed maximum.`)\n      }\n\n      this.RULE.range.add(value[i])\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 125,
            "column": 2
          },
          "end": {
            "line": 135,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": "A range can be a single array, such as `[min, max]`. An array of arrays is\nalso acceptable, such as `[[min1, max1], [min2, max2]]`.",
              "code": "@param {array} value\nA range can be a single array, such as `[min, max]`. An array of arrays is\nalso acceptable, such as `[[min1, max1], [min2, max2]]`.",
              "start": {
                "line": 125,
                "column": 2
              },
              "end": {
                "line": 135,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "array",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeRange": {
          "type": "method",
          "label": "removeRange",
          "description": "Remove an existing range from the rule.\n  \n  A range can be a single array, such as `[min, max]`. An array of arrays is\n  also acceptable, such as `[[min1, max1], [min2, max2]]`.",
          "code": "removeRange (value) {\n    let range = this.range\n    value = this.RULE.prepareRange(value)\n\n    for (let i = 0; i < value.length; i++) {\n      for (let x = 0; x < range.length; x++) {\n        if (value[i].toString() === range[x].toString()) {\n          this.RULE.range.delete(range[x])\n        }\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 143,
            "column": 2
          },
          "end": {
            "line": 154,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": "A range can be a single array, such as `[min, max]`. An array of arrays is\nalso acceptable, such as `[[min1, max1], [min2, max2]]`.",
              "code": "@param {array} value\nA range can be a single array, such as `[min, max]`. An array of arrays is\nalso acceptable, such as `[[min1, max1], [min2, max2]]`.",
              "start": {
                "line": 143,
                "column": 2
              },
              "end": {
                "line": 154,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "array",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.Rule": {
      "type": "class",
      "label": "NGN.DATA.Rule",
      "description": "A data validation rule.",
      "code": "class NGNDataValidationRule { // eslint-disable-line\n  /**\n   * Create a new data rule.\n   * @param {Function/String[]/Number[]/Date[]/RegExp/Array} rule\n   * * When rule is a _function_, the value is passed to it as an argument.\n   * * When rule is a _String_, the value is compared for an exact match (case sensitive)\n   * * When rule is a _Number_, the value is compared for equality.\n   * * When rule is a _Date_, the value is compared for exact equality.\n   * * When rule is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n   * * When rule is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n   * * When rule is _an array of dates_, the value is compared to each date for equality.\n   * @param {string} [name]\n   * An optional name for the rule. This can be useful when debugging data issues.\n   * @param {object} [scope]\n   * Aplpy a custom scope to the validation functions (applicable to custom methods only).\n   */\n  constructor (validation, name = null, scope = null) {\n    const type = NGN.typeof(validation)\n\n    Object.defineProperties(this, {\n      RULE: NGN.private({\n        type: type,\n        validator: validation,\n        name: NGN.coalesce(name, `Untitled ${type.toUpperCase()} Validation`),\n        scope: NGN.coalesce(scope, this)\n      })\n    })\n  }\n\n  get name () {\n    return this.RULE.name\n  }\n\n  get type () {\n    return this.RULE.type\n  }\n\n  /**\n   * @method test\n   * Test a value against the validation rule.\n   * @param {any} value\n   * The value to test.\n   * @returns {boolean}\n   * Returns `true` when the value meets the rule expectations and `false` when it does not.\n   */\n  test (value) {\n    if (NGN.isFn(this.RULE.validator)) {\n      // Custom enforcement function\n      return this.RULE.validator.apply(this.RULE.scope, [value])\n    } else {\n      switch (this.type) {\n        // Enumeration\n        case 'array':\n          return this.RULE.validator.indexOf(value) !== -1\n\n        // Pattern Matching\n        case 'regexp':\n          return this.RULE.validator.test(value)\n\n        default:\n          return this.RULE.validator === value\n      }\n    }\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 10,
        "column": 15
      },
      "end": {
        "line": 74,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/rule/Rule.js",
      "extends": null,
      "configuration": {},
      "properties": {
        "RULE": {
          "type": "property",
          "label": "RULE",
          "description": null,
          "code": "RULE: NGN.private({\n        type: type,\n        validator: validation,\n        name: NGN.coalesce(name, `Untitled ${type.toUpperCase()} Validation`),\n        scope: NGN.coalesce(scope, this)\n      })",
          "start": {
            "line": 30,
            "column": 6
          },
          "end": {
            "line": 35,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "name": {
          "type": "property",
          "label": "name",
          "description": null,
          "code": "get name () {\n    return this.RULE.name\n  }",
          "start": {
            "line": 39,
            "column": 2
          },
          "end": {
            "line": 41,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "type": {
          "type": "property",
          "label": "type",
          "description": null,
          "code": "get type () {\n    return this.RULE.type\n  }",
          "start": {
            "line": 43,
            "column": 2
          },
          "end": {
            "line": 45,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "Create a new data rule.\n  \n  When rule is a _function_, the value is passed to it as an argument.\n  When rule is a _String_, the value is compared for an exact match (case sensitive)\n  When rule is a _Number_, the value is compared for equality.\n  When rule is a _Date_, the value is compared for exact equality.\n  When rule is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n  When rule is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n  When rule is _an array of dates_, the value is compared to each date for equality.\n  \n  An optional name for the rule. This can be useful when debugging data issues.\n  \n  Aplpy a custom scope to the validation functions (applicable to custom methods only).",
          "code": "constructor (validation, name = null, scope = null) {\n    const type = NGN.typeof(validation)\n\n    Object.defineProperties(this, {\n      RULE: NGN.private({\n        type: type,\n        validator: validation,\n        name: NGN.coalesce(name, `Untitled ${type.toUpperCase()} Validation`),\n        scope: NGN.coalesce(scope, this)\n      })\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 26,
            "column": 2
          },
          "end": {
            "line": 37,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "validation": {
              "type": "argument",
              "label": "validation",
              "description": null,
              "code": "validation",
              "start": {
                "line": 26,
                "column": 15
              },
              "end": {
                "line": 26,
                "column": 25
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "name": {
              "type": "argument",
              "label": "rule",
              "description": "* When rule is a _function_, the value is passed to it as an argument.\n* When rule is a _String_, the value is compared for an exact match \n* When rule is a _Number_, the value is compared for equality.\n* When rule is a _Date_, the value is compared for exact equality.\n* When rule is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n* When rule is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n* When rule is _an array of dates_, the value is compared to each date for equality.",
              "code": "name = null",
              "start": {
                "line": 26,
                "column": 27
              },
              "end": {
                "line": 26,
                "column": 38
              },
              "flags": [],
              "default": null,
              "datatype": "function/string[]/number[]/date[]/regexp/array",
              "required": true,
              "enum": [
                "case sensitive"
              ]
            },
            "scope": {
              "type": "argument",
              "label": "scope",
              "description": "Aplpy a custom scope to the validation functions .",
              "code": "@param {object} [scope]\nAplpy a custom scope to the validation functions (applicable to custom methods only).",
              "start": {
                "line": 26,
                "column": 2
              },
              "end": {
                "line": 37,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "object",
              "required": false,
              "enum": [
                "applicable to custom methods only"
              ]
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "test": {
          "type": "method",
          "label": "test",
          "description": "Test a value against the validation rule.",
          "code": "test (value) {\n    if (NGN.isFn(this.RULE.validator)) {\n      // Custom enforcement function\n      return this.RULE.validator.apply(this.RULE.scope, [value])\n    } else {\n      switch (this.type) {\n        // Enumeration\n        case 'array':\n          return this.RULE.validator.indexOf(value) !== -1\n\n        // Pattern Matching\n        case 'regexp':\n          return this.RULE.validator.test(value)\n\n        default:\n          return this.RULE.validator === value\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 55,
            "column": 2
          },
          "end": {
            "line": 73,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": "The value to test.",
              "code": "@param {any} value\nThe value to test.",
              "start": {
                "line": 55,
                "column": 2
              },
              "end": {
                "line": 73,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "boolean",
          "returnDescription": "null Returns `true` when the value meets the rule expectations and `false` when it does not.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.DATA.JSONSchema": {
      "type": "class",
      "label": "NGN.DATA.JSONSchema",
      "description": "Retrieve all of the NGN.DATA.Model defitions that can be interpreted\n        from this schema.\n        \n        \n        \n        The schema object.\n        \n        An array of known models. This method is used recursively, so this\n        argument exists primarily for internal use.\n        \n        Executed when all models have been detected.",
      "code": "class NGNJSONSchema extends EventEmitter { // eslint-disable-line no-unused-vars\n  /**\n   * Create a new JSON schema reference.\n   * @param  {Object|String} [schema={}]\n   * The schema to parse. This can be the JSON schema object itself or the URL\n   * of a remote JSON schema.\n   * @param  {NGN.NET.Resource} [NetworkResource]\n   * Specify a custom network resource to make the request for a remote schema.\n   */\n  constructor (schema = {}, NetworkResource = null) {\n    super()\n\n    Object.defineProperties(this, {\n      METADATA: NGN.private({\n        schema,\n        ID: null,\n        name: null\n      }),\n\n      PRIVATE: NGN.privateconst({\n        MODELS: null,\n        NET: NGN.coalesce(NetworkResource, NGN.NET),\n\n        parsed: false,\n\n        /**\n         * @method PRIVATE.extractCommonPropertyAttributes\n         * @param  {object} property\n         * Schema metadata object.\n         * @param {array} [models=[]]\n         * The list of known models. This is passed in because nested objects\n         * may exist within a property. NGN identifies these as nested models,\n         * even though the JSON schema does not force these to be separate\n         * schemas.\n         * @return {Object}\n         * Returns a clean \"NGN-ready\" field object of common properties.\n         */\n        extractCommonPropertyAttributes: (property, models = []) => {\n          let field = {}\n\n          // Add pattern\n          if (property.pattern) {\n            field.pattern = property.pattern\n          }\n\n          // Add description\n          if (property.description) {\n            field.description = property.description\n          }\n\n          // Add default\n          if (property.default) {\n            field.default = property.default\n          }\n\n          if (!property.$ref) {\n            if (!property.type) {\n              field.type = String\n            } else {\n              let type = NGN.typeof(property.type) === 'array' ? 'array' : property.type.trim().toLowerCase()\n\n              switch (type) {\n                case 'string':\n                  let format = NGN.coalesce(property.format, 'unknown').trim().toLowerCase()\n\n                  field.type = String\n\n                  switch (format) {\n                    case 'date':\n                    case 'date-time':\n                    case 'datetime':\n                    case 'format-time':\n                      field.type = Date\n                      break\n\n                    case 'ipv4':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\n                      )\n\n                      break\n\n                    case 'ipv6':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\n                      )\n\n                      break\n\n                    case 'email':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\\b$/\n                      )\n\n                      break\n\n                    case 'hostname':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)+(\\.([a-zA-Z0-9]+(-[a-zA-Z0-9ââ]+)*))*$/ // eslint-disable-line no-irregular-whitespace\n                      )\n\n                      break\n\n                    case 'uri':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]\\.[^\\s]{2,})/\n                      )\n\n                      break\n                  }\n\n                  break\n\n                case 'integer':\n                  field.type = Number\n                  field.pattern = /^\\d+$/\n                  break\n\n                case 'number':\n                  field.type = Number\n                  break\n\n                case 'object':\n                  if (property.properties) {\n                    let subschema = new NGN.DATA.JSONSchema(property)\n\n                    subschema.name = `${NGN.coalesce(this.name, 'untitled')}_${NGN.coalesce(subschema.name, 'submodel')}${models.length + 1}`\n\n                    subschema.getModelDefinitions(definitions => {\n                      definitions[definitions.length - 1].name = subschema.name\n                      models = definitions.concat(models)\n                    })\n\n                    field = {\n                      $model: subschema.name\n                    }\n                  } else {\n                    field.type = Object\n                  }\n\n                  break\n\n                default:\n                  field.type = String\n                  break\n              }\n            }\n          }\n\n          // String validation options\n          if (field.type === String || field.type === Number) {\n            if (NGN.coalesce(property.minLength, property.minimum)) {\n              field.min = NGN.coalesce(property.minLength, property.minimum)\n            }\n\n            if (NGN.coalesce(property.maxLength, property.maximum)) {\n              field.max = NGN.coalesce(property.maxLength, property.maximum)\n            }\n\n            // Numeric-specific validations\n            if (property.type === Number) {\n              if (property.multipleOf) {\n                field.multipleOf = property.multipleOf\n              }\n\n              if (property.exclusiveMinimum) {\n                field.min = (property.exclusiveMinimum + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\n              }\n\n              if (property.exclusiveMaximum) {\n                field.max = (property.exclusiveMaximum - 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\n              }\n            }\n          }\n\n          // Array validation options\n          if (field.type === Array) {\n            // Support minimum array length\n            if (property.hasOwnProperty('minItems')) {\n              field.min = property.minItems\n            }\n\n            // Support maximum array length\n            if (property.hasOwnProperty('maxItems')) {\n              field.max = property.maxItems\n            }\n\n            if (property.hasOwnProperty('items')) {\n              if (NGN.typeof(property.items) === 'array') {\n                // Apply tuple validation\n                field.tuples = property.items\n              } else {\n                // Apply list validation\n                if (property.items.hasOwnProperty('type')) {\n                  field.listType = NGN.getType(property.items.type)\n                }\n\n                if (property.items.hasOwnProperty('enum')) {\n                  field.enum = property.items.enum\n                }\n              }\n            }\n          }\n\n          return field\n        },\n\n        /**\n         * @method PRIVATE.extractModelDefinitions\n         * Retrieve all of the NGN.DATA.Model defitions that can be interpreted\n         * from this schema.\n         * @protected\n         * @private\n         * @param  {Object} data\n         * The schema object.\n         * @param  {Array} [models=[]]\n         * An array of known models. This method is used recursively, so this\n         * argument exists primarily for internal use.\n         * @param  {Function} callback\n         * Executed when all models have been detected.\n         */\n        extractModelDefinitions: (data, models = [], callback) => {\n          if (NGN.isFn(models)) {\n            callback = models\n            models = []\n          }\n\n          if (data.type === 'object') {\n            let name = NGN.coalesce(data.name, this.name, 'Untitled')\n\n            if (data.hasOwnProperty('$schema') && name === null && this.METADATA.URL) {\n              name = this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', '')\n            }\n\n            // Configure the basic model\n            let model = {\n              name,\n              description: NGN.coalesce(data.description, 'No description.'),\n              fields: {}\n            }\n\n            // Flag the ID for the schema\n            if (data.hasOwnProperty('$schema')) {\n              this.METADATA.ID = NGN.coalesce(data.$id, data.$schema)\n            }\n\n            // Queue the tasks since several are async but sequential\n            let tasks = new NGN.Tasks()\n\n            // If the allOf attribute exists, the schema is extending another.\n            // Extract the subschema before continuing.\n            if (data.hasOwnProperty('allOf')) {\n              for (let i = 0; i < data.allOf.length; i++) {\n                tasks.add(`Identify base schema: ${data.allOf}`, cont => {\n                  let URI = NGN.coalesce(data.allOf[i].$ref, data.allOf[i].$schema)\n\n                  if (URI !== null) {\n                    // When a URI is specified, retrieve the remote schema\n                    let baseSchema = new NGN.DATA.JSONSchema(URI)\n\n                    baseSchema.getModelDefinitions(definitions => {\n                      let coreModel = definitions.pop()\n\n                      Object.assign(model.fields, coreModel.fields)\n\n                      // If the nested schema has additional models, apply them.\n                      if (definitions.length > 0) {\n                        models = definitions.concat(models)\n                      }\n\n                      this.METADATA.name = NGN.coalesce(this.METADATA.name, coreModel.name)\n\n                      cont()\n                    })\n                  } else if (data.allOf[i].hasOwnProperty('properties')) {\n                    // Handle additional properties\n                    let additionalProperties = Object.keys(data.allOf[i].properties)\n\n                    for (let prop = 0; prop < additionalProperties.length; prop++) {\n                      model.fields[additionalProperties[prop]] = this.extractCommonPropertyAttributes(data.allOf[i].properties[additionalProperties[prop]])\n                    }\n\n                    cont()\n                  }\n                })\n              }\n            }\n\n            tasks.add('Identify attributes', cont => {\n              // If the schema specifies dependencies, it is specifying a set of\n              // rules requiring the existance and non-empty value of additional\n              // fields. Create NGN.DATA.Rule sets to support this.\n              if (data.hasOwnProperty('dependencies')) {\n                Object.keys(data.dependencies).forEach(dependency => {\n                  let requiredFields = null\n                  let dep = data.dependencies[dependency]\n\n                  if (NGN.typeof(dep) === 'array') {\n                    // Simple property dependencies\n                    requiredFields = dep\n                  } else if (dep.hasOwnProperty('required')) {\n                    // Schema dependencies\n                    requiredFields = dep.required\n                  }\n\n                  // Add all valid dependencies as rules\n                  if (requiredFields !== null) {\n                    model.rules[`${dependency} dependency on \"${requiredFields.join(', ')}\"`] = function () {\n                      if (NGN.coalesce(this[dependency]) !== null) {\n                        for (let i = 0; i < requiredFields.length; i++) {\n                          if (NGN.coalesce(this[requiredFields[i]]) === null) {\n                            return false\n                          }\n                        }\n                      }\n\n                      return true\n                    }\n                  }\n                })\n              }\n\n              // Identify the fields\n              let properties = Object.keys(data.properties)\n              let subtasks = new NGN.Tasks()\n\n              if (properties.length > 0) {\n                for (let i = 0; i < properties.length; i++) {\n                  let propertyName = properties[i]\n                  let property = data.properties[propertyName]\n\n                  model.fields[propertyName] = this.PRIVATE.extractCommonPropertyAttributes(property, models)\n\n                  // If this is a subschema, retrieve it.\n                  if (property.$ref) {\n                    subtasks.add(next => {\n                      let nestedModel = new NGN.DATA.JSONSchema(property.$ref)\n\n                      nestedModel.getModelDefinitions(definitions => {\n                        models = definitions.concat(models)\n\n                        model.fields[propertyName] = {\n                          $model: definitions[definitions.length - 1].name\n                        }\n\n                        next()\n                      })\n                    })\n                  }\n\n                  model.fields[propertyName].required = NGN.coalesce(data.required, '').indexOf(propertyName) >= 0\n                }\n              }\n\n              subtasks.on('complete', () => {\n                models.push(model)\n                cont()\n              })\n\n              subtasks.run(true)\n            })\n\n            tasks.on('complete', () => callback(models))\n            tasks.run(true)\n          } else {\n            callback(models)\n          }\n        }\n      })\n    })\n\n    this.once('parsed', () => {\n      this.PRIVATE.parsed = true\n      this.METADATA.ID = NGN.coalesce(this.METADATA.schema.id, this.METADATA.schema.$schema)\n    })\n\n    // Initialize\n    switch (NGN.typeof(schema)) {\n      case 'string':\n        // If schema is actually a URL, retrieve it.\n        this.METADATA.URL = schema\n        this.PRIVATE.NET.json(schema, (err, schema) => {\n          if (err) {\n            throw err\n          }\n\n          this.METADATA.schema = schema\n          this.METADATA.name = NGN.coalesce(schema.name, this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', ''))\n\n          this.emit('parsed')\n        })\n\n        break\n\n      case 'object':\n        this.METADATA.name = NGN.coalesce(schema.name, 'Untitled')\n        this.emit('parsed')\n        break\n\n      default:\n        throw new Error('Invalid schema definition.')\n    }\n  }\n\n  get id () {\n    if (this.METADATA.ID) {\n      return this.METADATA.ID\n    }\n\n    let id = NGN.coalesce(this.METADATA.URL)\n\n    if (id !== null) {\n      return id\n    }\n\n    let root\n    /* node-only */\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, `http://${require('os').hostname()}`)\n    /* end-node-only */\n    /* browser-only */\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, window.location.origin)\n    /* end-browser-only */\n\n    this.METADATA.ID = this.PRIVATE.NET.normalizeUrl(`${root}/${NGN.coalesce(this.name, 'untitled').toLowerCase()}.json`)\n\n    return this.METADATA.ID\n  }\n\n  get name () {\n    return this.METADATA.name\n  }\n\n  set name (value) {\n    this.METADATA.name = NGN.coalesce(value, 'Untitled')\n  }\n\n  getModelDefinitions (callback) {\n    if (!this.PRIVATE.parsed) {\n      this.once('parsed', () => {\n        this.getModelDefinitions(callback)\n      })\n    } else if (!this.PRIVATE.MODELS) {\n      this.PRIVATE.extractModelDefinitions(this.METADATA.schema, [], definitions => {\n        this.PRIVATE.MODELS = definitions\n        callback(definitions)\n      })\n    } else {\n      callback(this.PRIVATE.MODELS)\n    }\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "parsed": {
          "type": "event",
          "label": "parsed",
          "description": null,
          "code": "this.emit('parsed')",
          "start": {
            "line": 410,
            "column": 8
          },
          "end": {
            "line": 410,
            "column": 27
          },
          "flags": [],
          "parameters": {},
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 9,
        "column": 15
      },
      "end": {
        "line": 464,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./data/schema/JSON.js",
      "extends": "EventEmitter",
      "configuration": {},
      "properties": {
        "METADATA": {
          "type": "property",
          "label": "METADATA",
          "description": null,
          "code": "METADATA: NGN.private({\n        schema,\n        ID: null,\n        name: null\n      })",
          "start": {
            "line": 22,
            "column": 6
          },
          "end": {
            "line": 26,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "PRIVATE": {
          "type": "property",
          "label": "PRIVATE",
          "description": null,
          "code": "PRIVATE: NGN.privateconst({\n        MODELS: null,\n        NET: NGN.coalesce(NetworkResource, NGN.NET),\n\n        parsed: false,\n\n        /**\n         * @method PRIVATE.extractCommonPropertyAttributes\n         * @param  {object} property\n         * Schema metadata object.\n         * @param {array} [models=[]]\n         * The list of known models. This is passed in because nested objects\n         * may exist within a property. NGN identifies these as nested models,\n         * even though the JSON schema does not force these to be separate\n         * schemas.\n         * @return {Object}\n         * Returns a clean \"NGN-ready\" field object of common properties.\n         */\n        extractCommonPropertyAttributes: (property, models = []) => {\n          let field = {}\n\n          // Add pattern\n          if (property.pattern) {\n            field.pattern = property.pattern\n          }\n\n          // Add description\n          if (property.description) {\n            field.description = property.description\n          }\n\n          // Add default\n          if (property.default) {\n            field.default = property.default\n          }\n\n          if (!property.$ref) {\n            if (!property.type) {\n              field.type = String\n            } else {\n              let type = NGN.typeof(property.type) === 'array' ? 'array' : property.type.trim().toLowerCase()\n\n              switch (type) {\n                case 'string':\n                  let format = NGN.coalesce(property.format, 'unknown').trim().toLowerCase()\n\n                  field.type = String\n\n                  switch (format) {\n                    case 'date':\n                    case 'date-time':\n                    case 'datetime':\n                    case 'format-time':\n                      field.type = Date\n                      break\n\n                    case 'ipv4':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\n                      )\n\n                      break\n\n                    case 'ipv6':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\n                      )\n\n                      break\n\n                    case 'email':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\\b$/\n                      )\n\n                      break\n\n                    case 'hostname':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)+(\\.([a-zA-Z0-9]+(-[a-zA-Z0-9ââ]+)*))*$/ // eslint-disable-line no-irregular-whitespace\n                      )\n\n                      break\n\n                    case 'uri':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]\\.[^\\s]{2,})/\n                      )\n\n                      break\n                  }\n\n                  break\n\n                case 'integer':\n                  field.type = Number\n                  field.pattern = /^\\d+$/\n                  break\n\n                case 'number':\n                  field.type = Number\n                  break\n\n                case 'object':\n                  if (property.properties) {\n                    let subschema = new NGN.DATA.JSONSchema(property)\n\n                    subschema.name = `${NGN.coalesce(this.name, 'untitled')}_${NGN.coalesce(subschema.name, 'submodel')}${models.length + 1}`\n\n                    subschema.getModelDefinitions(definitions => {\n                      definitions[definitions.length - 1].name = subschema.name\n                      models = definitions.concat(models)\n                    })\n\n                    field = {\n                      $model: subschema.name\n                    }\n                  } else {\n                    field.type = Object\n                  }\n\n                  break\n\n                default:\n                  field.type = String\n                  break\n              }\n            }\n          }\n\n          // String validation options\n          if (field.type === String || field.type === Number) {\n            if (NGN.coalesce(property.minLength, property.minimum)) {\n              field.min = NGN.coalesce(property.minLength, property.minimum)\n            }\n\n            if (NGN.coalesce(property.maxLength, property.maximum)) {\n              field.max = NGN.coalesce(property.maxLength, property.maximum)\n            }\n\n            // Numeric-specific validations\n            if (property.type === Number) {\n              if (property.multipleOf) {\n                field.multipleOf = property.multipleOf\n              }\n\n              if (property.exclusiveMinimum) {\n                field.min = (property.exclusiveMinimum + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\n              }\n\n              if (property.exclusiveMaximum) {\n                field.max = (property.exclusiveMaximum - 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\n              }\n            }\n          }\n\n          // Array validation options\n          if (field.type === Array) {\n            // Support minimum array length\n            if (property.hasOwnProperty('minItems')) {\n              field.min = property.minItems\n            }\n\n            // Support maximum array length\n            if (property.hasOwnProperty('maxItems')) {\n              field.max = property.maxItems\n            }\n\n            if (property.hasOwnProperty('items')) {\n              if (NGN.typeof(property.items) === 'array') {\n                // Apply tuple validation\n                field.tuples = property.items\n              } else {\n                // Apply list validation\n                if (property.items.hasOwnProperty('type')) {\n                  field.listType = NGN.getType(property.items.type)\n                }\n\n                if (property.items.hasOwnProperty('enum')) {\n                  field.enum = property.items.enum\n                }\n              }\n            }\n          }\n\n          return field\n        },\n\n        /**\n         * @method PRIVATE.extractModelDefinitions\n         * Retrieve all of the NGN.DATA.Model defitions that can be interpreted\n         * from this schema.\n         * @protected\n         * @private\n         * @param  {Object} data\n         * The schema object.\n         * @param  {Array} [models=[]]\n         * An array of known models. This method is used recursively, so this\n         * argument exists primarily for internal use.\n         * @param  {Function} callback\n         * Executed when all models have been detected.\n         */\n        extractModelDefinitions: (data, models = [], callback) => {\n          if (NGN.isFn(models)) {\n            callback = models\n            models = []\n          }\n\n          if (data.type === 'object') {\n            let name = NGN.coalesce(data.name, this.name, 'Untitled')\n\n            if (data.hasOwnProperty('$schema') && name === null && this.METADATA.URL) {\n              name = this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', '')\n            }\n\n            // Configure the basic model\n            let model = {\n              name,\n              description: NGN.coalesce(data.description, 'No description.'),\n              fields: {}\n            }\n\n            // Flag the ID for the schema\n            if (data.hasOwnProperty('$schema')) {\n              this.METADATA.ID = NGN.coalesce(data.$id, data.$schema)\n            }\n\n            // Queue the tasks since several are async but sequential\n            let tasks = new NGN.Tasks()\n\n            // If the allOf attribute exists, the schema is extending another.\n            // Extract the subschema before continuing.\n            if (data.hasOwnProperty('allOf')) {\n              for (let i = 0; i < data.allOf.length; i++) {\n                tasks.add(`Identify base schema: ${data.allOf}`, cont => {\n                  let URI = NGN.coalesce(data.allOf[i].$ref, data.allOf[i].$schema)\n\n                  if (URI !== null) {\n                    // When a URI is specified, retrieve the remote schema\n                    let baseSchema = new NGN.DATA.JSONSchema(URI)\n\n                    baseSchema.getModelDefinitions(definitions => {\n                      let coreModel = definitions.pop()\n\n                      Object.assign(model.fields, coreModel.fields)\n\n                      // If the nested schema has additional models, apply them.\n                      if (definitions.length > 0) {\n                        models = definitions.concat(models)\n                      }\n\n                      this.METADATA.name = NGN.coalesce(this.METADATA.name, coreModel.name)\n\n                      cont()\n                    })\n                  } else if (data.allOf[i].hasOwnProperty('properties')) {\n                    // Handle additional properties\n                    let additionalProperties = Object.keys(data.allOf[i].properties)\n\n                    for (let prop = 0; prop < additionalProperties.length; prop++) {\n                      model.fields[additionalProperties[prop]] = this.extractCommonPropertyAttributes(data.allOf[i].properties[additionalProperties[prop]])\n                    }\n\n                    cont()\n                  }\n                })\n              }\n            }\n\n            tasks.add('Identify attributes', cont => {\n              // If the schema specifies dependencies, it is specifying a set of\n              // rules requiring the existance and non-empty value of additional\n              // fields. Create NGN.DATA.Rule sets to support this.\n              if (data.hasOwnProperty('dependencies')) {\n                Object.keys(data.dependencies).forEach(dependency => {\n                  let requiredFields = null\n                  let dep = data.dependencies[dependency]\n\n                  if (NGN.typeof(dep) === 'array') {\n                    // Simple property dependencies\n                    requiredFields = dep\n                  } else if (dep.hasOwnProperty('required')) {\n                    // Schema dependencies\n                    requiredFields = dep.required\n                  }\n\n                  // Add all valid dependencies as rules\n                  if (requiredFields !== null) {\n                    model.rules[`${dependency} dependency on \"${requiredFields.join(', ')}\"`] = function () {\n                      if (NGN.coalesce(this[dependency]) !== null) {\n                        for (let i = 0; i < requiredFields.length; i++) {\n                          if (NGN.coalesce(this[requiredFields[i]]) === null) {\n                            return false\n                          }\n                        }\n                      }\n\n                      return true\n                    }\n                  }\n                })\n              }\n\n              // Identify the fields\n              let properties = Object.keys(data.properties)\n              let subtasks = new NGN.Tasks()\n\n              if (properties.length > 0) {\n                for (let i = 0; i < properties.length; i++) {\n                  let propertyName = properties[i]\n                  let property = data.properties[propertyName]\n\n                  model.fields[propertyName] = this.PRIVATE.extractCommonPropertyAttributes(property, models)\n\n                  // If this is a subschema, retrieve it.\n                  if (property.$ref) {\n                    subtasks.add(next => {\n                      let nestedModel = new NGN.DATA.JSONSchema(property.$ref)\n\n                      nestedModel.getModelDefinitions(definitions => {\n                        models = definitions.concat(models)\n\n                        model.fields[propertyName] = {\n                          $model: definitions[definitions.length - 1].name\n                        }\n\n                        next()\n                      })\n                    })\n                  }\n\n                  model.fields[propertyName].required = NGN.coalesce(data.required, '').indexOf(propertyName) >= 0\n                }\n              }\n\n              subtasks.on('complete', () => {\n                models.push(model)\n                cont()\n              })\n\n              subtasks.run(true)\n            })\n\n            tasks.on('complete', () => callback(models))\n            tasks.run(true)\n          } else {\n            callback(models)\n          }\n        }\n      })",
          "start": {
            "line": 28,
            "column": 6
          },
          "end": {
            "line": 382,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "id": {
          "type": "property",
          "label": "id",
          "description": null,
          "code": "get id () {\n    if (this.METADATA.ID) {\n      return this.METADATA.ID\n    }\n\n    let id = NGN.coalesce(this.METADATA.URL)\n\n    if (id !== null) {\n      return id\n    }\n\n    let root\n    /* node-only */\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, `http://${require('os').hostname()}`)\n    /* end-node-only */\n    /* browser-only */\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, window.location.origin)\n    /* end-browser-only */\n\n    this.METADATA.ID = this.PRIVATE.NET.normalizeUrl(`${root}/${NGN.coalesce(this.name, 'untitled').toLowerCase()}.json`)\n\n    return this.METADATA.ID\n  }",
          "start": {
            "line": 418,
            "column": 2
          },
          "end": {
            "line": 440,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "name": {
          "type": "property",
          "label": "name",
          "description": null,
          "code": "set name (value) {\n    this.METADATA.name = NGN.coalesce(value, 'Untitled')\n  }",
          "start": {
            "line": 446,
            "column": 2
          },
          "end": {
            "line": 448,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "Create a new JSON schema reference.\n  \n  The schema to parse. This can be the JSON schema object itself or the URL\n  of a remote JSON schema.\n  \n  Specify a custom network resource to make the request for a remote schema.",
          "code": "constructor (schema = {}, NetworkResource = null) {\n    super()\n\n    Object.defineProperties(this, {\n      METADATA: NGN.private({\n        schema,\n        ID: null,\n        name: null\n      }),\n\n      PRIVATE: NGN.privateconst({\n        MODELS: null,\n        NET: NGN.coalesce(NetworkResource, NGN.NET),\n\n        parsed: false,\n\n        /**\n         * @method PRIVATE.extractCommonPropertyAttributes\n         * @param  {object} property\n         * Schema metadata object.\n         * @param {array} [models=[]]\n         * The list of known models. This is passed in because nested objects\n         * may exist within a property. NGN identifies these as nested models,\n         * even though the JSON schema does not force these to be separate\n         * schemas.\n         * @return {Object}\n         * Returns a clean \"NGN-ready\" field object of common properties.\n         */\n        extractCommonPropertyAttributes: (property, models = []) => {\n          let field = {}\n\n          // Add pattern\n          if (property.pattern) {\n            field.pattern = property.pattern\n          }\n\n          // Add description\n          if (property.description) {\n            field.description = property.description\n          }\n\n          // Add default\n          if (property.default) {\n            field.default = property.default\n          }\n\n          if (!property.$ref) {\n            if (!property.type) {\n              field.type = String\n            } else {\n              let type = NGN.typeof(property.type) === 'array' ? 'array' : property.type.trim().toLowerCase()\n\n              switch (type) {\n                case 'string':\n                  let format = NGN.coalesce(property.format, 'unknown').trim().toLowerCase()\n\n                  field.type = String\n\n                  switch (format) {\n                    case 'date':\n                    case 'date-time':\n                    case 'datetime':\n                    case 'format-time':\n                      field.type = Date\n                      break\n\n                    case 'ipv4':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\n                      )\n\n                      break\n\n                    case 'ipv6':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\n                      )\n\n                      break\n\n                    case 'email':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\\b$/\n                      )\n\n                      break\n\n                    case 'hostname':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)+(\\.([a-zA-Z0-9]+(-[a-zA-Z0-9ââ]+)*))*$/ // eslint-disable-line no-irregular-whitespace\n                      )\n\n                      break\n\n                    case 'uri':\n                      field.pattern = NGN.coalesce(\n                        property.pattern,\n                        /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]\\.[^\\s]{2,})/\n                      )\n\n                      break\n                  }\n\n                  break\n\n                case 'integer':\n                  field.type = Number\n                  field.pattern = /^\\d+$/\n                  break\n\n                case 'number':\n                  field.type = Number\n                  break\n\n                case 'object':\n                  if (property.properties) {\n                    let subschema = new NGN.DATA.JSONSchema(property)\n\n                    subschema.name = `${NGN.coalesce(this.name, 'untitled')}_${NGN.coalesce(subschema.name, 'submodel')}${models.length + 1}`\n\n                    subschema.getModelDefinitions(definitions => {\n                      definitions[definitions.length - 1].name = subschema.name\n                      models = definitions.concat(models)\n                    })\n\n                    field = {\n                      $model: subschema.name\n                    }\n                  } else {\n                    field.type = Object\n                  }\n\n                  break\n\n                default:\n                  field.type = String\n                  break\n              }\n            }\n          }\n\n          // String validation options\n          if (field.type === String || field.type === Number) {\n            if (NGN.coalesce(property.minLength, property.minimum)) {\n              field.min = NGN.coalesce(property.minLength, property.minimum)\n            }\n\n            if (NGN.coalesce(property.maxLength, property.maximum)) {\n              field.max = NGN.coalesce(property.maxLength, property.maximum)\n            }\n\n            // Numeric-specific validations\n            if (property.type === Number) {\n              if (property.multipleOf) {\n                field.multipleOf = property.multipleOf\n              }\n\n              if (property.exclusiveMinimum) {\n                field.min = (property.exclusiveMinimum + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\n              }\n\n              if (property.exclusiveMaximum) {\n                field.max = (property.exclusiveMaximum - 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\n              }\n            }\n          }\n\n          // Array validation options\n          if (field.type === Array) {\n            // Support minimum array length\n            if (property.hasOwnProperty('minItems')) {\n              field.min = property.minItems\n            }\n\n            // Support maximum array length\n            if (property.hasOwnProperty('maxItems')) {\n              field.max = property.maxItems\n            }\n\n            if (property.hasOwnProperty('items')) {\n              if (NGN.typeof(property.items) === 'array') {\n                // Apply tuple validation\n                field.tuples = property.items\n              } else {\n                // Apply list validation\n                if (property.items.hasOwnProperty('type')) {\n                  field.listType = NGN.getType(property.items.type)\n                }\n\n                if (property.items.hasOwnProperty('enum')) {\n                  field.enum = property.items.enum\n                }\n              }\n            }\n          }\n\n          return field\n        },\n\n        /**\n         * @method PRIVATE.extractModelDefinitions\n         * Retrieve all of the NGN.DATA.Model defitions that can be interpreted\n         * from this schema.\n         * @protected\n         * @private\n         * @param  {Object} data\n         * The schema object.\n         * @param  {Array} [models=[]]\n         * An array of known models. This method is used recursively, so this\n         * argument exists primarily for internal use.\n         * @param  {Function} callback\n         * Executed when all models have been detected.\n         */\n        extractModelDefinitions: (data, models = [], callback) => {\n          if (NGN.isFn(models)) {\n            callback = models\n            models = []\n          }\n\n          if (data.type === 'object') {\n            let name = NGN.coalesce(data.name, this.name, 'Untitled')\n\n            if (data.hasOwnProperty('$schema') && name === null && this.METADATA.URL) {\n              name = this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', '')\n            }\n\n            // Configure the basic model\n            let model = {\n              name,\n              description: NGN.coalesce(data.description, 'No description.'),\n              fields: {}\n            }\n\n            // Flag the ID for the schema\n            if (data.hasOwnProperty('$schema')) {\n              this.METADATA.ID = NGN.coalesce(data.$id, data.$schema)\n            }\n\n            // Queue the tasks since several are async but sequential\n            let tasks = new NGN.Tasks()\n\n            // If the allOf attribute exists, the schema is extending another.\n            // Extract the subschema before continuing.\n            if (data.hasOwnProperty('allOf')) {\n              for (let i = 0; i < data.allOf.length; i++) {\n                tasks.add(`Identify base schema: ${data.allOf}`, cont => {\n                  let URI = NGN.coalesce(data.allOf[i].$ref, data.allOf[i].$schema)\n\n                  if (URI !== null) {\n                    // When a URI is specified, retrieve the remote schema\n                    let baseSchema = new NGN.DATA.JSONSchema(URI)\n\n                    baseSchema.getModelDefinitions(definitions => {\n                      let coreModel = definitions.pop()\n\n                      Object.assign(model.fields, coreModel.fields)\n\n                      // If the nested schema has additional models, apply them.\n                      if (definitions.length > 0) {\n                        models = definitions.concat(models)\n                      }\n\n                      this.METADATA.name = NGN.coalesce(this.METADATA.name, coreModel.name)\n\n                      cont()\n                    })\n                  } else if (data.allOf[i].hasOwnProperty('properties')) {\n                    // Handle additional properties\n                    let additionalProperties = Object.keys(data.allOf[i].properties)\n\n                    for (let prop = 0; prop < additionalProperties.length; prop++) {\n                      model.fields[additionalProperties[prop]] = this.extractCommonPropertyAttributes(data.allOf[i].properties[additionalProperties[prop]])\n                    }\n\n                    cont()\n                  }\n                })\n              }\n            }\n\n            tasks.add('Identify attributes', cont => {\n              // If the schema specifies dependencies, it is specifying a set of\n              // rules requiring the existance and non-empty value of additional\n              // fields. Create NGN.DATA.Rule sets to support this.\n              if (data.hasOwnProperty('dependencies')) {\n                Object.keys(data.dependencies).forEach(dependency => {\n                  let requiredFields = null\n                  let dep = data.dependencies[dependency]\n\n                  if (NGN.typeof(dep) === 'array') {\n                    // Simple property dependencies\n                    requiredFields = dep\n                  } else if (dep.hasOwnProperty('required')) {\n                    // Schema dependencies\n                    requiredFields = dep.required\n                  }\n\n                  // Add all valid dependencies as rules\n                  if (requiredFields !== null) {\n                    model.rules[`${dependency} dependency on \"${requiredFields.join(', ')}\"`] = function () {\n                      if (NGN.coalesce(this[dependency]) !== null) {\n                        for (let i = 0; i < requiredFields.length; i++) {\n                          if (NGN.coalesce(this[requiredFields[i]]) === null) {\n                            return false\n                          }\n                        }\n                      }\n\n                      return true\n                    }\n                  }\n                })\n              }\n\n              // Identify the fields\n              let properties = Object.keys(data.properties)\n              let subtasks = new NGN.Tasks()\n\n              if (properties.length > 0) {\n                for (let i = 0; i < properties.length; i++) {\n                  let propertyName = properties[i]\n                  let property = data.properties[propertyName]\n\n                  model.fields[propertyName] = this.PRIVATE.extractCommonPropertyAttributes(property, models)\n\n                  // If this is a subschema, retrieve it.\n                  if (property.$ref) {\n                    subtasks.add(next => {\n                      let nestedModel = new NGN.DATA.JSONSchema(property.$ref)\n\n                      nestedModel.getModelDefinitions(definitions => {\n                        models = definitions.concat(models)\n\n                        model.fields[propertyName] = {\n                          $model: definitions[definitions.length - 1].name\n                        }\n\n                        next()\n                      })\n                    })\n                  }\n\n                  model.fields[propertyName].required = NGN.coalesce(data.required, '').indexOf(propertyName) >= 0\n                }\n              }\n\n              subtasks.on('complete', () => {\n                models.push(model)\n                cont()\n              })\n\n              subtasks.run(true)\n            })\n\n            tasks.on('complete', () => callback(models))\n            tasks.run(true)\n          } else {\n            callback(models)\n          }\n        }\n      })\n    })\n\n    this.once('parsed', () => {\n      this.PRIVATE.parsed = true\n      this.METADATA.ID = NGN.coalesce(this.METADATA.schema.id, this.METADATA.schema.$schema)\n    })\n\n    // Initialize\n    switch (NGN.typeof(schema)) {\n      case 'string':\n        // If schema is actually a URL, retrieve it.\n        this.METADATA.URL = schema\n        this.PRIVATE.NET.json(schema, (err, schema) => {\n          if (err) {\n            throw err\n          }\n\n          this.METADATA.schema = schema\n          this.METADATA.name = NGN.coalesce(schema.name, this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', ''))\n\n          this.emit('parsed')\n        })\n\n        break\n\n      case 'object':\n        this.METADATA.name = NGN.coalesce(schema.name, 'Untitled')\n        this.emit('parsed')\n        break\n\n      default:\n        throw new Error('Invalid schema definition.')\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 18,
            "column": 2
          },
          "end": {
            "line": 416,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "schema": {
              "type": "argument",
              "label": "schema",
              "description": null,
              "code": "schema = {}",
              "start": {
                "line": 18,
                "column": 15
              },
              "end": {
                "line": 18,
                "column": 26
              },
              "flags": [],
              "default": "{}",
              "datatype": "object",
              "required": false,
              "enum": null
            },
            "NetworkResource": {
              "type": "argument",
              "label": "NetworkResource",
              "description": "Specify a custom network resource to make the request for a remote schema.",
              "code": "@param  {NGN.NET.Resource} [NetworkResource]\nSpecify a custom network resource to make the request for a remote schema.",
              "start": {
                "line": 18,
                "column": 2
              },
              "end": {
                "line": 416,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "ngn.net.resource",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getModelDefinitions": {
          "type": "method",
          "label": "getModelDefinitions",
          "description": null,
          "code": "getModelDefinitions (callback) {\n    if (!this.PRIVATE.parsed) {\n      this.once('parsed', () => {\n        this.getModelDefinitions(callback)\n      })\n    } else if (!this.PRIVATE.MODELS) {\n      this.PRIVATE.extractModelDefinitions(this.METADATA.schema, [], definitions => {\n        this.PRIVATE.MODELS = definitions\n        callback(definitions)\n      })\n    } else {\n      callback(this.PRIVATE.MODELS)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 450,
            "column": 2
          },
          "end": {
            "line": 463,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "callback": {
              "type": "argument",
              "label": "callback",
              "description": null,
              "code": "callback",
              "start": {
                "line": 450,
                "column": 23
              },
              "end": {
                "line": 450,
                "column": 31
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "PRIVATE.extractCommonPropertyAttributes": {
          "type": "method",
          "label": "PRIVATE.extractCommonPropertyAttributes",
          "description": "",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "PRIVATE.extractModelDefinitions": {
          "type": "method",
          "label": "PRIVATE.extractModelDefinitions",
          "description": "Retrieve all of the NGN.DATA.Model defitions that can be interpreted\nfrom this schema.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "hash": {
          "type": "method",
          "label": "hash",
          "description": "The hash part of the URL .",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "EventEmitterBase": {
      "type": "class",
      "label": "EventEmitterBase",
      "description": "The maximum number of listeners for a single event.",
      "code": "class BrowserEmitter { // eslint-disable-line no-unused-vars\n  /**\n   * @constructor\n   * ```\n   * let EE = new EventEmitter()\n   * ```\n   * This is a protected class. It is most commonly instantiated through\n   * the NGN namespace (i.e. `new NGN.EventEmitter()`). However; it is\n   * designed for use within the NGN library, not directly as an event emitter.\n   * Use with caution.\n   */\n  constructor (cfg) {\n    cfg = cfg || {}\n\n    Object.defineProperties(this, {\n      handlers: NGN.private({}),\n      adhoc: NGN.private({}),\n      maxlisteners: NGN.private(cfg.defaultMaxListeners || 25)\n    })\n  }\n\n  /**\n   * @property {object} subscribers\n   * An array of all subscribers which currently have a registered event handler.\n   * @warning This is a UI-only method.\n   */\n  get subscribers () {\n    let subscriberList = {}\n\n    for (let eventName in this.handlers) {\n      subscriberList[eventName] = {\n        handler: this.handlers[eventName].length,\n        adhoc: 0\n      }\n    }\n\n    for (let eventName in this.adhoc) {\n      subscriberList[eventName] = subscriberList[eventName] || {\n        handler: 0\n      }\n\n      subscriberList[eventName].adhoc = this.adhoc[eventName].length\n    }\n\n    return subscriberList\n  }\n\n  /**\n   * @property defaultMaxListeners\n   * The maximum number of listeners for a single event.\n   */\n  get defaultMaxListeners () {\n    return this.maxlisteners\n  }\n\n  set defaultMaxListeners (value) {\n    this.maxlisteners = value\n  }\n\n  /**\n   * @method {number} listenerCount\n   * The number of listeners for a specific event.\n   * @param {string} eventName\n   * The name of the event to count listeners for.\n   */\n  listenerCount (eventName) {\n    return (this.handlers[eventName] || []).length +\n      (this.adhoc[eventName] || []).length\n  }\n\n  /**\n   * @method getMaxListeners\n   * A node-like reference to the #defaultMaxListeners value.\n   * @return {number}\n   */\n  getMaxListeners () {\n    return this.defaultMaxListeners\n  }\n\n  /**\n   * @method setMaxListeners\n   * A node-like reference to the #defaultMaxListeners value (setter).\n   */\n  setMaxListeners (value) {\n    this.defaultMaxListeners = value\n  }\n\n  /**\n   * @method eventNames\n   * A node-like reference providing an array of recognized event names.\n   * @return {array}\n   */\n  eventNames () {\n    let handlers = Object.keys(this.handlers)\n    let adhoc = Object.keys(this.adhoc)\n    return NGN.dedupe(handlers.concat(adhoc))\n  }\n\n  /**\n   * @method listeners\n   * Returns the raw listener methods for the event.\n   * @param {string} eventName\n   * Name of the event to retrieve listeners for.\n   * @return {array}\n   */\n  listeners (eventName) {\n    let handlers = this.handlers[eventName] || []\n    let adhoc = this.adhoc[eventName] || []\n    return handlers.concat(adhoc)\n  }\n\n  /**\n   * @method addListener\n   * Create a new event handler for the specified event.\n   * @param  {string|object} eventName\n   * Name of the event to listen for.\n   * If an object is passed, this method will automatically setup a #pool.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   * This is ignored if eventName is an object.\n   */\n  addListener (eventName, callback) {\n    if (typeof eventName === 'object') {\n      return this.pool(eventName)\n    }\n\n    this.handlers[eventName] = this.handlers[eventName] || []\n    this.handlers[eventName].unshift(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method prependListener\n   * This is the same as #addListener, except the event handler is added to the end of the queue.\n   * @param  {string|object} eventName\n   * Name of the event to listen for.\n   * If an object is passed, this method will automatically setup a #pool.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   * This is ignored if eventName is an object.\n   */\n  prependListener (eventName, callback) {\n    if (typeof eventName === 'object') {\n      return this.pool(eventName)\n    }\n\n    this.handlers[eventName] = this.handlers[eventName] || []\n    this.handlers[eventName].push(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method onceListener\n   * Create a new event handler for the specified event. The\n   * handler will be removed immediately after it is executed. This\n   * effectively listens for an event to happen once and only once\n   * before the handler is destroyed.\n   * @param  {string} eventName\n   * Name of the event to listen for.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   */\n  once (eventName, callback) {\n    this.adhoc[eventName] = this.adhoc[eventName] || []\n    this.adhoc[eventName].push(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method prependOnceListener\n   * A node-like reference to the #once method, adding events to the\n   * beginning of the event list (processed before others) instead of the end.\n   * @param  {string} eventName\n   * Name of the event to listen for.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   */\n  prependOnceListener (eventName, callback) {\n    this.adhoc[eventName] = this.adhoc[eventName] || []\n    this.adhoc[eventName].unshift(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }\n\n  /**\n   * @method removeListener\n   * Remove an event handler. If no handler is specified, all handlers for\n   * the specified event will be removed.\n   * @param {string} eventName\n   * Name of the event to remove.\n   * @param {function} [handlerFn]\n   * The handler function to remove from the event handlers.\n   */\n  removeListener (eventName, handlerFn) {\n    this.deleteEventHandler('handlers', eventName, handlerFn)\n    this.deleteEventHandler('adhoc', eventName, handlerFn)\n  }\n\n  /**\n   * @method deleteEventHandler\n   * Remove a specific event handler.\n   * @param {string} type\n   * Either `handler` (multi-use events) or `adhoc` (one-time events)\n   * @param {string} eventName\n   * Name of the event to remove.\n   * @param {function} handlerFn\n   * The handler function to remove from the event handlers.\n   * @private\n   */\n  deleteEventHandler (type, eventName, handlerFn) {\n    let scope = this[type]\n\n    if (scope[eventName]) {\n      if (!handlerFn) {\n        delete scope[eventName]\n        return\n      }\n\n      let result = []\n      scope[eventName].forEach((handler) => {\n        if (handler.toString() !== handlerFn.toString()) {\n          result.push(handler)\n        }\n      })\n\n      if (result.length === 0) {\n        delete scope[eventName]\n        return\n      }\n\n      scope[eventName] = result\n    }\n  }\n\n  /**\n   * @method removeAllListeners\n   * Remove all event handlers from the EventEmitter (both regular and adhoc).\n   */\n  removeAllListeners (eventName = null) {\n    if (eventName !== null) {\n      delete this.handlers[eventName]\n      delete this.adhoc[eventName]\n    } else {\n      this.handlers = {}\n      this.adhoc = {}\n    }\n  }\n\n  /**\n   * @method emit\n   * Fires an event. This method accepts one or more arguments. The\n   * first argument is always the event name, followed by any number\n   * of payload arguments.\n   *\n   * Example:\n   * ```\n   * const EE = new NGN.EventEmitter()\n   *\n   * EE.emit('someevent', {payload: 1}, {payload: 2})\n   * ```\n   * The example above triggers an event called `someevent` and applies\n   * the remaining two arguments to any event handlers.\n   * @param {string} eventName\n   * The name of the event to trigger.\n   */\n  emit () {\n    let args = NGN.slice(arguments)\n    const eventName = args.shift()\n    const events = this.getAllEvents(eventName)\n\n    if (typeof eventName === 'symbol') {\n      events.push(eventName)\n    }\n\n    let scope = {\n      event: eventName\n    }\n\n    for (let name = 0; name < events.length; name++) {\n      let adhocEvent = this.adhoc[events[name]]\n\n      // Adhoc event handling\n      if (adhocEvent) {\n        delete this.adhoc[events[name]]\n\n        while (adhocEvent.length > 0) {\n          let fn = adhocEvent.pop()\n\n          scope.handler = fn\n\n          fn.apply(scope, args)\n        }\n      }\n\n      // Regular event handling\n      let handler = this.handlers[events[name]]\n\n      if (handler) {\n        for (let fn = 0; fn < handler.length; fn++) {\n          scope.handler = handler[fn]\n          handler[fn].apply(scope, args)\n        }\n      }\n    }\n  }\n\n  /**\n   * @method getAllEvents\n   * Returns all of the events that match an event name. The event name\n   * may contain wildcards (i.e. `*`) or it can be a regular expression.\n   * @param  {string|regexp} eventName\n   * A string or regular expression defining which event names to identify.\n   * A string value containing an asterisk (*) will be converted to a regular\n   * expression for simplistic wildcard event handling purposes.\n   * @return {array}\n   * An array of unique event names with handlers or adhoc handlers.\n   * @private\n   */\n  getAllEvents (eventName) {\n    const regularEvents = Object.keys(this.handlers)\n    const adhocEvents = Object.keys(this.adhoc)\n    let allEvents = NGN.dedupe(regularEvents.concat(adhocEvents))\n\n    allEvents = allEvents.filter(function (event) {\n      // If the event is an exact match, don't filter it out.\n      if (event === eventName) {\n        return true\n      }\n\n      // If the event is a regexp/wildcard, further processing is necessary.\n      if (NGN.typeof(event) === 'regexp' || event.indexOf('*') >= 0) {\n        // Convert wildcard events to a regular expression.\n        if (NGN.typeof(event) !== 'regexp') {\n          event = new RegExp(event.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\n        }\n        // If the event name matches the event, keep it.\n        return event.test(eventName)\n      }\n\n      // None of the criteria were met. Ignore the event.\n      return false\n    })\n\n    return allEvents\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "newListener": {
          "type": "event",
          "label": "newListener",
          "description": null,
          "code": "this.emit('newListener', eventName, callback)",
          "start": {
            "line": 200,
            "column": 4
          },
          "end": {
            "line": 200,
            "column": 49
          },
          "flags": [],
          "parameters": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": null,
              "code": "eventName",
              "start": {
                "line": 200,
                "column": 29
              },
              "end": {
                "line": 200,
                "column": 38
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "callback",
              "description": null,
              "code": "callback",
              "start": {
                "line": 200,
                "column": 40
              },
              "end": {
                "line": 200,
                "column": 48
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 8,
        "column": 15
      },
      "end": {
        "line": 368,
        "column": 1
      },
      "flags": [
        ""
      ],
      "sourcefile": "./emitter/BrowserEmitter.js",
      "extends": null,
      "configuration": {},
      "properties": {
        "handlers": {
          "type": "property",
          "label": "handlers",
          "description": null,
          "code": "handlers: NGN.private({})",
          "start": {
            "line": 23,
            "column": 6
          },
          "end": {
            "line": 23,
            "column": 31
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "adhoc": {
          "type": "property",
          "label": "adhoc",
          "description": null,
          "code": "adhoc: NGN.private({})",
          "start": {
            "line": 24,
            "column": 6
          },
          "end": {
            "line": 24,
            "column": 28
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "maxlisteners": {
          "type": "property",
          "label": "maxlisteners",
          "description": null,
          "code": "maxlisteners: NGN.private(cfg.defaultMaxListeners || 25)",
          "start": {
            "line": 25,
            "column": 6
          },
          "end": {
            "line": 25,
            "column": 62
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "subscribers": {
          "type": "property",
          "label": "subscribers",
          "description": null,
          "code": "get subscribers () {\n    let subscriberList = {}\n\n    for (let eventName in this.handlers) {\n      subscriberList[eventName] = {\n        handler: this.handlers[eventName].length,\n        adhoc: 0\n      }\n    }\n\n    for (let eventName in this.adhoc) {\n      subscriberList[eventName] = subscriberList[eventName] || {\n        handler: 0\n      }\n\n      subscriberList[eventName].adhoc = this.adhoc[eventName].length\n    }\n\n    return subscriberList\n  }",
          "start": {
            "line": 34,
            "column": 2
          },
          "end": {
            "line": 53,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "defaultMaxListeners": {
          "type": "property",
          "label": "defaultMaxListeners",
          "description": null,
          "code": "set defaultMaxListeners (value) {\n    this.maxlisteners = value\n  }",
          "start": {
            "line": 63,
            "column": 2
          },
          "end": {
            "line": 65,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "``` let EE = new EventEmitter\n```\nThis is a protected class. It is most commonly instantiated through\nthe NGN namespace (i.e. `new NGN.EventEmitter()`). However; it is\ndesigned for use within the NGN library, not directly as an event emitter.\nUse with caution.",
          "code": "constructor (cfg) {\n    cfg = cfg || {}\n\n    Object.defineProperties(this, {\n      handlers: NGN.private({}),\n      adhoc: NGN.private({}),\n      maxlisteners: NGN.private(cfg.defaultMaxListeners || 25)\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 19,
            "column": 2
          },
          "end": {
            "line": 27,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg",
              "start": {
                "line": 19,
                "column": 15
              },
              "end": {
                "line": 19,
                "column": 18
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "listenerCount": {
          "type": "method",
          "label": "listenerCount",
          "description": "The number of listeners for a specific event.",
          "code": "listenerCount (eventName) {\n    return (this.handlers[eventName] || []).length +\n      (this.adhoc[eventName] || []).length\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 73,
            "column": 2
          },
          "end": {
            "line": 76,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": "The name of the event to count listeners for.",
              "code": "@param {string} eventName\nThe name of the event to count listeners for.",
              "start": {
                "line": 73,
                "column": 2
              },
              "end": {
                "line": 76,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getMaxListeners": {
          "type": "method",
          "label": "getMaxListeners",
          "description": "A node-like reference to the #defaultMaxListeners value.",
          "code": "getMaxListeners () {\n    return this.defaultMaxListeners\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 83,
            "column": 2
          },
          "end": {
            "line": 85,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "number",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setMaxListeners": {
          "type": "method",
          "label": "setMaxListeners",
          "description": "A node-like reference to the #defaultMaxListeners value .",
          "code": "setMaxListeners (value) {\n    this.defaultMaxListeners = value\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 91,
            "column": 2
          },
          "end": {
            "line": 93,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "value": {
              "type": "argument",
              "label": "value",
              "description": null,
              "code": "value",
              "start": {
                "line": 91,
                "column": 19
              },
              "end": {
                "line": 91,
                "column": 24
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "eventNames": {
          "type": "method",
          "label": "eventNames",
          "description": "A node-like reference providing an array of recognized event names.",
          "code": "eventNames () {\n    let handlers = Object.keys(this.handlers)\n    let adhoc = Object.keys(this.adhoc)\n    return NGN.dedupe(handlers.concat(adhoc))\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 100,
            "column": 2
          },
          "end": {
            "line": 104,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "array",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "listeners": {
          "type": "method",
          "label": "listeners",
          "description": "Returns the raw listener methods for the event.",
          "code": "listeners (eventName) {\n    let handlers = this.handlers[eventName] || []\n    let adhoc = this.adhoc[eventName] || []\n    return handlers.concat(adhoc)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 113,
            "column": 2
          },
          "end": {
            "line": 117,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to retrieve listeners for.",
              "code": "@param {string} eventName\nName of the event to retrieve listeners for.",
              "start": {
                "line": 113,
                "column": 2
              },
              "end": {
                "line": 117,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "array",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "addListener": {
          "type": "method",
          "label": "addListener",
          "description": "Create a new event handler for the specified event.",
          "code": "addListener (eventName, callback) {\n    if (typeof eventName === 'object') {\n      return this.pool(eventName)\n    }\n\n    this.handlers[eventName] = this.handlers[eventName] || []\n    this.handlers[eventName].unshift(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 129,
            "column": 2
          },
          "end": {
            "line": 141,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": null,
              "code": "eventName",
              "start": {
                "line": 129,
                "column": 15
              },
              "end": {
                "line": 129,
                "column": 24
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to listen for.\nIf an object is passed, this method will automatically setup a #pool.",
              "code": "callback",
              "start": {
                "line": 129,
                "column": 26
              },
              "end": {
                "line": 129,
                "column": 34
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": null
            },
            "handler": {
              "type": "argument",
              "label": "handler",
              "description": "The method responsible for responding to the event.\nThis is ignored if eventName is an object.",
              "code": "@param  {Function} handler\nThe method responsible for responding to the event.\nThis is ignored if eventName is an object.",
              "start": {
                "line": 129,
                "column": 2
              },
              "end": {
                "line": 141,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "function",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "prependListener": {
          "type": "method",
          "label": "prependListener",
          "description": "This is the same as #addListener, except the event handler is added to the end of the queue.",
          "code": "prependListener (eventName, callback) {\n    if (typeof eventName === 'object') {\n      return this.pool(eventName)\n    }\n\n    this.handlers[eventName] = this.handlers[eventName] || []\n    this.handlers[eventName].push(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 153,
            "column": 2
          },
          "end": {
            "line": 165,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": null,
              "code": "eventName",
              "start": {
                "line": 153,
                "column": 19
              },
              "end": {
                "line": 153,
                "column": 28
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to listen for.\nIf an object is passed, this method will automatically setup a #pool.",
              "code": "callback",
              "start": {
                "line": 153,
                "column": 30
              },
              "end": {
                "line": 153,
                "column": 38
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": null
            },
            "handler": {
              "type": "argument",
              "label": "handler",
              "description": "The method responsible for responding to the event.\nThis is ignored if eventName is an object.",
              "code": "@param  {Function} handler\nThe method responsible for responding to the event.\nThis is ignored if eventName is an object.",
              "start": {
                "line": 153,
                "column": 2
              },
              "end": {
                "line": 165,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "function",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "onceListener": {
          "type": "method",
          "label": "onceListener",
          "description": "Create a new event handler for the specified event. The\nhandler will be removed immediately after it is executed. This\neffectively listens for an event to happen once and only once\nbefore the handler is destroyed.",
          "code": "once (eventName, callback) {\n    this.adhoc[eventName] = this.adhoc[eventName] || []\n    this.adhoc[eventName].push(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 178,
            "column": 2
          },
          "end": {
            "line": 186,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": null,
              "code": "eventName",
              "start": {
                "line": 178,
                "column": 8
              },
              "end": {
                "line": 178,
                "column": 17
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to listen for.",
              "code": "callback",
              "start": {
                "line": 178,
                "column": 19
              },
              "end": {
                "line": 178,
                "column": 27
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "handler": {
              "type": "argument",
              "label": "handler",
              "description": "The method responsible for responding to the event.",
              "code": "@param  {Function} handler\nThe method responsible for responding to the event.",
              "start": {
                "line": 178,
                "column": 2
              },
              "end": {
                "line": 186,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "function",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "prependOnceListener": {
          "type": "method",
          "label": "prependOnceListener",
          "description": "A node-like reference to the #once method, adding events to the\nbeginning of the event list  instead of the end.",
          "code": "prependOnceListener (eventName, callback) {\n    this.adhoc[eventName] = this.adhoc[eventName] || []\n    this.adhoc[eventName].unshift(callback)\n    this.emit('newListener', eventName, callback)\n\n    if (this.listenerCount(eventName) > this.maxlisteners) {\n      throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.')\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 197,
            "column": 2
          },
          "end": {
            "line": 205,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": null,
              "code": "eventName",
              "start": {
                "line": 197,
                "column": 23
              },
              "end": {
                "line": 197,
                "column": 32
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to listen for.",
              "code": "callback",
              "start": {
                "line": 197,
                "column": 34
              },
              "end": {
                "line": 197,
                "column": 42
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "handler": {
              "type": "argument",
              "label": "handler",
              "description": "The method responsible for responding to the event.",
              "code": "@param  {Function} handler\nThe method responsible for responding to the event.",
              "start": {
                "line": 197,
                "column": 2
              },
              "end": {
                "line": 205,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "function",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeListener": {
          "type": "method",
          "label": "removeListener",
          "description": "Remove an event handler. If no handler is specified, all handlers for\nthe specified event will be removed.",
          "code": "removeListener (eventName, handlerFn) {\n    this.deleteEventHandler('handlers', eventName, handlerFn)\n    this.deleteEventHandler('adhoc', eventName, handlerFn)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 216,
            "column": 2
          },
          "end": {
            "line": 219,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to remove.",
              "code": "handlerFn",
              "start": {
                "line": 216,
                "column": 29
              },
              "end": {
                "line": 216,
                "column": 38
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "handlerFn": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to remove.",
              "code": "handlerFn",
              "start": {
                "line": 216,
                "column": 29
              },
              "end": {
                "line": 216,
                "column": 38
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "deleteEventHandler": {
          "type": "method",
          "label": "deleteEventHandler",
          "description": "Remove a specific event handler.",
          "code": "deleteEventHandler (type, eventName, handlerFn) {\n    let scope = this[type]\n\n    if (scope[eventName]) {\n      if (!handlerFn) {\n        delete scope[eventName]\n        return\n      }\n\n      let result = []\n      scope[eventName].forEach((handler) => {\n        if (handler.toString() !== handlerFn.toString()) {\n          result.push(handler)\n        }\n      })\n\n      if (result.length === 0) {\n        delete scope[eventName]\n        return\n      }\n\n      scope[eventName] = result\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 232,
            "column": 2
          },
          "end": {
            "line": 255,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "type": {
              "type": "argument",
              "label": "type",
              "description": null,
              "code": "type",
              "start": {
                "line": 232,
                "column": 22
              },
              "end": {
                "line": 232,
                "column": 26
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to remove.",
              "code": "handlerFn",
              "start": {
                "line": 232,
                "column": 39
              },
              "end": {
                "line": 232,
                "column": 48
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "handlerFn": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to remove.",
              "code": "handlerFn",
              "start": {
                "line": 232,
                "column": 39
              },
              "end": {
                "line": 232,
                "column": 48
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeAllListeners": {
          "type": "method",
          "label": "removeAllListeners",
          "description": "Remove all event handlers from the EventEmitter .",
          "code": "removeAllListeners (eventName = null) {\n    if (eventName !== null) {\n      delete this.handlers[eventName]\n      delete this.adhoc[eventName]\n    } else {\n      this.handlers = {}\n      this.adhoc = {}\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 261,
            "column": 2
          },
          "end": {
            "line": 269,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": null,
              "code": "eventName = null",
              "start": {
                "line": 261,
                "column": 22
              },
              "end": {
                "line": 261,
                "column": 38
              },
              "flags": [],
              "default": null,
              "datatype": "object",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "emit": {
          "type": "method",
          "label": "emit",
          "description": "Fires an event. This method accepts one or more arguments. The\nfirst argument is always the event name, followed by any number\nof payload arguments.\n\nExample:\n```\nconst EE = new NGN.EventEmitter\n\nEE.emit('someevent', {payload: 1}, {payload: 2})\n```\nThe example above triggers an event called `someevent` and applies\nthe remaining two arguments to any event handlers.",
          "code": "emit () {\n    let args = NGN.slice(arguments)\n    const eventName = args.shift()\n    const events = this.getAllEvents(eventName)\n\n    if (typeof eventName === 'symbol') {\n      events.push(eventName)\n    }\n\n    let scope = {\n      event: eventName\n    }\n\n    for (let name = 0; name < events.length; name++) {\n      let adhocEvent = this.adhoc[events[name]]\n\n      // Adhoc event handling\n      if (adhocEvent) {\n        delete this.adhoc[events[name]]\n\n        while (adhocEvent.length > 0) {\n          let fn = adhocEvent.pop()\n\n          scope.handler = fn\n\n          fn.apply(scope, args)\n        }\n      }\n\n      // Regular event handling\n      let handler = this.handlers[events[name]]\n\n      if (handler) {\n        for (let fn = 0; fn < handler.length; fn++) {\n          scope.handler = handler[fn]\n          handler[fn].apply(scope, args)\n        }\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 288,
            "column": 2
          },
          "end": {
            "line": 327,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": "The name of the event to trigger.",
              "code": "@param {string} eventName\nThe name of the event to trigger.",
              "start": {
                "line": 288,
                "column": 2
              },
              "end": {
                "line": 327,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getAllEvents": {
          "type": "method",
          "label": "getAllEvents",
          "description": "Returns all of the events that match an event name. The event name\nmay contain wildcards  or it can be a regular expression.",
          "code": "getAllEvents (eventName) {\n    const regularEvents = Object.keys(this.handlers)\n    const adhocEvents = Object.keys(this.adhoc)\n    let allEvents = NGN.dedupe(regularEvents.concat(adhocEvents))\n\n    allEvents = allEvents.filter(function (event) {\n      // If the event is an exact match, don't filter it out.\n      if (event === eventName) {\n        return true\n      }\n\n      // If the event is a regexp/wildcard, further processing is necessary.\n      if (NGN.typeof(event) === 'regexp' || event.indexOf('*') >= 0) {\n        // Convert wildcard events to a regular expression.\n        if (NGN.typeof(event) !== 'regexp') {\n          event = new RegExp(event.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\n        }\n        // If the event name matches the event, keep it.\n        return event.test(eventName)\n      }\n\n      // None of the criteria were met. Ignore the event.\n      return false\n    })\n\n    return allEvents\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 341,
            "column": 2
          },
          "end": {
            "line": 367,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": "A string or regular expression defining which event names to identify.\nA string value containing an asterisk  will be converted to a regular\nexpression for simplistic wildcard event handling purposes.",
              "code": "@param  {string|regexp} eventName\nA string or regular expression defining which event names to identify.\nA string value containing an asterisk (*) will be converted to a regular\nexpression for simplistic wildcard event handling purposes.",
              "start": {
                "line": 341,
                "column": 2
              },
              "end": {
                "line": 367,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string|regexp",
              "required": true,
              "enum": [
                "*"
              ]
            }
          },
          "returnType": "array",
          "returnDescription": "null An array of unique event names with handlers or adhoc handlers.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.EventEmitter": {
      "type": "class",
      "label": "NGN.EventEmitter",
      "description": "The EventEmitter is an extandable event driver non-DOM objects, such as\ndata models, objects, and other common elements of JavaScript programming.\n\nThe NGN.EventEmitter is based on and compatible with the [Node.js EventEmitter].\nIt contains additional event management capabilities, which are available\nin browser _and_ Node.js environments.",
      "code": "class EventEmitter extends EEmitter {\n  constructor () {\n    super()\n\n    // const INSTANCE = Symbol('instance')\n\n    Object.defineProperties(this, {\n      // META: NGN.get(() => this[INSTANCE]),\n\n      META: NGN.private({\n        queued: {},\n        collectionQueue: {},\n        thresholdQueue: {},\n        defaultTTL: -1,\n        wildcardEvents: new Set()\n      }),\n\n      /**\n       * @method setTTL\n       * Set a default time-to-live for event handlers (in milliseconds).\n       * After the TTL period elapses, event handlers are removed.\n       * By default, there is no TTL (`-1`).\n       * @param {number} ttl\n       * The number of milliseconds before an event handler is automatically\n       * removed. This value may be `-1` (no TTL/never expires) or a value\n       * greater than `0`.\n       */\n      setTTL: NGN.const((ttl = -1) => {\n        if (ttl === 0) {\n          NGN.WARN('NGN.EventEmitter#TTL cannot be 0.')\n          return\n        }\n\n        this.META.defaultTTL = ttl\n      }),\n\n      /**\n       * @alias off\n       * Remove an event handler. If no handler is specified, all handlers for\n       * the specified event will be removed.\n       * This is a shortcut for #removeListener.\n       * @param {string} eventName\n       * Name of the event to remove.\n       * @param {function} [handlerFn]\n       * The handler function to remove from the event handlers.\n       */\n      off: NGN.public((eventName, handlerFn) => {\n        if (NGN.typeof(eventName) === 'array') {\n          for (let i = 0; i < eventName.length; i++) {\n            this.off(eventName[i], handlerFn)\n          }\n\n          return\n        }\n\n        let l = this.listeners(eventName)\n\n        if (!NGN.isFn(handlerFn)) {\n          return this.clear(eventName)\n        }\n\n        let wrappedHandlerFn = this.wrapEventHandlerWithScope(eventName, handlerFn)\n\n        if (l.indexOf(wrappedHandlerFn) < 0) {\n          for (let i = 0; i < l.length; i++) {\n            if (l[i].toString() === wrappedHandlerFn.toString()) {\n              this.META.wildcardEvents.delete(eventName)\n              // this.removeListener(eventName, handlerFn)\n              this.removeListener(eventName, l[i], false)\n              break\n            }\n          }\n        } else {\n          this.META.wildcardEvents.delete(eventName)\n          this.removeListener(eventName, handlerFn)\n        }\n      }),\n\n      /**\n       * @method deprecate\n       * Provides a deprecation notice for the specified event.\n       * Automatically emits the appropriate \"replacement\" event\n       * if a replacement event is configured. If no replacement\n       * event is configured, the deprecation notice will be written\n       * to the console but no replacement event will be triggered.\n       * @param {string} deprecatedEventName\n       * The name of the deprecated event.\n       * @param {string} [replacementEventName]\n       * The name of the new event.\n       */\n      deprecate: NGN.const((deprecatedEventName, replacementEventName) => {\n        const me = this\n\n        this.on(deprecatedEventName, function () {\n          NGN.WARN(`${deprecatedEventName} is deprecated. ` + (!replacementEventName ? '' : `Use ${replacementEventName} instead.`))\n\n          if (replacementEventName) {\n            let args = NGN.slice(arguments)\n\n            args.shift()\n            args.unshift(replacementEventName)\n\n            me.emit.apply(me, args)\n          }\n        })\n      }),\n\n      /**\n       * @method pool\n       * A helper command to create multiple related subscribers\n       * all at once. This is a convenience function.\n       * @property {string} [prefix]\n       * Supply a prefix to be added to every event. For example,\n       * `myScope.` would turn `someEvent` into `myScope.someEvent`.\n       * @property {Object} subscriberObject\n       * A key:value object where the key is the name of the\n       * unprefixed event and the key is the handler function.\n       * A value can be an object, allowing for nesting events. For example:\n       *\n       * ```js\n       * NGN.BUS.pool('prefix.', {\n       *   deep: {\n       *     nested: {\n       *       eventName: function () {\n       *         console.log('event triggered')\n       *       }\n       *     }\n       *   }\n       * })\n       *\n       * NGN.BUS.emit('prefix.deep.nested.eventName') // <-- Outputs \"event triggered\"\n       * ```\n       * @private\n       */\n      pool: NGN.privateconst(function (prefix, group) {\n        if (typeof prefix !== 'string') {\n          group = prefix\n          prefix = ''\n        }\n\n        let pool = {}\n\n        for (let eventName in group) {\n          let topic = `${NGN.coalesce(prefix, '')}${eventName}`\n\n          if (NGN.isFn(group[eventName])) {\n            this.increaseMaxListeners()\n\n            pool[eventName] = this.on(topic, group[eventName])\n          } else if (typeof group[eventName] === 'object') {\n            this.pool(`${topic}.`, group[eventName])\n          } else {\n            NGN.WARN(`${topic} could not be pooled in the event emitter because it's value is not a function.`)\n          }\n        }\n      }),\n\n      /**\n       * @method attach\n       * Attach a function to a topic. This can be used\n       * to forward events in response to asynchronous functions.\n       *\n       * For example:\n       *\n       * ```js\n       * myAsyncDataFetch(NGN.BUS.attach('topicName'))\n       * ```\n       *\n       * This is the same as:\n       *\n       * ```js\n       * myAsyncCall(function(data){\n       *  NGN.BUS.emit('topicName', data)\n       * })\n       * ```\n       * @param {string} eventName\n       * The name of the event to attach a handler method to.\n       * @param {boolean} [preventDefaultAction=false]\n       * Setting this to `true` will execute a `event.preventDefault()` before\n       * attaching the handler.\n       * @returns {function}\n       * Returns a function that will automatically be associated with an event.\n       */\n      attach: NGN.const(function (eventName, preventDefaultAction) {\n        preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\n\n        return (e) => {\n          if (preventDefaultAction && !NGN.nodelike) {\n            e.preventDefault()\n          }\n\n          this.emit(eventName, ...arguments)\n        }\n      }),\n\n      /**\n       * @method increaseMaxListeners\n       * Increase the number of maximum listeners.\n       * @param {Number} [value = 1]\n       * The number of events the max listener account will be increased by.\n       * @private\n       */\n      increaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() + count)\n      }),\n\n      /**\n       * @method decreaseMaxListeners\n       * Decrease the number of maximum listeners.\n       * @param {Number} [value = 1]\n       * The number of events the max listener account will be decreased by.\n       * @private\n       */\n      decreaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() - count)\n      }),\n\n      /**\n       * @method forward\n       * A special subscriber that fires one or more event in response to\n       * to an event. This is used to bubble events up/down an event chain.\n       *\n       * For example:\n       *\n       * ```js\n       * NGN.BUS.forward('sourceEvent', ['someEvent','anotherEvent'], {payload:true})\n       * ```\n       * When `sourceEvent` is published, the bind method triggers `someEvent` and\n       * `anotherEvent`, passing the payload object to `someEvent` and\n       * `anotherEvent` subscribers simultaneously.\n       *\n       * To forward an event to another EventEmitter, see #relay.\n       * @param {String} sourceEvent\n       * The event to subscribe to.\n       * @param {String|Array} triggeredEvent\n       * An event or array of events to fire in response to the sourceEvent.\n       * @param {any} data\n       * Optional data to pass to each bound event handler.\n       * @returns {Object}\n       * Returns an object with a single `remove()` method.\n       */\n      forward: NGN.const(function (eventName, triggers, payload) {\n        triggers = NGN.forceArray(triggers)\n\n        let me = this\n        let listener = function () {\n          let args = NGN.slice(arguments)\n\n          if (payload) {\n            args.push(payload)\n          }\n\n          me.emit(triggers, ...args)\n        }\n\n        this.increaseMaxListeners()\n        this.on(eventName, listener)\n\n        // Provide handle back for removal of topic\n        return {\n          remove: () => {\n            this.decreaseMaxListeners()\n            this.off(eventName, listener)\n          }\n        }\n      }),\n\n      /**\n       * This relays an entire event to a different event emitter.\n       * For example:\n       *\n       * ```js\n       * let emitterA = new NGN.EventEmitter()\n       * let emitterB = new NGN.EventEmitter()\n       *\n       * emitterA.relay('my.event', emitterB)\n       *\n       * emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n       *\n       * emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n       * ```\n       * @param  {string} eventName\n       * The name of the event to listen for.\n       * @param  {NGN.EventEmitter} targetEmitter\n       * The emitter to relay the event to.\n       * @param {string} [prefix]\n       * An optional prefix to prepend to the eventName.\n       * @param {string} [postfix]\n       * An optional postfix to append to the eventName.\n       */\n      relay: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.on(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      }),\n\n      /**\n       * This relays an entire event to a different event emitter. This is\n       * the same as #relay, but the event handler is removed after the\n       * first invocation of the event.\n       *\n       * For example:\n       *\n       * ```js\n       * let emitterA = new NGN.EventEmitter()\n       * let emitterB = new NGN.EventEmitter()\n       *\n       * emitterA.relayOnce('my.event', emitterB)\n       *\n       * emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n       *\n       * emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n       * emitterA.emit('my.event') // Does nothing\n       * ```\n       * @param  {string} eventName\n       * The name of the event to listen for.\n       * @param  {NGN.EventEmitter} targetEmitter\n       * The emitter to relay the event to.\n       * @param {string} [prefix]\n       * An optional prefix to prepend to the eventName.\n       * @param {string} [postfix]\n       * An optional postfix to append to the eventName.\n       */\n      relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.once(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      }),\n\n      /**\n       * @method delayEmit\n       * This method waits for the specified duration, then publishes an\n       * event once. This will publish the event only once at the end of the\n       * wait period, even if the event is triggered multiple times. This can\n       * be useful when working with many events triggered in rapid succession.\n       *\n       * For example, an NGN.DATA.Model representing a person may be used to\n       * track a user profile. The NGN.DATA.Model fires an event called `field.update`\n       * every time a data field is modified. In many cases, a user may update\n       * multiple fields of their profile using a form with a \"Save\" button.\n       * Instead of generating a new \"save\" (to disk, to memory, to an API, etc)\n       * operation for each field, the publishOnce event can wait until all\n       * changes are made before running the save operation.\n       *\n       * ```js\n       * // Create a data model representing a person.\n       * var Person = new NGN.DATA.Model({....})\n       *\n       * // Create a new person record for a user.\n       * var user = new Person()\n       *\n       * // When the user is modified, save the data.\n       * user.on('field.update', function () {\n       *   // Wait 300 milliseconds to trigger the save event\n       *   NGN.BUS.delayEmit('user.save', 300)\n       * })\n       *\n       * // Save the user using an API\n       * NGN.BUS.on('user.save', function () {\n       *   NGN.NET.put({\n       *     url: 'https://my.api.com/user',\n       *     json: user.data\n       *   })\n       * })\n       *\n       * // Modify the record attributes (which are blank by default)\n       * user.firstname = 'John'\n       * user.lastname = 'Doe'\n       * user.age = 42\n       *\n       * // Make another update 1 second later\n       * setTimeout(function () {\n       *   user.age = 32\n       * }, 1000)\n       * ```\n       *\n       * The code above sets up a model and record. Then it listens to the record\n       * for field updates. Each time it recognizes an update, it queues the \"save\"\n       * event. When the queue matures, it fires the `user.save` event.\n       *\n       * The first `field.update` is triggered when `user.firstname = 'John'` runs.\n       * This initiates a queue for `user.save`, set to mature in 300 millisenconds.\n       * Next, a `field.update` is triggered when `user.lastname = 'Doe'` runs.\n       * This time, since the queue for `user.save` is already initiated, notthing\n       * new happens. Finally, a `field.update` is triggered when `user.age = 42`\n       * runs. Just like the last one, nothing happens since the `user.save` queue\n       * is already active.\n       *\n       * The `user.save` queue \"matures\" after 300 milliseconds. This means after\n       * 300 milliseconds have elapsed, the `user.save` event is triggered. In this\n       * example, it means the `NGN.NET.put()` code will be executed. As a result,\n       * all 3 change (firstname, lastname, and age) will be complete before the\n       * API request is executed. The queue is cleared immediately.\n       *\n       * The final update occurs 1 second later (700 milliseconds after the queue\n       * matures). This triggers a `field.update`, but since the queue is no\n       * longer active, it is re-initiated. 300 milliseconds later, the `user.save`\n       * event is fired again, thus executing the API request again (1.3 seconds\n       * in total).\n       * @param {string} eventName\n       * The event/topic to publish/emit.\n       * @param {Number} [delay=300]\n       * The number of milliseconds to wait before firing the event.\n       * @param {Any} [payload]\n       * An optional payload, such as data to be passed to an event handler.\n       */\n      delayEmit: NGN.const(function (eventName, delay) {\n        if (!this.META.queued.hasOwnProperty(eventName)) {\n          let args = NGN.slice(arguments)\n          args.splice(1, 1)\n\n          this.META.queued[eventName] = setTimeout(() => {\n            delete this.META.queued[eventName]\n            this.emit(...args)\n          }, delay)\n        }\n      }),\n\n      /**\n       * @method getInternalCollectionId\n       * Returns a unique ID for special collections.\n       * @param {object} collection\n       * The collection to generate an ID for.\n       * @private\n       */\n      getInternalCollectionId: NGN.privateconst(function (collection) {\n        return Symbol(collection)\n        // let time = (new Date()).getTime().toString()\n        // let rand = Math.random().toString()\n        // let key = Object.keys(collection).length + 1\n        //\n        // while (collection.hasOwnProperty(`${key.toString()}${time}${rand}`)) {\n        //   key++\n        // }\n        //\n        // return `${key.toString()}${time}${rand}`\n      }),\n\n      /**\n       * @method handleCollectionTrigger\n       * A method to manage #chain event handlers.\n       * @private\n       */\n      handleCollectionTrigger: NGN.privateconst(function (eventName, key) {\n        let me = this\n\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            let cq = me.META.collectionQueue\n\n            if (cq[key]) {\n              cq[key].remainingqueue.delete(eventName)\n\n              if (cq[key].remainingqueue.size === 0) {\n                cq[key].remainingqueue = cq[key].masterqueue\n\n                if (NGN.isFn(cq[key].eventName)) {\n                  cq[key].eventName(cq[key].payload)\n                } else {\n                  me.emit(cq[key].eventName, cq[key].payload)\n                }\n              }\n            }\n          }, 0)\n        }\n      }),\n\n      /**\n       * @method funnel\n       * Emit an event after a collection of unique events have all fired.\n       * This can be useful in situations where multiple asynchronous actions\n       * must complete before another begins. For example, blending 3\n       * remote data sources from different API's into a single resultset\n       * can be achieved with this.\n       *\n       * **Example**\n       * ```js\n       * let collection = NGN.BUS.funnel(['download1done', 'download2done', 'download3done'], 'make.results')\n       *\n       * let allData = []\n       *\n       * // When all of the downloads are done, log them.\n       * NGN.BUS.on('make.results', () => {\n       *   console.log(allData)\n       * })\n       *\n       * // Download the first set of data asynchronously\n       * NGN.NET.json('http:/download1.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download1done')\n       * })\n       *\n       * // Download the second set of data asynchronously\n       * NGN.NET.json('http:/download2.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download2done')\n       * })\n       *\n       * // Download the third set of data asynchronously\n       * NGN.NET.json('http:/download3.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download3done')\n       * })\n       *\n       * // The handler can be removed with the special method:\n       * collection.remove()\n       * ```\n       * @param {array} eventCollection\n       * An array of events. Once _all_ of these events have fired,\n       * the triggerEventName will be fired.\n       * @param {string|function} triggerEventName\n       * The name of the event triggered after the collection has completed.\n       * This can also be a callback function. If a callback function is provided,\n       * it will receive the payload as the only argument when it is triggered.\n       * @param {any} [payload]\n       * An optional payload delivered to the #triggerEventName.\n       * @returns {object} collection\n       * Provides the key/value configuration of the collection.\n       * ```js\n       * {\n       *   masterqueue: ['event1', 'event2', 'etc'], // The original event array (non-editable)\n       *   remainingqueue: [...], // The events the BUS is still waiting for before firing the trigger event.\n       *   eventName: 'triggeredEventName', // Name of the event triggered after the remaining elements are flushed.\n       *   payload: 'anything', // OPTIONAL\n       *   remove: [Function]\n       * }\n       * ```\n       */\n      funnel: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        if (NGN.typeof(eventCollection) !== 'array') {\n          throw new Error(`NGN.BUS.funnel expected an array of events, but received a(n) ${NGN.typeof(eventCollection)}`)\n        }\n\n        let collection = new Set(eventCollection)\n        let key = this.getInternalCollectionId(this.META.collectionQueue)\n\n        this.META.collectionQueue[key] = {}\n\n        Object.defineProperties(this.META.collectionQueue[key], {\n          masterqueue: NGN.const(new Set(eventCollection)),\n          remainingqueue: NGN.private(collection),\n          eventName: NGN.const(triggerEventName),\n          remove: NGN.const(() => {\n            this.META.collectionQueue[key].masterqueue.forEach(event => {\n              this.off(event, this.handleCollectionTrigger(event, key))\n            })\n\n            this.decreaseMaxListeners(this.META.collectionQueue[key].masterqueue.size)\n\n            delete this.META.collectionQueue[key]\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners(collection.size)\n\n        collection.forEach(event => {\n          this.on(event, this.handleCollectionTrigger(event, key))\n        })\n\n        return this.META.collectionQueue[key]\n      }),\n\n      /**\n       * @method funnelOnce\n       * This provides the same functionality as #funnel, but\n       * removes the listener after the resultant event has fired.\n       * See #funnel for detailed usage.\n       * @param {array} eventCollection\n       * An array of events. Once _all_ of these events have fired,\n       * the triggerEventName will be fired.\n       * @param {string} triggerEventName\n       * The name of the event triggered after the collection has completed.\n       * @param {any} [payload]\n       * An optional payload delivered to the #triggerEventName.\n       * @returns {object} collection\n       * Provides the key/value configuration of the collection.\n       */\n      funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\n        // let funnelClosureEvent = Symbol(triggerEventName)\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\n\n        this.increaseMaxListeners()\n        this.once(funnelClosureEvent, () => {\n          collection.remove()\n          collection = null\n          this.emit(triggerEventName, payload)\n        })\n      }),\n\n      /**\n       * @method threshold\n       * After an event is fired a predetermined number of times (the threshold),\n       * trigger another event or function.\n       *\n       * For example:\n       *\n       * ```js\n       * NGN.BUS.threshold('push.my.button', 3, 'annoyed')\n       *\n       * NGN.BUS.on('annoyed', function () {\n       *   console.log('We apologize for the slow response, but excessive clicking will not speed up the process.')\n       * })\n       *\n       * document.getElementById('#myButton').addEventListener('click', NGN.BUS.attach('push.my.button'))\n       * ```\n       *\n       * Once the threshold is exceeded, the final event will be triggered and\n       * the threshold will be reset. Using the example above, this means\n       * clicking 3 times on `#myButton` would trigger the `annoyed` event ONCE,\n       * 6 times triggers `annoyed` TWICE, 9 times triggers `annoyed` THREE times, etc.\n       * @param {string} thresholdEventName\n       * The name of the event to count.\n       * @param {number} limit\n       * The number of occurrances allowed until the final event is triggered.\n       * The event will be triggered at the threshold. For example, if the limit\n       * is `3`, the finalEvent will be triggered the 3rd time thresholdEventName is\n       * fired.\n       * @param {string|function} finalEventName\n       * This can be an event or callback function triggered when the threshold is crossed.\n       * If a callback function is specified, the payload is passed as the only argument.\n       * @param {any} [payload]\n       * An optional payload to send to the finalEvent handler(s).\n       * @returns {object}\n       * Returns an object that can be used to remove the threshold.\n       *\n       */\n      threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        if (typeof thresholdEventName !== 'string') {\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\n        }\n\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\n\n        this.META.thresholdQueue[key] = {}\n\n        Object.defineProperties(this.META.thresholdQueue[key], {\n          key: NGN.const(key),\n          eventName: NGN.const(thresholdEventName),\n          limit: NGN.const(limit),\n          count: NGN.private(0),\n          finalEventName: NGN.const(finalEventName),\n          remove: NGN.const(() => {\n            let event = this.META.thresholdQueue[key].eventName\n\n            delete this.META.thresholdQueue[key]\n\n            this.decreaseMaxListeners()\n            this.off(event, this.handleThresholdTrigger(key))\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners()\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\n\n        return this.META.thresholdQueue[key]\n      }),\n\n      thresholdOnce: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        let thresholdClosureEvent = `::NGNTHRESHOLD::${(new Date()).getTime()}::${finalEventName}`\n        let threshold = this.threshold(thresholdEventName, limit, thresholdClosureEvent, payload)\n\n        this.once(thresholdClosureEvent, () => {\n          threshold.remove()\n          threshold = null\n          this.emit(finalEventName, payload)\n        })\n      }),\n\n      /**\n       * @method handleThresholdTrigger\n       * A method to manage #threshold event handlers.\n       * @private\n       */\n      handleThresholdTrigger: NGN.const(function (key) {\n        let me = this\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            if (me.META.thresholdQueue.hasOwnProperty(key)) {\n              me.META.thresholdQueue[key].count++\n              if (me.META.thresholdQueue[key].count === me.META.thresholdQueue[key].limit) {\n                if (NGN.isFn(me.META.thresholdQueue[key].finalEventName)) {\n                  me.META.thresholdQueue[key].finalEventName(me.META.thresholdQueue[key].payload)\n                } else {\n                  me.emit(me.META.thresholdQueue[key].finalEventName, me.META.thresholdQueue[key].payload)\n                }\n\n                // This if statement is required in case the event is removed\n                // during the reset process.\n                if (me.META.thresholdQueue.hasOwnProperty(key)) {\n                  me.META.thresholdQueue[key].count = 0\n                }\n              }\n            }\n          }, 0)\n        }\n      }),\n\n      /**\n       * An internal method to wrap node-based event handlers\n       * with the proper scope.\n       * @param {string} eventName\n       * The name of the event being handled.\n       * @param {function} handlerFn\n       * The handler function.\n       */\n      wrapEventHandlerWithScope: NGN.privateconst((name, fn) => {\n        if (!NGN.nodelike) {\n          return fn\n        }\n\n        const handlerFn = fn\n\n        return function () {\n          let args = arguments\n\n          if (typeof args[args.length - 1] === 'symbol') {\n            name = args[args.length - 1].toString().replace(/Symbol\\(|\\)/gi, '')\n            args = NGN.slice(args)\n            args.pop()\n          }\n\n          handlerFn.apply({ event: name }, args)\n        }\n      }),\n\n      /**\n       * An internal method to apply scope based on whether the handler\n       * is a Node-like \"once\" emitter or not.\n       * @param {string} eventName\n       * The name of the event being scoped.\n       * @param {function} handlerFn\n       * The handler function.\n       */\n      applyScope: NGN.privateconst((args) => {\n        if (NGN.nodelike && args.length > 1) {\n          if (args[args.length - 1].listener) {\n            args[args.length - 1].listener = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1].listener\n            )\n          } else {\n            args[args.length - 1] = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1]\n            )\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * @alias clear\n   * Remove all event handlers from the EventEmitter (both regular and adhoc).\n   * This is a shortcut for #removeAllListeners.\n   */\n  clear () {\n    let events = NGN.slice(arguments)\n\n    if (events.length === 0) {\n      this.META.wildcardEvents.clear()\n\n      let symbolEvents = []\n\n      if (NGN.nodelike) {\n        symbolEvents = Object.getOwnPropertySymbols(this._events)\n      } else {\n        symbolEvents = Object.getOwnPropertySymbols(this.adhoc)\n        symbolEvents = symbolEvents.concat(Object.getOwnPropertySymbols(this.handlers))\n      }\n\n      for (let i = 0; i < symbolEvents.length; i++) {\n        this.removeAllListeners(symbolEvents[i])\n      }\n\n      return this.removeAllListeners()\n    }\n\n    for (let i = 0; i < events.length; i++) {\n      this.META.wildcardEvents.delete(events[i])\n      this.removeAllListeners(events[i])\n    }\n  }\n\n  // Internal method used to handle TTL and wildcard management.\n  eventHandler (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(ttl) === 'boolean') {\n      prepend = ttl\n      ttl = this.META.defaultTTL\n    }\n\n    if (ttl === undefined) {\n      ttl = this.META.defaultTTL\n    }\n\n    if (ttl > 0) {\n      setTimeout(() => this.off(eventName, callback), ttl)\n    }\n\n    if (typeof eventName === 'string' && eventName.indexOf('*') >= 0) {\n      this.META.wildcardEvents.add(eventName)\n    }\n\n    return prepend\n  }\n\n  /**\n   * @method on\n   * Create a new event handler for the specified event.\n   * @param  {string|string[]|object} eventName\n   * Name of the event to listen for.\n   * If an object is passed, this method will automatically setup a #pool.\n   * @param  {function} handler\n   * The method responsible for responding to the event.\n   * This is ignored if eventName is an object.\n   * @param {number} [TTL]\n   * Time-To-Live is the number of milliseconds before the event handler\n   * is automatically removed. This is useful for automatically cleaning\n   * up limited-life event handlers.\n   * @param {boolean} [prepend=false]\n   * When set to `true`, the event is added to the beginning of\n   * the processing list instead of the end.\n   * This is ignored if eventName is an object.\n   */\n  on (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(eventName) === 'array') {\n      for (let i = 0; i < eventName.length; i++) {\n        this.on(eventName[i], callback, ttl, prepend)\n      }\n\n      return\n    }\n\n    if (this.eventHandler(...arguments)) {\n      this.prependListener(eventName, callback)\n    } else {\n      this.addListener(eventName, callback)\n    }\n  }\n\n  /**\n   * @method once\n   * Create a new event handler for the specified event. The\n   * handler will be removed immediately after it is executed. This\n   * effectively listens for an event to happen once and only once\n   * before the handler is destroyed.\n   * @param  {string} eventName\n   * Name of the event to listen for.\n   * @param  {Function} handler\n   * The method responsible for responding to the event.\n   * @param {boolean} [prepend=false]\n   * When set to `true`, the event is added to the beginning of\n   * the processing list instead of the end.\n   */\n  once (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(eventName) === 'array') {\n      for (let i = 0; i < eventName.length; i++) {\n        this.once(eventName[i], callback, ttl, prepend)\n      }\n\n      return\n    }\n\n    if (this.eventHandler(...arguments)) {\n      this.prependOnceListener(eventName, callback)\n    } else {\n      super.once(eventName, this.wrapEventHandlerWithScope(eventName, callback))\n    }\n  }\n\n  // The following methods override the Node event emitter only when necessary.\n  prependListener () {\n    this.applyScope(arguments)\n    super.prependListener(...arguments)\n  }\n\n  prependOnceListener () {\n    this.applyScope(arguments)\n    super.prependOnceListener(...arguments)\n  }\n\n  addListener () {\n    this.applyScope(arguments)\n    super.addListener(...arguments)\n  }\n\n  removeListener () {\n    if (arguments[arguments.length - 1] !== true) {\n      this.applyScope(arguments)\n    }\n\n    super.removeListener(...arguments)\n  }\n\n  /**\n   * @method emit\n   * Emits an event.\n   * @param {string[]} eventName\n   * The event name can be a string or an array of strings. If an array\n   * of strings is specified, an event will be fired for each event name\n   * within the array.\n   * @param {any} [payload]\n   * An optional payload. This can be any number of additional arguments.\n   */\n  emit () {\n    if (NGN.typeof(arguments[0]) === 'array') {\n      let args = NGN.slice(arguments)\n      let eventNames = args.shift()\n\n      for (let i = 0; i < eventNames.length; i++) {\n        this.emit(eventNames[i], ...args)\n      }\n\n      return\n    }\n\n    // This catches non-string event names. NGN internally uses Symbols\n    // for the NGN.WARN/INFO/ERROR event names to prevent name collisions.\n    // This check provides support for these special events. These types\n    // of events will never have wildcards.\n    if (!NGN.nodelike || !arguments[0] || this.META.wildcardEvents.size === 0) {\n      super.emit(...arguments)\n      return\n    }\n\n    if (NGN.nodelike && typeof arguments[0] === 'symbol') {\n      super.emit(...arguments)\n      return\n    }\n\n    /**\n     * The NGN browser-based event emitter supports wildcards natively, but\n     * Node.js does not. This adds simple wildcard support for Node. The\n     * only wildcard character supported at this time is `*`. This feature\n     * will check the event name for the existance of a wildcard. If a\n     * wilcard character is present, the internally-maintained list of\n     * wildcard events is checked to see if it's a known event. If none\n     * of these checks pass, the standard event emitter is used, otherwise\n     * special wildcard handling is used.\n     */\n    let iterator = this.META.wildcardEvents.values()\n    let currentEvent = null\n    let args = NGN.slice(arguments)\n\n    args.shift()\n\n    while (currentEvent === null || !currentEvent.done) {\n      if (currentEvent !== null && currentEvent.value !== arguments[0]) {\n        let pattern = new RegExp(currentEvent.value.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\n\n        if (pattern.test(arguments[0])) {\n          super.emit(currentEvent.value, ...args, typeof arguments[0] !== 'symbol' ? Symbol(arguments[0]) : arguments[0])\n          break\n        }\n      }\n\n      currentEvent = iterator.next()\n    }\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 24,
        "column": 15
      },
      "end": {
        "line": 1017,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./emitter/core.js",
      "extends": "EEmitter",
      "configuration": {},
      "properties": {
        "META": {
          "type": "property",
          "label": "META",
          "description": null,
          "code": "META: NGN.private({\n        queued: {},\n        collectionQueue: {},\n        thresholdQueue: {},\n        defaultTTL: -1,\n        wildcardEvents: new Set()\n      })",
          "start": {
            "line": 33,
            "column": 6
          },
          "end": {
            "line": 39,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "setTTL": {
          "type": "property",
          "label": "setTTL",
          "description": "Set a default time-to-live for event handlers .\nAfter the TTL period elapses, event handlers are removed.\nBy default, there is no TTL (`-1`).",
          "code": "setTTL: NGN.const((ttl = -1) => {\n        if (ttl === 0) {\n          NGN.WARN('NGN.EventEmitter#TTL cannot be 0.')\n          return\n        }\n\n        this.META.defaultTTL = ttl\n      })",
          "start": {
            "line": 51,
            "column": 6
          },
          "end": {
            "line": 58,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "off": {
          "type": "property",
          "label": "off",
          "description": "Remove an event handler. If no handler is specified, all handlers for\n      the specified event will be removed.\n      This is a shortcut for #removeListener.\n      \n      Name of the event to remove.\n      \n      The handler function to remove from the event handlers.",
          "code": "off: NGN.public((eventName, handlerFn) => {\n        if (NGN.typeof(eventName) === 'array') {\n          for (let i = 0; i < eventName.length; i++) {\n            this.off(eventName[i], handlerFn)\n          }\n\n          return\n        }\n\n        let l = this.listeners(eventName)\n\n        if (!NGN.isFn(handlerFn)) {\n          return this.clear(eventName)\n        }\n\n        let wrappedHandlerFn = this.wrapEventHandlerWithScope(eventName, handlerFn)\n\n        if (l.indexOf(wrappedHandlerFn) < 0) {\n          for (let i = 0; i < l.length; i++) {\n            if (l[i].toString() === wrappedHandlerFn.toString()) {\n              this.META.wildcardEvents.delete(eventName)\n              // this.removeListener(eventName, handlerFn)\n              this.removeListener(eventName, l[i], false)\n              break\n            }\n          }\n        } else {\n          this.META.wildcardEvents.delete(eventName)\n          this.removeListener(eventName, handlerFn)\n        }\n      })",
          "start": {
            "line": 70,
            "column": 6
          },
          "end": {
            "line": 100,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "deprecate": {
          "type": "property",
          "label": "deprecate",
          "description": "Provides a deprecation notice for the specified event.\nAutomatically emits the appropriate \"replacement\" event\nif a replacement event is configured. If no replacement\nevent is configured, the deprecation notice will be written\nto the console but no replacement event will be triggered.",
          "code": "deprecate: NGN.const((deprecatedEventName, replacementEventName) => {\n        const me = this\n\n        this.on(deprecatedEventName, function () {\n          NGN.WARN(`${deprecatedEventName} is deprecated. ` + (!replacementEventName ? '' : `Use ${replacementEventName} instead.`))\n\n          if (replacementEventName) {\n            let args = NGN.slice(arguments)\n\n            args.shift()\n            args.unshift(replacementEventName)\n\n            me.emit.apply(me, args)\n          }\n        })\n      })",
          "start": {
            "line": 114,
            "column": 6
          },
          "end": {
            "line": 129,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "subscriberObject": {
          "type": "property",
          "label": "subscriberObject",
          "description": "A key:value object where the key is the name of the\nunprefixed event and the key is the handler function.\nA value can be an object, allowing for nesting events. For example:\n\n```js\nNGN.BUS.pool('prefix.', {\ndeep: {\nnested: {\neventName: function  {\nconsole.log('event triggered')\n}\n}\n}\n})\n\nNGN.BUS.emit('prefix.deep.nested.eventName') // <-- Outputs \"event triggered\"\n```",
          "code": "pool: NGN.privateconst(function (prefix, group) {\n        if (typeof prefix !== 'string') {\n          group = prefix\n          prefix = ''\n        }\n\n        let pool = {}\n\n        for (let eventName in group) {\n          let topic = `${NGN.coalesce(prefix, '')}${eventName}`\n\n          if (NGN.isFn(group[eventName])) {\n            this.increaseMaxListeners()\n\n            pool[eventName] = this.on(topic, group[eventName])\n          } else if (typeof group[eventName] === 'object') {\n            this.pool(`${topic}.`, group[eventName])\n          } else {\n            NGN.WARN(`${topic} could not be pooled in the event emitter because it's value is not a function.`)\n          }\n        }\n      })",
          "start": {
            "line": 158,
            "column": 6
          },
          "end": {
            "line": 179,
            "column": 8
          },
          "flags": [],
          "default": null,
          "datatype": "object",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "attach": {
          "type": "property",
          "label": "attach",
          "description": "Attach a function to a topic. This can be used\nto forward events in response to asynchronous functions.\n\nFor example:\n\n```js\nmyAsyncDataFetch\n```\n\nThis is the same as:\n\n```js\nmyAsyncCall(function(data){\nNGN.BUS.emit('topicName', data)\n})\n```",
          "code": "attach: NGN.const(function (eventName, preventDefaultAction) {\n        preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\n\n        return (e) => {\n          if (preventDefaultAction && !NGN.nodelike) {\n            e.preventDefault()\n          }\n\n          this.emit(eventName, ...arguments)\n        }\n      })",
          "start": {
            "line": 207,
            "column": 6
          },
          "end": {
            "line": 217,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "increaseMaxListeners": {
          "type": "property",
          "label": "increaseMaxListeners",
          "description": "Increase the number of maximum listeners.",
          "code": "increaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() + count)\n      })",
          "start": {
            "line": 226,
            "column": 6
          },
          "end": {
            "line": 228,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "decreaseMaxListeners": {
          "type": "property",
          "label": "decreaseMaxListeners",
          "description": "Decrease the number of maximum listeners.",
          "code": "decreaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() - count)\n      })",
          "start": {
            "line": 237,
            "column": 6
          },
          "end": {
            "line": 239,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "forward": {
          "type": "property",
          "label": "forward",
          "description": "A special subscriber that fires one or more event in response to\nto an event. This is used to bubble events up/down an event chain.\n\nFor example:\n\n```js\nNGN.BUS.forward\n```\nWhen `sourceEvent` is published, the bind method triggers `someEvent` and\n`anotherEvent`, passing the payload object to `someEvent` and\n`anotherEvent` subscribers simultaneously.\n\nTo forward an event to another EventEmitter, see #relay.",
          "code": "forward: NGN.const(function (eventName, triggers, payload) {\n        triggers = NGN.forceArray(triggers)\n\n        let me = this\n        let listener = function () {\n          let args = NGN.slice(arguments)\n\n          if (payload) {\n            args.push(payload)\n          }\n\n          me.emit(triggers, ...args)\n        }\n\n        this.increaseMaxListeners()\n        this.on(eventName, listener)\n\n        // Provide handle back for removal of topic\n        return {\n          remove: () => {\n            this.decreaseMaxListeners()\n            this.off(eventName, listener)\n          }\n        }\n      })",
          "start": {
            "line": 265,
            "column": 6
          },
          "end": {
            "line": 289,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "relay": {
          "type": "property",
          "label": "relay",
          "description": "This relays an entire event to a different event emitter.\n      For example:\n            ```js\n      let emitterA = new NGN.EventEmitter()\n      let emitterB = new NGN.EventEmitter()\n            emitterA.relay('my.event', emitterB)\n            emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n            emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n      ```\n      \n      The name of the event to listen for.\n      \n      The emitter to relay the event to.\n      \n      An optional prefix to prepend to the eventName.\n      \n      An optional postfix to append to the eventName.",
          "code": "relay: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.on(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      })",
          "start": {
            "line": 314,
            "column": 6
          },
          "end": {
            "line": 332,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "relayOnce": {
          "type": "property",
          "label": "relayOnce",
          "description": "This relays an entire event to a different event emitter. This is\n      the same as #relay, but the event handler is removed after the\n      first invocation of the event.\n            For example:\n            ```js\n      let emitterA = new NGN.EventEmitter()\n      let emitterB = new NGN.EventEmitter()\n            emitterA.relayOnce('my.event', emitterB)\n            emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n            emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n      emitterA.emit('my.event') // Does nothing\n      ```\n      \n      The name of the event to listen for.\n      \n      The emitter to relay the event to.\n      \n      An optional prefix to prepend to the eventName.\n      \n      An optional postfix to append to the eventName.",
          "code": "relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.once(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      })",
          "start": {
            "line": 361,
            "column": 6
          },
          "end": {
            "line": 379,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "delayEmit": {
          "type": "property",
          "label": "delayEmit",
          "description": "This method waits for the specified duration, then publishes an\nevent once. This will publish the event only once at the end of the\nwait period, even if the event is triggered multiple times. This can\nbe useful when working with many events triggered in rapid succession.\n\nFor example, an NGN.DATA.Model representing a person may be used to\ntrack a user profile. The NGN.DATA.Model fires an event called `field.update`\nevery time a data field is modified. In many cases, a user may update\nmultiple fields of their profile using a form with a \"Save\" button.\nInstead of generating a new \"save\" \noperation for each field, the publishOnce event can wait until all\nchanges are made before running the save operation.\n\n```js\n// Create a data model representing a person.\nvar Person = new NGN.DATA.Model({....})\n\n// Create a new person record for a user.\nvar user = new Person()\n\n// When the user is modified, save the data.\nuser.on('field.update', function () {\n// Wait 300 milliseconds to trigger the save event\nNGN.BUS.delayEmit('user.save', 300)\n})\n\n// Save the user using an API\nNGN.BUS.on('user.save', function () {\nNGN.NET.put({\nurl: 'https://my.api.com/user',\njson: user.data\n})\n})\n\n// Modify the record attributes (which are blank by default)\nuser.firstname = 'John'\nuser.lastname = 'Doe'\nuser.age = 42\n\n// Make another update 1 second later\nsetTimeout(function () {\nuser.age = 32\n}, 1000)\n```\n\nThe code above sets up a model and record. Then it listens to the record\nfor field updates. Each time it recognizes an update, it queues the \"save\"\nevent. When the queue matures, it fires the `user.save` event.\n\nThe first `field.update` is triggered when `user.firstname = 'John'` runs.\nThis initiates a queue for `user.save`, set to mature in 300 millisenconds.\nNext, a `field.update` is triggered when `user.lastname = 'Doe'` runs.\nThis time, since the queue for `user.save` is already initiated, notthing\nnew happens. Finally, a `field.update` is triggered when `user.age = 42`\nruns. Just like the last one, nothing happens since the `user.save` queue\nis already active.\n\nThe `user.save` queue \"matures\" after 300 milliseconds. This means after\n300 milliseconds have elapsed, the `user.save` event is triggered. In this\nexample, it means the `NGN.NET.put()` code will be executed. As a result,\nall 3 change (firstname, lastname, and age) will be complete before the\nAPI request is executed. The queue is cleared immediately.\n\nThe final update occurs 1 second later (700 milliseconds after the queue\nmatures). This triggers a `field.update`, but since the queue is no\nlonger active, it is re-initiated. 300 milliseconds later, the `user.save`\nevent is fired again, thus executing the API request again (1.3 seconds\nin total).",
          "code": "delayEmit: NGN.const(function (eventName, delay) {\n        if (!this.META.queued.hasOwnProperty(eventName)) {\n          let args = NGN.slice(arguments)\n          args.splice(1, 1)\n\n          this.META.queued[eventName] = setTimeout(() => {\n            delete this.META.queued[eventName]\n            this.emit(...args)\n          }, delay)\n        }\n      })",
          "start": {
            "line": 458,
            "column": 6
          },
          "end": {
            "line": 468,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "getInternalCollectionId": {
          "type": "property",
          "label": "getInternalCollectionId",
          "description": "Returns a unique ID for special collections.",
          "code": "getInternalCollectionId: NGN.privateconst(function (collection) {\n        return Symbol(collection)\n        // let time = (new Date()).getTime().toString()\n        // let rand = Math.random().toString()\n        // let key = Object.keys(collection).length + 1\n        //\n        // while (collection.hasOwnProperty(`${key.toString()}${time}${rand}`)) {\n        //   key++\n        // }\n        //\n        // return `${key.toString()}${time}${rand}`\n      })",
          "start": {
            "line": 477,
            "column": 6
          },
          "end": {
            "line": 488,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "handleCollectionTrigger": {
          "type": "property",
          "label": "handleCollectionTrigger",
          "description": "A method to manage #chain event handlers.",
          "code": "handleCollectionTrigger: NGN.privateconst(function (eventName, key) {\n        let me = this\n\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            let cq = me.META.collectionQueue\n\n            if (cq[key]) {\n              cq[key].remainingqueue.delete(eventName)\n\n              if (cq[key].remainingqueue.size === 0) {\n                cq[key].remainingqueue = cq[key].masterqueue\n\n                if (NGN.isFn(cq[key].eventName)) {\n                  cq[key].eventName(cq[key].payload)\n                } else {\n                  me.emit(cq[key].eventName, cq[key].payload)\n                }\n              }\n            }\n          }, 0)\n        }\n      })",
          "start": {
            "line": 495,
            "column": 6
          },
          "end": {
            "line": 518,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "funnel": {
          "type": "property",
          "label": "funnel",
          "description": "Emit an event after a collection of unique events have all fired.\nThis can be useful in situations where multiple asynchronous actions\nmust complete before another begins. For example, blending 3\nremote data sources from different API's into a single resultset\ncan be achieved with this.\n\n**Example**\n```js\nlet collection = NGN.BUS.funnel\n\nlet allData = []\n\n// When all of the downloads are done, log them.\nNGN.BUS.on('make.results', () => {\nconsole.log(allData)\n})\n\n// Download the first set of data asynchronously\nNGN.NET.json('http:/download1.com/data.json', (data) => {\nallData.push(data)\nNGN.BUS.emit('download1done')\n})\n\n// Download the second set of data asynchronously\nNGN.NET.json('http:/download2.com/data.json', (data) => {\nallData.push(data)\nNGN.BUS.emit('download2done')\n})\n\n// Download the third set of data asynchronously\nNGN.NET.json('http:/download3.com/data.json', (data) => {\nallData.push(data)\nNGN.BUS.emit('download3done')\n})\n\n// The handler can be removed with the special method:\ncollection.remove()\n```",
          "code": "funnel: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        if (NGN.typeof(eventCollection) !== 'array') {\n          throw new Error(`NGN.BUS.funnel expected an array of events, but received a(n) ${NGN.typeof(eventCollection)}`)\n        }\n\n        let collection = new Set(eventCollection)\n        let key = this.getInternalCollectionId(this.META.collectionQueue)\n\n        this.META.collectionQueue[key] = {}\n\n        Object.defineProperties(this.META.collectionQueue[key], {\n          masterqueue: NGN.const(new Set(eventCollection)),\n          remainingqueue: NGN.private(collection),\n          eventName: NGN.const(triggerEventName),\n          remove: NGN.const(() => {\n            this.META.collectionQueue[key].masterqueue.forEach(event => {\n              this.off(event, this.handleCollectionTrigger(event, key))\n            })\n\n            this.decreaseMaxListeners(this.META.collectionQueue[key].masterqueue.size)\n\n            delete this.META.collectionQueue[key]\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners(collection.size)\n\n        collection.forEach(event => {\n          this.on(event, this.handleCollectionTrigger(event, key))\n        })\n\n        return this.META.collectionQueue[key]\n      })",
          "start": {
            "line": 581,
            "column": 6
          },
          "end": {
            "line": 614,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "funnelOnce": {
          "type": "property",
          "label": "funnelOnce",
          "description": "This provides the same functionality as #funnel, but\nremoves the listener after the resultant event has fired.\nSee #funnel for detailed usage.",
          "code": "funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\n        // let funnelClosureEvent = Symbol(triggerEventName)\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\n\n        this.increaseMaxListeners()\n        this.once(funnelClosureEvent, () => {\n          collection.remove()\n          collection = null\n          this.emit(triggerEventName, payload)\n        })\n      })",
          "start": {
            "line": 631,
            "column": 6
          },
          "end": {
            "line": 642,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "threshold": {
          "type": "property",
          "label": "threshold",
          "description": "After an event is fired a predetermined number of times ,\ntrigger another event or function.\n\nFor example:\n\n```js\nNGN.BUS.threshold('push.my.button', 3, 'annoyed')\n\nNGN.BUS.on('annoyed', function () {\nconsole.log('We apologize for the slow response, but excessive clicking will not speed up the process.')\n})\n\ndocument.getElementById('#myButton').addEventListener('click', NGN.BUS.attach('push.my.button'))\n```\n\nOnce the threshold is exceeded, the final event will be triggered and\nthe threshold will be reset. Using the example above, this means\nclicking 3 times on `#myButton` would trigger the `annoyed` event ONCE,\n6 times triggers `annoyed` TWICE, 9 times triggers `annoyed` THREE times, etc.",
          "code": "threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        if (typeof thresholdEventName !== 'string') {\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\n        }\n\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\n\n        this.META.thresholdQueue[key] = {}\n\n        Object.defineProperties(this.META.thresholdQueue[key], {\n          key: NGN.const(key),\n          eventName: NGN.const(thresholdEventName),\n          limit: NGN.const(limit),\n          count: NGN.private(0),\n          finalEventName: NGN.const(finalEventName),\n          remove: NGN.const(() => {\n            let event = this.META.thresholdQueue[key].eventName\n\n            delete this.META.thresholdQueue[key]\n\n            this.decreaseMaxListeners()\n            this.off(event, this.handleThresholdTrigger(key))\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners()\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\n\n        return this.META.thresholdQueue[key]\n      })",
          "start": {
            "line": 681,
            "column": 6
          },
          "end": {
            "line": 712,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "thresholdOnce": {
          "type": "property",
          "label": "thresholdOnce",
          "description": null,
          "code": "thresholdOnce: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        let thresholdClosureEvent = `::NGNTHRESHOLD::${(new Date()).getTime()}::${finalEventName}`\n        let threshold = this.threshold(thresholdEventName, limit, thresholdClosureEvent, payload)\n\n        this.once(thresholdClosureEvent, () => {\n          threshold.remove()\n          threshold = null\n          this.emit(finalEventName, payload)\n        })\n      })",
          "start": {
            "line": 714,
            "column": 6
          },
          "end": {
            "line": 723,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "handleThresholdTrigger": {
          "type": "property",
          "label": "handleThresholdTrigger",
          "description": "A method to manage #threshold event handlers.",
          "code": "handleThresholdTrigger: NGN.const(function (key) {\n        let me = this\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            if (me.META.thresholdQueue.hasOwnProperty(key)) {\n              me.META.thresholdQueue[key].count++\n              if (me.META.thresholdQueue[key].count === me.META.thresholdQueue[key].limit) {\n                if (NGN.isFn(me.META.thresholdQueue[key].finalEventName)) {\n                  me.META.thresholdQueue[key].finalEventName(me.META.thresholdQueue[key].payload)\n                } else {\n                  me.emit(me.META.thresholdQueue[key].finalEventName, me.META.thresholdQueue[key].payload)\n                }\n\n                // This if statement is required in case the event is removed\n                // during the reset process.\n                if (me.META.thresholdQueue.hasOwnProperty(key)) {\n                  me.META.thresholdQueue[key].count = 0\n                }\n              }\n            }\n          }, 0)\n        }\n      })",
          "start": {
            "line": 730,
            "column": 6
          },
          "end": {
            "line": 753,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "wrapEventHandlerWithScope": {
          "type": "property",
          "label": "wrapEventHandlerWithScope",
          "description": "An internal method to wrap node-based event handlers\n      with the proper scope.\n      \n      The name of the event being handled.\n      \n      The handler function.",
          "code": "wrapEventHandlerWithScope: NGN.privateconst((name, fn) => {\n        if (!NGN.nodelike) {\n          return fn\n        }\n\n        const handlerFn = fn\n\n        return function () {\n          let args = arguments\n\n          if (typeof args[args.length - 1] === 'symbol') {\n            name = args[args.length - 1].toString().replace(/Symbol\\(|\\)/gi, '')\n            args = NGN.slice(args)\n            args.pop()\n          }\n\n          handlerFn.apply({ event: name }, args)\n        }\n      })",
          "start": {
            "line": 763,
            "column": 6
          },
          "end": {
            "line": 781,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "applyScope": {
          "type": "property",
          "label": "applyScope",
          "description": "An internal method to apply scope based on whether the handler\n      is a Node-like \"once\" emitter or not.\n      \n      The name of the event being scoped.\n      \n      The handler function.",
          "code": "applyScope: NGN.privateconst((args) => {\n        if (NGN.nodelike && args.length > 1) {\n          if (args[args.length - 1].listener) {\n            args[args.length - 1].listener = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1].listener\n            )\n          } else {\n            args[args.length - 1] = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1]\n            )\n          }\n        }\n      })",
          "start": {
            "line": 791,
            "column": 6
          },
          "end": {
            "line": 805,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "url": {
          "type": "property",
          "label": "url",
          "description": "The URL where the request will be sent.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "crossOriginRequest": {
          "type": "property",
          "label": "crossOriginRequest",
          "description": "Indicates the request will be made to a domain outside of the\none hosting the request.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "boolean",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "username": {
          "type": "property",
          "label": "username",
          "description": "The username that will be used in any basic authentication operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "password": {
          "type": "property",
          "label": "password",
          "description": "It is possible to set a password for any basic authentication operations,\nbut it is not possible to read a password.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "accessToken": {
          "type": "property",
          "label": "accessToken",
          "description": "Supply a bearer access token for basic authenticaiton operations.",
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": false,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor () {\n    super()\n\n    // const INSTANCE = Symbol('instance')\n\n    Object.defineProperties(this, {\n      // META: NGN.get(() => this[INSTANCE]),\n\n      META: NGN.private({\n        queued: {},\n        collectionQueue: {},\n        thresholdQueue: {},\n        defaultTTL: -1,\n        wildcardEvents: new Set()\n      }),\n\n      /**\n       * @method setTTL\n       * Set a default time-to-live for event handlers (in milliseconds).\n       * After the TTL period elapses, event handlers are removed.\n       * By default, there is no TTL (`-1`).\n       * @param {number} ttl\n       * The number of milliseconds before an event handler is automatically\n       * removed. This value may be `-1` (no TTL/never expires) or a value\n       * greater than `0`.\n       */\n      setTTL: NGN.const((ttl = -1) => {\n        if (ttl === 0) {\n          NGN.WARN('NGN.EventEmitter#TTL cannot be 0.')\n          return\n        }\n\n        this.META.defaultTTL = ttl\n      }),\n\n      /**\n       * @alias off\n       * Remove an event handler. If no handler is specified, all handlers for\n       * the specified event will be removed.\n       * This is a shortcut for #removeListener.\n       * @param {string} eventName\n       * Name of the event to remove.\n       * @param {function} [handlerFn]\n       * The handler function to remove from the event handlers.\n       */\n      off: NGN.public((eventName, handlerFn) => {\n        if (NGN.typeof(eventName) === 'array') {\n          for (let i = 0; i < eventName.length; i++) {\n            this.off(eventName[i], handlerFn)\n          }\n\n          return\n        }\n\n        let l = this.listeners(eventName)\n\n        if (!NGN.isFn(handlerFn)) {\n          return this.clear(eventName)\n        }\n\n        let wrappedHandlerFn = this.wrapEventHandlerWithScope(eventName, handlerFn)\n\n        if (l.indexOf(wrappedHandlerFn) < 0) {\n          for (let i = 0; i < l.length; i++) {\n            if (l[i].toString() === wrappedHandlerFn.toString()) {\n              this.META.wildcardEvents.delete(eventName)\n              // this.removeListener(eventName, handlerFn)\n              this.removeListener(eventName, l[i], false)\n              break\n            }\n          }\n        } else {\n          this.META.wildcardEvents.delete(eventName)\n          this.removeListener(eventName, handlerFn)\n        }\n      }),\n\n      /**\n       * @method deprecate\n       * Provides a deprecation notice for the specified event.\n       * Automatically emits the appropriate \"replacement\" event\n       * if a replacement event is configured. If no replacement\n       * event is configured, the deprecation notice will be written\n       * to the console but no replacement event will be triggered.\n       * @param {string} deprecatedEventName\n       * The name of the deprecated event.\n       * @param {string} [replacementEventName]\n       * The name of the new event.\n       */\n      deprecate: NGN.const((deprecatedEventName, replacementEventName) => {\n        const me = this\n\n        this.on(deprecatedEventName, function () {\n          NGN.WARN(`${deprecatedEventName} is deprecated. ` + (!replacementEventName ? '' : `Use ${replacementEventName} instead.`))\n\n          if (replacementEventName) {\n            let args = NGN.slice(arguments)\n\n            args.shift()\n            args.unshift(replacementEventName)\n\n            me.emit.apply(me, args)\n          }\n        })\n      }),\n\n      /**\n       * @method pool\n       * A helper command to create multiple related subscribers\n       * all at once. This is a convenience function.\n       * @property {string} [prefix]\n       * Supply a prefix to be added to every event. For example,\n       * `myScope.` would turn `someEvent` into `myScope.someEvent`.\n       * @property {Object} subscriberObject\n       * A key:value object where the key is the name of the\n       * unprefixed event and the key is the handler function.\n       * A value can be an object, allowing for nesting events. For example:\n       *\n       * ```js\n       * NGN.BUS.pool('prefix.', {\n       *   deep: {\n       *     nested: {\n       *       eventName: function () {\n       *         console.log('event triggered')\n       *       }\n       *     }\n       *   }\n       * })\n       *\n       * NGN.BUS.emit('prefix.deep.nested.eventName') // <-- Outputs \"event triggered\"\n       * ```\n       * @private\n       */\n      pool: NGN.privateconst(function (prefix, group) {\n        if (typeof prefix !== 'string') {\n          group = prefix\n          prefix = ''\n        }\n\n        let pool = {}\n\n        for (let eventName in group) {\n          let topic = `${NGN.coalesce(prefix, '')}${eventName}`\n\n          if (NGN.isFn(group[eventName])) {\n            this.increaseMaxListeners()\n\n            pool[eventName] = this.on(topic, group[eventName])\n          } else if (typeof group[eventName] === 'object') {\n            this.pool(`${topic}.`, group[eventName])\n          } else {\n            NGN.WARN(`${topic} could not be pooled in the event emitter because it's value is not a function.`)\n          }\n        }\n      }),\n\n      /**\n       * @method attach\n       * Attach a function to a topic. This can be used\n       * to forward events in response to asynchronous functions.\n       *\n       * For example:\n       *\n       * ```js\n       * myAsyncDataFetch(NGN.BUS.attach('topicName'))\n       * ```\n       *\n       * This is the same as:\n       *\n       * ```js\n       * myAsyncCall(function(data){\n       *  NGN.BUS.emit('topicName', data)\n       * })\n       * ```\n       * @param {string} eventName\n       * The name of the event to attach a handler method to.\n       * @param {boolean} [preventDefaultAction=false]\n       * Setting this to `true` will execute a `event.preventDefault()` before\n       * attaching the handler.\n       * @returns {function}\n       * Returns a function that will automatically be associated with an event.\n       */\n      attach: NGN.const(function (eventName, preventDefaultAction) {\n        preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\n\n        return (e) => {\n          if (preventDefaultAction && !NGN.nodelike) {\n            e.preventDefault()\n          }\n\n          this.emit(eventName, ...arguments)\n        }\n      }),\n\n      /**\n       * @method increaseMaxListeners\n       * Increase the number of maximum listeners.\n       * @param {Number} [value = 1]\n       * The number of events the max listener account will be increased by.\n       * @private\n       */\n      increaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() + count)\n      }),\n\n      /**\n       * @method decreaseMaxListeners\n       * Decrease the number of maximum listeners.\n       * @param {Number} [value = 1]\n       * The number of events the max listener account will be decreased by.\n       * @private\n       */\n      decreaseMaxListeners: NGN.private((count = 1) => {\n        this.setMaxListeners(this.getMaxListeners() - count)\n      }),\n\n      /**\n       * @method forward\n       * A special subscriber that fires one or more event in response to\n       * to an event. This is used to bubble events up/down an event chain.\n       *\n       * For example:\n       *\n       * ```js\n       * NGN.BUS.forward('sourceEvent', ['someEvent','anotherEvent'], {payload:true})\n       * ```\n       * When `sourceEvent` is published, the bind method triggers `someEvent` and\n       * `anotherEvent`, passing the payload object to `someEvent` and\n       * `anotherEvent` subscribers simultaneously.\n       *\n       * To forward an event to another EventEmitter, see #relay.\n       * @param {String} sourceEvent\n       * The event to subscribe to.\n       * @param {String|Array} triggeredEvent\n       * An event or array of events to fire in response to the sourceEvent.\n       * @param {any} data\n       * Optional data to pass to each bound event handler.\n       * @returns {Object}\n       * Returns an object with a single `remove()` method.\n       */\n      forward: NGN.const(function (eventName, triggers, payload) {\n        triggers = NGN.forceArray(triggers)\n\n        let me = this\n        let listener = function () {\n          let args = NGN.slice(arguments)\n\n          if (payload) {\n            args.push(payload)\n          }\n\n          me.emit(triggers, ...args)\n        }\n\n        this.increaseMaxListeners()\n        this.on(eventName, listener)\n\n        // Provide handle back for removal of topic\n        return {\n          remove: () => {\n            this.decreaseMaxListeners()\n            this.off(eventName, listener)\n          }\n        }\n      }),\n\n      /**\n       * This relays an entire event to a different event emitter.\n       * For example:\n       *\n       * ```js\n       * let emitterA = new NGN.EventEmitter()\n       * let emitterB = new NGN.EventEmitter()\n       *\n       * emitterA.relay('my.event', emitterB)\n       *\n       * emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n       *\n       * emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n       * ```\n       * @param  {string} eventName\n       * The name of the event to listen for.\n       * @param  {NGN.EventEmitter} targetEmitter\n       * The emitter to relay the event to.\n       * @param {string} [prefix]\n       * An optional prefix to prepend to the eventName.\n       * @param {string} [postfix]\n       * An optional postfix to append to the eventName.\n       */\n      relay: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.on(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      }),\n\n      /**\n       * This relays an entire event to a different event emitter. This is\n       * the same as #relay, but the event handler is removed after the\n       * first invocation of the event.\n       *\n       * For example:\n       *\n       * ```js\n       * let emitterA = new NGN.EventEmitter()\n       * let emitterB = new NGN.EventEmitter()\n       *\n       * emitterA.relayOnce('my.event', emitterB)\n       *\n       * emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\n       *\n       * emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\n       * emitterA.emit('my.event') // Does nothing\n       * ```\n       * @param  {string} eventName\n       * The name of the event to listen for.\n       * @param  {NGN.EventEmitter} targetEmitter\n       * The emitter to relay the event to.\n       * @param {string} [prefix]\n       * An optional prefix to prepend to the eventName.\n       * @param {string} [postfix]\n       * An optional postfix to append to the eventName.\n       */\n      relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\n        let eventNameList = NGN.forceArray(eventName)\n\n        for (let i = 0; i < eventNameList.length; i++) {\n          let eventName = eventNameList[i]\n\n          this.once(eventName, function () {\n            if (NGN.typeof(this.event) === 'symbol') {\n              if (prefix !== null || postfix !== null) {\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\n              }\n\n              targetEmitter.emit(...arguments)\n            } else {\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\n            }\n          })\n        }\n      }),\n\n      /**\n       * @method delayEmit\n       * This method waits for the specified duration, then publishes an\n       * event once. This will publish the event only once at the end of the\n       * wait period, even if the event is triggered multiple times. This can\n       * be useful when working with many events triggered in rapid succession.\n       *\n       * For example, an NGN.DATA.Model representing a person may be used to\n       * track a user profile. The NGN.DATA.Model fires an event called `field.update`\n       * every time a data field is modified. In many cases, a user may update\n       * multiple fields of their profile using a form with a \"Save\" button.\n       * Instead of generating a new \"save\" (to disk, to memory, to an API, etc)\n       * operation for each field, the publishOnce event can wait until all\n       * changes are made before running the save operation.\n       *\n       * ```js\n       * // Create a data model representing a person.\n       * var Person = new NGN.DATA.Model({....})\n       *\n       * // Create a new person record for a user.\n       * var user = new Person()\n       *\n       * // When the user is modified, save the data.\n       * user.on('field.update', function () {\n       *   // Wait 300 milliseconds to trigger the save event\n       *   NGN.BUS.delayEmit('user.save', 300)\n       * })\n       *\n       * // Save the user using an API\n       * NGN.BUS.on('user.save', function () {\n       *   NGN.NET.put({\n       *     url: 'https://my.api.com/user',\n       *     json: user.data\n       *   })\n       * })\n       *\n       * // Modify the record attributes (which are blank by default)\n       * user.firstname = 'John'\n       * user.lastname = 'Doe'\n       * user.age = 42\n       *\n       * // Make another update 1 second later\n       * setTimeout(function () {\n       *   user.age = 32\n       * }, 1000)\n       * ```\n       *\n       * The code above sets up a model and record. Then it listens to the record\n       * for field updates. Each time it recognizes an update, it queues the \"save\"\n       * event. When the queue matures, it fires the `user.save` event.\n       *\n       * The first `field.update` is triggered when `user.firstname = 'John'` runs.\n       * This initiates a queue for `user.save`, set to mature in 300 millisenconds.\n       * Next, a `field.update` is triggered when `user.lastname = 'Doe'` runs.\n       * This time, since the queue for `user.save` is already initiated, notthing\n       * new happens. Finally, a `field.update` is triggered when `user.age = 42`\n       * runs. Just like the last one, nothing happens since the `user.save` queue\n       * is already active.\n       *\n       * The `user.save` queue \"matures\" after 300 milliseconds. This means after\n       * 300 milliseconds have elapsed, the `user.save` event is triggered. In this\n       * example, it means the `NGN.NET.put()` code will be executed. As a result,\n       * all 3 change (firstname, lastname, and age) will be complete before the\n       * API request is executed. The queue is cleared immediately.\n       *\n       * The final update occurs 1 second later (700 milliseconds after the queue\n       * matures). This triggers a `field.update`, but since the queue is no\n       * longer active, it is re-initiated. 300 milliseconds later, the `user.save`\n       * event is fired again, thus executing the API request again (1.3 seconds\n       * in total).\n       * @param {string} eventName\n       * The event/topic to publish/emit.\n       * @param {Number} [delay=300]\n       * The number of milliseconds to wait before firing the event.\n       * @param {Any} [payload]\n       * An optional payload, such as data to be passed to an event handler.\n       */\n      delayEmit: NGN.const(function (eventName, delay) {\n        if (!this.META.queued.hasOwnProperty(eventName)) {\n          let args = NGN.slice(arguments)\n          args.splice(1, 1)\n\n          this.META.queued[eventName] = setTimeout(() => {\n            delete this.META.queued[eventName]\n            this.emit(...args)\n          }, delay)\n        }\n      }),\n\n      /**\n       * @method getInternalCollectionId\n       * Returns a unique ID for special collections.\n       * @param {object} collection\n       * The collection to generate an ID for.\n       * @private\n       */\n      getInternalCollectionId: NGN.privateconst(function (collection) {\n        return Symbol(collection)\n        // let time = (new Date()).getTime().toString()\n        // let rand = Math.random().toString()\n        // let key = Object.keys(collection).length + 1\n        //\n        // while (collection.hasOwnProperty(`${key.toString()}${time}${rand}`)) {\n        //   key++\n        // }\n        //\n        // return `${key.toString()}${time}${rand}`\n      }),\n\n      /**\n       * @method handleCollectionTrigger\n       * A method to manage #chain event handlers.\n       * @private\n       */\n      handleCollectionTrigger: NGN.privateconst(function (eventName, key) {\n        let me = this\n\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            let cq = me.META.collectionQueue\n\n            if (cq[key]) {\n              cq[key].remainingqueue.delete(eventName)\n\n              if (cq[key].remainingqueue.size === 0) {\n                cq[key].remainingqueue = cq[key].masterqueue\n\n                if (NGN.isFn(cq[key].eventName)) {\n                  cq[key].eventName(cq[key].payload)\n                } else {\n                  me.emit(cq[key].eventName, cq[key].payload)\n                }\n              }\n            }\n          }, 0)\n        }\n      }),\n\n      /**\n       * @method funnel\n       * Emit an event after a collection of unique events have all fired.\n       * This can be useful in situations where multiple asynchronous actions\n       * must complete before another begins. For example, blending 3\n       * remote data sources from different API's into a single resultset\n       * can be achieved with this.\n       *\n       * **Example**\n       * ```js\n       * let collection = NGN.BUS.funnel(['download1done', 'download2done', 'download3done'], 'make.results')\n       *\n       * let allData = []\n       *\n       * // When all of the downloads are done, log them.\n       * NGN.BUS.on('make.results', () => {\n       *   console.log(allData)\n       * })\n       *\n       * // Download the first set of data asynchronously\n       * NGN.NET.json('http:/download1.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download1done')\n       * })\n       *\n       * // Download the second set of data asynchronously\n       * NGN.NET.json('http:/download2.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download2done')\n       * })\n       *\n       * // Download the third set of data asynchronously\n       * NGN.NET.json('http:/download3.com/data.json', (data) => {\n       *   allData.push(data)\n       *   NGN.BUS.emit('download3done')\n       * })\n       *\n       * // The handler can be removed with the special method:\n       * collection.remove()\n       * ```\n       * @param {array} eventCollection\n       * An array of events. Once _all_ of these events have fired,\n       * the triggerEventName will be fired.\n       * @param {string|function} triggerEventName\n       * The name of the event triggered after the collection has completed.\n       * This can also be a callback function. If a callback function is provided,\n       * it will receive the payload as the only argument when it is triggered.\n       * @param {any} [payload]\n       * An optional payload delivered to the #triggerEventName.\n       * @returns {object} collection\n       * Provides the key/value configuration of the collection.\n       * ```js\n       * {\n       *   masterqueue: ['event1', 'event2', 'etc'], // The original event array (non-editable)\n       *   remainingqueue: [...], // The events the BUS is still waiting for before firing the trigger event.\n       *   eventName: 'triggeredEventName', // Name of the event triggered after the remaining elements are flushed.\n       *   payload: 'anything', // OPTIONAL\n       *   remove: [Function]\n       * }\n       * ```\n       */\n      funnel: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        if (NGN.typeof(eventCollection) !== 'array') {\n          throw new Error(`NGN.BUS.funnel expected an array of events, but received a(n) ${NGN.typeof(eventCollection)}`)\n        }\n\n        let collection = new Set(eventCollection)\n        let key = this.getInternalCollectionId(this.META.collectionQueue)\n\n        this.META.collectionQueue[key] = {}\n\n        Object.defineProperties(this.META.collectionQueue[key], {\n          masterqueue: NGN.const(new Set(eventCollection)),\n          remainingqueue: NGN.private(collection),\n          eventName: NGN.const(triggerEventName),\n          remove: NGN.const(() => {\n            this.META.collectionQueue[key].masterqueue.forEach(event => {\n              this.off(event, this.handleCollectionTrigger(event, key))\n            })\n\n            this.decreaseMaxListeners(this.META.collectionQueue[key].masterqueue.size)\n\n            delete this.META.collectionQueue[key]\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners(collection.size)\n\n        collection.forEach(event => {\n          this.on(event, this.handleCollectionTrigger(event, key))\n        })\n\n        return this.META.collectionQueue[key]\n      }),\n\n      /**\n       * @method funnelOnce\n       * This provides the same functionality as #funnel, but\n       * removes the listener after the resultant event has fired.\n       * See #funnel for detailed usage.\n       * @param {array} eventCollection\n       * An array of events. Once _all_ of these events have fired,\n       * the triggerEventName will be fired.\n       * @param {string} triggerEventName\n       * The name of the event triggered after the collection has completed.\n       * @param {any} [payload]\n       * An optional payload delivered to the #triggerEventName.\n       * @returns {object} collection\n       * Provides the key/value configuration of the collection.\n       */\n      funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\n        // let funnelClosureEvent = Symbol(triggerEventName)\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\n\n        this.increaseMaxListeners()\n        this.once(funnelClosureEvent, () => {\n          collection.remove()\n          collection = null\n          this.emit(triggerEventName, payload)\n        })\n      }),\n\n      /**\n       * @method threshold\n       * After an event is fired a predetermined number of times (the threshold),\n       * trigger another event or function.\n       *\n       * For example:\n       *\n       * ```js\n       * NGN.BUS.threshold('push.my.button', 3, 'annoyed')\n       *\n       * NGN.BUS.on('annoyed', function () {\n       *   console.log('We apologize for the slow response, but excessive clicking will not speed up the process.')\n       * })\n       *\n       * document.getElementById('#myButton').addEventListener('click', NGN.BUS.attach('push.my.button'))\n       * ```\n       *\n       * Once the threshold is exceeded, the final event will be triggered and\n       * the threshold will be reset. Using the example above, this means\n       * clicking 3 times on `#myButton` would trigger the `annoyed` event ONCE,\n       * 6 times triggers `annoyed` TWICE, 9 times triggers `annoyed` THREE times, etc.\n       * @param {string} thresholdEventName\n       * The name of the event to count.\n       * @param {number} limit\n       * The number of occurrances allowed until the final event is triggered.\n       * The event will be triggered at the threshold. For example, if the limit\n       * is `3`, the finalEvent will be triggered the 3rd time thresholdEventName is\n       * fired.\n       * @param {string|function} finalEventName\n       * This can be an event or callback function triggered when the threshold is crossed.\n       * If a callback function is specified, the payload is passed as the only argument.\n       * @param {any} [payload]\n       * An optional payload to send to the finalEvent handler(s).\n       * @returns {object}\n       * Returns an object that can be used to remove the threshold.\n       *\n       */\n      threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        if (typeof thresholdEventName !== 'string') {\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\n        }\n\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\n\n        this.META.thresholdQueue[key] = {}\n\n        Object.defineProperties(this.META.thresholdQueue[key], {\n          key: NGN.const(key),\n          eventName: NGN.const(thresholdEventName),\n          limit: NGN.const(limit),\n          count: NGN.private(0),\n          finalEventName: NGN.const(finalEventName),\n          remove: NGN.const(() => {\n            let event = this.META.thresholdQueue[key].eventName\n\n            delete this.META.thresholdQueue[key]\n\n            this.decreaseMaxListeners()\n            this.off(event, this.handleThresholdTrigger(key))\n          }),\n          payload: NGN.const(payload)\n        })\n\n        this.increaseMaxListeners()\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\n\n        return this.META.thresholdQueue[key]\n      }),\n\n      thresholdOnce: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\n        let thresholdClosureEvent = `::NGNTHRESHOLD::${(new Date()).getTime()}::${finalEventName}`\n        let threshold = this.threshold(thresholdEventName, limit, thresholdClosureEvent, payload)\n\n        this.once(thresholdClosureEvent, () => {\n          threshold.remove()\n          threshold = null\n          this.emit(finalEventName, payload)\n        })\n      }),\n\n      /**\n       * @method handleThresholdTrigger\n       * A method to manage #threshold event handlers.\n       * @private\n       */\n      handleThresholdTrigger: NGN.const(function (key) {\n        let me = this\n        return function () {\n          // Use setTimeout to simulate nextTick\n          setTimeout(() => {\n            if (me.META.thresholdQueue.hasOwnProperty(key)) {\n              me.META.thresholdQueue[key].count++\n              if (me.META.thresholdQueue[key].count === me.META.thresholdQueue[key].limit) {\n                if (NGN.isFn(me.META.thresholdQueue[key].finalEventName)) {\n                  me.META.thresholdQueue[key].finalEventName(me.META.thresholdQueue[key].payload)\n                } else {\n                  me.emit(me.META.thresholdQueue[key].finalEventName, me.META.thresholdQueue[key].payload)\n                }\n\n                // This if statement is required in case the event is removed\n                // during the reset process.\n                if (me.META.thresholdQueue.hasOwnProperty(key)) {\n                  me.META.thresholdQueue[key].count = 0\n                }\n              }\n            }\n          }, 0)\n        }\n      }),\n\n      /**\n       * An internal method to wrap node-based event handlers\n       * with the proper scope.\n       * @param {string} eventName\n       * The name of the event being handled.\n       * @param {function} handlerFn\n       * The handler function.\n       */\n      wrapEventHandlerWithScope: NGN.privateconst((name, fn) => {\n        if (!NGN.nodelike) {\n          return fn\n        }\n\n        const handlerFn = fn\n\n        return function () {\n          let args = arguments\n\n          if (typeof args[args.length - 1] === 'symbol') {\n            name = args[args.length - 1].toString().replace(/Symbol\\(|\\)/gi, '')\n            args = NGN.slice(args)\n            args.pop()\n          }\n\n          handlerFn.apply({ event: name }, args)\n        }\n      }),\n\n      /**\n       * An internal method to apply scope based on whether the handler\n       * is a Node-like \"once\" emitter or not.\n       * @param {string} eventName\n       * The name of the event being scoped.\n       * @param {function} handlerFn\n       * The handler function.\n       */\n      applyScope: NGN.privateconst((args) => {\n        if (NGN.nodelike && args.length > 1) {\n          if (args[args.length - 1].listener) {\n            args[args.length - 1].listener = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1].listener\n            )\n          } else {\n            args[args.length - 1] = this.wrapEventHandlerWithScope(\n              args[0],\n              args[args.length - 1]\n            )\n          }\n        }\n      })\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 25,
            "column": 2
          },
          "end": {
            "line": 807,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "clear": {
          "type": "method",
          "label": "clear",
          "description": "Remove all event handlers from the EventEmitter (both regular and adhoc).\n  This is a shortcut for #removeAllListeners.",
          "code": "clear () {\n    let events = NGN.slice(arguments)\n\n    if (events.length === 0) {\n      this.META.wildcardEvents.clear()\n\n      let symbolEvents = []\n\n      if (NGN.nodelike) {\n        symbolEvents = Object.getOwnPropertySymbols(this._events)\n      } else {\n        symbolEvents = Object.getOwnPropertySymbols(this.adhoc)\n        symbolEvents = symbolEvents.concat(Object.getOwnPropertySymbols(this.handlers))\n      }\n\n      for (let i = 0; i < symbolEvents.length; i++) {\n        this.removeAllListeners(symbolEvents[i])\n      }\n\n      return this.removeAllListeners()\n    }\n\n    for (let i = 0; i < events.length; i++) {\n      this.META.wildcardEvents.delete(events[i])\n      this.removeAllListeners(events[i])\n    }\n  }",
          "tags": {
            "alias": {
              "tag": "alias",
              "name": "clear",
              "optional": false,
              "description": "Remove all event handlers from the EventEmitter .\nThis is a shortcut for #removeAllListeners.",
              "type": "",
              "line": 1,
              "source": "@alias clear\nRemove all event handlers from the EventEmitter (both regular and adhoc).\nThis is a shortcut for #removeAllListeners.",
              "options": [
                "both regular and adhoc"
              ]
            }
          },
          "exceptions": {},
          "start": {
            "line": 814,
            "column": 2
          },
          "end": {
            "line": 840,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "eventHandler": {
          "type": "method",
          "label": "eventHandler",
          "description": null,
          "code": "eventHandler (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(ttl) === 'boolean') {\n      prepend = ttl\n      ttl = this.META.defaultTTL\n    }\n\n    if (ttl === undefined) {\n      ttl = this.META.defaultTTL\n    }\n\n    if (ttl > 0) {\n      setTimeout(() => this.off(eventName, callback), ttl)\n    }\n\n    if (typeof eventName === 'string' && eventName.indexOf('*') >= 0) {\n      this.META.wildcardEvents.add(eventName)\n    }\n\n    return prepend\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 843,
            "column": 2
          },
          "end": {
            "line": 862,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": null,
              "code": "eventName",
              "start": {
                "line": 843,
                "column": 16
              },
              "end": {
                "line": 843,
                "column": 25
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "callback",
              "description": null,
              "code": "callback",
              "start": {
                "line": 843,
                "column": 27
              },
              "end": {
                "line": 843,
                "column": 35
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "ttl": {
              "type": "argument",
              "label": "ttl",
              "description": null,
              "code": "ttl",
              "start": {
                "line": 843,
                "column": 37
              },
              "end": {
                "line": 843,
                "column": 40
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "prepend": {
              "type": "argument",
              "label": "prepend",
              "description": null,
              "code": "prepend = false",
              "start": {
                "line": 843,
                "column": 42
              },
              "end": {
                "line": 843,
                "column": 57
              },
              "flags": [],
              "default": false,
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "on": {
          "type": "method",
          "label": "on",
          "description": "Create a new event handler for the specified event.",
          "code": "on (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(eventName) === 'array') {\n      for (let i = 0; i < eventName.length; i++) {\n        this.on(eventName[i], callback, ttl, prepend)\n      }\n\n      return\n    }\n\n    if (this.eventHandler(...arguments)) {\n      this.prependListener(eventName, callback)\n    } else {\n      this.addListener(eventName, callback)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 882,
            "column": 2
          },
          "end": {
            "line": 896,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": null,
              "code": "eventName",
              "start": {
                "line": 882,
                "column": 6
              },
              "end": {
                "line": 882,
                "column": 15
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to listen for.\nIf an object is passed, this method will automatically setup a #pool.",
              "code": "callback",
              "start": {
                "line": 882,
                "column": 17
              },
              "end": {
                "line": 882,
                "column": 25
              },
              "flags": [],
              "default": null,
              "datatype": "string|string[]|object",
              "required": true,
              "enum": null
            },
            "ttl": {
              "type": "argument",
              "label": "ttl",
              "description": null,
              "code": "ttl",
              "start": {
                "line": 882,
                "column": 27
              },
              "end": {
                "line": 882,
                "column": 30
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "prepend": {
              "type": "argument",
              "label": "prepend",
              "description": "When set to `true`, the event is added to the beginning of\nthe processing list instead of the end.\nThis is ignored if eventName is an object.",
              "code": "@param {boolean} [prepend=false]\nWhen set to `true`, the event is added to the beginning of\nthe processing list instead of the end.\nThis is ignored if eventName is an object.",
              "start": {
                "line": 882,
                "column": 2
              },
              "end": {
                "line": 896,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            },
            "handler": {
              "type": "method",
              "label": "handler",
              "description": "The method responsible for responding to the event.\nThis is ignored if eventName is an object.",
              "code": "@param  {function} handler\nThe method responsible for responding to the event.\nThis is ignored if eventName is an object.",
              "start": {
                "line": 882,
                "column": 2
              },
              "end": {
                "line": 896,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "once": {
          "type": "method",
          "label": "once",
          "description": "Create a new event handler for the specified event. The\nhandler will be removed immediately after it is executed. This\neffectively listens for an event to happen once and only once\nbefore the handler is destroyed.",
          "code": "once (eventName, callback, ttl, prepend = false) {\n    if (NGN.typeof(eventName) === 'array') {\n      for (let i = 0; i < eventName.length; i++) {\n        this.once(eventName[i], callback, ttl, prepend)\n      }\n\n      return\n    }\n\n    if (this.eventHandler(...arguments)) {\n      this.prependOnceListener(eventName, callback)\n    } else {\n      super.once(eventName, this.wrapEventHandlerWithScope(eventName, callback))\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 912,
            "column": 2
          },
          "end": {
            "line": 926,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": null,
              "code": "eventName",
              "start": {
                "line": 912,
                "column": 8
              },
              "end": {
                "line": 912,
                "column": 17
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "eventName",
              "description": "Name of the event to listen for.",
              "code": "callback",
              "start": {
                "line": 912,
                "column": 19
              },
              "end": {
                "line": 912,
                "column": 27
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "ttl": {
              "type": "argument",
              "label": "handler",
              "description": "The method responsible for responding to the event.",
              "code": "ttl",
              "start": {
                "line": 912,
                "column": 29
              },
              "end": {
                "line": 912,
                "column": 32
              },
              "flags": [],
              "default": null,
              "datatype": "function",
              "required": true,
              "enum": null
            },
            "prepend": {
              "type": "argument",
              "label": "prepend",
              "description": "When set to `true`, the event is added to the beginning of\nthe processing list instead of the end.",
              "code": "prepend = false",
              "start": {
                "line": 912,
                "column": 34
              },
              "end": {
                "line": 912,
                "column": 49
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "prependListener": {
          "type": "method",
          "label": "prependListener",
          "description": null,
          "code": "prependListener () {\n    this.applyScope(arguments)\n    super.prependListener(...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 929,
            "column": 2
          },
          "end": {
            "line": 932,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "prependOnceListener": {
          "type": "method",
          "label": "prependOnceListener",
          "description": null,
          "code": "prependOnceListener () {\n    this.applyScope(arguments)\n    super.prependOnceListener(...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 934,
            "column": 2
          },
          "end": {
            "line": 937,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "addListener": {
          "type": "method",
          "label": "addListener",
          "description": null,
          "code": "addListener () {\n    this.applyScope(arguments)\n    super.addListener(...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 939,
            "column": 2
          },
          "end": {
            "line": 942,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeListener": {
          "type": "method",
          "label": "removeListener",
          "description": null,
          "code": "removeListener () {\n    if (arguments[arguments.length - 1] !== true) {\n      this.applyScope(arguments)\n    }\n\n    super.removeListener(...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 944,
            "column": 2
          },
          "end": {
            "line": 950,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "emit": {
          "type": "method",
          "label": "emit",
          "description": "Emits an event.",
          "code": "emit () {\n    if (NGN.typeof(arguments[0]) === 'array') {\n      let args = NGN.slice(arguments)\n      let eventNames = args.shift()\n\n      for (let i = 0; i < eventNames.length; i++) {\n        this.emit(eventNames[i], ...args)\n      }\n\n      return\n    }\n\n    // This catches non-string event names. NGN internally uses Symbols\n    // for the NGN.WARN/INFO/ERROR event names to prevent name collisions.\n    // This check provides support for these special events. These types\n    // of events will never have wildcards.\n    if (!NGN.nodelike || !arguments[0] || this.META.wildcardEvents.size === 0) {\n      super.emit(...arguments)\n      return\n    }\n\n    if (NGN.nodelike && typeof arguments[0] === 'symbol') {\n      super.emit(...arguments)\n      return\n    }\n\n    /**\n     * The NGN browser-based event emitter supports wildcards natively, but\n     * Node.js does not. This adds simple wildcard support for Node. The\n     * only wildcard character supported at this time is `*`. This feature\n     * will check the event name for the existance of a wildcard. If a\n     * wilcard character is present, the internally-maintained list of\n     * wildcard events is checked to see if it's a known event. If none\n     * of these checks pass, the standard event emitter is used, otherwise\n     * special wildcard handling is used.\n     */\n    let iterator = this.META.wildcardEvents.values()\n    let currentEvent = null\n    let args = NGN.slice(arguments)\n\n    args.shift()\n\n    while (currentEvent === null || !currentEvent.done) {\n      if (currentEvent !== null && currentEvent.value !== arguments[0]) {\n        let pattern = new RegExp(currentEvent.value.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\n\n        if (pattern.test(arguments[0])) {\n          super.emit(currentEvent.value, ...args, typeof arguments[0] !== 'symbol' ? Symbol(arguments[0]) : arguments[0])\n          break\n        }\n      }\n\n      currentEvent = iterator.next()\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 962,
            "column": 2
          },
          "end": {
            "line": 1016,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "eventName": {
              "type": "argument",
              "label": "eventName",
              "description": "The event name can be a string or an array of strings. If an array\nof strings is specified, an event will be fired for each event name\nwithin the array.",
              "code": "@param {string[]} eventName\nThe event name can be a string or an array of strings. If an array\nof strings is specified, an event will be fired for each event name\nwithin the array.",
              "start": {
                "line": 962,
                "column": 2
              },
              "end": {
                "line": 1016,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string[]",
              "required": true,
              "enum": null
            },
            "payload": {
              "type": "argument",
              "label": "payload",
              "description": "An optional payload. This can be any number of additional arguments.",
              "code": "@param {any} [payload]\nAn optional payload. This can be any number of additional arguments.",
              "start": {
                "line": 962,
                "column": 2
              },
              "end": {
                "line": 1016,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "any",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "hash": {
          "type": "method",
          "label": "hash",
          "description": "The hash part of the URL .",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setHeader": {
          "type": "method",
          "label": "setHeader",
          "description": "Add a header to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getHeader": {
          "type": "method",
          "label": "getHeader",
          "description": "",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeHeader": {
          "type": "method",
          "label": "removeHeader",
          "description": "Removes a header from the request. Nothing happens if the header does\nnot exist.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "setQueryParameter": {
          "type": "method",
          "label": "setQueryParameter",
          "description": "Add a query parameter to the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeQueryParameter": {
          "type": "method",
          "label": "removeQueryParameter",
          "description": "Remove a query parameter from the request URI.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "send": {
          "type": "method",
          "label": "send",
          "description": "Send the request.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "CustomException": {
      "type": "class",
      "label": "CustomException",
      "description": null,
      "code": "class CustomException extends Error { // eslint-disable-line\n  constructor (config) {\n    super()\n\n    Object.defineProperty(this, 'frameFilter', NGN.privateconst((frame) => {\n      return NGN.nodelike\n        ? frame.getFileName() !== __filename && frame.getFileName()\n        : frame.getFileName()\n    }))\n\n    config = config || {}\n    config = typeof config === 'string' ? { message: config } : config\n    config.custom = config.custom || {}\n\n    let me = this\n\n    this.name = config.name || 'NgnError'\n    this.type = config.type || 'TypeError'\n    this.severity = config.severity || 'minor'\n    this.message = config.message || 'Unknown Error'\n    this.category = config.category || 'operational' // Alternative is \"programmer\"\n\n    // Cleanup name\n    this.name = this.name.replace(/[^a-zA-Z0-9_]/gi, '')\n\n    // Add any custom properties\n    for (let attr in config.custom) {\n      if (config.custom.hasOwnProperty(attr)) {\n        this[attr] = config.custom[attr]\n      }\n    }\n\n    this.hasOwnProperty('custom') && delete this.custom\n\n    if (NGN.nodelike || Error.prepareStackTrace) {\n      // Capture the stack trace on a new error so the detail can be saved as a structured trace.\n      Error.prepareStackTrace = function (_, stack) { return stack }\n\n      let _err = new Error()\n\n      Error.captureStackTrace(_err, this)\n\n      this.rawstack = _err.stack\n\n      Error.prepareStackTrace = function (err, stack) { // eslint-disable-line handle-callback-err\n        me.cause && console.warn(me.cause)\n        me.help && console.info(me.help)\n\n        return `${me.name}: ${me.message}\\n` + stack.filter(me.frameFilter).map((el) => {\n          return `    at ${el}`\n        }).join('\\n')\n      }\n\n      // Enable stack trace\n      Error.captureStackTrace(this)\n    }\n  }\n\n  /*\n   * @property {Array} trace\n   * The structured data of the stacktrace. Each array element is a JSON object corresponding to\n   * the full stack trace:\n   *\n   * ```js\n   * {\n   *   filename: String,\n   *   line: Number,\n   *   column: Number,\n   *   functionname: String,\n   *   native: Boolean,\n   *   eval: Boolean,\n   *   type: String\n   * }\n   * ```\n   * @readonly\n   */\n  get trace () {\n    return this.rawstack.filter(this.frameFilter).map((frame) => {\n      return {\n        filename: frame.getFileName(),\n        line: frame.getLineNumber(),\n        column: frame.getColumnNumber(),\n        functionname: frame.getFunctionName(),\n        native: frame.isNative(),\n        eval: frame.isEval(),\n        type: frame.getTypeName()\n      }\n    })\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 1,
        "column": 15
      },
      "end": {
        "line": 90,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./exception.js",
      "extends": "Error",
      "configuration": {},
      "properties": {
        "custom": {
          "type": "property",
          "label": "custom",
          "description": null,
          "code": "config.custom = config.custom || {}",
          "start": {
            "line": 13,
            "column": 11
          },
          "end": {
            "line": 13,
            "column": 17
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "name": {
          "type": "property",
          "label": "name",
          "description": null,
          "code": "this.name = this.name.replace(/[^a-zA-Z0-9_]/gi, '')",
          "start": {
            "line": 24,
            "column": 9
          },
          "end": {
            "line": 24,
            "column": 13
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "type": {
          "type": "property",
          "label": "type",
          "description": null,
          "code": "this.type = config.type || 'TypeError'",
          "start": {
            "line": 18,
            "column": 9
          },
          "end": {
            "line": 18,
            "column": 13
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "severity": {
          "type": "property",
          "label": "severity",
          "description": null,
          "code": "this.severity = config.severity || 'minor'",
          "start": {
            "line": 19,
            "column": 9
          },
          "end": {
            "line": 19,
            "column": 17
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "message": {
          "type": "property",
          "label": "message",
          "description": null,
          "code": "this.message = config.message || 'Unknown Error'",
          "start": {
            "line": 20,
            "column": 9
          },
          "end": {
            "line": 20,
            "column": 16
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "category": {
          "type": "property",
          "label": "category",
          "description": null,
          "code": "this.category = config.category || 'operational'",
          "start": {
            "line": 21,
            "column": 9
          },
          "end": {
            "line": 21,
            "column": 17
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "trace": {
          "type": "property",
          "label": "trace",
          "description": null,
          "code": "get trace () {\n    return this.rawstack.filter(this.frameFilter).map((frame) => {\n      return {\n        filename: frame.getFileName(),\n        line: frame.getLineNumber(),\n        column: frame.getColumnNumber(),\n        functionname: frame.getFunctionName(),\n        native: frame.isNative(),\n        eval: frame.isEval(),\n        type: frame.getTypeName()\n      }\n    })\n  }",
          "start": {
            "line": 77,
            "column": 2
          },
          "end": {
            "line": 89,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (config) {\n    super()\n\n    Object.defineProperty(this, 'frameFilter', NGN.privateconst((frame) => {\n      return NGN.nodelike\n        ? frame.getFileName() !== __filename && frame.getFileName()\n        : frame.getFileName()\n    }))\n\n    config = config || {}\n    config = typeof config === 'string' ? { message: config } : config\n    config.custom = config.custom || {}\n\n    let me = this\n\n    this.name = config.name || 'NgnError'\n    this.type = config.type || 'TypeError'\n    this.severity = config.severity || 'minor'\n    this.message = config.message || 'Unknown Error'\n    this.category = config.category || 'operational' // Alternative is \"programmer\"\n\n    // Cleanup name\n    this.name = this.name.replace(/[^a-zA-Z0-9_]/gi, '')\n\n    // Add any custom properties\n    for (let attr in config.custom) {\n      if (config.custom.hasOwnProperty(attr)) {\n        this[attr] = config.custom[attr]\n      }\n    }\n\n    this.hasOwnProperty('custom') && delete this.custom\n\n    if (NGN.nodelike || Error.prepareStackTrace) {\n      // Capture the stack trace on a new error so the detail can be saved as a structured trace.\n      Error.prepareStackTrace = function (_, stack) { return stack }\n\n      let _err = new Error()\n\n      Error.captureStackTrace(_err, this)\n\n      this.rawstack = _err.stack\n\n      Error.prepareStackTrace = function (err, stack) { // eslint-disable-line handle-callback-err\n        me.cause && console.warn(me.cause)\n        me.help && console.info(me.help)\n\n        return `${me.name}: ${me.message}\\n` + stack.filter(me.frameFilter).map((el) => {\n          return `    at ${el}`\n        }).join('\\n')\n      }\n\n      // Enable stack trace\n      Error.captureStackTrace(this)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 2,
            "column": 2
          },
          "end": {
            "line": 57,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "config": {
              "type": "argument",
              "label": "config",
              "description": null,
              "code": "config",
              "start": {
                "line": 2,
                "column": 15
              },
              "end": {
                "line": 2,
                "column": 21
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "Network": {
      "type": "class",
      "label": "Network",
      "description": null,
      "code": "class Network { // eslint-disable-line\n  constructor () {\n    Object.defineProperties(this, {\n      /**\n       * @method parseRequestConfiguration\n       * Prepare common configuration attributes for a request.\n       * @return {NGN.NET.Request}\n       * @private\n       */\n      parseRequestConfiguration: NGN.private((cfg, method = 'GET') => {\n        if (typeof cfg === 'string') {\n          cfg = {\n            url: cfg\n          }\n        }\n\n        cfg = cfg || {}\n        cfg.method = method\n        cfg.url = NGN.coalesceb(cfg.url, hostname) // eslint-disable-line no-undef\n\n        return new NGN.NET.Request(cfg)\n      }),\n\n      // Returns a scoped method for sending the request, after preparing it.\n      makeRequest: NGN.private((method) => {\n        const me = this\n\n        return function () {\n          let args = NGN.slice(arguments)\n          let callback\n\n          if (NGN.isFn(args[args.length - 1])) {\n            callback = args.pop()\n          }\n\n          args.push(method)\n\n          let request = me.parseRequestConfiguration(...args)\n\n          // Send the request\n          me.send(request, callback)\n        }\n      }),\n\n      // Helper aliases (undocumented)\n      OPTIONS: NGN.privateconst(this.options.bind(this)),\n      HEAD: NGN.privateconst(this.head.bind(this)),\n      GET: NGN.privateconst(this.get.bind(this)),\n      POST: NGN.privateconst(this.post.bind(this)),\n      PUT: NGN.privateconst(this.put.bind(this)),\n      DELETE: NGN.privateconst(this.delete.bind(this)),\n      TRACE: NGN.privateconst(this.trace.bind(this)),\n      JSON: NGN.privateconst(this.json.bind(this)),\n      JSONP: NGN.privateconst(this.jsonp.bind(this))\n    })\n  }\n\n  get Request () {\n    return Request\n  }\n\n  /**\n   * @method request\n   * Send a request. In most cases, it is easier to use one of the built-in\n   * request functions (#get, #post, #put, #delete, #json, etc). This method\n   * is available for creating custom requests.\n   * @param  {Object} configuration\n   * Provide a #NGN.NET.Request configuration.\n   * @param  {Function} callback\n   * The callback to execute when the request is complete.\n   */\n  request (cfg, callback) {\n    cfg = cfg || {}\n    cfg.method = NGN.coalesceb(cfg.method, 'GET')\n\n    if (NGN.isFn(this[cfg.method])) {\n      this.makeRequest(cfg.method)(...arguments)\n    } else {\n      this.send(new NGN.NET.Request(cfg), callback)\n    }\n  }\n\n  /**\n   * @method options\n   * Issue a `OPTIONS` request.\n   * @param {string|object} url\n   * The URL to issue the request to, or a configuration object.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  options () {\n    this.makeRequest('OPTIONS').apply(this, arguments)\n  }\n\n  /**\n   * @method head\n   * Issue a `HEAD` request.\n   * @param {string|object} url\n   * The URL to issue the request to, or a configuration object.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  head () {\n    this.makeRequest('HEAD').apply(this, arguments)\n  }\n\n  /**\n   * @method get\n   * Issue a `GET` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  get () {\n    this.makeRequest('GET').apply(this, arguments)\n  }\n\n  /**\n   * @method post\n   * Issue a `POST` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  post () {\n    this.makeRequest('POST').apply(this, arguments)\n  }\n\n  /**\n   * @method put\n   * Issue a `PUT` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  put () {\n    this.makeRequest('PUT').apply(this, arguments)\n  }\n\n  /**\n   * @method delete\n   * Issue a `DELETE` request.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  delete () {\n    this.makeRequest('DELETE').apply(this, arguments)\n  }\n\n  /**\n   * @method trace\n   * Issue a `TRACE` request. This is a debugging method, which\n   * echoes input back to the user. It is a standard HTTP method,\n   * but considered a security risk by many practioners and may\n   * not be supported by remote hosts.\n   * @param {string|object} url\n   * The URL to issue the request to.\n   * The configuration object accepts all of the #NGN.NET.Request\n   * configuration options (except method, which is defined automatically).\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  trace () {\n    NGN.WARN('NGN.NET.Request.method', 'An HTTP TRACE request was made.')\n    this.makeRequest('TRACE').apply(this, arguments)\n  }\n\n  /**\n   * @method json\n   * This is a shortcut method for creating a `GET` request and\n   * auto-processing the response body into a JSON object.\n   * @param  {string} url\n   * The URL to issue the request to.\n   * @param  {Function} callback\n   * This receives a JSON response object from the server.\n   * @param {Error} callback.error\n   * If the request cannot be completed for any reason, this argument will be\n   * populated with the error. If the request is successful, this will be `null`.\n   * @param {Object} callback.data\n   * The JSON response from the remote URL.\n   */\n  json (url, callback) {\n    if (!NGN.isFn(callback)) {\n      throw new Error('NGN.NET.json requires a callback method.')\n    }\n\n    // Request method is \"GET\"\n    let request = this.parseRequestConfiguration({url})\n\n    this.preflight(request)\n\n    request.send((response) => {\n      try {\n        let responseData = JSON.parse(response.responseText)\n        callback(null, responseData)\n      } catch (e) {\n        e.response = NGN.coalesce(response.responseText)\n        callback(e, null)\n      }\n    })\n  }\n\n  /**\n   * @method jsonp\n   * Execute a request via JSONP. JSONP is only available in browser\n   * environments, since it's operation is dependent on the existance of\n   * the DOM. However; this may work with some headless browsers.\n   * @param {string} url\n   * The URL of the JSONP endpoint.\n   * @param {function} callback\n   * Handles the response.\n   * @param {Error} callback.error\n   * If an error occurred, this will be populated. If no error occurred, this will\n   * be null.\n   * @param {object|array} callback.response\n   * The response.\n   * @environment browser\n   */\n  jsonp (url, callback) {\n    /* node-only */\n    NGN.WARN('NET.Request', 'An unsupported JSONP request was made.')\n    callback(new Error('JSONP unsupported in Node-like environments.'))\n    /* end-node-only */\n    /* browser-only */\n    const fn = 'jsonp_callback_' + Math.round(100000 * Math.random())\n\n    window[fn] = (data) => {\n      delete window[fn]\n\n      document.body.removeChild(script)\n\n      return callback(null, data)\n    }\n\n    let script = document.createElement('script')\n\n    script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + fn\n\n    script.addEventListener('error', (e) => {\n      delete window[fn]\n\n      return callback(new Error('The JSONP request was blocked. This may be the result of an invalid URL, cross origin restrictions, or the remote server may not be online.'))\n    })\n\n    document.body.appendChild(script)\n    /* end-browser-only */\n  }\n\n  // Apply a preflight request option to the network request.\n  send (request, callback) {\n    this.preflight(request)\n    request.send(callback)\n  }\n\n  /**\n   * @method preflight\n   * This is a no-op method that runs before a request is sent.\n   * This exists specicially to be overridden by class extensions.\n   */\n  preflight (request) {}\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 4,
        "column": 15
      },
      "end": {
        "line": 288,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./net/Network.js",
      "extends": null,
      "configuration": {},
      "properties": {
        "parseRequestConfiguration": {
          "type": "property",
          "label": "parseRequestConfiguration",
          "description": "Prepare common configuration attributes for a request.",
          "code": "parseRequestConfiguration: NGN.private((cfg, method = 'GET') => {\n        if (typeof cfg === 'string') {\n          cfg = {\n            url: cfg\n          }\n        }\n\n        cfg = cfg || {}\n        cfg.method = method\n        cfg.url = NGN.coalesceb(cfg.url, hostname) // eslint-disable-line no-undef\n\n        return new NGN.NET.Request(cfg)\n      })",
          "start": {
            "line": 13,
            "column": 6
          },
          "end": {
            "line": 25,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "makeRequest": {
          "type": "property",
          "label": "makeRequest",
          "description": null,
          "code": "makeRequest: NGN.private((method) => {\n        const me = this\n\n        return function () {\n          let args = NGN.slice(arguments)\n          let callback\n\n          if (NGN.isFn(args[args.length - 1])) {\n            callback = args.pop()\n          }\n\n          args.push(method)\n\n          let request = me.parseRequestConfiguration(...args)\n\n          // Send the request\n          me.send(request, callback)\n        }\n      })",
          "start": {
            "line": 28,
            "column": 6
          },
          "end": {
            "line": 46,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "OPTIONS": {
          "type": "property",
          "label": "OPTIONS",
          "description": null,
          "code": "OPTIONS: NGN.privateconst(this.options.bind(this))",
          "start": {
            "line": 49,
            "column": 6
          },
          "end": {
            "line": 49,
            "column": 56
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "HEAD": {
          "type": "property",
          "label": "HEAD",
          "description": null,
          "code": "HEAD: NGN.privateconst(this.head.bind(this))",
          "start": {
            "line": 50,
            "column": 6
          },
          "end": {
            "line": 50,
            "column": 50
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "GET": {
          "type": "property",
          "label": "GET",
          "description": null,
          "code": "GET: NGN.privateconst(this.get.bind(this))",
          "start": {
            "line": 51,
            "column": 6
          },
          "end": {
            "line": 51,
            "column": 48
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "POST": {
          "type": "property",
          "label": "POST",
          "description": null,
          "code": "POST: NGN.privateconst(this.post.bind(this))",
          "start": {
            "line": 52,
            "column": 6
          },
          "end": {
            "line": 52,
            "column": 50
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "PUT": {
          "type": "property",
          "label": "PUT",
          "description": null,
          "code": "PUT: NGN.privateconst(this.put.bind(this))",
          "start": {
            "line": 53,
            "column": 6
          },
          "end": {
            "line": 53,
            "column": 48
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "DELETE": {
          "type": "property",
          "label": "DELETE",
          "description": null,
          "code": "DELETE: NGN.privateconst(this.delete.bind(this))",
          "start": {
            "line": 54,
            "column": 6
          },
          "end": {
            "line": 54,
            "column": 54
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "TRACE": {
          "type": "property",
          "label": "TRACE",
          "description": null,
          "code": "TRACE: NGN.privateconst(this.trace.bind(this))",
          "start": {
            "line": 55,
            "column": 6
          },
          "end": {
            "line": 55,
            "column": 52
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "JSON": {
          "type": "property",
          "label": "JSON",
          "description": null,
          "code": "JSON: NGN.privateconst(this.json.bind(this))",
          "start": {
            "line": 56,
            "column": 6
          },
          "end": {
            "line": 56,
            "column": 50
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "JSONP": {
          "type": "property",
          "label": "JSONP",
          "description": null,
          "code": "JSONP: NGN.privateconst(this.jsonp.bind(this))",
          "start": {
            "line": 57,
            "column": 6
          },
          "end": {
            "line": 57,
            "column": 52
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "Request": {
          "type": "property",
          "label": "Request",
          "description": null,
          "code": "get Request () {\n    return Request\n  }",
          "start": {
            "line": 61,
            "column": 2
          },
          "end": {
            "line": 63,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor () {\n    Object.defineProperties(this, {\n      /**\n       * @method parseRequestConfiguration\n       * Prepare common configuration attributes for a request.\n       * @return {NGN.NET.Request}\n       * @private\n       */\n      parseRequestConfiguration: NGN.private((cfg, method = 'GET') => {\n        if (typeof cfg === 'string') {\n          cfg = {\n            url: cfg\n          }\n        }\n\n        cfg = cfg || {}\n        cfg.method = method\n        cfg.url = NGN.coalesceb(cfg.url, hostname) // eslint-disable-line no-undef\n\n        return new NGN.NET.Request(cfg)\n      }),\n\n      // Returns a scoped method for sending the request, after preparing it.\n      makeRequest: NGN.private((method) => {\n        const me = this\n\n        return function () {\n          let args = NGN.slice(arguments)\n          let callback\n\n          if (NGN.isFn(args[args.length - 1])) {\n            callback = args.pop()\n          }\n\n          args.push(method)\n\n          let request = me.parseRequestConfiguration(...args)\n\n          // Send the request\n          me.send(request, callback)\n        }\n      }),\n\n      // Helper aliases (undocumented)\n      OPTIONS: NGN.privateconst(this.options.bind(this)),\n      HEAD: NGN.privateconst(this.head.bind(this)),\n      GET: NGN.privateconst(this.get.bind(this)),\n      POST: NGN.privateconst(this.post.bind(this)),\n      PUT: NGN.privateconst(this.put.bind(this)),\n      DELETE: NGN.privateconst(this.delete.bind(this)),\n      TRACE: NGN.privateconst(this.trace.bind(this)),\n      JSON: NGN.privateconst(this.json.bind(this)),\n      JSONP: NGN.privateconst(this.jsonp.bind(this))\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 5,
            "column": 2
          },
          "end": {
            "line": 59,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "request": {
          "type": "method",
          "label": "request",
          "description": "Send a request. In most cases, it is easier to use one of the built-in\nrequest functions . This method\nis available for creating custom requests.",
          "code": "request (cfg, callback) {\n    cfg = cfg || {}\n    cfg.method = NGN.coalesceb(cfg.method, 'GET')\n\n    if (NGN.isFn(this[cfg.method])) {\n      this.makeRequest(cfg.method)(...arguments)\n    } else {\n      this.send(new NGN.NET.Request(cfg), callback)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 75,
            "column": 2
          },
          "end": {
            "line": 84,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg",
              "start": {
                "line": 75,
                "column": 11
              },
              "end": {
                "line": 75,
                "column": 14
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "configuration",
              "description": "Provide a #NGN.NET.Request configuration.",
              "code": "callback",
              "start": {
                "line": 75,
                "column": 16
              },
              "end": {
                "line": 75,
                "column": 24
              },
              "flags": [],
              "default": null,
              "datatype": "object",
              "required": true,
              "enum": null
            },
            "configuration": {
              "type": "argument",
              "label": "configuration",
              "description": "Provide a #NGN.NET.Request configuration.",
              "code": "callback",
              "start": {
                "line": 75,
                "column": 16
              },
              "end": {
                "line": 75,
                "column": 24
              },
              "flags": [],
              "default": null,
              "datatype": "object",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "options": {
          "type": "method",
          "label": "options",
          "description": "Issue a `OPTIONS` request.",
          "code": "options () {\n    this.makeRequest('OPTIONS').apply(this, arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 97,
            "column": 2
          },
          "end": {
            "line": 99,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "url": {
              "type": "argument",
              "label": "url",
              "description": "The URL to issue the request to, or a configuration object.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options .",
              "code": "@param {string|object} url\nThe URL to issue the request to, or a configuration object.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options (except method, which is defined automatically).",
              "start": {
                "line": 97,
                "column": 2
              },
              "end": {
                "line": 99,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": [
                "except method",
                " which is defined automatically"
              ]
            },
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "A callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "code": "@param {Function} callback\nA callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "start": {
                "line": 97,
                "column": 2
              },
              "end": {
                "line": 99,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "head": {
          "type": "method",
          "label": "head",
          "description": "Issue a `HEAD` request.",
          "code": "head () {\n    this.makeRequest('HEAD').apply(this, arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 112,
            "column": 2
          },
          "end": {
            "line": 114,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "url": {
              "type": "argument",
              "label": "url",
              "description": "The URL to issue the request to, or a configuration object.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options .",
              "code": "@param {string|object} url\nThe URL to issue the request to, or a configuration object.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options (except method, which is defined automatically).",
              "start": {
                "line": 112,
                "column": 2
              },
              "end": {
                "line": 114,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": [
                "except method",
                " which is defined automatically"
              ]
            },
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "A callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "code": "@param {Function} callback\nA callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "start": {
                "line": 112,
                "column": 2
              },
              "end": {
                "line": 114,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "get": {
          "type": "method",
          "label": "get",
          "description": "Issue a `GET` request.",
          "code": "get () {\n    this.makeRequest('GET').apply(this, arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 127,
            "column": 2
          },
          "end": {
            "line": 129,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "url": {
              "type": "argument",
              "label": "url",
              "description": "The URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options .",
              "code": "@param {string|object} url\nThe URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options (except method, which is defined automatically).",
              "start": {
                "line": 127,
                "column": 2
              },
              "end": {
                "line": 129,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": [
                "except method",
                " which is defined automatically"
              ]
            },
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "A callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "code": "@param {Function} callback\nA callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "start": {
                "line": 127,
                "column": 2
              },
              "end": {
                "line": 129,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "post": {
          "type": "method",
          "label": "post",
          "description": "Issue a `POST` request.",
          "code": "post () {\n    this.makeRequest('POST').apply(this, arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 142,
            "column": 2
          },
          "end": {
            "line": 144,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "url": {
              "type": "argument",
              "label": "url",
              "description": "The URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options .",
              "code": "@param {string|object} url\nThe URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options (except method, which is defined automatically).",
              "start": {
                "line": 142,
                "column": 2
              },
              "end": {
                "line": 144,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": [
                "except method",
                " which is defined automatically"
              ]
            },
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "A callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "code": "@param {Function} callback\nA callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "start": {
                "line": 142,
                "column": 2
              },
              "end": {
                "line": 144,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "put": {
          "type": "method",
          "label": "put",
          "description": "Issue a `PUT` request.",
          "code": "put () {\n    this.makeRequest('PUT').apply(this, arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 157,
            "column": 2
          },
          "end": {
            "line": 159,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "url": {
              "type": "argument",
              "label": "url",
              "description": "The URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options .",
              "code": "@param {string|object} url\nThe URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options (except method, which is defined automatically).",
              "start": {
                "line": 157,
                "column": 2
              },
              "end": {
                "line": 159,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": [
                "except method",
                " which is defined automatically"
              ]
            },
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "A callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "code": "@param {Function} callback\nA callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "start": {
                "line": 157,
                "column": 2
              },
              "end": {
                "line": 159,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "delete": {
          "type": "method",
          "label": "delete",
          "description": "Issue a `DELETE` request.",
          "code": "delete () {\n    this.makeRequest('DELETE').apply(this, arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 172,
            "column": 2
          },
          "end": {
            "line": 174,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "url": {
              "type": "argument",
              "label": "url",
              "description": "The URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options .",
              "code": "@param {string|object} url\nThe URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options (except method, which is defined automatically).",
              "start": {
                "line": 172,
                "column": 2
              },
              "end": {
                "line": 174,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": [
                "except method",
                " which is defined automatically"
              ]
            },
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "A callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "code": "@param {Function} callback\nA callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "start": {
                "line": 172,
                "column": 2
              },
              "end": {
                "line": 174,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "trace": {
          "type": "method",
          "label": "trace",
          "description": "Issue a `TRACE` request. This is a debugging method, which\nechoes input back to the user. It is a standard HTTP method,\nbut considered a security risk by many practioners and may\nnot be supported by remote hosts.",
          "code": "trace () {\n    NGN.WARN('NGN.NET.Request.method', 'An HTTP TRACE request was made.')\n    this.makeRequest('TRACE').apply(this, arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 190,
            "column": 2
          },
          "end": {
            "line": 193,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "url": {
              "type": "argument",
              "label": "url",
              "description": "The URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options .",
              "code": "@param {string|object} url\nThe URL to issue the request to.\nThe configuration object accepts all of the #NGN.NET.Request\nconfiguration options (except method, which is defined automatically).",
              "start": {
                "line": 190,
                "column": 2
              },
              "end": {
                "line": 193,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string|object",
              "required": true,
              "enum": [
                "except method",
                " which is defined automatically"
              ]
            },
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "A callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "code": "@param {Function} callback\nA callback method to run when the request is complete.\nThis receives the response object as the only argument.",
              "start": {
                "line": 190,
                "column": 2
              },
              "end": {
                "line": 193,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "json": {
          "type": "method",
          "label": "json",
          "description": "This is a shortcut method for creating a `GET` request and\nauto-processing the response body into a JSON object.",
          "code": "json (url, callback) {\n    if (!NGN.isFn(callback)) {\n      throw new Error('NGN.NET.json requires a callback method.')\n    }\n\n    // Request method is \"GET\"\n    let request = this.parseRequestConfiguration({url})\n\n    this.preflight(request)\n\n    request.send((response) => {\n      try {\n        let responseData = JSON.parse(response.responseText)\n        callback(null, responseData)\n      } catch (e) {\n        e.response = NGN.coalesce(response.responseText)\n        callback(e, null)\n      }\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 209,
            "column": 2
          },
          "end": {
            "line": 228,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "url": {
              "type": "argument",
              "label": "url",
              "description": "The URL to issue the request to.",
              "code": "callback",
              "start": {
                "line": 209,
                "column": 13
              },
              "end": {
                "line": 209,
                "column": 21
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "url",
              "description": "The URL to issue the request to.",
              "code": "callback",
              "start": {
                "line": 209,
                "column": 13
              },
              "end": {
                "line": 209,
                "column": 21
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "jsonp": {
          "type": "method",
          "label": "jsonp",
          "description": "Execute a request via JSONP. JSONP is only available in browser\nenvironments, since it's operation is dependent on the existance of\nthe DOM. However; this may work with some headless browsers.",
          "code": "jsonp (url, callback) {\n    /* node-only */\n    NGN.WARN('NET.Request', 'An unsupported JSONP request was made.')\n    callback(new Error('JSONP unsupported in Node-like environments.'))\n    /* end-node-only */\n    /* browser-only */\n    const fn = 'jsonp_callback_' + Math.round(100000 * Math.random())\n\n    window[fn] = (data) => {\n      delete window[fn]\n\n      document.body.removeChild(script)\n\n      return callback(null, data)\n    }\n\n    let script = document.createElement('script')\n\n    script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + fn\n\n    script.addEventListener('error', (e) => {\n      delete window[fn]\n\n      return callback(new Error('The JSONP request was blocked. This may be the result of an invalid URL, cross origin restrictions, or the remote server may not be online.'))\n    })\n\n    document.body.appendChild(script)\n    /* end-browser-only */\n  }",
          "tags": {
            "environment": {
              "tag": "environment",
              "name": "browser",
              "optional": false,
              "type": "",
              "description": "",
              "line": 14,
              "source": "@environment browser",
              "options": null
            }
          },
          "exceptions": {},
          "start": {
            "line": 246,
            "column": 2
          },
          "end": {
            "line": 274,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "url": {
              "type": "argument",
              "label": "url",
              "description": "The URL of the JSONP endpoint.",
              "code": "callback",
              "start": {
                "line": 246,
                "column": 14
              },
              "end": {
                "line": 246,
                "column": 22
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "url",
              "description": "The URL of the JSONP endpoint.",
              "code": "callback",
              "start": {
                "line": 246,
                "column": 14
              },
              "end": {
                "line": 246,
                "column": 22
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "send": {
          "type": "method",
          "label": "send",
          "description": null,
          "code": "send (request, callback) {\n    this.preflight(request)\n    request.send(callback)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 277,
            "column": 2
          },
          "end": {
            "line": 280,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "request": {
              "type": "argument",
              "label": "request",
              "description": null,
              "code": "request",
              "start": {
                "line": 277,
                "column": 8
              },
              "end": {
                "line": 277,
                "column": 15
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "callback": {
              "type": "argument",
              "label": "callback",
              "description": null,
              "code": "callback",
              "start": {
                "line": 277,
                "column": 17
              },
              "end": {
                "line": 277,
                "column": 25
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "preflight": {
          "type": "method",
          "label": "preflight",
          "description": "This is a no-op method that runs before a request is sent.\nThis exists specicially to be overridden by class extensions.",
          "code": "preflight (request) {}",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 287,
            "column": 2
          },
          "end": {
            "line": 287,
            "column": 24
          },
          "flags": [],
          "arguments": {
            "request": {
              "type": "argument",
              "label": "request",
              "description": null,
              "code": "request",
              "start": {
                "line": 287,
                "column": 13
              },
              "end": {
                "line": 287,
                "column": 20
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.NET.Resource": {
      "type": "class",
      "label": "NGN.NET.Resource",
      "description": "Represents the current global query paramaters.\n    This is commonly used when a remote resource requires a specific\n  query paramater on every call.\n    Example    ```js\n  let resource = new NGN.NET.Resource(...)\n    resource.query = {\n    'user_id': '12345'\n  }\n  ```\n    All parameter values are automatically URL-encoded.",
      "code": "class NetworkResource extends Network {\n  constructor (cfg) {\n    super()\n\n    cfg = cfg || {}\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {object} headers\n       * Contains headers (key/value) that are applied to all requests.\n       */\n      globalHeaders: NGN.private(NGN.coalesceb(cfg.headers, {})),\n\n      /**\n       * @cfg {object} credentials\n       * Contains credentials that are applied to all requests.\n       * @private\n       */\n      globalCredentials: NGN.private(NGN.coalesceb(cfg.credentials, {})),\n\n      /**\n       * @cfg {string} username\n       * Use this to set a username (instead of using #credentials).\n       */\n      user: NGN.private(NGN.coalesceb(cfg.username)),\n\n      /**\n       * @cfg {string} password\n       * Use this to set a password (instead of using #credentials).\n       */\n      secret: NGN.private(NGN.coalesceb(cfg.password)),\n\n      /**\n       * @cfg {string} accessToken\n       * Use this to set an access token (instead of using #credentials).\n       */\n      accesstoken: NGN.private(NGN.coalesceb(cfg.token, cfg.accessToken)),\n\n      /**\n       * @cfg {object} query\n       * Contains query parameters to be applied to all requests. All values\n       * are automatically url-encoded.\n       */\n      globalQuery: NGN.private(NGN.coalesceb(cfg.query, {})),\n\n      /**\n       * @cfg {string} [baseUrl=window.loction.origin]\n       * The root domain/base URL to apply to all requests to relative URL's.\n       * This was designed for uses where a backend API may be served on\n       * another domain (such as api.mydomain.com instead of www.mydomain.com).\n       * The root will only be applied to relative paths that do not begin\n       * with a protocol. For example, `./path/to/endpoint` **will** have\n       * the root applied (`{root}/path/to/endpoint`) whereas `https://domain.com/endpoint`\n       * will **not** have the root applied.\n       */\n      baseUrl: NGN.private(NGN.coalesce(cfg.baseUrl, cfg.baseurl, `http://${hostname}/`)),\n\n      /**\n       * @cfg {boolean} [nocache=false]\n       * Set this to `true` to add a unique cache-busting URL parameter to all requests.\n       */\n      nocache: NGN.private(NGN.coalesce(cfg.nocache, false)),\n\n      /**\n       * @cfg {boolean} [sslonly=false]\n       * Set this to true to rewrite all URL's to use HTTPS.\n       */\n      sslonly: NGN.public(NGN.coalesce(cfg.sslonly, false))\n    })\n\n    if (this.baseUrl.indexOf('://') < 0 || this.baseUrl.indexOf('://') > 10) {\n      this.baseUrl = `http${this.sslonly ? 's' : ''}://${this.baseUrl}`\n    } else if (this.sslonly) {\n      this.baseUrl = this.baseUrl.replace('http://', 'https://')\n    }\n\n    if (this.accesstoken !== null) {\n      this.credentials = {\n        accessToken: this.accesstoken\n      }\n    } else if (this.user !== null && this.ssecret !== null) {\n      this.credentials = {\n        username: this.user,\n        password: this.secret\n      }\n    }\n  }\n\n  get username () {\n    return this.user\n  }\n\n  set username (value) {\n    if (this.user !== value) {\n      this.user = value\n\n      if (this.secret !== null) {\n        this.credentials = {\n          username: this.user,\n          password: this.secret\n        }\n      }\n    }\n  }\n\n  set password (value) {\n    if (this.secret !== value) {\n      this.secret = value\n\n      if (this.user !== null) {\n        this.credentials = {\n          username: this.user,\n          password: this.secret\n        }\n      }\n    }\n  }\n\n  /**\n   * @property {object} headers\n   * Represents the current global headers.\n   *\n   * This is commonly used when a remote resource requires a specific\n   * header on every call.\n   *\n   * **Example**\n   *\n   * ```js\n   * let resource = new NGN.NET.Resource(...)\n   *\n   * resource.headers = {\n   *   'user-agent': 'my custom agent name'\n   * }\n   * ```\n   */\n  get headers () {\n    return this.globalHeaders\n  }\n\n  set headers (value) {\n    this.globalHeaders = value\n  }\n\n  /**\n   * @property credentials\n   * Configure credentials that are applied to every request.\n   * This is commonly used when communicating with a RESTful API.\n   * This can accept a username and password or an access token.\n   *\n   * **Examples**\n   *\n   * ```js\n   *  let resource = new NGN.NET.Resource(...)\n   *\n   *  resource.credentials = {\n   *    username: 'user',\n   *    password: 'pass'\n   *  }\n   * ```\n   *\n   * ```js\n   * resource.credentials = {\n   *   accessToken: 'token'\n   * }\n   * ```\n   */\n  set credentials (credentials) {\n    if (credentials.hasOwnProperty('accesstoken') || credentials.hasOwnProperty('accessToken') || credentials.hasOwnProperty('token')) {\n      credentials.accessToken = NGN.coalesce(credentials.accessToken, credentials.accesstoken, credentials.token)\n\n      if (credentials.hasOwnProperty('username')) {\n        delete credentials.username\n      }\n\n      if (credentials.hasOwnProperty('password')) {\n        delete credentials.password\n      }\n    } else if (!(credentials.hasOwnProperty('username') && credentials.hasOwnProperty('password')) && !credentials.hasOwnProperty('accessToken')) {\n      throw new Error('Invalid credentials. Must contain an access token OR the combination of a username AND password.')\n    }\n\n    this.globalCredentials = credentials\n\n    if (credentials.username) {\n      this.username = credentials.username\n    }\n\n    if (credentials.password) {\n      this.password = credentials.password\n    }\n  }\n\n  // Explicitly deny credential reading.\n  get credentials () {\n    NGN.WARN('Credentials are write-only. An attempt to read credentials was denied.')\n    return {\n      username: null,\n      secret: null,\n      password: null,\n      accessToken: null\n    }\n  }\n\n  /**\n   * @property {object} query\n   * Represents the current global query paramaters.\n   *\n   * This is commonly used when a remote resource requires a specific\n   * query paramater on every call.\n   *\n   * **Example**\n   *\n   * ```js\n   * let resource = new NGN.NET.Resource(...)\n   *\n   * resource.query = {\n   *   'user_id': '12345'\n   * }\n   * ```\n   *\n   * All parameter values are automatically URL-encoded.\n   */\n  get query () {\n    return this.globalQuery\n  }\n\n  set query (value) {\n    this.globalQuery = value\n  }\n\n  /**\n   * @method prepareUrl\n   * Prepare a URL by applying the base URL (only when appropriate).\n   * @param  {string} uri\n   * The universal resource indicator (URI/URL) to prepare.\n   * @return {string}\n   * Returns a fully qualified URL.\n   * @private\n   */\n  prepareUrl (uri) {\n    if (uri.indexOf('://') < 0) {\n      uri = normalizeUrl(`${this.baseUrl}/${uri}`)\n    }\n\n    return uri.replace(/\\/{2,5}/gi, '/').replace(/:\\/{1}/i, '://')\n  }\n\n  /**\n   * @method preflight\n   * Prepares a request before it is sent.\n   * @param {NGN.NET.Request} request\n   * The request object.\n   * @private\n   */\n  preflight (request) {\n    // Apply the base URL\n    request.url = this.prepareUrl(request.url)\n\n    // If global query parameters have been defined, apply them.\n    let qp = Object.keys(this.globalQuery)\n    if (qp.length > 0) {\n      let queryString = []\n      for (let i = 0; i < qp.length; i++) {\n        queryString.push(`${qp[i]}=${encodeURIComponent(this.globalQuery[qp[i]])}`)\n      }\n\n      if (request.query === '') {\n        request.url = `${request.url}?${queryString.join('&')}`\n      } else {\n        request.url = `${request.url}&${queryString.join('&')}`\n      }\n    }\n\n    // If global credentials are available, apply them.\n    let gHeaders = Object.keys(this.globalHeaders)\n    for (let i = 0; i < gHeaders.length; i++) {\n      request.setHeader(gHeaders[i], this.globalHeaders[gHeaders[i]])\n    }\n\n    // If global headers/credentials are available, apply them.\n    if (this.globalCredentials.accessToken) {\n      request.accessToken = this.globalCredentials.accessToken\n    } else if (this.globalCredentials.username) {\n      request.username = this.globalCredentials.username\n      request.password = this.globalCredentials.password\n    }\n\n    // Add a cache buster\n    if (this.nocache) {\n      request.setQueryParameter('nocache' + (new Date()).getTime().toString() + Math.random().toString().replace('.', ''), null)\n    }\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 55,
        "column": 15
      },
      "end": {
        "line": 347,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./net/Resource.js",
      "extends": "NGN.NET",
      "configuration": {
        "headers": {
          "type": "property",
          "label": "headers",
          "description": "Contains headers  that are applied to all requests.",
          "code": "globalHeaders: NGN.private(NGN.coalesceb(cfg.headers, {}))",
          "start": {
            "line": 66,
            "column": 6
          },
          "end": {
            "line": 66,
            "column": 64
          },
          "flags": [],
          "default": null,
          "datatype": "object",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "credentials": {
          "type": "property",
          "label": "credentials",
          "description": "Contains credentials that are applied to all requests.",
          "code": "globalCredentials: NGN.private(NGN.coalesceb(cfg.credentials, {}))",
          "start": {
            "line": 73,
            "column": 6
          },
          "end": {
            "line": 73,
            "column": 72
          },
          "flags": [],
          "default": null,
          "datatype": "object",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "username": {
          "type": "property",
          "label": "username",
          "description": "Use this to set a username .",
          "code": "user: NGN.private(NGN.coalesceb(cfg.username))",
          "start": {
            "line": 79,
            "column": 6
          },
          "end": {
            "line": 79,
            "column": 52
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "password": {
          "type": "property",
          "label": "password",
          "description": "Use this to set a password .",
          "code": "secret: NGN.private(NGN.coalesceb(cfg.password))",
          "start": {
            "line": 85,
            "column": 6
          },
          "end": {
            "line": 85,
            "column": 54
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "accessToken": {
          "type": "property",
          "label": "accessToken",
          "description": "Use this to set an access token .",
          "code": "accesstoken: NGN.private(NGN.coalesceb(cfg.token, cfg.accessToken))",
          "start": {
            "line": 91,
            "column": 6
          },
          "end": {
            "line": 91,
            "column": 73
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "query": {
          "type": "property",
          "label": "query",
          "description": "Contains query parameters to be applied to all requests. All values\nare automatically url-encoded.",
          "code": "globalQuery: NGN.private(NGN.coalesceb(cfg.query, {}))",
          "start": {
            "line": 98,
            "column": 6
          },
          "end": {
            "line": 98,
            "column": 60
          },
          "flags": [],
          "default": null,
          "datatype": "object",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "baseUrl": {
          "type": "property",
          "label": "baseUrl",
          "description": "The root domain/base URL to apply to all requests to relative URL's.\nThis was designed for uses where a backend API may be served on\nanother domain .\nThe root will only be applied to relative paths that do not begin\nwith a protocol. For example, `./path/to/endpoint` **will** have\nthe root applied (`{root}/path/to/endpoint`) whereas `https://domain.com/endpoint`\nwill **not** have the root applied.",
          "code": "baseUrl: NGN.private(NGN.coalesce(cfg.baseUrl, cfg.baseurl, `http://${hostname}/`))",
          "start": {
            "line": 110,
            "column": 6
          },
          "end": {
            "line": 110,
            "column": 89
          },
          "flags": [],
          "default": "window.loction.origin",
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "nocache": {
          "type": "property",
          "label": "nocache",
          "description": "Set this to `true` to add a unique cache-busting URL parameter to all requests.",
          "code": "nocache: NGN.private(NGN.coalesce(cfg.nocache, false))",
          "start": {
            "line": 116,
            "column": 6
          },
          "end": {
            "line": 116,
            "column": 60
          },
          "flags": [],
          "default": "false",
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "sslonly": {
          "type": "property",
          "label": "sslonly",
          "description": "Set this to true to rewrite all URL's to use HTTPS.",
          "code": "sslonly: NGN.public(NGN.coalesce(cfg.sslonly, false))",
          "start": {
            "line": 122,
            "column": 6
          },
          "end": {
            "line": 122,
            "column": 59
          },
          "flags": [],
          "default": "false",
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        }
      },
      "properties": {
        "headers": {
          "type": "property",
          "label": "headers",
          "description": null,
          "code": "set headers (value) {\n    this.globalHeaders = value\n  }",
          "start": {
            "line": 194,
            "column": 2
          },
          "end": {
            "line": 196,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "credentials": {
          "type": "property",
          "label": "credentials",
          "description": null,
          "code": "get credentials () {\n    NGN.WARN('Credentials are write-only. An attempt to read credentials was denied.')\n    return {\n      username: null,\n      secret: null,\n      password: null,\n      accessToken: null\n    }\n  }",
          "start": {
            "line": 248,
            "column": 2
          },
          "end": {
            "line": 256,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "username": {
          "type": "property",
          "label": "username",
          "description": null,
          "code": "set username (value) {\n    if (this.user !== value) {\n      this.user = value\n\n      if (this.secret !== null) {\n        this.credentials = {\n          username: this.user,\n          password: this.secret\n        }\n      }\n    }\n  }",
          "start": {
            "line": 147,
            "column": 2
          },
          "end": {
            "line": 158,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "password": {
          "type": "property",
          "label": "password",
          "description": null,
          "code": "set password (value) {\n    if (this.secret !== value) {\n      this.secret = value\n\n      if (this.user !== null) {\n        this.credentials = {\n          username: this.user,\n          password: this.secret\n        }\n      }\n    }\n  }",
          "start": {
            "line": 160,
            "column": 2
          },
          "end": {
            "line": 171,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "accessToken": {
          "type": "property",
          "label": "accessToken",
          "description": "Use this to set an access token .",
          "code": "accesstoken: NGN.private(NGN.coalesceb(cfg.token, cfg.accessToken))",
          "start": {
            "line": 91,
            "column": 6
          },
          "end": {
            "line": 91,
            "column": 73
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "query": {
          "type": "property",
          "label": "query",
          "description": null,
          "code": "set query (value) {\n    this.globalQuery = value\n  }",
          "start": {
            "line": 281,
            "column": 2
          },
          "end": {
            "line": 283,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "baseUrl": {
          "type": "property",
          "label": "baseUrl",
          "description": "The root domain/base URL to apply to all requests to relative URL's.\nThis was designed for uses where a backend API may be served on\nanother domain .\nThe root will only be applied to relative paths that do not begin\nwith a protocol. For example, `./path/to/endpoint` **will** have\nthe root applied (`{root}/path/to/endpoint`) whereas `https://domain.com/endpoint`\nwill **not** have the root applied.",
          "code": "baseUrl: NGN.private(NGN.coalesce(cfg.baseUrl, cfg.baseurl, `http://${hostname}/`))",
          "start": {
            "line": 110,
            "column": 6
          },
          "end": {
            "line": 110,
            "column": 89
          },
          "flags": [],
          "default": "window.loction.origin",
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "nocache": {
          "type": "property",
          "label": "nocache",
          "description": "Set this to `true` to add a unique cache-busting URL parameter to all requests.",
          "code": "nocache: NGN.private(NGN.coalesce(cfg.nocache, false))",
          "start": {
            "line": 116,
            "column": 6
          },
          "end": {
            "line": 116,
            "column": 60
          },
          "flags": [],
          "default": "false",
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "sslonly": {
          "type": "property",
          "label": "sslonly",
          "description": "Set this to true to rewrite all URL's to use HTTPS.",
          "code": "sslonly: NGN.public(NGN.coalesce(cfg.sslonly, false))",
          "start": {
            "line": 122,
            "column": 6
          },
          "end": {
            "line": 122,
            "column": 59
          },
          "flags": [],
          "default": "false",
          "datatype": "boolean",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (cfg) {\n    super()\n\n    cfg = cfg || {}\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {object} headers\n       * Contains headers (key/value) that are applied to all requests.\n       */\n      globalHeaders: NGN.private(NGN.coalesceb(cfg.headers, {})),\n\n      /**\n       * @cfg {object} credentials\n       * Contains credentials that are applied to all requests.\n       * @private\n       */\n      globalCredentials: NGN.private(NGN.coalesceb(cfg.credentials, {})),\n\n      /**\n       * @cfg {string} username\n       * Use this to set a username (instead of using #credentials).\n       */\n      user: NGN.private(NGN.coalesceb(cfg.username)),\n\n      /**\n       * @cfg {string} password\n       * Use this to set a password (instead of using #credentials).\n       */\n      secret: NGN.private(NGN.coalesceb(cfg.password)),\n\n      /**\n       * @cfg {string} accessToken\n       * Use this to set an access token (instead of using #credentials).\n       */\n      accesstoken: NGN.private(NGN.coalesceb(cfg.token, cfg.accessToken)),\n\n      /**\n       * @cfg {object} query\n       * Contains query parameters to be applied to all requests. All values\n       * are automatically url-encoded.\n       */\n      globalQuery: NGN.private(NGN.coalesceb(cfg.query, {})),\n\n      /**\n       * @cfg {string} [baseUrl=window.loction.origin]\n       * The root domain/base URL to apply to all requests to relative URL's.\n       * This was designed for uses where a backend API may be served on\n       * another domain (such as api.mydomain.com instead of www.mydomain.com).\n       * The root will only be applied to relative paths that do not begin\n       * with a protocol. For example, `./path/to/endpoint` **will** have\n       * the root applied (`{root}/path/to/endpoint`) whereas `https://domain.com/endpoint`\n       * will **not** have the root applied.\n       */\n      baseUrl: NGN.private(NGN.coalesce(cfg.baseUrl, cfg.baseurl, `http://${hostname}/`)),\n\n      /**\n       * @cfg {boolean} [nocache=false]\n       * Set this to `true` to add a unique cache-busting URL parameter to all requests.\n       */\n      nocache: NGN.private(NGN.coalesce(cfg.nocache, false)),\n\n      /**\n       * @cfg {boolean} [sslonly=false]\n       * Set this to true to rewrite all URL's to use HTTPS.\n       */\n      sslonly: NGN.public(NGN.coalesce(cfg.sslonly, false))\n    })\n\n    if (this.baseUrl.indexOf('://') < 0 || this.baseUrl.indexOf('://') > 10) {\n      this.baseUrl = `http${this.sslonly ? 's' : ''}://${this.baseUrl}`\n    } else if (this.sslonly) {\n      this.baseUrl = this.baseUrl.replace('http://', 'https://')\n    }\n\n    if (this.accesstoken !== null) {\n      this.credentials = {\n        accessToken: this.accesstoken\n      }\n    } else if (this.user !== null && this.ssecret !== null) {\n      this.credentials = {\n        username: this.user,\n        password: this.secret\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 56,
            "column": 2
          },
          "end": {
            "line": 141,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "cfg": {
              "type": "argument",
              "label": "cfg",
              "description": null,
              "code": "cfg",
              "start": {
                "line": 56,
                "column": 15
              },
              "end": {
                "line": 56,
                "column": 18
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "prepareUrl": {
          "type": "method",
          "label": "prepareUrl",
          "description": "Prepare a URL by applying the base URL .",
          "code": "prepareUrl (uri) {\n    if (uri.indexOf('://') < 0) {\n      uri = normalizeUrl(`${this.baseUrl}/${uri}`)\n    }\n\n    return uri.replace(/\\/{2,5}/gi, '/').replace(/:\\/{1}/i, '://')\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 294,
            "column": 2
          },
          "end": {
            "line": 300,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "uri": {
              "type": "argument",
              "label": "uri",
              "description": "The universal resource indicator  to prepare.",
              "code": "@param  {string} uri\nThe universal resource indicator (URI/URL) to prepare.",
              "start": {
                "line": 294,
                "column": 2
              },
              "end": {
                "line": 300,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": [
                "URI/URL"
              ]
            }
          },
          "returnType": "string",
          "returnDescription": "null Returns a fully qualified URL.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "preflight": {
          "type": "method",
          "label": "preflight",
          "description": "Prepares a request before it is sent.",
          "code": "preflight (request) {\n    // Apply the base URL\n    request.url = this.prepareUrl(request.url)\n\n    // If global query parameters have been defined, apply them.\n    let qp = Object.keys(this.globalQuery)\n    if (qp.length > 0) {\n      let queryString = []\n      for (let i = 0; i < qp.length; i++) {\n        queryString.push(`${qp[i]}=${encodeURIComponent(this.globalQuery[qp[i]])}`)\n      }\n\n      if (request.query === '') {\n        request.url = `${request.url}?${queryString.join('&')}`\n      } else {\n        request.url = `${request.url}&${queryString.join('&')}`\n      }\n    }\n\n    // If global credentials are available, apply them.\n    let gHeaders = Object.keys(this.globalHeaders)\n    for (let i = 0; i < gHeaders.length; i++) {\n      request.setHeader(gHeaders[i], this.globalHeaders[gHeaders[i]])\n    }\n\n    // If global headers/credentials are available, apply them.\n    if (this.globalCredentials.accessToken) {\n      request.accessToken = this.globalCredentials.accessToken\n    } else if (this.globalCredentials.username) {\n      request.username = this.globalCredentials.username\n      request.password = this.globalCredentials.password\n    }\n\n    // Add a cache buster\n    if (this.nocache) {\n      request.setQueryParameter('nocache' + (new Date()).getTime().toString() + Math.random().toString().replace('.', ''), null)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 309,
            "column": 2
          },
          "end": {
            "line": 346,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "request": {
              "type": "argument",
              "label": "request",
              "description": "The request object.",
              "code": "@param {NGN.NET.Request} request\nThe request object.",
              "start": {
                "line": 309,
                "column": 2
              },
              "end": {
                "line": 346,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "ngn.net.request",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.Queue": {
      "type": "class",
      "label": "NGN.Queue",
      "description": "The type of processing (dev, production, etc). Setting this to\n  `dev` enables verbose logging.",
      "code": "class Queue extends EventEmitter {\n  /**\n   * @constructor\n   * @param {string} [mode=production]\n   * Set this to `dev` for verbose console output.\n   */\n  constructor (mode = 'production') {\n    super()\n\n    Object.defineProperties(this, {\n      steps: NGN.private([]),\n      completed: NGN.private(0),\n      timeout: NGN.private(null),\n      _mode: NGN.private(mode),\n      _cancel: NGN.private(false),\n      processing: NGN.private(false),\n      timer: NGN.private(null),\n      sequential: NGN.private(false)\n    })\n\n    this.on('taskcomplete', (step) => {\n      // Disallow duplicates\n      if (this.sequential || step.status === 'completed') {\n        return\n      }\n\n      step._status = 'complete'\n\n      // When the step is done, tally it\n      this.completed++\n\n      if (this.mode === 'dev') {\n        NGN.INFO(step.name + ' completed.')\n      }\n\n      // If all of the queries have been tallied, we're done.\n      if (this.completed === this.steps.length) {\n        this.processing = false\n\n        Object.keys(this.steps).forEach((step) => {\n          clearTimeout(this.steps[step].timer)\n        })\n\n        this.emit('complete')\n      }\n    })\n\n    this.on('aborting', () => {\n      this._cancel = true\n    })\n  }\n\n  /**\n   * @property {Array} list\n   * A list of tasks within the collection. This is an array of\n   * objects, where each object contains the `id`, `name`, and\n   * `status` of the task.\n   *\n   * ```js\n   * {\n   *   id: <Number>,\n   *   name: <String>,\n   *   status: <String>\n   * }\n   * ```\n   */\n  get list () {\n    return this.steps.map(function (s) {\n      return {\n        id: s.number,\n        name: s.name,\n        status: s.status\n      }\n    })\n  }\n\n  /**\n   * @property {string} mode\n   * The type of processing (dev, production, etc). Setting this to\n   * `dev` enables verbose logging.\n   */\n  get mode () {\n    return this._mode\n  }\n\n  set mode (value) {\n    if (value.toLowerCase().substr(0, 3) === 'dev') {\n      this._mode = 'dev'\n    } else {\n      this._mode = 'production'\n    }\n  }\n\n  get cancelled () {\n    return this._cancel\n  }\n\n  onTimeout () {\n    let log = []\n\n    if (this.steps.length > 0) {\n      this.steps.forEach((s) => {\n        log.push(s.name, s.status === null ? 'NOT STARTED' : s.status)\n      })\n    }\n\n    this.emit('timeout', {\n      process: log\n    })\n\n    log = null\n  }\n\n  /**\n   * @method add\n   * Add a task to the list.\n   * @param {string} [name]\n   * A descriptive name for the queued process/task.\n   * @param {function} callback\n   * The function to queue.\n   * @param {function} callback.next\n   * This argument allows users to explicitly use asynchronous\n   * methods. Example:\n   *\n   * ```\n   * let tasks = new NGN.Tasks()\n   *\n   * tasks.add('Descriptive Title', function (next) {\n   *   myAsyncMethod(function () {\n   *     console.log('Ran something async.')\n   *     next()\n   *   })\n   * })\n   * @returns {NGN.Task}\n   * Returns the task object added to the queue.\n   */\n  add (name, fn) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    if (typeof name === 'function') {\n      fn = name\n      name = 'Step ' + (parseInt(this.steps.length) + 1)\n    }\n\n    if (typeof fn !== 'function') {\n      throw new Error('No processing method defined for step ' + (parseInt(this.steps.length) + 1) + '.')\n    }\n\n    const queue = new NGN.Task({\n      name: name,\n      callback: fn,\n      number: (this.steps.length > 0 ? this.steps[this.steps.length - 1].number : 0) + 1\n    })\n\n    queue.on('complete', (step) => this.emit('taskcomplete', step))\n\n    queue.on('timeout', (step) => {\n      if (step.status === 'running' || step.status === 'timedout') {\n        this.emit('tasktimeout', step)\n      }\n    })\n\n    this.steps.push(queue)\n    this.emit('taskcreate', queue)\n\n    return queue\n  }\n\n  /**\n   * @method getAt\n   * @param  {number} index\n   * Retrieve a queue item by it's index/queue number.\n   * @return {Queue}\n   */\n  getAt (index) {\n    return this.steps[index]\n  }\n\n  /**\n   * @method get\n   * Retrieve a specific queue item.\n   * @param  {string} requestedStepTitle\n   * The descriptie name of the queue item to retrieve.\n   * @return {Queue}\n   */\n  get (requestedStep) {\n    // Get by Name\n    let element = this.steps.filter((step) => {\n      return step.name === requestedStep\n    })\n\n    if (element.length === 1) {\n      return element[0]\n    }\n\n    // Get by index\n    element = this.steps.filter((step) => {\n      return step.number === requestedStep\n    })\n\n    if (element.length === 1) {\n      return element[0]\n    }\n  }\n\n  /**\n   * @method remove\n   * Remove a queue item by name or number.\n   * @param  {string} requestedStepTitle\n   * The descriptive name of the queue item to retrieve.\n   * @return {Queue}\n   * Returns the item that was removed.\n   */\n  remove (requestedStep) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    // Remove by name\n    let element = this.steps.filter((step) => {\n      return step.name === requestedStep\n    })\n\n    if (element.length === 1) {\n      this.steps = this.steps.filter((step) => {\n        return step.name !== requestedStep\n      })\n\n      this.emit('taskremove', element[0])\n      return element[0]\n    }\n\n    // Remove by ID\n    element = this.steps.filter((step) => {\n      return step.number === requestedStep\n    })\n\n    if (element.length === 1) {\n      this.steps = this.steps.filter((step) => {\n        return step.number !== requestedStep\n      })\n\n      this.emit('taskremove', element[0])\n      return element[0]\n    }\n  }\n\n  /**\n   * @method removeAt\n   * Removes a queue item from the specific index.\n   * @param  {number} requestedStepIndex\n   * The queue index/number.\n   * @return {Queue}\n   * Returns the item that was removed.\n   */\n  removeAt (requestedStep) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    // Remove by index\n    if (typeof requestedStep !== 'number') {\n      return console.error('Failed to remove step: ' + requestedStep)\n    }\n\n    if (requestedStep < 0 || requestedStep >= this.steps.length) {\n      return console.error('Step index ' + requestedStep + ' could not be found or does not exist.')\n    }\n\n    return this.steps.splice(requestedStep, 1)[0]\n  }\n\n  /**\n   * @method reset\n   * Resets all cancelled/skipped steps, essentially resetting the queue\n   * to it's pre-aborted state.\n   */\n  reset () {\n    if (this.processing) {\n      return NGN.WARN('Cannot reset a running queue. Abort or wait for the process to complete before resetting.')\n    }\n\n    // Refresh cancelled steps\n    this.steps.forEach((step) => {\n      step._skip = false\n    })\n  }\n\n  /**\n   * @method process\n   * Run the queued processes in order.\n   * @param {boolean} [sequential=false]\n   * Set to `true` to run the queue items in a synchronous-like manner.\n   * This will execute each method one after the other. Each method must\n   * complete before the next is started.\n   */\n  process (sequential = false) {\n    if (this.processing) {\n      return NGN.WARN('Cannot start processing (already running). Please wait for this process to complete before calling process() again.')\n    }\n\n    if (this.steps.length === 0) {\n      return this.emit('complete')\n    }\n\n    this.processing = true\n    this._cancel = false\n\n    if (this.timeout !== null) {\n      this.timer = setTimeout(() => this.onTimeout(), this.timeout)\n    }\n\n    this.sequential = typeof sequential === 'boolean' ? sequential : false\n    if (!this.sequential) {\n      for (let i = 0; i < this.steps.length; i++) {\n        this.steps[i].run(this.mode)\n      }\n    } else {\n      let queue = this.steps\n      let listener = new NGN.EventEmitter()\n\n      listener.on('taskcomplete', () => {\n        if (queue.length > 0) {\n          const currentTask = queue.shift()\n\n          if (currentTask.skipped) {\n            return listener.emit('taskcomplete')\n          }\n\n          currentTask.on('complete', () => listener.emit('taskcomplete'))\n          currentTask.on('start', () => this.emit('taskstart', currentTask))\n\n          currentTask.run(this.mode)\n        } else {\n          this.emit('complete')\n        }\n      })\n\n      let currentStep = queue.shift()\n\n      currentStep.on('complete', () => listener.emit('taskcomplete'))\n      currentStep.on('start', () => this.emit('taskstart', currentStep))\n\n      currentStep.run(this.mode)\n    }\n  }\n\n  // Alias for process\n  run () {\n    this.process(...arguments)\n  }\n\n  /**\n   * @method abort\n   * Abort/cancel processing. This prevents further steps from processing.\n   */\n  abort () {\n    this.emit('aborting')\n\n    // Make sure the steps are skipped.\n    this.each((step) => {\n      if (['completed', 'running', 'timedout'].indexOf(step.status) < 0 && !step.skipped) {\n        step.skip()\n      }\n    })\n\n    this.once('complete', () => this.emit('aborted'))\n  }\n\n  /**\n   * @method each\n   * Apply a method to each step.\n   * @param {function} method\n   * @private\n   */\n  each (fn) {\n    for (let i = 0; i < this.steps.length; i++) {\n      fn(this.steps[i])\n    }\n  }\n\n  // Alias for abort\n  cancel () {\n    this.abort(...arguments)\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "complete": {
          "type": "event",
          "label": "complete",
          "description": null,
          "code": "this.emit('complete')",
          "start": {
            "line": 367,
            "column": 10
          },
          "end": {
            "line": 367,
            "column": 31
          },
          "flags": [],
          "parameters": {},
          "deprecated": false,
          "deprecationReplacement": null
        },
        "timeout": {
          "type": "event",
          "label": "timeout",
          "description": null,
          "code": "this.emit('timeout', {\n      process: log\n    })",
          "start": {
            "line": 137,
            "column": 4
          },
          "end": {
            "line": 139,
            "column": 6
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": "{\n      process: log\n    }",
              "start": {
                "line": 137,
                "column": 25
              },
              "end": {
                "line": 139,
                "column": 5
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "taskcomplete": {
          "type": "event",
          "label": "taskcomplete",
          "description": null,
          "code": "this.emit('taskcomplete', step)",
          "start": {
            "line": 187,
            "column": 35
          },
          "end": {
            "line": 187,
            "column": 66
          },
          "flags": [],
          "parameters": {
            "step": {
              "type": "argument",
              "label": "step",
              "description": null,
              "code": "step",
              "start": {
                "line": 187,
                "column": 61
              },
              "end": {
                "line": 187,
                "column": 65
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "tasktimeout": {
          "type": "event",
          "label": "tasktimeout",
          "description": null,
          "code": "this.emit('tasktimeout', step)",
          "start": {
            "line": 191,
            "column": 8
          },
          "end": {
            "line": 191,
            "column": 38
          },
          "flags": [],
          "parameters": {
            "step": {
              "type": "argument",
              "label": "step",
              "description": null,
              "code": "step",
              "start": {
                "line": 191,
                "column": 33
              },
              "end": {
                "line": 191,
                "column": 37
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "taskcreate": {
          "type": "event",
          "label": "taskcreate",
          "description": null,
          "code": "this.emit('taskcreate', queue)",
          "start": {
            "line": 196,
            "column": 4
          },
          "end": {
            "line": 196,
            "column": 34
          },
          "flags": [],
          "parameters": {
            "queue": {
              "type": "argument",
              "label": "queue",
              "description": null,
              "code": "queue",
              "start": {
                "line": 196,
                "column": 28
              },
              "end": {
                "line": 196,
                "column": 33
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "taskremove": {
          "type": "event",
          "label": "taskremove",
          "description": null,
          "code": "this.emit('taskremove', element[0])",
          "start": {
            "line": 275,
            "column": 6
          },
          "end": {
            "line": 275,
            "column": 41
          },
          "flags": [],
          "parameters": {
            "element.undefined": {
              "type": "argument",
              "label": "element.undefined",
              "description": null,
              "code": "element[0]",
              "start": {
                "line": 275,
                "column": 30
              },
              "end": {
                "line": 275,
                "column": 40
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "taskstart": {
          "type": "event",
          "label": "taskstart",
          "description": null,
          "code": "this.emit('taskstart', currentStep)",
          "start": {
            "line": 374,
            "column": 36
          },
          "end": {
            "line": 374,
            "column": 71
          },
          "flags": [],
          "parameters": {
            "currentStep": {
              "type": "argument",
              "label": "currentStep",
              "description": null,
              "code": "currentStep",
              "start": {
                "line": 374,
                "column": 59
              },
              "end": {
                "line": 374,
                "column": 70
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "aborting": {
          "type": "event",
          "label": "aborting",
          "description": null,
          "code": "this.emit('aborting')",
          "start": {
            "line": 390,
            "column": 4
          },
          "end": {
            "line": 390,
            "column": 25
          },
          "flags": [],
          "parameters": {},
          "deprecated": false,
          "deprecationReplacement": null
        },
        "aborted": {
          "type": "event",
          "label": "aborted",
          "description": null,
          "code": "this.emit('aborted')",
          "start": {
            "line": 399,
            "column": 32
          },
          "end": {
            "line": 399,
            "column": 52
          },
          "flags": [],
          "parameters": {},
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 31,
        "column": 15
      },
      "end": {
        "line": 418,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./queue/queue.js",
      "extends": "EventEmitter",
      "configuration": {},
      "properties": {
        "steps": {
          "type": "property",
          "label": "steps",
          "description": null,
          "code": "steps: NGN.private([])",
          "start": {
            "line": 41,
            "column": 6
          },
          "end": {
            "line": 41,
            "column": 28
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "completed": {
          "type": "property",
          "label": "completed",
          "description": null,
          "code": "completed: NGN.private(0)",
          "start": {
            "line": 42,
            "column": 6
          },
          "end": {
            "line": 42,
            "column": 31
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "timeout": {
          "type": "property",
          "label": "timeout",
          "description": null,
          "code": "timeout: NGN.private(null)",
          "start": {
            "line": 43,
            "column": 6
          },
          "end": {
            "line": 43,
            "column": 32
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "_mode": {
          "type": "property",
          "label": "_mode",
          "description": null,
          "code": "_mode: NGN.private(mode)",
          "start": {
            "line": 44,
            "column": 6
          },
          "end": {
            "line": 44,
            "column": 30
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "_cancel": {
          "type": "property",
          "label": "_cancel",
          "description": null,
          "code": "_cancel: NGN.private(false)",
          "start": {
            "line": 45,
            "column": 6
          },
          "end": {
            "line": 45,
            "column": 33
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "processing": {
          "type": "property",
          "label": "processing",
          "description": null,
          "code": "processing: NGN.private(false)",
          "start": {
            "line": 46,
            "column": 6
          },
          "end": {
            "line": 46,
            "column": 36
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "timer": {
          "type": "property",
          "label": "timer",
          "description": null,
          "code": "timer: NGN.private(null)",
          "start": {
            "line": 47,
            "column": 6
          },
          "end": {
            "line": 47,
            "column": 30
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "sequential": {
          "type": "property",
          "label": "sequential",
          "description": null,
          "code": "sequential: NGN.private(false)",
          "start": {
            "line": 48,
            "column": 6
          },
          "end": {
            "line": 48,
            "column": 36
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "list": {
          "type": "property",
          "label": "list",
          "description": null,
          "code": "get list () {\n    return this.steps.map(function (s) {\n      return {\n        id: s.number,\n        name: s.name,\n        status: s.status\n      }\n    })\n  }",
          "start": {
            "line": 97,
            "column": 2
          },
          "end": {
            "line": 105,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "mode": {
          "type": "property",
          "label": "mode",
          "description": null,
          "code": "set mode (value) {\n    if (value.toLowerCase().substr(0, 3) === 'dev') {\n      this._mode = 'dev'\n    } else {\n      this._mode = 'production'\n    }\n  }",
          "start": {
            "line": 116,
            "column": 2
          },
          "end": {
            "line": 122,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "cancelled": {
          "type": "property",
          "label": "cancelled",
          "description": null,
          "code": "get cancelled () {\n    return this._cancel\n  }",
          "start": {
            "line": 124,
            "column": 2
          },
          "end": {
            "line": 126,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "",
          "code": "constructor (mode = 'production') {\n    super()\n\n    Object.defineProperties(this, {\n      steps: NGN.private([]),\n      completed: NGN.private(0),\n      timeout: NGN.private(null),\n      _mode: NGN.private(mode),\n      _cancel: NGN.private(false),\n      processing: NGN.private(false),\n      timer: NGN.private(null),\n      sequential: NGN.private(false)\n    })\n\n    this.on('taskcomplete', (step) => {\n      // Disallow duplicates\n      if (this.sequential || step.status === 'completed') {\n        return\n      }\n\n      step._status = 'complete'\n\n      // When the step is done, tally it\n      this.completed++\n\n      if (this.mode === 'dev') {\n        NGN.INFO(step.name + ' completed.')\n      }\n\n      // If all of the queries have been tallied, we're done.\n      if (this.completed === this.steps.length) {\n        this.processing = false\n\n        Object.keys(this.steps).forEach((step) => {\n          clearTimeout(this.steps[step].timer)\n        })\n\n        this.emit('complete')\n      }\n    })\n\n    this.on('aborting', () => {\n      this._cancel = true\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 37,
            "column": 2
          },
          "end": {
            "line": 81,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "mode": {
              "type": "argument",
              "label": "mode",
              "description": "Set this to `dev` for verbose console output.",
              "code": "@param {string} [mode=production]\nSet this to `dev` for verbose console output.",
              "start": {
                "line": 37,
                "column": 2
              },
              "end": {
                "line": 81,
                "column": 3
              },
              "flags": [],
              "default": "production",
              "datatype": "string",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "onTimeout": {
          "type": "method",
          "label": "onTimeout",
          "description": null,
          "code": "onTimeout () {\n    let log = []\n\n    if (this.steps.length > 0) {\n      this.steps.forEach((s) => {\n        log.push(s.name, s.status === null ? 'NOT STARTED' : s.status)\n      })\n    }\n\n    this.emit('timeout', {\n      process: log\n    })\n\n    log = null\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 128,
            "column": 2
          },
          "end": {
            "line": 142,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "add": {
          "type": "method",
          "label": "add",
          "description": "Add a task to the list.",
          "code": "add (name, fn) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    if (typeof name === 'function') {\n      fn = name\n      name = 'Step ' + (parseInt(this.steps.length) + 1)\n    }\n\n    if (typeof fn !== 'function') {\n      throw new Error('No processing method defined for step ' + (parseInt(this.steps.length) + 1) + '.')\n    }\n\n    const queue = new NGN.Task({\n      name: name,\n      callback: fn,\n      number: (this.steps.length > 0 ? this.steps[this.steps.length - 1].number : 0) + 1\n    })\n\n    queue.on('complete', (step) => this.emit('taskcomplete', step))\n\n    queue.on('timeout', (step) => {\n      if (step.status === 'running' || step.status === 'timedout') {\n        this.emit('tasktimeout', step)\n      }\n    })\n\n    this.steps.push(queue)\n    this.emit('taskcreate', queue)\n\n    return queue\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 167,
            "column": 2
          },
          "end": {
            "line": 199,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "name": {
              "type": "argument",
              "label": "name",
              "description": null,
              "code": "name",
              "start": {
                "line": 167,
                "column": 7
              },
              "end": {
                "line": 167,
                "column": 11
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "fn": {
              "type": "argument",
              "label": "name",
              "description": "A descriptive name for the queued process/task.",
              "code": "fn",
              "start": {
                "line": 167,
                "column": 13
              },
              "end": {
                "line": 167,
                "column": 15
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": false,
              "enum": null
            },
            "callback": {
              "type": "method",
              "label": "callback",
              "description": "The function to queue.",
              "code": "@param {function} callback\nThe function to queue.",
              "start": {
                "line": 167,
                "column": 2
              },
              "end": {
                "line": 199,
                "column": 3
              },
              "flags": [],
              "arguments": {
                "next": {
                  "type": "argument",
                  "label": "next",
                  "description": "This argument allows users to explicitly use asynchronous\nmethods. Example:\n\n```\nlet tasks = new NGN.Tasks\n\ntasks.add('Descriptive Title', function (next) {\nmyAsyncMethod(function () {\nconsole.log('Ran something async.')\nnext()\n})\n})",
                  "code": "@param {function} callback.next\nThis argument allows users to explicitly use asynchronous\nmethods. Example:\n\n```\nlet tasks = new NGN.Tasks()\n\ntasks.add('Descriptive Title', function (next) {\nmyAsyncMethod(function () {\nconsole.log('Ran something async.')\nnext()\n})\n})",
                  "start": {
                    "line": 167,
                    "column": 2
                  },
                  "end": {
                    "line": 199,
                    "column": 3
                  },
                  "flags": [],
                  "default": null,
                  "datatype": "function",
                  "required": true,
                  "enum": [
                    ""
                  ]
                }
              },
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "NGN.Task",
          "returnDescription": "null Returns the task object added to the queue.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getAt": {
          "type": "method",
          "label": "getAt",
          "description": "",
          "code": "getAt (index) {\n    return this.steps[index]\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 207,
            "column": 2
          },
          "end": {
            "line": 209,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "index": {
              "type": "argument",
              "label": "index",
              "description": "Retrieve a queue item by it's index/queue number.",
              "code": "@param  {number} index\nRetrieve a queue item by it's index/queue number.",
              "start": {
                "line": 207,
                "column": 2
              },
              "end": {
                "line": 209,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Queue",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "get": {
          "type": "method",
          "label": "get",
          "description": "Retrieve a specific queue item.",
          "code": "get (requestedStep) {\n    // Get by Name\n    let element = this.steps.filter((step) => {\n      return step.name === requestedStep\n    })\n\n    if (element.length === 1) {\n      return element[0]\n    }\n\n    // Get by index\n    element = this.steps.filter((step) => {\n      return step.number === requestedStep\n    })\n\n    if (element.length === 1) {\n      return element[0]\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 218,
            "column": 2
          },
          "end": {
            "line": 236,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "requestedStep": {
              "type": "argument",
              "label": "requestedStep",
              "description": null,
              "code": "requestedStep",
              "start": {
                "line": 218,
                "column": 7
              },
              "end": {
                "line": 218,
                "column": 20
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "requestedStepTitle": {
              "type": "argument",
              "label": "requestedStepTitle",
              "description": "The descriptie name of the queue item to retrieve.",
              "code": "@param  {string} requestedStepTitle\nThe descriptie name of the queue item to retrieve.",
              "start": {
                "line": 218,
                "column": 2
              },
              "end": {
                "line": 236,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Queue",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "remove": {
          "type": "method",
          "label": "remove",
          "description": "Remove a queue item by name or number.",
          "code": "remove (requestedStep) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    // Remove by name\n    let element = this.steps.filter((step) => {\n      return step.name === requestedStep\n    })\n\n    if (element.length === 1) {\n      this.steps = this.steps.filter((step) => {\n        return step.name !== requestedStep\n      })\n\n      this.emit('taskremove', element[0])\n      return element[0]\n    }\n\n    // Remove by ID\n    element = this.steps.filter((step) => {\n      return step.number === requestedStep\n    })\n\n    if (element.length === 1) {\n      this.steps = this.steps.filter((step) => {\n        return step.number !== requestedStep\n      })\n\n      this.emit('taskremove', element[0])\n      return element[0]\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 246,
            "column": 2
          },
          "end": {
            "line": 278,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "requestedStep": {
              "type": "argument",
              "label": "requestedStep",
              "description": null,
              "code": "requestedStep",
              "start": {
                "line": 246,
                "column": 10
              },
              "end": {
                "line": 246,
                "column": 23
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "requestedStepTitle": {
              "type": "argument",
              "label": "requestedStepTitle",
              "description": "The descriptive name of the queue item to retrieve.",
              "code": "@param  {string} requestedStepTitle\nThe descriptive name of the queue item to retrieve.",
              "start": {
                "line": 246,
                "column": 2
              },
              "end": {
                "line": 278,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Queue",
          "returnDescription": "null Returns the item that was removed.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "removeAt": {
          "type": "method",
          "label": "removeAt",
          "description": "Removes a queue item from the specific index.",
          "code": "removeAt (requestedStep) {\n    if (this.processing) {\n      return NGN.WARN('Cannot add a step while processing.')\n    }\n\n    // Remove by index\n    if (typeof requestedStep !== 'number') {\n      return console.error('Failed to remove step: ' + requestedStep)\n    }\n\n    if (requestedStep < 0 || requestedStep >= this.steps.length) {\n      return console.error('Step index ' + requestedStep + ' could not be found or does not exist.')\n    }\n\n    return this.steps.splice(requestedStep, 1)[0]\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 288,
            "column": 2
          },
          "end": {
            "line": 303,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "requestedStep": {
              "type": "argument",
              "label": "requestedStep",
              "description": null,
              "code": "requestedStep",
              "start": {
                "line": 288,
                "column": 12
              },
              "end": {
                "line": 288,
                "column": 25
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "requestedStepIndex": {
              "type": "argument",
              "label": "requestedStepIndex",
              "description": "The queue index/number.",
              "code": "@param  {number} requestedStepIndex\nThe queue index/number.",
              "start": {
                "line": 288,
                "column": 2
              },
              "end": {
                "line": 303,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "number",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Queue",
          "returnDescription": "null Returns the item that was removed.",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "reset": {
          "type": "method",
          "label": "reset",
          "description": "Resets all cancelled/skipped steps, essentially resetting the queue\nto it's pre-aborted state.",
          "code": "reset () {\n    if (this.processing) {\n      return NGN.WARN('Cannot reset a running queue. Abort or wait for the process to complete before resetting.')\n    }\n\n    // Refresh cancelled steps\n    this.steps.forEach((step) => {\n      step._skip = false\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 310,
            "column": 2
          },
          "end": {
            "line": 319,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "process": {
          "type": "method",
          "label": "process",
          "description": "Run the queued processes in order.",
          "code": "process (sequential = false) {\n    if (this.processing) {\n      return NGN.WARN('Cannot start processing (already running). Please wait for this process to complete before calling process() again.')\n    }\n\n    if (this.steps.length === 0) {\n      return this.emit('complete')\n    }\n\n    this.processing = true\n    this._cancel = false\n\n    if (this.timeout !== null) {\n      this.timer = setTimeout(() => this.onTimeout(), this.timeout)\n    }\n\n    this.sequential = typeof sequential === 'boolean' ? sequential : false\n    if (!this.sequential) {\n      for (let i = 0; i < this.steps.length; i++) {\n        this.steps[i].run(this.mode)\n      }\n    } else {\n      let queue = this.steps\n      let listener = new NGN.EventEmitter()\n\n      listener.on('taskcomplete', () => {\n        if (queue.length > 0) {\n          const currentTask = queue.shift()\n\n          if (currentTask.skipped) {\n            return listener.emit('taskcomplete')\n          }\n\n          currentTask.on('complete', () => listener.emit('taskcomplete'))\n          currentTask.on('start', () => this.emit('taskstart', currentTask))\n\n          currentTask.run(this.mode)\n        } else {\n          this.emit('complete')\n        }\n      })\n\n      let currentStep = queue.shift()\n\n      currentStep.on('complete', () => listener.emit('taskcomplete'))\n      currentStep.on('start', () => this.emit('taskstart', currentStep))\n\n      currentStep.run(this.mode)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 329,
            "column": 2
          },
          "end": {
            "line": 378,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "sequential": {
              "type": "argument",
              "label": "sequential",
              "description": "Set to `true` to run the queue items in a synchronous-like manner.\nThis will execute each method one after the other. Each method must\ncomplete before the next is started.",
              "code": "@param {boolean} [sequential=false]\nSet to `true` to run the queue items in a synchronous-like manner.\nThis will execute each method one after the other. Each method must\ncomplete before the next is started.",
              "start": {
                "line": 329,
                "column": 2
              },
              "end": {
                "line": 378,
                "column": 3
              },
              "flags": [],
              "default": "false",
              "datatype": "boolean",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "run": {
          "type": "method",
          "label": "run",
          "description": null,
          "code": "run () {\n    this.process(...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 381,
            "column": 2
          },
          "end": {
            "line": 383,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "abort": {
          "type": "method",
          "label": "abort",
          "description": "Abort/cancel processing. This prevents further steps from processing.",
          "code": "abort () {\n    this.emit('aborting')\n\n    // Make sure the steps are skipped.\n    this.each((step) => {\n      if (['completed', 'running', 'timedout'].indexOf(step.status) < 0 && !step.skipped) {\n        step.skip()\n      }\n    })\n\n    this.once('complete', () => this.emit('aborted'))\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 389,
            "column": 2
          },
          "end": {
            "line": 400,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "each": {
          "type": "method",
          "label": "each",
          "description": "Apply a method to each step.",
          "code": "each (fn) {\n    for (let i = 0; i < this.steps.length; i++) {\n      fn(this.steps[i])\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 408,
            "column": 2
          },
          "end": {
            "line": 412,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "fn": {
              "type": "argument",
              "label": "fn",
              "description": null,
              "code": "fn",
              "start": {
                "line": 408,
                "column": 8
              },
              "end": {
                "line": 408,
                "column": 10
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "method": {
              "type": "method",
              "label": "method",
              "description": "",
              "code": "@param {function} method",
              "start": {
                "line": 408,
                "column": 2
              },
              "end": {
                "line": 412,
                "column": 3
              },
              "flags": [],
              "arguments": {},
              "returnType": "void",
              "returnDescription": "void",
              "kind": null,
              "generator": false,
              "static": false,
              "computed": false,
              "async": false
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "cancel": {
          "type": "method",
          "label": "cancel",
          "description": null,
          "code": "cancel () {\n    this.abort(...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 415,
            "column": 2
          },
          "end": {
            "line": 417,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.Task": {
      "type": "class",
      "label": "NGN.Task",
      "description": "`true` to skip the step, `false` to execute it.",
      "code": "class QueueItem extends EventEmitter {\n  constructor (config) {\n    config = config || {}\n\n    super(config)\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {string} name\n       * Descriptive name of the worker.\n       */\n      name: NGN.const(NGN.coalesce(config.name, 'Unknown')),\n\n      /**\n       * @cfg {function} callback\n       * The method to execute when the queue is ready.\n       */\n      callback: NGN.privateconst(config.callback),\n\n      /**\n       * @cfg {number} number\n       * The queue item number. This is used primarily as an ID.\n       */\n      number: NGN.const(parseInt(config.number, 10)),\n\n      timer: NGN.private(null),\n      _status: NGN.private(null),\n      bus: NGN.private(config.buz),\n      _skip: NGN.private(false)\n    })\n\n    this.on('timeout', () => {\n      this._status = 'timedout'\n    })\n\n    this.on('skip', () => {\n      this._status = 'skipped'\n    })\n  }\n\n  /**\n   * @property {string} status\n   * May be `running`, `complete`, or `null` (not run yet)\n   */\n  get status () {\n    return this._status\n  }\n\n  /**\n   * @property {boolean} skipped\n   * `true` to skip the step, `false` to execute it.\n   */\n  get skipped () {\n    return this._skip\n  }\n\n  /**\n   * @method run\n   * Execute the callback function.\n   * @param {string} mode\n   * `dev` or `prod`. When in \"dev\" mode, verbose output is written\n   * to the console.\n   */\n  run (mode) {\n    if (this.skipped) {\n      this.emit('skip', this)\n\n      if (mode && mode === 'dev') {\n        NGN.WARN('SKIPPED ' + this.name)\n      }\n\n      return\n    }\n\n    this.emit('start', this)\n\n    if (mode && mode === 'dev') {\n      NGN.INFO('Executing ' + this.name + ':')\n    }\n\n    this._status = 'running'\n\n    const me = this\n    const scope = {\n      name: this.name,\n      number: this.number,\n      timeout: function (milliseconds) {\n        me.timer = setTimeout(function () {\n          me.emit('timeout', me)\n        }, milliseconds)\n      }\n    }\n\n    this.callback.apply(scope, [function () {\n      me._status = 'complete'\n      me.emit('complete', me)\n    }])\n\n    if (this.callback.length === 0) {\n      me._status = 'complete'\n      me.emit('complete', me)\n    }\n  }\n\n  /**\n   * @method skip\n   * Skip this item\n   */\n  skip () {\n    if (this._status === 'running') {\n      NGN.WARN(`Cannot skip step: ${this.name} is currently running.`)\n    } else if (this._status === 'timedout') {\n      NGN.WARN(`Cannot skip step: ${this.name} timed out.`)\n    } else if (this._status === 'complete') {\n      NGN.WARN(`Cannot skip step: ${this.name} already completed.`)\n    }\n\n    this._skip = true\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {
        "skip": {
          "type": "event",
          "label": "skip",
          "description": null,
          "code": "this.emit('skip', this)",
          "start": {
            "line": 85,
            "column": 6
          },
          "end": {
            "line": 85,
            "column": 29
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": "this",
              "start": {
                "line": 85,
                "column": 24
              },
              "end": {
                "line": 85,
                "column": 28
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        },
        "start": {
          "type": "event",
          "label": "start",
          "description": null,
          "code": "this.emit('start', this)",
          "start": {
            "line": 94,
            "column": 4
          },
          "end": {
            "line": 94,
            "column": 28
          },
          "flags": [],
          "parameters": {
            "payload1": {
              "type": "argument",
              "label": "payload1",
              "description": null,
              "code": "this",
              "start": {
                "line": 94,
                "column": 23
              },
              "end": {
                "line": 94,
                "column": 27
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "deprecated": false,
          "deprecationReplacement": null
        }
      },
      "start": {
        "line": 20,
        "column": 15
      },
      "end": {
        "line": 139,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./queue/task.js",
      "extends": "EventEmitter",
      "configuration": {
        "name": {
          "type": "property",
          "label": "name",
          "description": "Descriptive name of the worker.",
          "code": "name: NGN.const(NGN.coalesce(config.name, 'Unknown'))",
          "start": {
            "line": 31,
            "column": 6
          },
          "end": {
            "line": 31,
            "column": 59
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        },
        "callback": {
          "type": "property",
          "label": "callback",
          "description": "The method to execute when the queue is ready.",
          "code": "callback: NGN.privateconst(config.callback)",
          "start": {
            "line": 37,
            "column": 6
          },
          "end": {
            "line": 37,
            "column": 49
          },
          "flags": [],
          "default": null,
          "datatype": "function",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "number": {
          "type": "property",
          "label": "number",
          "description": "The queue item number. This is used primarily as an ID.",
          "code": "number: NGN.const(parseInt(config.number, 10))",
          "start": {
            "line": 43,
            "column": 6
          },
          "end": {
            "line": 43,
            "column": 52
          },
          "flags": [],
          "default": null,
          "datatype": "number",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        }
      },
      "properties": {
        "name": {
          "type": "property",
          "label": "name",
          "description": "Descriptive name of the worker.",
          "code": "name: NGN.const(NGN.coalesce(config.name, 'Unknown'))",
          "start": {
            "line": 31,
            "column": 6
          },
          "end": {
            "line": 31,
            "column": 59
          },
          "flags": [],
          "default": null,
          "datatype": "string",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        },
        "callback": {
          "type": "property",
          "label": "callback",
          "description": "The method to execute when the queue is ready.",
          "code": "callback: NGN.privateconst(config.callback)",
          "start": {
            "line": 37,
            "column": 6
          },
          "end": {
            "line": 37,
            "column": 49
          },
          "flags": [],
          "default": null,
          "datatype": "function",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": true
        },
        "number": {
          "type": "property",
          "label": "number",
          "description": "The queue item number. This is used primarily as an ID.",
          "code": "number: NGN.const(parseInt(config.number, 10))",
          "start": {
            "line": 43,
            "column": 6
          },
          "end": {
            "line": 43,
            "column": 52
          },
          "flags": [],
          "default": null,
          "datatype": "number",
          "readable": true,
          "writable": false,
          "configuration": true,
          "private": false
        },
        "timer": {
          "type": "property",
          "label": "timer",
          "description": null,
          "code": "timer: NGN.private(null)",
          "start": {
            "line": 45,
            "column": 6
          },
          "end": {
            "line": 45,
            "column": 30
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "_status": {
          "type": "property",
          "label": "_status",
          "description": null,
          "code": "_status: NGN.private(null)",
          "start": {
            "line": 46,
            "column": 6
          },
          "end": {
            "line": 46,
            "column": 32
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "bus": {
          "type": "property",
          "label": "bus",
          "description": null,
          "code": "bus: NGN.private(config.buz)",
          "start": {
            "line": 47,
            "column": 6
          },
          "end": {
            "line": 47,
            "column": 34
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "_skip": {
          "type": "property",
          "label": "_skip",
          "description": null,
          "code": "_skip: NGN.private(false)",
          "start": {
            "line": 48,
            "column": 6
          },
          "end": {
            "line": 48,
            "column": 31
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "status": {
          "type": "property",
          "label": "status",
          "description": null,
          "code": "get status () {\n    return this._status\n  }",
          "start": {
            "line": 64,
            "column": 2
          },
          "end": {
            "line": 66,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "skipped": {
          "type": "property",
          "label": "skipped",
          "description": null,
          "code": "get skipped () {\n    return this._skip\n  }",
          "start": {
            "line": 72,
            "column": 2
          },
          "end": {
            "line": 74,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": null,
          "code": "constructor (config) {\n    config = config || {}\n\n    super(config)\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {string} name\n       * Descriptive name of the worker.\n       */\n      name: NGN.const(NGN.coalesce(config.name, 'Unknown')),\n\n      /**\n       * @cfg {function} callback\n       * The method to execute when the queue is ready.\n       */\n      callback: NGN.privateconst(config.callback),\n\n      /**\n       * @cfg {number} number\n       * The queue item number. This is used primarily as an ID.\n       */\n      number: NGN.const(parseInt(config.number, 10)),\n\n      timer: NGN.private(null),\n      _status: NGN.private(null),\n      bus: NGN.private(config.buz),\n      _skip: NGN.private(false)\n    })\n\n    this.on('timeout', () => {\n      this._status = 'timedout'\n    })\n\n    this.on('skip', () => {\n      this._status = 'skipped'\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 21,
            "column": 2
          },
          "end": {
            "line": 58,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "config": {
              "type": "argument",
              "label": "config",
              "description": null,
              "code": "config",
              "start": {
                "line": 21,
                "column": 15
              },
              "end": {
                "line": 21,
                "column": 21
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "run": {
          "type": "method",
          "label": "run",
          "description": "Execute the callback function.",
          "code": "run (mode) {\n    if (this.skipped) {\n      this.emit('skip', this)\n\n      if (mode && mode === 'dev') {\n        NGN.WARN('SKIPPED ' + this.name)\n      }\n\n      return\n    }\n\n    this.emit('start', this)\n\n    if (mode && mode === 'dev') {\n      NGN.INFO('Executing ' + this.name + ':')\n    }\n\n    this._status = 'running'\n\n    const me = this\n    const scope = {\n      name: this.name,\n      number: this.number,\n      timeout: function (milliseconds) {\n        me.timer = setTimeout(function () {\n          me.emit('timeout', me)\n        }, milliseconds)\n      }\n    }\n\n    this.callback.apply(scope, [function () {\n      me._status = 'complete'\n      me.emit('complete', me)\n    }])\n\n    if (this.callback.length === 0) {\n      me._status = 'complete'\n      me.emit('complete', me)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 83,
            "column": 2
          },
          "end": {
            "line": 122,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "mode": {
              "type": "argument",
              "label": "mode",
              "description": "`dev` or `prod`. When in \"dev\" mode, verbose output is written\nto the console.",
              "code": "@param {string} mode\n`dev` or `prod`. When in \"dev\" mode, verbose output is written\nto the console.",
              "start": {
                "line": 83,
                "column": 2
              },
              "end": {
                "line": 122,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "skip": {
          "type": "method",
          "label": "skip",
          "description": "Skip this item",
          "code": "skip () {\n    if (this._status === 'running') {\n      NGN.WARN(`Cannot skip step: ${this.name} is currently running.`)\n    } else if (this._status === 'timedout') {\n      NGN.WARN(`Cannot skip step: ${this.name} timed out.`)\n    } else if (this._status === 'complete') {\n      NGN.WARN(`Cannot skip step: ${this.name} already completed.`)\n    }\n\n    this._skip = true\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 128,
            "column": 2
          },
          "end": {
            "line": 138,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.UTILITY.Lexer": {
      "type": "class",
      "label": "NGN.UTILITY.Lexer",
      "description": "Retrieves the current column wherever the lexer left off (i.e. last\n  recognized token).",
      "code": "class NGNLexer { // eslint-disable-line no-unused-vars\n  /**\n   * Create a new lexer instance.\n   * @param  {String} [input='']\n   * Initialize with text input.\n   */\n  constructor (statement = '') {\n    Object.defineProperties(this, {\n      tokens: NGN.private([]),\n      rules: NGN.private([]),\n      remove: NGN.private(0),\n      state: NGN.private(0),\n      index: NGN.private(0),\n      statement: NGN.private(statement),\n      reject: NGN.private(false),\n      lastLineIndex: NGN.private(0),\n      currentLength: NGN.private(0),\n      currentMatch: NGN.private(null),\n      row: NGN.private(1),\n      unrecognizedCharacters: NGN.private(false)\n    })\n\n    // Identify beginning of file/statement\n    this.addRule(/^/, function () {\n      return 'BOF'\n    })\n\n    // Identify end of file/statement\n    this.addRule(/$/, function () {\n      return 'EOF'\n    })\n\n    if (statement && statement.length > 0) {\n      this.input = statement\n    }\n  }\n\n  /**\n   * @property {String} value\n   * The input text to analyze. Changing this automatically resets the lexer.\n   */\n  set input (value) {\n    this.remove = 0\n    this.state = 0\n    this.index = 0\n    this.currentMatch = null\n    this.tokens = []\n    this.row = 1\n    this.statement = value\n  }\n\n  get input () {\n    return this.statement\n  }\n\n  /**\n   * @property {number} lines\n   * The number of lines in the input text.\n   */\n  get lines () {\n    return this.statement.split('\\n').length\n  }\n\n  /**\n   * @property {boolean} unrecognized\n   * Set this to `true` within a rule if a value is unrecognized.\n   * The more common approach is to use the #error method, which\n   * sets this to `true` when a rule should produce an error.\n   */\n  get unrecognized () {\n    return this.unrecognizedCharacters\n  }\n\n  set unrecognized (value) {\n    // TODO: NGN.forceBoolean\n    this.reject = true\n    this.unrecognizedCharacters = NGN.forceBoolean(value)\n  }\n\n  /**\n   * @property {number} currentLine\n   * Retrieves the current line wherever the lexer left off (i.e. last\n   * recognized token).\n   */\n  get currentLine () {\n    return this.row\n  }\n\n  /**\n   * @property {number} currentColumn\n   * Retrieves the current column wherever the lexer left off (i.e. last\n   * recognized token).\n   */\n  get currentColumn () {\n    let col = (this.index - this.lastLineIndex) - this.currentLength\n\n    return col === 0 ? 1 : col\n  }\n\n  /**\n   * Called within a rule to force an error. This is most commonly used\n   * when a block of text contains a value it shouldn't.\n   * @param  {String} [message]\n   * An optional message prefixed to the error message.\n   */\n  error (message) {\n    if (message) {\n      let col = (this.index - this.lastLineIndex) - 1\n\n      throw new Error(`${message} at line ${this.currentLine}, column ${col < 1 ? 1 : col}.`)\n    }\n\n    this.unrecognized = true\n  }\n\n  /**\n   * Add a rule for detecting a token.\n   * @param {RegExp} pattern\n   * The pattern is applied to the text to determine whether the action should\n   * be triggered or not.\n   * @param {Function|String} action\n   * The action method is executed when a pattern match is detected. If the\n   * action is a function, it must return the name of the token. Functions\n   * receive a single argument, which is the text that matched the rule.\n   *\n   * If a string is provided as the action, that string will be returned as\n   * the token value whenever a pattern match occurs. This is a convenient\n   * way to avoid repetitively writing the following type of token handler:\n   *\n   * ```js\n   * function () {\n   *   return 'token'\n   * }\n   * ```\n   * @param {Array} [start=[0]]\n   * An optional array of unsigned integers acting as\n   * [start conditions](http://flex.sourceforge.net/manual/Start-Conditions.html).\n   * By default all rules are active in the initial state (i.e. `0`).\n   */\n  addRule (pattern, action, start = [0]) {\n    if (!pattern.global) {\n      let flags = 'g'\n\n      if (pattern.multiline) {\n        flags += 'm'\n      }\n\n      if (pattern.ignoreCase) {\n        flags += 'i'\n      }\n\n      pattern = new RegExp(pattern.source, flags)\n    }\n\n    let actionFn\n    if (typeof action === 'string') {\n      actionFn = function () {\n        return action\n      }\n    } else {\n      actionFn = action\n    }\n\n    if (!NGN.isFn(actionFn)) {\n      throw new Error(`INVALID LEXER ATTRIBUTES: ${pattern.toString()} rule is missing a valid handler function (action) or token name.`)\n    }\n\n    let actionString = actionFn.toString()\n\n    if (actionString.indexOf('this.error(') >= 0 && /^\\(.*\\)\\s{0,10}=>\\s{0,10}\\{/.test(actionString)) {\n      throw new Error('Cannot use a non-lexical expression (arrow function) as a lexer rule.')\n    }\n\n    this.rules.push({\n      pattern,\n      global: pattern.global,\n      action: actionFn,\n      start\n    })\n  }\n\n  /**\n   * An iterator method.\n   * @return {Object}\n   * Returns the next recognized token as a detailed object:\n   *\n   * ```js\n   * {\n   *   line: 1,\n   *   column: 1,\n   *   index: 0,\n   *   token: 'token name',\n   *   length: 5,\n   *   input: 'original input string'\n   * }\n   */\n  next () {\n    if (this.tokens.length) {\n      return this.tokens.shift()\n    }\n\n    this.reject = true\n\n    while (this.index <= this.statement.length) {\n      // Count any new line & reset column\n      if (/\\n/i.test(this.statement.charAt(this.index))) {\n        this.row++\n        this.lastLineIndex = this.index\n      }\n\n      let matches = this.scan().splice(this.remove)\n      let index = this.index\n\n      while (matches.length) {\n        if (this.reject) {\n          let match = matches.shift()\n          let result = match.result\n          let length = match.length\n\n          this.index += length\n          this.currentLength = length\n          this.reject = false\n          this.remove++\n          let token = match.action.apply(this, result)\n\n          if (this.reject) {\n            this.index = result.index\n          } else if (token !== undefined) {\n            switch (NGN.typeof(token)) {\n              case 'array':\n                this.tokens = token.slice(1)\n                token = token[0]\n\n              default: // eslint-disable-line no-fallthrough\n                if (length) {\n                  this.remove = 0\n                }\n\n                return token\n            }\n          }\n        } else {\n          break\n        }\n      }\n\n      let input = this.statement\n\n      if (index < input.length) {\n        if (this.reject) {\n          this.remove = 0\n\n          let token = this.unexpected(input.substr(this.index++, this.index + input.length))\n\n          if (token !== undefined) {\n            if (NGN.typeof(token) === 'array') {\n              this.tokens = token.slice(1)\n              return token[0]\n            } else {\n              return token\n            }\n          }\n        } else {\n          if (this.index !== index) {\n            this.remove = 0\n          }\n\n          this.reject = true\n        }\n      } else if (matches.length) {\n        this.reject = true\n      } else {\n        break\n      }\n    }\n  }\n\n  /**\n   * Scan the text and apply rules.\n   * @private\n   */\n  scan () {\n    let matches = []\n    let index = 0\n    let state = this.state\n    let lastIndex = this.index\n    let input = this.statement\n\n    for (let i = 0, length = this.rules.length; i < length; i++) {\n      let rule = this.rules[i]\n      let start = rule.start\n      let states = start.length\n\n      if (\n        (!states || start.indexOf(state) >= 0) ||\n          (state % 2 && states === 1 && !start[0])\n      ) {\n        let pattern = rule.pattern\n        pattern.lastIndex = lastIndex\n        let result = pattern.exec(input)\n\n        if (result && result.index === lastIndex) {\n          let j = matches.push({\n            result,\n            action: rule.action,\n            length: result[0].length\n          })\n\n          if (rule.global) {\n            index = j\n          }\n\n          while (--j > index) {\n            let k = j - 1\n\n            if (matches[j].length > matches[k].length) {\n              let temple = matches[j]\n              matches[j] = matches[k]\n              matches[k] = temple\n            }\n          }\n        }\n      }\n    }\n\n    return matches\n  }\n\n  /**\n   * Handles unexpected character sequences.\n   * This may throw an error if the characters are unrecognized.\n   * @param  {String} characters\n   * The characters which triggered the unexpected flag.\n   * @private\n   */\n  unexpected (str) {\n    if (this.unrecognizedCharacters) {\n      let col = (this.index - this.lastLineIndex) - 1\n\n      throw new Error(`Unexpected syntax at line ${this.currentLine}, column ${col < 1 ? 1 : col}\\nat ${str}\\n   ^`)\n    }\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 43,
        "column": 15
      },
      "end": {
        "line": 385,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./utility/Lexer.js",
      "extends": null,
      "configuration": {},
      "properties": {
        "tokens": {
          "type": "property",
          "label": "tokens",
          "description": null,
          "code": "tokens: NGN.private([])",
          "start": {
            "line": 51,
            "column": 6
          },
          "end": {
            "line": 51,
            "column": 29
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "rules": {
          "type": "property",
          "label": "rules",
          "description": null,
          "code": "rules: NGN.private([])",
          "start": {
            "line": 52,
            "column": 6
          },
          "end": {
            "line": 52,
            "column": 28
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "remove": {
          "type": "property",
          "label": "remove",
          "description": null,
          "code": "remove: NGN.private(0)",
          "start": {
            "line": 53,
            "column": 6
          },
          "end": {
            "line": 53,
            "column": 28
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "state": {
          "type": "property",
          "label": "state",
          "description": null,
          "code": "state: NGN.private(0)",
          "start": {
            "line": 54,
            "column": 6
          },
          "end": {
            "line": 54,
            "column": 27
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "index": {
          "type": "property",
          "label": "index",
          "description": null,
          "code": "index: NGN.private(0)",
          "start": {
            "line": 55,
            "column": 6
          },
          "end": {
            "line": 55,
            "column": 27
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "statement": {
          "type": "property",
          "label": "statement",
          "description": null,
          "code": "statement: NGN.private(statement)",
          "start": {
            "line": 56,
            "column": 6
          },
          "end": {
            "line": 56,
            "column": 39
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "reject": {
          "type": "property",
          "label": "reject",
          "description": null,
          "code": "reject: NGN.private(false)",
          "start": {
            "line": 57,
            "column": 6
          },
          "end": {
            "line": 57,
            "column": 32
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "lastLineIndex": {
          "type": "property",
          "label": "lastLineIndex",
          "description": null,
          "code": "lastLineIndex: NGN.private(0)",
          "start": {
            "line": 58,
            "column": 6
          },
          "end": {
            "line": 58,
            "column": 35
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "currentLength": {
          "type": "property",
          "label": "currentLength",
          "description": null,
          "code": "currentLength: NGN.private(0)",
          "start": {
            "line": 59,
            "column": 6
          },
          "end": {
            "line": 59,
            "column": 35
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "currentMatch": {
          "type": "property",
          "label": "currentMatch",
          "description": null,
          "code": "currentMatch: NGN.private(null)",
          "start": {
            "line": 60,
            "column": 6
          },
          "end": {
            "line": 60,
            "column": 37
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "row": {
          "type": "property",
          "label": "row",
          "description": null,
          "code": "row: NGN.private(1)",
          "start": {
            "line": 61,
            "column": 6
          },
          "end": {
            "line": 61,
            "column": 25
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "unrecognizedCharacters": {
          "type": "property",
          "label": "unrecognizedCharacters",
          "description": null,
          "code": "unrecognizedCharacters: NGN.private(false)",
          "start": {
            "line": 62,
            "column": 6
          },
          "end": {
            "line": 62,
            "column": 48
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "input": {
          "type": "property",
          "label": "input",
          "description": null,
          "code": "get input () {\n    return this.statement\n  }",
          "start": {
            "line": 94,
            "column": 2
          },
          "end": {
            "line": 96,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "lines": {
          "type": "property",
          "label": "lines",
          "description": null,
          "code": "get lines () {\n    return this.statement.split('\\n').length\n  }",
          "start": {
            "line": 102,
            "column": 2
          },
          "end": {
            "line": 104,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "unrecognized": {
          "type": "property",
          "label": "unrecognized",
          "description": null,
          "code": "set unrecognized (value) {\n    // TODO: NGN.forceBoolean\n    this.reject = true\n    this.unrecognizedCharacters = NGN.forceBoolean(value)\n  }",
          "start": {
            "line": 116,
            "column": 2
          },
          "end": {
            "line": 120,
            "column": 3
          },
          "flags": [],
          "datatype": "any",
          "readable": false,
          "writable": true,
          "configuration": false,
          "private": false
        },
        "currentLine": {
          "type": "property",
          "label": "currentLine",
          "description": null,
          "code": "get currentLine () {\n    return this.row\n  }",
          "start": {
            "line": 127,
            "column": 2
          },
          "end": {
            "line": 129,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "currentColumn": {
          "type": "property",
          "label": "currentColumn",
          "description": null,
          "code": "get currentColumn () {\n    let col = (this.index - this.lastLineIndex) - this.currentLength\n\n    return col === 0 ? 1 : col\n  }",
          "start": {
            "line": 136,
            "column": 2
          },
          "end": {
            "line": 140,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "Create a new lexer instance.\n  \n  Initialize with text input.",
          "code": "constructor (statement = '') {\n    Object.defineProperties(this, {\n      tokens: NGN.private([]),\n      rules: NGN.private([]),\n      remove: NGN.private(0),\n      state: NGN.private(0),\n      index: NGN.private(0),\n      statement: NGN.private(statement),\n      reject: NGN.private(false),\n      lastLineIndex: NGN.private(0),\n      currentLength: NGN.private(0),\n      currentMatch: NGN.private(null),\n      row: NGN.private(1),\n      unrecognizedCharacters: NGN.private(false)\n    })\n\n    // Identify beginning of file/statement\n    this.addRule(/^/, function () {\n      return 'BOF'\n    })\n\n    // Identify end of file/statement\n    this.addRule(/$/, function () {\n      return 'EOF'\n    })\n\n    if (statement && statement.length > 0) {\n      this.input = statement\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 49,
            "column": 2
          },
          "end": {
            "line": 78,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "statement": {
              "type": "argument",
              "label": "statement",
              "description": null,
              "code": "statement = ''",
              "start": {
                "line": 49,
                "column": 15
              },
              "end": {
                "line": 49,
                "column": 29
              },
              "flags": [],
              "default": "",
              "datatype": "string",
              "required": false,
              "enum": null
            },
            "input": {
              "type": "argument",
              "label": "input",
              "description": "Initialize with text input.",
              "code": "@param  {String} [input='']\nInitialize with text input.",
              "start": {
                "line": 49,
                "column": 2
              },
              "end": {
                "line": 78,
                "column": 3
              },
              "flags": [],
              "default": "''",
              "datatype": "string",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "error": {
          "type": "method",
          "label": "error",
          "description": "Called within a rule to force an error. This is most commonly used\n  when a block of text contains a value it shouldn't.\n  \n  An optional message prefixed to the error message.",
          "code": "error (message) {\n    if (message) {\n      let col = (this.index - this.lastLineIndex) - 1\n\n      throw new Error(`${message} at line ${this.currentLine}, column ${col < 1 ? 1 : col}.`)\n    }\n\n    this.unrecognized = true\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 148,
            "column": 2
          },
          "end": {
            "line": 156,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "message": {
              "type": "argument",
              "label": "message",
              "description": "An optional message prefixed to the error message.",
              "code": "@param  {String} [message]\nAn optional message prefixed to the error message.",
              "start": {
                "line": 148,
                "column": 2
              },
              "end": {
                "line": 156,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": false,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "addRule": {
          "type": "method",
          "label": "addRule",
          "description": "Add a rule for detecting a token.\n  \n  The pattern is applied to the text to determine whether the action should\n  be triggered or not.\n  \n  The action method is executed when a pattern match is detected. If the\n  action is a function, it must return the name of the token. Functions\n  receive a single argument, which is the text that matched the rule.\n    If a string is provided as the action, that string will be returned as\n  the token value whenever a pattern match occurs. This is a convenient\n  way to avoid repetitively writing the following type of token handler:\n    ```js\n  function () {\n    return 'token'\n  }\n  ```\n  \n  An optional array of unsigned integers acting as\n  [start conditions](http://flex.sourceforge.net/manual/Start-Conditions.html).\n  By default all rules are active in the initial state (i.e. `0`).",
          "code": "addRule (pattern, action, start = [0]) {\n    if (!pattern.global) {\n      let flags = 'g'\n\n      if (pattern.multiline) {\n        flags += 'm'\n      }\n\n      if (pattern.ignoreCase) {\n        flags += 'i'\n      }\n\n      pattern = new RegExp(pattern.source, flags)\n    }\n\n    let actionFn\n    if (typeof action === 'string') {\n      actionFn = function () {\n        return action\n      }\n    } else {\n      actionFn = action\n    }\n\n    if (!NGN.isFn(actionFn)) {\n      throw new Error(`INVALID LEXER ATTRIBUTES: ${pattern.toString()} rule is missing a valid handler function (action) or token name.`)\n    }\n\n    let actionString = actionFn.toString()\n\n    if (actionString.indexOf('this.error(') >= 0 && /^\\(.*\\)\\s{0,10}=>\\s{0,10}\\{/.test(actionString)) {\n      throw new Error('Cannot use a non-lexical expression (arrow function) as a lexer rule.')\n    }\n\n    this.rules.push({\n      pattern,\n      global: pattern.global,\n      action: actionFn,\n      start\n    })\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 182,
            "column": 2
          },
          "end": {
            "line": 222,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "pattern": {
              "type": "argument",
              "label": "pattern",
              "description": null,
              "code": "pattern",
              "start": {
                "line": 182,
                "column": 11
              },
              "end": {
                "line": 182,
                "column": 18
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "action": {
              "type": "argument",
              "label": "pattern",
              "description": "The pattern is applied to the text to determine whether the action should\nbe triggered or not.",
              "code": "action",
              "start": {
                "line": 182,
                "column": 20
              },
              "end": {
                "line": 182,
                "column": 26
              },
              "flags": [],
              "default": null,
              "datatype": "regexp",
              "required": true,
              "enum": null
            },
            "start": {
              "type": "argument",
              "label": "start",
              "description": "An optional array of unsigned integers acting as\n[start conditions].\nBy default all rules are active in the initial state (i.e. `0`).",
              "code": "@param {Array} [start=[0]]\nAn optional array of unsigned integers acting as\n[start conditions](http://flex.sourceforge.net/manual/Start-Conditions.html).\nBy default all rules are active in the initial state (i.e. `0`).",
              "start": {
                "line": 182,
                "column": 2
              },
              "end": {
                "line": 222,
                "column": 3
              },
              "flags": [],
              "default": "[0]",
              "datatype": "array",
              "required": false,
              "enum": [
                "http://flex.sourceforge.net/manual/Start-Conditions.html"
              ]
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "next": {
          "type": "method",
          "label": "next",
          "description": "An iterator method.\n  \n  Returns the next recognized token as a detailed object:\n    ```js\n  {\n    line: 1,\n    column: 1,\n    index: 0,\n    token: 'token name',\n    length: 5,\n    input: 'original input string'\n  }",
          "code": "next () {\n    if (this.tokens.length) {\n      return this.tokens.shift()\n    }\n\n    this.reject = true\n\n    while (this.index <= this.statement.length) {\n      // Count any new line & reset column\n      if (/\\n/i.test(this.statement.charAt(this.index))) {\n        this.row++\n        this.lastLineIndex = this.index\n      }\n\n      let matches = this.scan().splice(this.remove)\n      let index = this.index\n\n      while (matches.length) {\n        if (this.reject) {\n          let match = matches.shift()\n          let result = match.result\n          let length = match.length\n\n          this.index += length\n          this.currentLength = length\n          this.reject = false\n          this.remove++\n          let token = match.action.apply(this, result)\n\n          if (this.reject) {\n            this.index = result.index\n          } else if (token !== undefined) {\n            switch (NGN.typeof(token)) {\n              case 'array':\n                this.tokens = token.slice(1)\n                token = token[0]\n\n              default: // eslint-disable-line no-fallthrough\n                if (length) {\n                  this.remove = 0\n                }\n\n                return token\n            }\n          }\n        } else {\n          break\n        }\n      }\n\n      let input = this.statement\n\n      if (index < input.length) {\n        if (this.reject) {\n          this.remove = 0\n\n          let token = this.unexpected(input.substr(this.index++, this.index + input.length))\n\n          if (token !== undefined) {\n            if (NGN.typeof(token) === 'array') {\n              this.tokens = token.slice(1)\n              return token[0]\n            } else {\n              return token\n            }\n          }\n        } else {\n          if (this.index !== index) {\n            this.remove = 0\n          }\n\n          this.reject = true\n        }\n      } else if (matches.length) {\n        this.reject = true\n      } else {\n        break\n      }\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 239,
            "column": 2
          },
          "end": {
            "line": 318,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "Object",
          "returnDescription": "null Returns the next recognized token as a detailed object:\n\n```js\n{\nline: 1,\ncolumn: 1,\nindex: 0,\ntoken: 'token name',\nlength: 5,\ninput: 'original input string'\n}",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "scan": {
          "type": "method",
          "label": "scan",
          "description": "Scan the text and apply rules.",
          "code": "scan () {\n    let matches = []\n    let index = 0\n    let state = this.state\n    let lastIndex = this.index\n    let input = this.statement\n\n    for (let i = 0, length = this.rules.length; i < length; i++) {\n      let rule = this.rules[i]\n      let start = rule.start\n      let states = start.length\n\n      if (\n        (!states || start.indexOf(state) >= 0) ||\n          (state % 2 && states === 1 && !start[0])\n      ) {\n        let pattern = rule.pattern\n        pattern.lastIndex = lastIndex\n        let result = pattern.exec(input)\n\n        if (result && result.index === lastIndex) {\n          let j = matches.push({\n            result,\n            action: rule.action,\n            length: result[0].length\n          })\n\n          if (rule.global) {\n            index = j\n          }\n\n          while (--j > index) {\n            let k = j - 1\n\n            if (matches[j].length > matches[k].length) {\n              let temple = matches[j]\n              matches[j] = matches[k]\n              matches[k] = temple\n            }\n          }\n        }\n      }\n    }\n\n    return matches\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 324,
            "column": 2
          },
          "end": {
            "line": 369,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "unexpected": {
          "type": "method",
          "label": "unexpected",
          "description": "Handles unexpected character sequences.\n  This may throw an error if the characters are unrecognized.\n  \n  The characters which triggered the unexpected flag.",
          "code": "unexpected (str) {\n    if (this.unrecognizedCharacters) {\n      let col = (this.index - this.lastLineIndex) - 1\n\n      throw new Error(`Unexpected syntax at line ${this.currentLine}, column ${col < 1 ? 1 : col}\\nat ${str}\\n   ^`)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 378,
            "column": 2
          },
          "end": {
            "line": 384,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "str": {
              "type": "argument",
              "label": "str",
              "description": null,
              "code": "str",
              "start": {
                "line": 378,
                "column": 14
              },
              "end": {
                "line": 378,
                "column": 17
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "characters": {
              "type": "argument",
              "label": "characters",
              "description": "The characters which triggered the unexpected flag.",
              "code": "@param  {String} characters\nThe characters which triggered the unexpected flag.",
              "start": {
                "line": 378,
                "column": 2
              },
              "end": {
                "line": 384,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.UTILITY.Set": {
      "type": "class",
      "label": "NGN.UTILITY.Set",
      "description": "Provides advanced features for [Set]\nobjects.",
      "code": "class NGNSet { // eslint-disable-line\n  /**\n   * Indicates the subset is wholly contained within the main set.\n   * @param  {Set}  mainset\n   * @param  {Set}  subset\n   * @return {Boolean}\n   */\n  static isSuperSet (mainset, subset) {\n    if (subset.size > mainset.size || subset.size === 0) {\n      return false\n    }\n\n    let elements = mainset.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      if (!mainset.has(element.value)) {\n        return false\n      }\n\n      element = elements.next()\n    }\n\n    return true\n  }\n\n  /**\n   * Join any number of sets together into a single aggregate set.\n   * Only unique values will be added.\n   * Accepts any number of Set arguments.\n   * @return {Set}\n   */\n  static concat () {\n    let aggregate = new Set(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      let elements = arguments[i].values()\n      let element = elements.next()\n\n      while (!element.done) {\n        aggregate.add(element.value)\n        element = elements.next()\n      }\n    }\n\n    return aggregate\n  }\n\n  /**\n   * Identify the intersection/overlap between two sets.\n   * @param  {Set} setA\n   * @param  {Set} setB\n   * @return {Set}\n   * Returns a Set containing the common elements of setA and setB.\n   */\n  static intersection (setA, setB) {\n    let intersection = new Set()\n    let a = setA.size < setB.size ? setA : setB\n    let b = setA.size < setB.size ? setB : setA\n    let elements = a.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      if (b.has(element.value)) {\n        intersection.add(element.value)\n      }\n\n      element = elements.next()\n    }\n\n    return intersection\n  }\n\n  /**\n   * Identify the elements that are NOT part of both sets.\n   * @param  {Set} setA\n   * @param  {Set} setB\n   * @return {Set}\n   * Returns a set containing elements that are NOT common between setA and setB.\n   */\n  static difference (setA, setB) {\n    let diff = new Set(setA)\n    let elements = setB.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      diff.delete(element.value)\n      element = elements.next()\n    }\n\n    return diff\n  }\n\n  /**\n   * Determines whether two sets contain the same values.\n   * @param  {Set} setA\n   * @param  {Set} setB\n   * @return {Boolean}\n   */\n  static equal (setA, setB) {\n    return NGN.UTILITY.Set.difference(setA, setB).size === 0\n  }\n\n  static equals () {\n    NGN.WARN('NGN.UTILITY.Set.equals() should be equal() (no s at the end).')\n    NGN.UTILITY.Set.equal(...arguments)\n  }\n\n  /**\n   * A convenience method for appending the Set prototype with all\n   * of the methods in this utility, where the first argument of\n   * each method automatically refers to the Set.\n   * @private\n   */\n  static applyAll () {\n    Set.prototype.isSuperSet = function (subset) { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.isSuperSet(this, subset)\n    }\n\n    Set.prototype.concat = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.concat(this, ...arguments)\n    }\n\n    Set.prototype.intersection = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.intersection(this, ...arguments)\n    }\n\n    Set.prototype.difference = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.difference(this, ...arguments)\n    }\n\n    Set.prototype.equals = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.equal(this, ...arguments)\n    }\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 6,
        "column": 15
      },
      "end": {
        "line": 141,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./utility/Set.js",
      "extends": null,
      "configuration": {},
      "properties": {},
      "methods": {
        "isSuperSet": {
          "type": "method",
          "label": "isSuperSet",
          "description": "Indicates the subset is wholly contained within the main set.",
          "code": "static isSuperSet (mainset, subset) {\n    if (subset.size > mainset.size || subset.size === 0) {\n      return false\n    }\n\n    let elements = mainset.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      if (!mainset.has(element.value)) {\n        return false\n      }\n\n      element = elements.next()\n    }\n\n    return true\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 13,
            "column": 2
          },
          "end": {
            "line": 30,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "mainset": {
              "type": "argument",
              "label": "mainset",
              "description": null,
              "code": "mainset",
              "start": {
                "line": 13,
                "column": 21
              },
              "end": {
                "line": 13,
                "column": 28
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "subset": {
              "type": "argument",
              "label": "subset",
              "description": "",
              "code": "@param  {Set}  subset",
              "start": {
                "line": 13,
                "column": 2
              },
              "end": {
                "line": 30,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "set",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Boolean",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "concat": {
          "type": "method",
          "label": "concat",
          "description": "Join any number of sets together into a single aggregate set.\n  Only unique values will be added.\n  Accepts any number of Set arguments.",
          "code": "static concat () {\n    let aggregate = new Set(arguments[0])\n\n    for (let i = 1; i < arguments.length; i++) {\n      let elements = arguments[i].values()\n      let element = elements.next()\n\n      while (!element.done) {\n        aggregate.add(element.value)\n        element = elements.next()\n      }\n    }\n\n    return aggregate\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 38,
            "column": 2
          },
          "end": {
            "line": 52,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "Set",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "intersection": {
          "type": "method",
          "label": "intersection",
          "description": "Identify the intersection/overlap between two sets.\n  \n  \n  \n  Returns a Set containing the common elements of setA and setB.",
          "code": "static intersection (setA, setB) {\n    let intersection = new Set()\n    let a = setA.size < setB.size ? setA : setB\n    let b = setA.size < setB.size ? setB : setA\n    let elements = a.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      if (b.has(element.value)) {\n        intersection.add(element.value)\n      }\n\n      element = elements.next()\n    }\n\n    return intersection\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 61,
            "column": 2
          },
          "end": {
            "line": 77,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "setA": {
              "type": "argument",
              "label": "setA",
              "description": null,
              "code": "setA",
              "start": {
                "line": 61,
                "column": 23
              },
              "end": {
                "line": 61,
                "column": 27
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "setB": {
              "type": "argument",
              "label": "setB",
              "description": "",
              "code": "@param  {Set} setB",
              "start": {
                "line": 61,
                "column": 2
              },
              "end": {
                "line": 77,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "set",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Set",
          "returnDescription": "null Returns a Set containing the common elements of setA and setB.",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "difference": {
          "type": "method",
          "label": "difference",
          "description": "Identify the elements that are NOT part of both sets.\n  \n  \n  \n  Returns a set containing elements that are NOT common between setA and setB.",
          "code": "static difference (setA, setB) {\n    let diff = new Set(setA)\n    let elements = setB.values()\n    let element = elements.next()\n\n    while (!element.done) {\n      diff.delete(element.value)\n      element = elements.next()\n    }\n\n    return diff\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 86,
            "column": 2
          },
          "end": {
            "line": 97,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "setA": {
              "type": "argument",
              "label": "setA",
              "description": null,
              "code": "setA",
              "start": {
                "line": 86,
                "column": 21
              },
              "end": {
                "line": 86,
                "column": 25
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "setB": {
              "type": "argument",
              "label": "setB",
              "description": "",
              "code": "@param  {Set} setB",
              "start": {
                "line": 86,
                "column": 2
              },
              "end": {
                "line": 97,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "set",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Set",
          "returnDescription": "null Returns a set containing elements that are NOT common between setA and setB.",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "equal": {
          "type": "method",
          "label": "equal",
          "description": "Determines whether two sets contain the same values.",
          "code": "static equal (setA, setB) {\n    return NGN.UTILITY.Set.difference(setA, setB).size === 0\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 105,
            "column": 2
          },
          "end": {
            "line": 107,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "setA": {
              "type": "argument",
              "label": "setA",
              "description": null,
              "code": "setA",
              "start": {
                "line": 105,
                "column": 16
              },
              "end": {
                "line": 105,
                "column": 20
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "setB": {
              "type": "argument",
              "label": "setB",
              "description": "",
              "code": "@param  {Set} setB",
              "start": {
                "line": 105,
                "column": 2
              },
              "end": {
                "line": 107,
                "column": 3
              },
              "flags": [],
              "default": null,
              "datatype": "set",
              "required": true,
              "enum": null
            }
          },
          "returnType": "Boolean",
          "returnDescription": "",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "equals": {
          "type": "method",
          "label": "equals",
          "description": null,
          "code": "static equals () {\n    NGN.WARN('NGN.UTILITY.Set.equals() should be equal() (no s at the end).')\n    NGN.UTILITY.Set.equal(...arguments)\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 109,
            "column": 2
          },
          "end": {
            "line": 112,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        },
        "applyAll": {
          "type": "method",
          "label": "applyAll",
          "description": "A convenience method for appending the Set prototype with all\n  of the methods in this utility, where the first argument of\n  each method automatically refers to the Set.",
          "code": "static applyAll () {\n    Set.prototype.isSuperSet = function (subset) { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.isSuperSet(this, subset)\n    }\n\n    Set.prototype.concat = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.concat(this, ...arguments)\n    }\n\n    Set.prototype.intersection = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.intersection(this, ...arguments)\n    }\n\n    Set.prototype.difference = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.difference(this, ...arguments)\n    }\n\n    Set.prototype.equals = function () { // eslint-disable-line no-extend-native\n      return NGN.UTILITY.Set.equal(this, ...arguments)\n    }\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 120,
            "column": 2
          },
          "end": {
            "line": 140,
            "column": 3
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": "method",
          "generator": false,
          "static": true,
          "computed": false,
          "async": false
        }
      }
    },
    "NGN.UTILITY.Tokenizer": {
      "type": "class",
      "label": "NGN.UTILITY.Tokenizer",
      "description": "An ordered list of tokens as they appear within the text.\n    Example Result:    ```js\n  [{\n    column: 1,\n    index: 0,\n    input: 'original string',\n    length: 15,\n    line: 4,\n    token: 'mytoken'\n  }, {\n    ...\n  }]\n  ```",
      "code": "class NGNTokenizer { // eslint-disable-line no-unused-vars\n  /**\n   * Create a new tokenizer. This will return an instance of itself,\n   * allowing for methods to be chained like `(new Tokenizker([...])).parse('...')`.\n   * @param  {Array}  [grammar=[]]\n   * A grammar is a collection of rules that are passed to\n   * NGN.UTILITY.Lexer#addRule.\n   *\n   * The following example provides a subset of the NGN.DATA.JQL grammar.\n   *\n   * ```js\n   * new Tokenizer([\n   *   // Disallow irrelevant keywords (SQL)\n   *   [\n   *     /FROM/i,\n   *     function () {\n   *       this.error('FROM is not a valid JQL query descriptor. Found')\n   *     }\n   *   ],\n   *\n   *   // Skip whitespace\n   *   [/\\s+/, function () {}],\n   *\n   *   // Common tokens\n   *   [/SELECT\\s{1,1000}/i, 'SELECT'],\n   *   [/DISTINCT\\s{1,1000}/i, 'DISTINCT'],\n   *   [/WHERE\\s{1,1000}/i, 'WHERE'],\n   *   [/ORDER BY\\s{1,1000}/i, 'ORDERBY']\n   * ])\n   * ```\n   */\n  constructor (grammar = []) {\n    if (grammar.length === 0) {\n      throw new Error('No grammaer rules specified.')\n    }\n\n    Object.defineProperties(this, {\n      statement: NGN.private(null),\n      rules: NGN.privateconst(grammar),\n\n      PROTECTED: NGN.privateconst({\n        lexer: new NGN.UTILITY.Lexer(),\n        activeText: null,\n        orderedList: new Set()\n      })\n    })\n\n    // Add rules\n    for (let i = 0; i < this.rules.length; i++) {\n      this.PROTECTED.lexer.addRule(this.rules[i][0], this.rules[i][1])\n    }\n\n    return this\n  }\n\n  /**\n   * @property {string} text\n   * The text being \"tokenized\".\n   */\n  get text () {\n    return this.PROTECTED.activeText\n  }\n\n  /**\n   * @property {Array} orderedTokenList\n   * An ordered list of tokens as they appear within the text.\n   *\n   * **Example Result:**\n   *\n   * ```js\n   * [{\n   *   column: 1,\n   *   index: 0,\n   *   input: 'original string',\n   *   length: 15,\n   *   line: 4,\n   *   token: 'mytoken'\n   * }, {\n   *   ...\n   * }]\n   * ```\n   */\n  get orderedTokenList () {\n    return Array.from(this.PROTECTED.orderedList).map(item => item.detail)\n  }\n\n  /**\n   * Parses text to generate a token list.\n   * @param  {string} text\n   * The text to parse.\n   * @param  {Boolean} [suppressXOF=true]\n   * By default, `BOF` (Beginning of File) and `EOF` (End of File) tokens are\n   * suppressed. Set this to `false` to enable them.\n   * @return {Array}\n   * Returns an array of tokens.\n   *\n   * **Example Result:**\n   *\n   * ```js\n   * [{\n   *   column: 1,\n   *   index: 0,\n   *   input: 'original string',\n   *   length: 15,\n   *   line: 4,\n   *   token: 'mytoken'\n   * }, {\n   *   ...\n   * }]\n   * ```\n   */\n  parse (text, ignoreXOF = true) {\n    if (!NGN.coalesce(text) || typeof text !== 'string') {\n      throw new Error('Cannot parse empty string or non-string.')\n    }\n\n    this.PROTECTED.activeText = text\n\n    let tokens = {}\n    let token\n\n    this.PROTECTED.lexer.input = text\n    this.PROTECTED.orderedList.clear()\n\n    while (token = this.PROTECTED.lexer.next()) { // eslint-disable-line no-cond-assign\n      if (!ignoreXOF || (token !== 'BOF' && token !== 'EOF')) {\n        tokens[token] = NGN.coalesce(tokens[token], [])\n\n        tokens[token].push({\n          line: this.PROTECTED.lexer.currentLine,\n          column: this.PROTECTED.lexer.currentColumn,\n          length: this.PROTECTED.lexer.currentLength,\n          index: this.PROTECTED.lexer.index - this.PROTECTED.lexer.currentLength,\n          input: this.PROTECTED.lexer.statement.substr(this.PROTECTED.lexer.index - this.PROTECTED.lexer.currentLength, this.PROTECTED.lexer.currentLength)\n        })\n\n        const index = tokens[token].length - 1\n\n        this.PROTECTED.orderedList.add({\n          index: index,\n          token: token,\n          get detail () {\n            return Object.assign(tokens[this.token][this.index], {token: this.token})\n          }\n        })\n      }\n    }\n\n    return tokens\n  }\n}",
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 11,
        "column": 15
      },
      "end": {
        "line": 161,
        "column": 1
      },
      "flags": [],
      "sourcefile": "./utility/Tokenizer.js",
      "extends": null,
      "configuration": {},
      "properties": {
        "statement": {
          "type": "property",
          "label": "statement",
          "description": null,
          "code": "statement: NGN.private(null)",
          "start": {
            "line": 48,
            "column": 6
          },
          "end": {
            "line": 48,
            "column": 34
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": true,
          "configuration": false,
          "private": true
        },
        "rules": {
          "type": "property",
          "label": "rules",
          "description": null,
          "code": "rules: NGN.privateconst(grammar)",
          "start": {
            "line": 49,
            "column": 6
          },
          "end": {
            "line": 49,
            "column": 38
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "PROTECTED": {
          "type": "property",
          "label": "PROTECTED",
          "description": null,
          "code": "PROTECTED: NGN.privateconst({\n        lexer: new NGN.UTILITY.Lexer(),\n        activeText: null,\n        orderedList: new Set()\n      })",
          "start": {
            "line": 51,
            "column": 6
          },
          "end": {
            "line": 55,
            "column": 8
          },
          "flags": [],
          "datatype": "any",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": true
        },
        "text": {
          "type": "property",
          "label": "text",
          "description": null,
          "code": "get text () {\n    return this.PROTECTED.activeText\n  }",
          "start": {
            "line": 70,
            "column": 2
          },
          "end": {
            "line": 72,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        },
        "orderedTokenList": {
          "type": "property",
          "label": "orderedTokenList",
          "description": null,
          "code": "get orderedTokenList () {\n    return Array.from(this.PROTECTED.orderedList).map(item => item.detail)\n  }",
          "start": {
            "line": 93,
            "column": 2
          },
          "end": {
            "line": 95,
            "column": 3
          },
          "flags": [],
          "datatype": "undefined",
          "readable": true,
          "writable": false,
          "configuration": false,
          "private": false
        }
      },
      "methods": {
        "constructor": {
          "type": "method",
          "label": "constructor",
          "description": "Create a new tokenizer. This will return an instance of itself,\n  allowing for methods to be chained like `(new Tokenizker([...])).parse('...')`.\n  \n  A grammar is a collection of rules that are passed to\n  NGN.UTILITY.Lexer#addRule.\n    The following example provides a subset of the NGN.DATA.JQL grammar.\n    ```js\n  new Tokenizer([\n    // Disallow irrelevant keywords (SQL)\n    [\n      /FROM/i,\n      function () {\n        this.error('FROM is not a valid JQL query descriptor. Found')\n      }\n    ],\n      // Skip whitespace\n    [/\\s+/, function () {}],\n      // Common tokens\n    [/SELECT\\s{1,1000}/i, 'SELECT'],\n    [/DISTINCT\\s{1,1000}/i, 'DISTINCT'],\n    [/WHERE\\s{1,1000}/i, 'WHERE'],\n    [/ORDER BY\\s{1,1000}/i, 'ORDERBY']\n  ])\n  ```",
          "code": "constructor (grammar = []) {\n    if (grammar.length === 0) {\n      throw new Error('No grammaer rules specified.')\n    }\n\n    Object.defineProperties(this, {\n      statement: NGN.private(null),\n      rules: NGN.privateconst(grammar),\n\n      PROTECTED: NGN.privateconst({\n        lexer: new NGN.UTILITY.Lexer(),\n        activeText: null,\n        orderedList: new Set()\n      })\n    })\n\n    // Add rules\n    for (let i = 0; i < this.rules.length; i++) {\n      this.PROTECTED.lexer.addRule(this.rules[i][0], this.rules[i][1])\n    }\n\n    return this\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 42,
            "column": 2
          },
          "end": {
            "line": 64,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "grammar": {
              "type": "argument",
              "label": "grammar",
              "description": "A grammar is a collection of rules that are passed to\nNGN.UTILITY.Lexer#addRule.\n\nThe following example provides a subset of the NGN.DATA.JQL grammar.\n\n```js\nnew Tokenizer([\n// Disallow irrelevant keywords \n[\n/FROM/i,\nfunction () {\nthis.error('FROM is not a valid JQL query descriptor. Found')\n}\n],\n\n// Skip whitespace\n[/\\s+/, function () {}],\n\n// Common tokens\n[/SELECT\\s{1,1000}/i, 'SELECT'],\n[/DISTINCT\\s{1,1000}/i, 'DISTINCT'],\n[/WHERE\\s{1,1000}/i, 'WHERE'],\n[/ORDER BY\\s{1,1000}/i, 'ORDERBY']\n])\n```",
              "code": "@param  {Array}  [grammar=[]]\nA grammar is a collection of rules that are passed to\nNGN.UTILITY.Lexer#addRule.\n\nThe following example provides a subset of the NGN.DATA.JQL grammar.\n\n```js\nnew Tokenizer([\n// Disallow irrelevant keywords (SQL)\n[\n/FROM/i,\nfunction () {\nthis.error('FROM is not a valid JQL query descriptor. Found')\n}\n],\n\n// Skip whitespace\n[/\\s+/, function () {}],\n\n// Common tokens\n[/SELECT\\s{1,1000}/i, 'SELECT'],\n[/DISTINCT\\s{1,1000}/i, 'DISTINCT'],\n[/WHERE\\s{1,1000}/i, 'WHERE'],\n[/ORDER BY\\s{1,1000}/i, 'ORDERBY']\n])\n```",
              "start": {
                "line": 42,
                "column": 2
              },
              "end": {
                "line": 64,
                "column": 3
              },
              "flags": [],
              "default": "[]",
              "datatype": "array",
              "required": false,
              "enum": [
                "SQL"
              ]
            }
          },
          "returnType": "void",
          "returnDescription": "void",
          "kind": "constructor",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "parse": {
          "type": "method",
          "label": "parse",
          "description": "Parses text to generate a token list.\n  \n  The text to parse.\n  \n  By default, `BOF` (Beginning of File) and `EOF` (End of File) tokens are\n  suppressed. Set this to `false` to enable them.\n  \n  Returns an array of tokens.\n    Example Result:    ```js\n  [{\n    column: 1,\n    index: 0,\n    input: 'original string',\n    length: 15,\n    line: 4,\n    token: 'mytoken'\n  }, {\n    ...\n  }]\n  ```",
          "code": "parse (text, ignoreXOF = true) {\n    if (!NGN.coalesce(text) || typeof text !== 'string') {\n      throw new Error('Cannot parse empty string or non-string.')\n    }\n\n    this.PROTECTED.activeText = text\n\n    let tokens = {}\n    let token\n\n    this.PROTECTED.lexer.input = text\n    this.PROTECTED.orderedList.clear()\n\n    while (token = this.PROTECTED.lexer.next()) { // eslint-disable-line no-cond-assign\n      if (!ignoreXOF || (token !== 'BOF' && token !== 'EOF')) {\n        tokens[token] = NGN.coalesce(tokens[token], [])\n\n        tokens[token].push({\n          line: this.PROTECTED.lexer.currentLine,\n          column: this.PROTECTED.lexer.currentColumn,\n          length: this.PROTECTED.lexer.currentLength,\n          index: this.PROTECTED.lexer.index - this.PROTECTED.lexer.currentLength,\n          input: this.PROTECTED.lexer.statement.substr(this.PROTECTED.lexer.index - this.PROTECTED.lexer.currentLength, this.PROTECTED.lexer.currentLength)\n        })\n\n        const index = tokens[token].length - 1\n\n        this.PROTECTED.orderedList.add({\n          index: index,\n          token: token,\n          get detail () {\n            return Object.assign(tokens[this.token][this.index], {token: this.token})\n          }\n        })\n      }\n    }\n\n    return tokens\n  }",
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 122,
            "column": 2
          },
          "end": {
            "line": 160,
            "column": 3
          },
          "flags": [],
          "arguments": {
            "text": {
              "type": "argument",
              "label": "text",
              "description": null,
              "code": "text",
              "start": {
                "line": 122,
                "column": 9
              },
              "end": {
                "line": 122,
                "column": 13
              },
              "flags": [],
              "datatype": "any",
              "required": true,
              "enum": null
            },
            "ignoreXOF": {
              "type": "argument",
              "label": "text",
              "description": "The text to parse.",
              "code": "ignoreXOF = true",
              "start": {
                "line": 122,
                "column": 15
              },
              "end": {
                "line": 122,
                "column": 31
              },
              "flags": [],
              "default": null,
              "datatype": "string",
              "required": true,
              "enum": null
            },
            "suppressXOF": {
              "type": "argument",
              "label": "suppressXOF",
              "description": "By default, `BOF`  tokens are\nsuppressed. Set this to `false` to enable them.",
              "code": "@param  {Boolean} [suppressXOF=true]\nBy default, `BOF` (Beginning of File) and `EOF` (End of File) tokens are\nsuppressed. Set this to `false` to enable them.",
              "start": {
                "line": 122,
                "column": 2
              },
              "end": {
                "line": 160,
                "column": 3
              },
              "flags": [],
              "default": "true",
              "datatype": "boolean",
              "required": false,
              "enum": [
                "Beginning of File) and `EOF` (End of File"
              ]
            }
          },
          "returnType": "Array",
          "returnDescription": "null Returns an array of tokens.\n\n**Example Result:**\n\n```js\n[{\ncolumn: 1,\nindex: 0,\ninput: 'original string',\nlength: 15,\nline: 4,\ntoken: 'mytoken'\n}, {\n...\n}]\n```",
          "kind": "method",
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    }
  },
  "exceptions": {
    "MissingNgnDependencyError": {
      "type": "MissingNgnDependencyError",
      "label": "MissingNgnDependencyError",
      "description": "Standard NGN Exceptions",
      "code": "NGN.createException({\n  name: 'MissingNgnDependencyError',\n  type: 'MissingNgnDependencyError',\n  severity: 'critical',\n  message: 'An NGN dependency is missing or could not be found.',\n  category: 'programmer',\n  custom: {\n    help: 'Include the missing library.',\n    cause: 'A required dependency was not included, or it was not included in the correct sequence.'\n  }\n})",
      "tags": {
        "help": {
          "value": "help",
          "description": "Include the missing library.",
          "type": "help",
          "line": 1291,
          "raw": "help: 'Include the missing library.'"
        },
        "cause": {
          "value": "cause",
          "description": "A required dependency was not included, or it was not included in the correct sequence.",
          "type": "cause",
          "line": 1292,
          "raw": "cause: 'A required dependency was not included, or it was not included in the correct sequence.'"
        }
      },
      "start": {
        "line": 1284,
        "column": 0
      },
      "end": {
        "line": 1294,
        "column": 2
      },
      "flags": [],
      "source": "./core.js",
      "name": "MissingNgnDependencyError",
      "severity": "critical",
      "message": "An NGN dependency is missing or could not be found.",
      "category": "programmer"
    },
    "ReservedWordError": {
      "type": "ReservedWordError",
      "label": "ReservedWordError",
      "description": null,
      "code": "NGN.createException({\n  name: 'ReservedWordError',\n  type: 'ReservedWordError',\n  severity: 'critical',\n  message: 'An attempt to use a reserved word failed.',\n  category: 'programmer',\n  custom: {\n    help: 'Use an alternative word.',\n    cause: 'A word was used to define an attribute, method, field, or other element that already exists.'\n  }\n})",
      "tags": {
        "help": {
          "value": "help",
          "description": "Use an alternative word.",
          "type": "help",
          "line": 1303,
          "raw": "help: 'Use an alternative word.'"
        },
        "cause": {
          "value": "cause",
          "description": "A word was used to define an attribute, method, field, or other element that already exists.",
          "type": "cause",
          "line": 1304,
          "raw": "cause: 'A word was used to define an attribute, method, field, or other element that already exists.'"
        }
      },
      "start": {
        "line": 1296,
        "column": 0
      },
      "end": {
        "line": 1306,
        "column": 2
      },
      "flags": [],
      "source": "./core.js",
      "name": "ReservedWordError",
      "severity": "critical",
      "message": "An attempt to use a reserved word failed.",
      "category": "programmer"
    },
    "InvalidConfigurationError": {
      "type": "InvalidConfigurationError",
      "label": "InvalidConfigurationError",
      "description": null,
      "code": "NGN.createException({\n  name: 'InvalidConfigurationError',\n  type: 'InvalidConfigurationError',\n  severity: 'critical',\n  message: 'Invalid configuration.',\n  category: 'programmer',\n  custom: {\n    help: 'See the documentation for the proper configuration.',\n    cause: 'The configuration specified was marked as invalid or caused an error during instantiation.'\n  }\n})",
      "tags": {
        "help": {
          "value": "help",
          "description": "See the documentation for the proper configuration.",
          "type": "help",
          "line": 1315,
          "raw": "help: 'See the documentation for the proper configuration.'"
        },
        "cause": {
          "value": "cause",
          "description": "The configuration specified was marked as invalid or caused an error during instantiation.",
          "type": "cause",
          "line": 1316,
          "raw": "cause: 'The configuration specified was marked as invalid or caused an error during instantiation.'"
        }
      },
      "start": {
        "line": 1308,
        "column": 0
      },
      "end": {
        "line": 1318,
        "column": 2
      },
      "flags": [],
      "source": "./core.js",
      "name": "InvalidConfigurationError",
      "severity": "critical",
      "message": "Invalid configuration.",
      "category": "programmer"
    },
    "undefined": {
      "description": null,
      "code": "NGN.private({\n        type: type,\n        validator: validation,\n        name: NGN.coalesce(name, `Untitled ${type.toUpperCase()} Validation`),\n        scope: NGN.coalesce(scope, this)\n      })",
      "tags": {},
      "start": {
        "line": 30,
        "column": 12
      },
      "end": {
        "line": 35,
        "column": 8
      },
      "flags": [],
      "source": "./data/rule/Rule.js",
      "severity": "minor",
      "message": "Unknown Error",
      "category": "operational"
    },
    "BadConfig": {
      "type": "InvalidConfigurationError",
      "label": "BadConfig",
      "description": "This is a baaaaad config.",
      "code": "NGN.createException({\n  name: 'InvalidConfigurationError',\n  type: 'InvalidConfigurationError',\n  severity: 'critical',\n  message: 'Invalid configuration.',\n  category: 'programmer',\n  custom: {\n    help: 'See the documentation for the proper configuration.',\n    cause: 'The configuration specified was marked as invalid or caused an error during instantiation.'\n  }\n})",
      "tags": {
        "help": {
          "value": "help",
          "description": "See the documentation for the proper configuration.",
          "type": "help",
          "line": 119,
          "raw": "help: 'See the documentation for the proper configuration.'"
        },
        "cause": {
          "value": "cause",
          "description": "The configuration specified was marked as invalid or caused an error during instantiation.",
          "type": "cause",
          "line": 120,
          "raw": "cause: 'The configuration specified was marked as invalid or caused an error during instantiation.'"
        }
      },
      "start": {
        "line": 112,
        "column": 0
      },
      "end": {
        "line": 122,
        "column": 2
      },
      "flags": [],
      "source": "./data/Representation.js",
      "name": "BadConfig",
      "severity": "critical",
      "message": "Invalid configuration.",
      "category": "programmer"
    },
    "NGNDuplicateRecordError": {
      "type": "unknown",
      "label": "NGNDuplicateRecordError",
      "description": null,
      "code": "NGN.createException({\n  name: 'NGNDuplicateRecordError',\n  message: 'A duplicate record exists within the unique data set.'\n})",
      "tags": {},
      "start": {
        "line": 3,
        "column": 0
      },
      "end": {
        "line": 6,
        "column": 2
      },
      "flags": [],
      "source": "./data/Store.js",
      "name": "NGNDuplicateRecordError",
      "severity": "minor",
      "message": "A duplicate record exists within the unique data set.",
      "category": "operational"
    },
    "NgnError": {
      "type": "unknown",
      "label": "NgnError",
      "description": null,
      "code": "NGN.privateconst({\n        lexer: new NGN.UTILITY.Lexer(),\n        activeText: null,\n        orderedList: new Set()\n      })",
      "tags": {},
      "start": {
        "line": 51,
        "column": 17
      },
      "end": {
        "line": 55,
        "column": 8
      },
      "flags": [],
      "source": "./utility/Tokenizer.js",
      "name": "NgnError",
      "severity": "minor",
      "message": "Unknown Error",
      "category": "operational"
    },
    "null": {
      "type": "unknown",
      "label": null,
      "description": null,
      "code": "NGN.private({\n        schema,\n        ID: null,\n        name: null\n      })",
      "tags": {},
      "start": {
        "line": 22,
        "column": 16
      },
      "end": {
        "line": 26,
        "column": 8
      },
      "flags": [],
      "source": "./data/schema/JSON.js",
      "name": null,
      "severity": "minor",
      "message": "Unknown Error",
      "category": "operational"
    }
  },
  "bus": {
    "yo": {
      "type": "event",
      "label": "yo",
      "description": null,
      "code": "NGN.BUS.emit('yo')",
      "start": {
        "line": 96,
        "column": 0
      },
      "end": {
        "line": 96,
        "column": 18
      },
      "flags": [],
      "parameters": {},
      "deprecated": false,
      "deprecationReplacement": null
    }
  },
  "namespaces": {
    "NGN": {
      "type": "class",
      "label": "NGN",
      "description": "Returns the primitive object/function of the specified type.\n  For example:\n    ```js\n  let type = NGN.getType('number') // Returns Number\n  let type = NGN.getType('string') // Returns String\n  ```",
      "code": null,
      "tags": {},
      "exceptions": {},
      "events": {},
      "start": {
        "line": 0,
        "column": 0
      },
      "end": {
        "line": 0,
        "column": 0
      },
      "flags": [],
      "sourcefile": "./core.js",
      "extends": null,
      "configuration": {},
      "properties": {},
      "methods": {
        "define": {
          "type": "method",
          "label": "define",
          "description": "Create an object definition for a property.\nFor example:\n\n```\nObject.defineProperty\n\n// The snippet above is the same as:\nObject.defineProperty(this, 'attr', {\nenumberable: true,\nwritable: false,\nconfigurable: true,\nvalue: 'value'\n})\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "public": {
          "type": "method",
          "label": "public",
          "description": "Create a `public` property definition for an object.\nExample:\n\n```\nObject.defineProperty\n\n// Longhand equivalent\nObject.defineProperty(this, 'attr', {\nenumerable: true,\nwritable: true,\nconfigurable: false,\nvalue: 'somevalue'\n})\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "private": {
          "type": "method",
          "label": "private",
          "description": "Create a `private` property definition for an object.\nExample:\n\n```\nObject.defineProperty\n\n// Longhand equivalent\nObject.defineProperty(this, 'attr', {\nenumerable: false,\nwritable: true,\nconfigurable: false,\nvalue: 'somevalue'\n})\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "const": {
          "type": "method",
          "label": "const",
          "description": "Create a `public` constant property definition for an object.\nExample:\n\n```\nObject.defineProperty\n\n// Longhand equivalent\nObject.defineProperty(this, 'attr', {\nenumerable: true,\nwritable: false,\nconfigurable: false,\nvalue: 'somevalue'\n})\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "privateconst": {
          "type": "method",
          "label": "privateconst",
          "description": "Create a `private` constant property definition for an object.\nExample:\n\n```\nObject.defineProperty\n\n// Longhand equivalent\nObject.defineProperty(this, 'attr', {\nenumerable: false,\nwritable: false,\nconfigurable: false,\nvalue: 'somevalue'\n})\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "get": {
          "type": "method",
          "label": "get",
          "description": "Create a private `getter` property definition for an object.\nPublic getters are part of the ES2015 class spec.\n\nExample:\n\n```\nlet myFunction = function  {\nreturn 'somevalue'\n}\n\n// Longhand equivalent\nObject.defineProperty(this, 'attr', {\nenumerable: false,\nget: function () {\nreturn 'somevalue'\n}\n})\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "set": {
          "type": "method",
          "label": "set",
          "description": "Create a private `setter` property definition for an object.\nPublic setters are part of the ES2015 class spec.\n\nExample:\n\n```\nlet myFunction = function  {\nreturn 'somevalue'\n}\n\n// Longhand equivalent\nObject.defineProperty(this, 'attr', {\nenumerable: false,\nset: function (value) {\nsomethingElse = value\n}\n})\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getset": {
          "type": "method",
          "label": "getset",
          "description": "Create a private property defintion containing both a `getter` and `setter`\nfor the specified attribute.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "extend": {
          "type": "method",
          "label": "extend",
          "description": "Extend the NGN core object. Extending NGN is the equivalent of:\n\nExample:\n```\nNGN.extend {\nreturn 'Hello, ' + recipient + '!'\n}))\n\n// Equivalent of:\n\nObject.defineProperty(NGN, 'greet', {\nenumerable: true,\nwritable: false,\nconfigurable: false,\nvalue: function (recipient) {\nreturn 'Hello, ' + recipient + '!'\n}\n})\n```\nThe example above produces a public function available from NGN:\n\n```\nconsole.log(NGN.greet('world')) // outputs Hello, world!",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "inherit": {
          "type": "method",
          "label": "inherit",
          "description": "Inherit the properties of another object/class.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "slice": {
          "type": "method",
          "label": "slice",
          "description": "Converts an array-like object to an array.\n\nExample:\n```\nfunction  {\nreturn NGN.slice(arguments)\n}\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "splice": {
          "type": "method",
          "label": "splice",
          "description": "Converts an array-like object to a spliced array.\n\nExample:\n```\nfunction  {\nreturn NGN.splice(arguments)\n}\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "nullIf": {
          "type": "method",
          "label": "nullIf",
          "description": "Returns a null value if the two specified expressions are equal.\n```js\nif  {\nconsole.log('Variable had a value of \"value\", which is considered null')\n}\n\n// or\n\nif (NGN.nullIf(myvar) === null) {\nconsole.log('Empty variable whose trimmed length is 0')\n}\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "converge": {
          "type": "method",
          "label": "converge",
          "description": "Provides a basic coalesce. Expects the first parameter to be a boolean\nvalue. `true` will wrap arguments in a nullIf operator. `false` will not.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "coalesce": {
          "type": "method",
          "label": "coalesce",
          "description": "Finds the first non-null/defined value in a list of arguments.\nThis can be used with {@link Boolean Boolean} values, since `true`/`false` is a\nnon-null/defined value.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "coalesceb": {
          "type": "method",
          "label": "coalesceb",
          "description": "Provides the same functionality as #coalesce, except **b**lank/empty arguments\nare treated as `null` values.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "dedupe": {
          "type": "method",
          "label": "dedupe",
          "description": "Deduplicate a simple array.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "typeof": {
          "type": "method",
          "label": "typeof",
          "description": "A more specific typeof method.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "forceArray": {
          "type": "method",
          "label": "forceArray",
          "description": "Forces a value to become an array if it is not already one. For example:\n\n```js\nlet x = 'value'\n\nx = NGN.forceArray\n\nconsole.log(x) // Outputs ['value']\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "forceBoolean": {
          "type": "method",
          "label": "forceBoolean",
          "description": "Forces a value to become a boolean if it is not already one. For example:\n\n```js\nlet x = NGN.forceBoolean // String ==> Boolean\nconsole.log(x) // Outputs false\n\nlet y = NGN.forceBoolean('text') // String ==> Boolean\nconsole.log(y) // Outputs true (any non-blank text results in true, except the word \"false\")\n\nlet z = NGN.forceBoolean(0) // Number ==> Boolean (0 = false, 1 = true)\nconsole.log(z) // Outputs false\n```\n\nAll other types will yield a `true` value, except for `null`. A `null`\nvalue is treated as `false`.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "forceNumber": {
          "type": "method",
          "label": "forceNumber",
          "description": "Forces a value to become a number if it is not already one. For example:\n\n```js\nlet x = NGN.forceNumber // String ==> Number\nconsole.log(x === 10) // Outputs true\n\nlet y = NGN.forceNumber(true) // Boolean ==> Number\nconsole.log(y) // Output 1\n\nlet z = NGN.forceNumber(false) // Boolean ==> Number\nconsole.log(y) // Output 0\n```\n\nAll other types will yield a `NaN` value. This has no effect on",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "stack": {
          "type": "method",
          "label": "stack",
          "description": "Retrieve the stack trace from a specific code location without throwing\nan exception. Files are always listed from the root. This is the default\norder in browsers, but the reverse of the normal stack order in node-like\nenvironments.\n\nFor example, the following stack on node shows `_test.js` as the last item\nin the array. In node-like environments, the `_test.js` would normally be\nthe first item in the stacktrace.\n\n```js\n[\n{ path: 'node.js:348:7', file: 'node.js', line: 348, column: 7 },\n{ path: 'module.js:575:10',\nfile: 'module.js',\nline: 575,\ncolumn: 10 },\n{ path: 'module.js:550:10',\nfile: 'module.js',\nline: 550,\ncolumn: 10 },\n{ path: 'module.js:541:32',\nfile: 'module.js',\nline: 541,\ncolumn: 32 },\n{ path: '/_test.js:8:14', file: '/_test.js', line: 8, column: 14 }\n]\n```\n\nBy standardizing the order of the stack trace, it is easier to programmatically\nidentify sources of problems. This method does not prevent developers from\naccessing a normal stacktrace.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "isFn": {
          "type": "method",
          "label": "isFn",
          "description": "A shortcut method for determining if a variable is a function.\nThis is useful for identifying the existance of callback methods.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "wrap": {
          "type": "method",
          "label": "wrap",
          "description": "Executes a **synchronous** method before invoking a standard function.\nThis is primarily designed for displaying warnings, but can also be\nused for other operations like migration layers.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "wrapClass": {
          "type": "method",
          "label": "wrapClass",
          "description": "Executes a **synchronous** method before returning an instantiated class.\nIt runs a function first, then returns the equivalent of\n`new MyClass`. This is primarily designed for displaying warnings,\nbut can also be used for other operations like migration layers.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "deprecate": {
          "type": "method",
          "label": "deprecate",
          "description": "Fires an event  or logs a warning indicating the\nmethod is deprecated.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "deprecateClass": {
          "type": "method",
          "label": "deprecateClass",
          "description": "Logs a warning indicating the class is deprecated. This differs from\n#deprecate by extending & preserving the original class (the resulting\nclass can be used with the `new` operator).",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "needs": {
          "type": "method",
          "label": "needs",
          "description": "A method to check for the existance of required attributes in an object.\nThis is designed to check for namespace existance.\n\n```js\nNGN.needs // Throws an error because \"JUNK\" doesn't exist.\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getObjectMissingPropertyNames": {
          "type": "method",
          "label": "getObjectMissingPropertyNames",
          "description": "Given a list, returns which list items are not present in an\nobject's enumerable properties.\n\n```js\nlet obj = { a: 1, b: 2 }\nlet missing = NGN.getObjectMissingPropertyNames\n\nconsole.log(missing) // Outputs ['c']\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getObjectExtraneousPropertyNames": {
          "type": "method",
          "label": "getObjectExtraneousPropertyNames",
          "description": "Given a list, returns which enumerable object properties\nare not in the list.\n\n```js\nlet obj = { a: 1, b: 2, d: 4 }\nlet extra = NGN.getObjectExtraneousPropertyNames\n\nconsole.log(extra) // Outputs ['d']\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "objectHasAll": {
          "type": "method",
          "label": "objectHasAll",
          "description": "Determines whether the specified object has _all_ of the provided properties.\nThis only accounts for enumerable properties. It also decorates the Boolean\nresult with a property called `properties`, which contains any missing property\nnames.\n\n**Example**\n```js\nlet check = NGN.objectHasAll\n\nconsole.log(check) // Outputs: true\n```\n\n```js\nlet check = NGN.objectHasAll(NGN, 'BUS', 'NET', 'JUNK')\n\nconsole.log(check) // Outputs: false\nconsole.log(check.properties) // Outputs ['JUNK']\n```js",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "objectHasAny": {
          "type": "method",
          "label": "objectHasAny",
          "description": "Determines whether the specified object has _any_ of the requested properties.\nThis only accounts for enumerable properties.\n\n**Example**\n```js\nlet check = NGN.objectHasAny\n\nconsole.log(check) // Outputs: true\n```\n\n```js\nlet check = NGN.objectHasAny(NGN, 'JUNK1', 'JUNK2', 'JUNK3')\n\nconsole.log(check) // Outputs: false\n```js",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "objectHasExactly": {
          "type": "method",
          "label": "objectHasExactly",
          "description": "Determines whether the specified object has _only_ the requested properties.\nThis only accounts for enumerable properties.\n\n**Example**\n```js\nlet obj = { a: 1, b: 2 }\nlet check = NGN.objectHasExactly\n\nconsole.log(check) // Outputs: true\n```\n\n```js\nlet obj = { a: 1, b: 2, d: 4 }\nlet check = NGN.objectHasExactly(obj, 'a', 'b', 'c')\n\nconsole.log(check) // Outputs: false\n```js",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "objectRequires": {
          "type": "method",
          "label": "objectRequires",
          "description": "This is the same as #objectHasAll, but will throw an\nerror if the object is missing any properties.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "createAlias": {
          "type": "method",
          "label": "createAlias",
          "description": "A helper method to alias a value on an object. This is the equivalent of:\n```js\nObject.defineProperty => {\nreturn value\n}))\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "WARN": {
          "type": "method",
          "label": "WARN",
          "description": "This method is used to emit special info events.\nThe NGN.BUS can listen for all events using the NGN.WARN global symbol.\n\n```js\nNGN.BUS.on => {\nconsole.warn(...arguments)\n})\n```\n\nSee NGN.EventEmitter#emit for detailed parameter usage.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "INFO": {
          "type": "method",
          "label": "INFO",
          "description": "This method is used to emit special warning events.\nThe NGN.BUS can listen for all events using the NGN.INFO global symbol.\n\n```js\nNGN.BUS.on => {\nconsole.info(...arguments)\n})\n```\n\nSee NGN.EventEmitter#emit for detailed parameter usage.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "ERROR": {
          "type": "method",
          "label": "ERROR",
          "description": "This method is used to emit special soft error events. A soft error\nis one that does not throw, but does get logged .\nThe NGN.BUS can listen for all events using the NGN.ERROR global symbol.\n\n```js\nNGN.BUS.on(NGN.ERROR_EVENT, function () => {\nconsole.info(...arguments)\n})\n```\n\nSee NGN.EventEmitter#emit for detailed parameter usage.",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "createException": {
          "type": "method",
          "label": "createException",
          "description": "Create a custom global exception .",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        },
        "getType": {
          "type": "method",
          "label": "getType",
          "description": "Returns the primitive object/function of the specified type.\nFor example:\n\n```js\nlet type = NGN.getType // Returns Number\nlet type = NGN.getType('string') // Returns String\n```",
          "code": null,
          "tags": {},
          "exceptions": {},
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false
        }
      }
    }
  }
}