{
  "type": "class",
  "label": "NGN.DATA.JSONSchema",
  "description": "Retrieve all of the NGN.DATA.Model defitions that can be interpreted\r\n        from this schema.\r\n        \r\n        \r\n        \r\n        The schema object.\r\n        \r\n        An array of known models. This method is used recursively, so this\r\n        argument exists primarily for internal use.\r\n        \r\n        Executed when all models have been detected.",
  "code": "class NGNJSONSchema extends EventEmitter { // eslint-disable-line no-unused-vars\r\n  /**\r\n   * Create a new JSON schema reference.\r\n   * @param  {Object|String} [schema={}]\r\n   * The schema to parse. This can be the JSON schema object itself or the URL\r\n   * of a remote JSON schema.\r\n   * @param  {NGN.NET.Resource} [NetworkResource]\r\n   * Specify a custom network resource to make the request for a remote schema.\r\n   */\r\n  constructor (schema = {}, NetworkResource = null) {\r\n    super()\r\n\r\n    Object.defineProperties(this, {\r\n      METADATA: NGN.private({\r\n        schema,\r\n        ID: null,\r\n        name: null\r\n      }),\r\n\r\n      PRIVATE: NGN.privateconst({\r\n        MODELS: null,\r\n        NET: NGN.coalesce(NetworkResource, NGN.NET),\r\n\r\n        parsed: false,\r\n\r\n        /**\r\n         * @method PRIVATE.extractCommonPropertyAttributes\r\n         * @param  {object} property\r\n         * Schema metadata object.\r\n         * @param {array} [models=[]]\r\n         * The list of known models. This is passed in because nested objects\r\n         * may exist within a property. NGN identifies these as nested models,\r\n         * even though the JSON schema does not force these to be separate\r\n         * schemas.\r\n         * @return {Object}\r\n         * Returns a clean \"NGN-ready\" field object of common properties.\r\n         */\r\n        extractCommonPropertyAttributes: (property, models = []) => {\r\n          let field = {}\r\n\r\n          // Add pattern\r\n          if (property.pattern) {\r\n            field.pattern = property.pattern\r\n          }\r\n\r\n          // Add description\r\n          if (property.description) {\r\n            field.description = property.description\r\n          }\r\n\r\n          // Add default\r\n          if (property.default) {\r\n            field.default = property.default\r\n          }\r\n\r\n          if (!property.$ref) {\r\n            if (!property.type) {\r\n              field.type = String\r\n            } else {\r\n              let type = NGN.typeof(property.type) === 'array' ? 'array' : property.type.trim().toLowerCase()\r\n\r\n              switch (type) {\r\n                case 'string':\r\n                  let format = NGN.coalesce(property.format, 'unknown').trim().toLowerCase()\r\n\r\n                  field.type = String\r\n\r\n                  switch (format) {\r\n                    case 'date':\r\n                    case 'date-time':\r\n                    case 'datetime':\r\n                    case 'format-time':\r\n                      field.type = Date\r\n                      break\r\n\r\n                    case 'ipv4':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'ipv6':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'email':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\\b$/\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'hostname':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)+(\\.([a-zA-Z0-9]+(-[a-zA-Z0-9‌​]+)*))*$/ // eslint-disable-line no-irregular-whitespace\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'uri':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]\\.[^\\s]{2,})/\r\n                      )\r\n\r\n                      break\r\n                  }\r\n\r\n                  break\r\n\r\n                case 'integer':\r\n                  field.type = Number\r\n                  field.pattern = /^\\d+$/\r\n                  break\r\n\r\n                case 'number':\r\n                  field.type = Number\r\n                  break\r\n\r\n                case 'object':\r\n                  if (property.properties) {\r\n                    let subschema = new NGN.DATA.JSONSchema(property)\r\n\r\n                    subschema.name = `${NGN.coalesce(this.name, 'untitled')}_${NGN.coalesce(subschema.name, 'submodel')}${models.length + 1}`\r\n\r\n                    subschema.getModelDefinitions(definitions => {\r\n                      definitions[definitions.length - 1].name = subschema.name\r\n                      models = definitions.concat(models)\r\n                    })\r\n\r\n                    field = {\r\n                      $model: subschema.name\r\n                    }\r\n                  } else {\r\n                    field.type = Object\r\n                  }\r\n\r\n                  break\r\n\r\n                default:\r\n                  field.type = String\r\n                  break\r\n              }\r\n            }\r\n          }\r\n\r\n          // String validation options\r\n          if (field.type === String || field.type === Number) {\r\n            if (NGN.coalesce(property.minLength, property.minimum)) {\r\n              field.min = NGN.coalesce(property.minLength, property.minimum)\r\n            }\r\n\r\n            if (NGN.coalesce(property.maxLength, property.maximum)) {\r\n              field.max = NGN.coalesce(property.maxLength, property.maximum)\r\n            }\r\n\r\n            // Numeric-specific validations\r\n            if (property.type === Number) {\r\n              if (property.multipleOf) {\r\n                field.multipleOf = property.multipleOf\r\n              }\r\n\r\n              if (property.exclusiveMinimum) {\r\n                field.min = (property.exclusiveMinimum + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\r\n              }\r\n\r\n              if (property.exclusiveMaximum) {\r\n                field.max = (property.exclusiveMaximum - 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\r\n              }\r\n            }\r\n          }\r\n\r\n          // Array validation options\r\n          if (field.type === Array) {\r\n            // Support minimum array length\r\n            if (property.hasOwnProperty('minItems')) {\r\n              field.min = property.minItems\r\n            }\r\n\r\n            // Support maximum array length\r\n            if (property.hasOwnProperty('maxItems')) {\r\n              field.max = property.maxItems\r\n            }\r\n\r\n            if (property.hasOwnProperty('items')) {\r\n              if (NGN.typeof(property.items) === 'array') {\r\n                // Apply tuple validation\r\n                field.tuples = property.items\r\n              } else {\r\n                // Apply list validation\r\n                if (property.items.hasOwnProperty('type')) {\r\n                  field.listType = NGN.getType(property.items.type)\r\n                }\r\n\r\n                if (property.items.hasOwnProperty('enum')) {\r\n                  field.enum = property.items.enum\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          return field\r\n        },\r\n\r\n        /**\r\n         * @method PRIVATE.extractModelDefinitions\r\n         * Retrieve all of the NGN.DATA.Model defitions that can be interpreted\r\n         * from this schema.\r\n         * @protected\r\n         * @private\r\n         * @param  {Object} data\r\n         * The schema object.\r\n         * @param  {Array} [models=[]]\r\n         * An array of known models. This method is used recursively, so this\r\n         * argument exists primarily for internal use.\r\n         * @param  {Function} callback\r\n         * Executed when all models have been detected.\r\n         */\r\n        extractModelDefinitions: (data, models = [], callback) => {\r\n          if (NGN.isFn(models)) {\r\n            callback = models\r\n            models = []\r\n          }\r\n\r\n          if (data.type === 'object') {\r\n            let name = NGN.coalesce(data.name, this.name, 'Untitled')\r\n\r\n            if (data.hasOwnProperty('$schema') && name === null && this.METADATA.URL) {\r\n              name = this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', '')\r\n            }\r\n\r\n            // Configure the basic model\r\n            let model = {\r\n              name,\r\n              description: NGN.coalesce(data.description, 'No description.'),\r\n              fields: {}\r\n            }\r\n\r\n            // Flag the ID for the schema\r\n            if (data.hasOwnProperty('$schema')) {\r\n              this.METADATA.ID = NGN.coalesce(data.$id, data.$schema)\r\n            }\r\n\r\n            // Queue the tasks since several are async but sequential\r\n            let tasks = new NGN.Tasks()\r\n\r\n            // If the allOf attribute exists, the schema is extending another.\r\n            // Extract the subschema before continuing.\r\n            if (data.hasOwnProperty('allOf')) {\r\n              for (let i = 0; i < data.allOf.length; i++) {\r\n                tasks.add(`Identify base schema: ${data.allOf}`, cont => {\r\n                  let URI = NGN.coalesce(data.allOf[i].$ref, data.allOf[i].$schema)\r\n\r\n                  if (URI !== null) {\r\n                    // When a URI is specified, retrieve the remote schema\r\n                    let baseSchema = new NGN.DATA.JSONSchema(URI)\r\n\r\n                    baseSchema.getModelDefinitions(definitions => {\r\n                      let coreModel = definitions.pop()\r\n\r\n                      Object.assign(model.fields, coreModel.fields)\r\n\r\n                      // If the nested schema has additional models, apply them.\r\n                      if (definitions.length > 0) {\r\n                        models = definitions.concat(models)\r\n                      }\r\n\r\n                      this.METADATA.name = NGN.coalesce(this.METADATA.name, coreModel.name)\r\n\r\n                      cont()\r\n                    })\r\n                  } else if (data.allOf[i].hasOwnProperty('properties')) {\r\n                    // Handle additional properties\r\n                    let additionalProperties = Object.keys(data.allOf[i].properties)\r\n\r\n                    for (let prop = 0; prop < additionalProperties.length; prop++) {\r\n                      model.fields[additionalProperties[prop]] = this.extractCommonPropertyAttributes(data.allOf[i].properties[additionalProperties[prop]])\r\n                    }\r\n\r\n                    cont()\r\n                  }\r\n                })\r\n              }\r\n            }\r\n\r\n            tasks.add('Identify attributes', cont => {\r\n              // If the schema specifies dependencies, it is specifying a set of\r\n              // rules requiring the existance and non-empty value of additional\r\n              // fields. Create NGN.DATA.Rule sets to support this.\r\n              if (data.hasOwnProperty('dependencies')) {\r\n                Object.keys(data.dependencies).forEach(dependency => {\r\n                  let requiredFields = null\r\n                  let dep = data.dependencies[dependency]\r\n\r\n                  if (NGN.typeof(dep) === 'array') {\r\n                    // Simple property dependencies\r\n                    requiredFields = dep\r\n                  } else if (dep.hasOwnProperty('required')) {\r\n                    // Schema dependencies\r\n                    requiredFields = dep.required\r\n                  }\r\n\r\n                  // Add all valid dependencies as rules\r\n                  if (requiredFields !== null) {\r\n                    model.rules[`${dependency} dependency on \"${requiredFields.join(', ')}\"`] = function () {\r\n                      if (NGN.coalesce(this[dependency]) !== null) {\r\n                        for (let i = 0; i < requiredFields.length; i++) {\r\n                          if (NGN.coalesce(this[requiredFields[i]]) === null) {\r\n                            return false\r\n                          }\r\n                        }\r\n                      }\r\n\r\n                      return true\r\n                    }\r\n                  }\r\n                })\r\n              }\r\n\r\n              // Identify the fields\r\n              let properties = Object.keys(data.properties)\r\n              let subtasks = new NGN.Tasks()\r\n\r\n              if (properties.length > 0) {\r\n                for (let i = 0; i < properties.length; i++) {\r\n                  let propertyName = properties[i]\r\n                  let property = data.properties[propertyName]\r\n\r\n                  model.fields[propertyName] = this.PRIVATE.extractCommonPropertyAttributes(property, models)\r\n\r\n                  // If this is a subschema, retrieve it.\r\n                  if (property.$ref) {\r\n                    subtasks.add(next => {\r\n                      let nestedModel = new NGN.DATA.JSONSchema(property.$ref)\r\n\r\n                      nestedModel.getModelDefinitions(definitions => {\r\n                        models = definitions.concat(models)\r\n\r\n                        model.fields[propertyName] = {\r\n                          $model: definitions[definitions.length - 1].name\r\n                        }\r\n\r\n                        next()\r\n                      })\r\n                    })\r\n                  }\r\n\r\n                  model.fields[propertyName].required = NGN.coalesce(data.required, '').indexOf(propertyName) >= 0\r\n                }\r\n              }\r\n\r\n              subtasks.on('complete', () => {\r\n                models.push(model)\r\n                cont()\r\n              })\r\n\r\n              subtasks.run(true)\r\n            })\r\n\r\n            tasks.on('complete', () => callback(models))\r\n            tasks.run(true)\r\n          } else {\r\n            callback(models)\r\n          }\r\n        }\r\n      })\r\n    })\r\n\r\n    this.once('parsed', () => {\r\n      this.PRIVATE.parsed = true\r\n      this.METADATA.ID = NGN.coalesce(this.METADATA.schema.id, this.METADATA.schema.$schema)\r\n    })\r\n\r\n    // Initialize\r\n    switch (NGN.typeof(schema)) {\r\n      case 'string':\r\n        // If schema is actually a URL, retrieve it.\r\n        this.METADATA.URL = schema\r\n        this.PRIVATE.NET.json(schema, (err, schema) => {\r\n          if (err) {\r\n            throw err\r\n          }\r\n\r\n          this.METADATA.schema = schema\r\n          this.METADATA.name = NGN.coalesce(schema.name, this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', ''))\r\n\r\n          this.emit('parsed')\r\n        })\r\n\r\n        break\r\n\r\n      case 'object':\r\n        this.METADATA.name = NGN.coalesce(schema.name, 'Untitled')\r\n        this.emit('parsed')\r\n        break\r\n\r\n      default:\r\n        throw new Error('Invalid schema definition.')\r\n    }\r\n  }\r\n\r\n  get id () {\r\n    if (this.METADATA.ID) {\r\n      return this.METADATA.ID\r\n    }\r\n\r\n    let id = NGN.coalesce(this.METADATA.URL)\r\n\r\n    if (id !== null) {\r\n      return id\r\n    }\r\n\r\n    let root\r\n    /* node-only */\r\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, `http://${require('os').hostname()}`)\r\n    /* end-node-only */\r\n    /* browser-only */\r\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, window.location.origin)\r\n    /* end-browser-only */\r\n\r\n    this.METADATA.ID = this.PRIVATE.NET.normalizeUrl(`${root}/${NGN.coalesce(this.name, 'untitled').toLowerCase()}.json`)\r\n\r\n    return this.METADATA.ID\r\n  }\r\n\r\n  get name () {\r\n    return this.METADATA.name\r\n  }\r\n\r\n  set name (value) {\r\n    this.METADATA.name = NGN.coalesce(value, 'Untitled')\r\n  }\r\n\r\n  getModelDefinitions (callback) {\r\n    if (!this.PRIVATE.parsed) {\r\n      this.once('parsed', () => {\r\n        this.getModelDefinitions(callback)\r\n      })\r\n    } else if (!this.PRIVATE.MODELS) {\r\n      this.PRIVATE.extractModelDefinitions(this.METADATA.schema, [], definitions => {\r\n        this.PRIVATE.MODELS = definitions\r\n        callback(definitions)\r\n      })\r\n    } else {\r\n      callback(this.PRIVATE.MODELS)\r\n    }\r\n  }\r\n}",
  "tags": {},
  "exceptions": {},
  "events": {
    "parsed": {
      "type": "event",
      "label": "parsed",
      "description": null,
      "code": "this.emit('parsed')",
      "start": {
        "line": 410,
        "column": 8
      },
      "end": {
        "line": 410,
        "column": 27
      },
      "flags": [],
      "authors": [],
      "parameters": {},
      "deprecated": false,
      "deprecationReplacement": null
    }
  },
  "start": {
    "line": 9,
    "column": 15
  },
  "end": {
    "line": 464,
    "column": 1
  },
  "flags": [],
  "authors": [],
  "sourcefile": "data/schema/JSON.js",
  "extends": "EventEmitter",
  "configuration": {},
  "properties": {
    "METADATA": {
      "type": "property",
      "label": "METADATA",
      "description": null,
      "code": "METADATA: NGN.private({\r\n        schema,\r\n        ID: null,\r\n        name: null\r\n      })",
      "start": {
        "line": 22,
        "column": 6
      },
      "end": {
        "line": 26,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": true,
      "configuration": false,
      "private": true
    },
    "PRIVATE": {
      "type": "property",
      "label": "PRIVATE",
      "description": null,
      "code": "PRIVATE: NGN.privateconst({\r\n        MODELS: null,\r\n        NET: NGN.coalesce(NetworkResource, NGN.NET),\r\n\r\n        parsed: false,\r\n\r\n        /**\r\n         * @method PRIVATE.extractCommonPropertyAttributes\r\n         * @param  {object} property\r\n         * Schema metadata object.\r\n         * @param {array} [models=[]]\r\n         * The list of known models. This is passed in because nested objects\r\n         * may exist within a property. NGN identifies these as nested models,\r\n         * even though the JSON schema does not force these to be separate\r\n         * schemas.\r\n         * @return {Object}\r\n         * Returns a clean \"NGN-ready\" field object of common properties.\r\n         */\r\n        extractCommonPropertyAttributes: (property, models = []) => {\r\n          let field = {}\r\n\r\n          // Add pattern\r\n          if (property.pattern) {\r\n            field.pattern = property.pattern\r\n          }\r\n\r\n          // Add description\r\n          if (property.description) {\r\n            field.description = property.description\r\n          }\r\n\r\n          // Add default\r\n          if (property.default) {\r\n            field.default = property.default\r\n          }\r\n\r\n          if (!property.$ref) {\r\n            if (!property.type) {\r\n              field.type = String\r\n            } else {\r\n              let type = NGN.typeof(property.type) === 'array' ? 'array' : property.type.trim().toLowerCase()\r\n\r\n              switch (type) {\r\n                case 'string':\r\n                  let format = NGN.coalesce(property.format, 'unknown').trim().toLowerCase()\r\n\r\n                  field.type = String\r\n\r\n                  switch (format) {\r\n                    case 'date':\r\n                    case 'date-time':\r\n                    case 'datetime':\r\n                    case 'format-time':\r\n                      field.type = Date\r\n                      break\r\n\r\n                    case 'ipv4':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'ipv6':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'email':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\\b$/\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'hostname':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)+(\\.([a-zA-Z0-9]+(-[a-zA-Z0-9‌​]+)*))*$/ // eslint-disable-line no-irregular-whitespace\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'uri':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]\\.[^\\s]{2,})/\r\n                      )\r\n\r\n                      break\r\n                  }\r\n\r\n                  break\r\n\r\n                case 'integer':\r\n                  field.type = Number\r\n                  field.pattern = /^\\d+$/\r\n                  break\r\n\r\n                case 'number':\r\n                  field.type = Number\r\n                  break\r\n\r\n                case 'object':\r\n                  if (property.properties) {\r\n                    let subschema = new NGN.DATA.JSONSchema(property)\r\n\r\n                    subschema.name = `${NGN.coalesce(this.name, 'untitled')}_${NGN.coalesce(subschema.name, 'submodel')}${models.length + 1}`\r\n\r\n                    subschema.getModelDefinitions(definitions => {\r\n                      definitions[definitions.length - 1].name = subschema.name\r\n                      models = definitions.concat(models)\r\n                    })\r\n\r\n                    field = {\r\n                      $model: subschema.name\r\n                    }\r\n                  } else {\r\n                    field.type = Object\r\n                  }\r\n\r\n                  break\r\n\r\n                default:\r\n                  field.type = String\r\n                  break\r\n              }\r\n            }\r\n          }\r\n\r\n          // String validation options\r\n          if (field.type === String || field.type === Number) {\r\n            if (NGN.coalesce(property.minLength, property.minimum)) {\r\n              field.min = NGN.coalesce(property.minLength, property.minimum)\r\n            }\r\n\r\n            if (NGN.coalesce(property.maxLength, property.maximum)) {\r\n              field.max = NGN.coalesce(property.maxLength, property.maximum)\r\n            }\r\n\r\n            // Numeric-specific validations\r\n            if (property.type === Number) {\r\n              if (property.multipleOf) {\r\n                field.multipleOf = property.multipleOf\r\n              }\r\n\r\n              if (property.exclusiveMinimum) {\r\n                field.min = (property.exclusiveMinimum + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\r\n              }\r\n\r\n              if (property.exclusiveMaximum) {\r\n                field.max = (property.exclusiveMaximum - 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\r\n              }\r\n            }\r\n          }\r\n\r\n          // Array validation options\r\n          if (field.type === Array) {\r\n            // Support minimum array length\r\n            if (property.hasOwnProperty('minItems')) {\r\n              field.min = property.minItems\r\n            }\r\n\r\n            // Support maximum array length\r\n            if (property.hasOwnProperty('maxItems')) {\r\n              field.max = property.maxItems\r\n            }\r\n\r\n            if (property.hasOwnProperty('items')) {\r\n              if (NGN.typeof(property.items) === 'array') {\r\n                // Apply tuple validation\r\n                field.tuples = property.items\r\n              } else {\r\n                // Apply list validation\r\n                if (property.items.hasOwnProperty('type')) {\r\n                  field.listType = NGN.getType(property.items.type)\r\n                }\r\n\r\n                if (property.items.hasOwnProperty('enum')) {\r\n                  field.enum = property.items.enum\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          return field\r\n        },\r\n\r\n        /**\r\n         * @method PRIVATE.extractModelDefinitions\r\n         * Retrieve all of the NGN.DATA.Model defitions that can be interpreted\r\n         * from this schema.\r\n         * @protected\r\n         * @private\r\n         * @param  {Object} data\r\n         * The schema object.\r\n         * @param  {Array} [models=[]]\r\n         * An array of known models. This method is used recursively, so this\r\n         * argument exists primarily for internal use.\r\n         * @param  {Function} callback\r\n         * Executed when all models have been detected.\r\n         */\r\n        extractModelDefinitions: (data, models = [], callback) => {\r\n          if (NGN.isFn(models)) {\r\n            callback = models\r\n            models = []\r\n          }\r\n\r\n          if (data.type === 'object') {\r\n            let name = NGN.coalesce(data.name, this.name, 'Untitled')\r\n\r\n            if (data.hasOwnProperty('$schema') && name === null && this.METADATA.URL) {\r\n              name = this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', '')\r\n            }\r\n\r\n            // Configure the basic model\r\n            let model = {\r\n              name,\r\n              description: NGN.coalesce(data.description, 'No description.'),\r\n              fields: {}\r\n            }\r\n\r\n            // Flag the ID for the schema\r\n            if (data.hasOwnProperty('$schema')) {\r\n              this.METADATA.ID = NGN.coalesce(data.$id, data.$schema)\r\n            }\r\n\r\n            // Queue the tasks since several are async but sequential\r\n            let tasks = new NGN.Tasks()\r\n\r\n            // If the allOf attribute exists, the schema is extending another.\r\n            // Extract the subschema before continuing.\r\n            if (data.hasOwnProperty('allOf')) {\r\n              for (let i = 0; i < data.allOf.length; i++) {\r\n                tasks.add(`Identify base schema: ${data.allOf}`, cont => {\r\n                  let URI = NGN.coalesce(data.allOf[i].$ref, data.allOf[i].$schema)\r\n\r\n                  if (URI !== null) {\r\n                    // When a URI is specified, retrieve the remote schema\r\n                    let baseSchema = new NGN.DATA.JSONSchema(URI)\r\n\r\n                    baseSchema.getModelDefinitions(definitions => {\r\n                      let coreModel = definitions.pop()\r\n\r\n                      Object.assign(model.fields, coreModel.fields)\r\n\r\n                      // If the nested schema has additional models, apply them.\r\n                      if (definitions.length > 0) {\r\n                        models = definitions.concat(models)\r\n                      }\r\n\r\n                      this.METADATA.name = NGN.coalesce(this.METADATA.name, coreModel.name)\r\n\r\n                      cont()\r\n                    })\r\n                  } else if (data.allOf[i].hasOwnProperty('properties')) {\r\n                    // Handle additional properties\r\n                    let additionalProperties = Object.keys(data.allOf[i].properties)\r\n\r\n                    for (let prop = 0; prop < additionalProperties.length; prop++) {\r\n                      model.fields[additionalProperties[prop]] = this.extractCommonPropertyAttributes(data.allOf[i].properties[additionalProperties[prop]])\r\n                    }\r\n\r\n                    cont()\r\n                  }\r\n                })\r\n              }\r\n            }\r\n\r\n            tasks.add('Identify attributes', cont => {\r\n              // If the schema specifies dependencies, it is specifying a set of\r\n              // rules requiring the existance and non-empty value of additional\r\n              // fields. Create NGN.DATA.Rule sets to support this.\r\n              if (data.hasOwnProperty('dependencies')) {\r\n                Object.keys(data.dependencies).forEach(dependency => {\r\n                  let requiredFields = null\r\n                  let dep = data.dependencies[dependency]\r\n\r\n                  if (NGN.typeof(dep) === 'array') {\r\n                    // Simple property dependencies\r\n                    requiredFields = dep\r\n                  } else if (dep.hasOwnProperty('required')) {\r\n                    // Schema dependencies\r\n                    requiredFields = dep.required\r\n                  }\r\n\r\n                  // Add all valid dependencies as rules\r\n                  if (requiredFields !== null) {\r\n                    model.rules[`${dependency} dependency on \"${requiredFields.join(', ')}\"`] = function () {\r\n                      if (NGN.coalesce(this[dependency]) !== null) {\r\n                        for (let i = 0; i < requiredFields.length; i++) {\r\n                          if (NGN.coalesce(this[requiredFields[i]]) === null) {\r\n                            return false\r\n                          }\r\n                        }\r\n                      }\r\n\r\n                      return true\r\n                    }\r\n                  }\r\n                })\r\n              }\r\n\r\n              // Identify the fields\r\n              let properties = Object.keys(data.properties)\r\n              let subtasks = new NGN.Tasks()\r\n\r\n              if (properties.length > 0) {\r\n                for (let i = 0; i < properties.length; i++) {\r\n                  let propertyName = properties[i]\r\n                  let property = data.properties[propertyName]\r\n\r\n                  model.fields[propertyName] = this.PRIVATE.extractCommonPropertyAttributes(property, models)\r\n\r\n                  // If this is a subschema, retrieve it.\r\n                  if (property.$ref) {\r\n                    subtasks.add(next => {\r\n                      let nestedModel = new NGN.DATA.JSONSchema(property.$ref)\r\n\r\n                      nestedModel.getModelDefinitions(definitions => {\r\n                        models = definitions.concat(models)\r\n\r\n                        model.fields[propertyName] = {\r\n                          $model: definitions[definitions.length - 1].name\r\n                        }\r\n\r\n                        next()\r\n                      })\r\n                    })\r\n                  }\r\n\r\n                  model.fields[propertyName].required = NGN.coalesce(data.required, '').indexOf(propertyName) >= 0\r\n                }\r\n              }\r\n\r\n              subtasks.on('complete', () => {\r\n                models.push(model)\r\n                cont()\r\n              })\r\n\r\n              subtasks.run(true)\r\n            })\r\n\r\n            tasks.on('complete', () => callback(models))\r\n            tasks.run(true)\r\n          } else {\r\n            callback(models)\r\n          }\r\n        }\r\n      })",
      "start": {
        "line": 28,
        "column": 6
      },
      "end": {
        "line": 382,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": true
    },
    "id": {
      "type": "property",
      "label": "id",
      "description": null,
      "code": "get id () {\r\n    if (this.METADATA.ID) {\r\n      return this.METADATA.ID\r\n    }\r\n\r\n    let id = NGN.coalesce(this.METADATA.URL)\r\n\r\n    if (id !== null) {\r\n      return id\r\n    }\r\n\r\n    let root\r\n    /* node-only */\r\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, `http://${require('os').hostname()}`)\r\n    /* end-node-only */\r\n    /* browser-only */\r\n    root = NGN.coalesce(this.PRIVATE.NET.baseUrl, window.location.origin)\r\n    /* end-browser-only */\r\n\r\n    this.METADATA.ID = this.PRIVATE.NET.normalizeUrl(`${root}/${NGN.coalesce(this.name, 'untitled').toLowerCase()}.json`)\r\n\r\n    return this.METADATA.ID\r\n  }",
      "start": {
        "line": 418,
        "column": 2
      },
      "end": {
        "line": 440,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "name": {
      "type": "property",
      "label": "name",
      "description": null,
      "code": "set name (value) {\r\n    this.METADATA.name = NGN.coalesce(value, 'Untitled')\r\n  }",
      "start": {
        "line": 446,
        "column": 2
      },
      "end": {
        "line": 448,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": false,
      "writable": true,
      "configuration": false,
      "private": false
    }
  },
  "methods": {
    "constructor": {
      "type": "method",
      "label": "constructor",
      "description": "Create a new JSON schema reference.\r\n  \r\n  The schema to parse. This can be the JSON schema object itself or the URL\r\n  of a remote JSON schema.\r\n  \r\n  Specify a custom network resource to make the request for a remote schema.",
      "code": "constructor (schema = {}, NetworkResource = null) {\r\n    super()\r\n\r\n    Object.defineProperties(this, {\r\n      METADATA: NGN.private({\r\n        schema,\r\n        ID: null,\r\n        name: null\r\n      }),\r\n\r\n      PRIVATE: NGN.privateconst({\r\n        MODELS: null,\r\n        NET: NGN.coalesce(NetworkResource, NGN.NET),\r\n\r\n        parsed: false,\r\n\r\n        /**\r\n         * @method PRIVATE.extractCommonPropertyAttributes\r\n         * @param  {object} property\r\n         * Schema metadata object.\r\n         * @param {array} [models=[]]\r\n         * The list of known models. This is passed in because nested objects\r\n         * may exist within a property. NGN identifies these as nested models,\r\n         * even though the JSON schema does not force these to be separate\r\n         * schemas.\r\n         * @return {Object}\r\n         * Returns a clean \"NGN-ready\" field object of common properties.\r\n         */\r\n        extractCommonPropertyAttributes: (property, models = []) => {\r\n          let field = {}\r\n\r\n          // Add pattern\r\n          if (property.pattern) {\r\n            field.pattern = property.pattern\r\n          }\r\n\r\n          // Add description\r\n          if (property.description) {\r\n            field.description = property.description\r\n          }\r\n\r\n          // Add default\r\n          if (property.default) {\r\n            field.default = property.default\r\n          }\r\n\r\n          if (!property.$ref) {\r\n            if (!property.type) {\r\n              field.type = String\r\n            } else {\r\n              let type = NGN.typeof(property.type) === 'array' ? 'array' : property.type.trim().toLowerCase()\r\n\r\n              switch (type) {\r\n                case 'string':\r\n                  let format = NGN.coalesce(property.format, 'unknown').trim().toLowerCase()\r\n\r\n                  field.type = String\r\n\r\n                  switch (format) {\r\n                    case 'date':\r\n                    case 'date-time':\r\n                    case 'datetime':\r\n                    case 'format-time':\r\n                      field.type = Date\r\n                      break\r\n\r\n                    case 'ipv4':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'ipv6':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/ // eslint-disable-line no-useless-escape\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'email':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\\b$/\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'hostname':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)+(\\.([a-zA-Z0-9]+(-[a-zA-Z0-9‌​]+)*))*$/ // eslint-disable-line no-irregular-whitespace\r\n                      )\r\n\r\n                      break\r\n\r\n                    case 'uri':\r\n                      field.pattern = NGN.coalesce(\r\n                        property.pattern,\r\n                        /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]\\.[^\\s]{2,})/\r\n                      )\r\n\r\n                      break\r\n                  }\r\n\r\n                  break\r\n\r\n                case 'integer':\r\n                  field.type = Number\r\n                  field.pattern = /^\\d+$/\r\n                  break\r\n\r\n                case 'number':\r\n                  field.type = Number\r\n                  break\r\n\r\n                case 'object':\r\n                  if (property.properties) {\r\n                    let subschema = new NGN.DATA.JSONSchema(property)\r\n\r\n                    subschema.name = `${NGN.coalesce(this.name, 'untitled')}_${NGN.coalesce(subschema.name, 'submodel')}${models.length + 1}`\r\n\r\n                    subschema.getModelDefinitions(definitions => {\r\n                      definitions[definitions.length - 1].name = subschema.name\r\n                      models = definitions.concat(models)\r\n                    })\r\n\r\n                    field = {\r\n                      $model: subschema.name\r\n                    }\r\n                  } else {\r\n                    field.type = Object\r\n                  }\r\n\r\n                  break\r\n\r\n                default:\r\n                  field.type = String\r\n                  break\r\n              }\r\n            }\r\n          }\r\n\r\n          // String validation options\r\n          if (field.type === String || field.type === Number) {\r\n            if (NGN.coalesce(property.minLength, property.minimum)) {\r\n              field.min = NGN.coalesce(property.minLength, property.minimum)\r\n            }\r\n\r\n            if (NGN.coalesce(property.maxLength, property.maximum)) {\r\n              field.max = NGN.coalesce(property.maxLength, property.maximum)\r\n            }\r\n\r\n            // Numeric-specific validations\r\n            if (property.type === Number) {\r\n              if (property.multipleOf) {\r\n                field.multipleOf = property.multipleOf\r\n              }\r\n\r\n              if (property.exclusiveMinimum) {\r\n                field.min = (property.exclusiveMinimum + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\r\n              }\r\n\r\n              if (property.exclusiveMaximum) {\r\n                field.max = (property.exclusiveMaximum - 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)\r\n              }\r\n            }\r\n          }\r\n\r\n          // Array validation options\r\n          if (field.type === Array) {\r\n            // Support minimum array length\r\n            if (property.hasOwnProperty('minItems')) {\r\n              field.min = property.minItems\r\n            }\r\n\r\n            // Support maximum array length\r\n            if (property.hasOwnProperty('maxItems')) {\r\n              field.max = property.maxItems\r\n            }\r\n\r\n            if (property.hasOwnProperty('items')) {\r\n              if (NGN.typeof(property.items) === 'array') {\r\n                // Apply tuple validation\r\n                field.tuples = property.items\r\n              } else {\r\n                // Apply list validation\r\n                if (property.items.hasOwnProperty('type')) {\r\n                  field.listType = NGN.getType(property.items.type)\r\n                }\r\n\r\n                if (property.items.hasOwnProperty('enum')) {\r\n                  field.enum = property.items.enum\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          return field\r\n        },\r\n\r\n        /**\r\n         * @method PRIVATE.extractModelDefinitions\r\n         * Retrieve all of the NGN.DATA.Model defitions that can be interpreted\r\n         * from this schema.\r\n         * @protected\r\n         * @private\r\n         * @param  {Object} data\r\n         * The schema object.\r\n         * @param  {Array} [models=[]]\r\n         * An array of known models. This method is used recursively, so this\r\n         * argument exists primarily for internal use.\r\n         * @param  {Function} callback\r\n         * Executed when all models have been detected.\r\n         */\r\n        extractModelDefinitions: (data, models = [], callback) => {\r\n          if (NGN.isFn(models)) {\r\n            callback = models\r\n            models = []\r\n          }\r\n\r\n          if (data.type === 'object') {\r\n            let name = NGN.coalesce(data.name, this.name, 'Untitled')\r\n\r\n            if (data.hasOwnProperty('$schema') && name === null && this.METADATA.URL) {\r\n              name = this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', '')\r\n            }\r\n\r\n            // Configure the basic model\r\n            let model = {\r\n              name,\r\n              description: NGN.coalesce(data.description, 'No description.'),\r\n              fields: {}\r\n            }\r\n\r\n            // Flag the ID for the schema\r\n            if (data.hasOwnProperty('$schema')) {\r\n              this.METADATA.ID = NGN.coalesce(data.$id, data.$schema)\r\n            }\r\n\r\n            // Queue the tasks since several are async but sequential\r\n            let tasks = new NGN.Tasks()\r\n\r\n            // If the allOf attribute exists, the schema is extending another.\r\n            // Extract the subschema before continuing.\r\n            if (data.hasOwnProperty('allOf')) {\r\n              for (let i = 0; i < data.allOf.length; i++) {\r\n                tasks.add(`Identify base schema: ${data.allOf}`, cont => {\r\n                  let URI = NGN.coalesce(data.allOf[i].$ref, data.allOf[i].$schema)\r\n\r\n                  if (URI !== null) {\r\n                    // When a URI is specified, retrieve the remote schema\r\n                    let baseSchema = new NGN.DATA.JSONSchema(URI)\r\n\r\n                    baseSchema.getModelDefinitions(definitions => {\r\n                      let coreModel = definitions.pop()\r\n\r\n                      Object.assign(model.fields, coreModel.fields)\r\n\r\n                      // If the nested schema has additional models, apply them.\r\n                      if (definitions.length > 0) {\r\n                        models = definitions.concat(models)\r\n                      }\r\n\r\n                      this.METADATA.name = NGN.coalesce(this.METADATA.name, coreModel.name)\r\n\r\n                      cont()\r\n                    })\r\n                  } else if (data.allOf[i].hasOwnProperty('properties')) {\r\n                    // Handle additional properties\r\n                    let additionalProperties = Object.keys(data.allOf[i].properties)\r\n\r\n                    for (let prop = 0; prop < additionalProperties.length; prop++) {\r\n                      model.fields[additionalProperties[prop]] = this.extractCommonPropertyAttributes(data.allOf[i].properties[additionalProperties[prop]])\r\n                    }\r\n\r\n                    cont()\r\n                  }\r\n                })\r\n              }\r\n            }\r\n\r\n            tasks.add('Identify attributes', cont => {\r\n              // If the schema specifies dependencies, it is specifying a set of\r\n              // rules requiring the existance and non-empty value of additional\r\n              // fields. Create NGN.DATA.Rule sets to support this.\r\n              if (data.hasOwnProperty('dependencies')) {\r\n                Object.keys(data.dependencies).forEach(dependency => {\r\n                  let requiredFields = null\r\n                  let dep = data.dependencies[dependency]\r\n\r\n                  if (NGN.typeof(dep) === 'array') {\r\n                    // Simple property dependencies\r\n                    requiredFields = dep\r\n                  } else if (dep.hasOwnProperty('required')) {\r\n                    // Schema dependencies\r\n                    requiredFields = dep.required\r\n                  }\r\n\r\n                  // Add all valid dependencies as rules\r\n                  if (requiredFields !== null) {\r\n                    model.rules[`${dependency} dependency on \"${requiredFields.join(', ')}\"`] = function () {\r\n                      if (NGN.coalesce(this[dependency]) !== null) {\r\n                        for (let i = 0; i < requiredFields.length; i++) {\r\n                          if (NGN.coalesce(this[requiredFields[i]]) === null) {\r\n                            return false\r\n                          }\r\n                        }\r\n                      }\r\n\r\n                      return true\r\n                    }\r\n                  }\r\n                })\r\n              }\r\n\r\n              // Identify the fields\r\n              let properties = Object.keys(data.properties)\r\n              let subtasks = new NGN.Tasks()\r\n\r\n              if (properties.length > 0) {\r\n                for (let i = 0; i < properties.length; i++) {\r\n                  let propertyName = properties[i]\r\n                  let property = data.properties[propertyName]\r\n\r\n                  model.fields[propertyName] = this.PRIVATE.extractCommonPropertyAttributes(property, models)\r\n\r\n                  // If this is a subschema, retrieve it.\r\n                  if (property.$ref) {\r\n                    subtasks.add(next => {\r\n                      let nestedModel = new NGN.DATA.JSONSchema(property.$ref)\r\n\r\n                      nestedModel.getModelDefinitions(definitions => {\r\n                        models = definitions.concat(models)\r\n\r\n                        model.fields[propertyName] = {\r\n                          $model: definitions[definitions.length - 1].name\r\n                        }\r\n\r\n                        next()\r\n                      })\r\n                    })\r\n                  }\r\n\r\n                  model.fields[propertyName].required = NGN.coalesce(data.required, '').indexOf(propertyName) >= 0\r\n                }\r\n              }\r\n\r\n              subtasks.on('complete', () => {\r\n                models.push(model)\r\n                cont()\r\n              })\r\n\r\n              subtasks.run(true)\r\n            })\r\n\r\n            tasks.on('complete', () => callback(models))\r\n            tasks.run(true)\r\n          } else {\r\n            callback(models)\r\n          }\r\n        }\r\n      })\r\n    })\r\n\r\n    this.once('parsed', () => {\r\n      this.PRIVATE.parsed = true\r\n      this.METADATA.ID = NGN.coalesce(this.METADATA.schema.id, this.METADATA.schema.$schema)\r\n    })\r\n\r\n    // Initialize\r\n    switch (NGN.typeof(schema)) {\r\n      case 'string':\r\n        // If schema is actually a URL, retrieve it.\r\n        this.METADATA.URL = schema\r\n        this.PRIVATE.NET.json(schema, (err, schema) => {\r\n          if (err) {\r\n            throw err\r\n          }\r\n\r\n          this.METADATA.schema = schema\r\n          this.METADATA.name = NGN.coalesce(schema.name, this.METADATA.URL.split(/\\/|\\\\/).pop().replace('.json', ''))\r\n\r\n          this.emit('parsed')\r\n        })\r\n\r\n        break\r\n\r\n      case 'object':\r\n        this.METADATA.name = NGN.coalesce(schema.name, 'Untitled')\r\n        this.emit('parsed')\r\n        break\r\n\r\n      default:\r\n        throw new Error('Invalid schema definition.')\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 18,
        "column": 2
      },
      "end": {
        "line": 416,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "schema": {
          "type": "argument",
          "label": "schema",
          "description": "The schema to parse. This can be the JSON schema object itself or the URL\nof a remote JSON schema.",
          "code": "schema = {}",
          "start": {
            "line": 18,
            "column": 15
          },
          "end": {
            "line": 18,
            "column": 26
          },
          "flags": [],
          "authors": [],
          "default": "{}",
          "datatype": "object|string",
          "required": false,
          "enum": null
        },
        "NetworkResource": {
          "type": "argument",
          "label": "NetworkResource",
          "description": "Specify a custom network resource to make the request for a remote schema.",
          "code": "NetworkResource = null",
          "start": {
            "line": 18,
            "column": 28
          },
          "end": {
            "line": 18,
            "column": 50
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "ngn.net.resource",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "constructor",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "getModelDefinitions": {
      "type": "method",
      "label": "getModelDefinitions",
      "description": null,
      "code": "getModelDefinitions (callback) {\r\n    if (!this.PRIVATE.parsed) {\r\n      this.once('parsed', () => {\r\n        this.getModelDefinitions(callback)\r\n      })\r\n    } else if (!this.PRIVATE.MODELS) {\r\n      this.PRIVATE.extractModelDefinitions(this.METADATA.schema, [], definitions => {\r\n        this.PRIVATE.MODELS = definitions\r\n        callback(definitions)\r\n      })\r\n    } else {\r\n      callback(this.PRIVATE.MODELS)\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 450,
        "column": 2
      },
      "end": {
        "line": 463,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "callback": {
          "type": "argument",
          "label": "callback",
          "description": null,
          "code": "callback",
          "start": {
            "line": 450,
            "column": 23
          },
          "end": {
            "line": 450,
            "column": 31
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "PRIVATE.extractCommonPropertyAttributes": {
      "type": "method",
      "label": "PRIVATE.extractCommonPropertyAttributes",
      "description": "",
      "code": null,
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 0,
        "column": 0
      },
      "end": {
        "line": 0,
        "column": 0
      },
      "flags": [],
      "authors": [],
      "arguments": {},
      "returnType": "void",
      "returnDescription": "void",
      "kind": null,
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "PRIVATE.extractModelDefinitions": {
      "type": "method",
      "label": "PRIVATE.extractModelDefinitions",
      "description": "Retrieve all of the NGN.DATA.Model defitions that can be interpreted\nfrom this schema.",
      "code": null,
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 0,
        "column": 0
      },
      "end": {
        "line": 0,
        "column": 0
      },
      "flags": [],
      "authors": [],
      "arguments": {},
      "returnType": "void",
      "returnDescription": "void",
      "kind": null,
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    }
  }
}