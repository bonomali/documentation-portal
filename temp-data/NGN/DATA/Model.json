{
  "type": "class",
  "label": "NGN.DATA.Model",
  "description": "The date/time when the record expires. This may be set to\r\n  a future date, or a numeric value. Numeric values\r\n  represent the number of milliseconds from the current time\r\n  before the record expires. For example, set this to `3000`\r\n  to force the record to expire 3 seconds from now.\r\n  \n  Set this to `0` to immediately expire the record. Set this to\r\n  `-1` or `null` to prevent the record from expiring.",
  "code": "class NGNDataEntity extends EventEmitter { // eslint-disable-line\r\n  constructor (cfg) {\r\n    cfg = NGN.coalesce(cfg, {})\r\n\r\n    super()\r\n\r\n    if (cfg.dataMap) {\r\n      cfg.fieldmap = cfg.dataMap\r\n      NGN.WARN('\"dataMap\" is deprecated. Use \"map\" instead.')\r\n    }\r\n\r\n    if (cfg.idAttribute) {\r\n      cfg.IdentificationField = cfg.idAttribute\r\n      NGN.WARN('\"idAttribute\" is deprecated. Use \"IdentificationField\" instead.')\r\n    }\r\n\r\n    const me = this\r\n\r\n    // Create private attributes & data placeholders\r\n    Object.defineProperties(this, {\r\n      /**\r\n       * @property {Symbol} OID\r\n       * A unique object ID assigned to the model. This is an\r\n       * internal readon-only reference.\r\n       * @private\r\n       */\r\n      OID: NGN.private(Symbol('model.id')),\r\n\r\n      METADATA: NGN.privateconst({\r\n        /**\r\n         * @cfg {string} [name]\r\n         * A descriptive name for the model. This is typically used for\r\n         * debugging, logging, schema defintions, and (sometimes) data proxies.\r\n         */\r\n        name: NGN.coalesce(cfg.name, 'Untitled Model'),\r\n\r\n        /**\r\n         * @cfg {string} [description]\r\n         * A description of the model. This is typically used for\r\n         * debugging, logging, schema definitions, and (sometimes) data proxies.\r\n         */\r\n        description: NGN.coalesce(cfg.description, cfg.name, 'Generic Data Model'),\r\n\r\n        /**\r\n         * @cfg {object} fields\r\n         * A private object containing the data fields of the model.\r\n         * Each key contains the field name, while each value can be one of\r\n         * the following:\r\n         *\r\n         * - Primitive (String, Number, RegExp, Boolean)\r\n         * - Standard Type (Array, Object, Date)\r\n         * - Custom Class\r\n         * - NGN.DATA.Field\r\n         * - An NGN.DATA.Field configuration\r\n         * - `null` (Defaults to String primitive)\r\n         *\r\n         * ```js\r\n         * fields: {\r\n         *   a: String,\r\n         *   b: Date,\r\n         *   c: MyCustomClass,\r\n         *   d: new NGN.DATA.Field({\r\n         *     required: true,\r\n         *     type: String,\r\n         *     default: 'some default value'\r\n         *   }),\r\n         *   e: {\r\n         *     required: true,\r\n         *     type: String,\r\n         *     default: 'some default value'\r\n         *   },\r\n         *   f: null // Uses default field config (String)\r\n         * }\r\n         * ```\r\n         *\r\n         * Extensions of the NGN.DATA.Field are also supported,\r\n         * such as NGN.DATA.VirtualField and NGN.DATA.Relationship.\r\n         */\r\n        fields: Object.assign({}, NGN.coalesce(cfg.fields, {})),\r\n        knownFieldNames: new Set(),\r\n        invalidFieldNames: new Set(),\r\n        auditFieldNames: NGN.coalesce(cfg.audit, false) ? new Set() : null,\r\n\r\n        /**\r\n         * @property {[NGN.DATA.Rule]|Object}\r\n         * Custom validation rules used to verify the integrity of the entire\r\n         * model. This only applies to the full model. Individual data fields\r\n         * may have their own validators.\r\n         *\r\n         * If an object is specified, it should contain simple key/value pairs,\r\n         * where the key is the descriptive name of the rule and the value is\r\n         * a synchronous callback function that returns a `true`/`false` value.\r\n         * For instance, assume the fields called `price`, `items`, and `tax` exist\r\n         * in the example model below. :\r\n         *\r\n         * ```js\r\n         * {\r\n         *   'Positive Sale': function () {\r\n         *      return (this.price * this.items) > 0\r\n         *   },\r\n         *   'Taxes Applied': function () {\r\n         *      return this.tax > 0\r\n         *   }\r\n         * }\r\n         * ```\r\n         *\r\n         * Alternatively, an array of NGN.DATA.Rule instances may be provided.\r\n         */\r\n        validators: NGN.coalesce(cfg.rules, cfg.rule, cfg.validators),\r\n\r\n        /**\r\n         * @cfgproperty {boolean} [validation=true]\r\n         * Toggle data validation using this.\r\n         */\r\n        validation: NGN.coalesce(cfg.validation, true),\r\n\r\n        /**\r\n         * @cfg {boolean} [autoid=false]\r\n         * If the NGN.DATA.Model#IdentificationField/id is not provided for a record,\r\n         * a unique ID will be automatically generated for it.\r\n         *\r\n         * An NGN.DATA.Store using a model with this set to `true` will never\r\n         * have a duplicate record, since the #id or #IdentificationField will always\r\n         * be unique.\r\n         */\r\n        autoid: NGN.coalesce(cfg.autoid, false),\r\n\r\n        /**\r\n         * @cfg {String} [IdentificationField='id']\r\n         * Setting this allows an attribute of the object to be used as the ID.\r\n         * For example, if an email is the ID of a user, this would be set to\r\n         * `email`.\r\n         */\r\n        IdentificationField: NGN.coalesce(cfg.IdentificationField, cfg.idField, 'id'),\r\n\r\n        /**\r\n         * @cfgproperty {Date|Number} [expires]\r\n         * When this is set to a date/time, the model record will be marked\r\n         * as expired at the specified time/date. If a number is specified\r\n         * (milliseconds), the record will be marked as expired after the\r\n         * specified time period has elapsed. When a record/model is marked as\r\n         * \"expired\", it triggers the `expired` event. By default, expired\r\n         * records/models within an NGN.DATA.Store will be removed from the store.\r\n         *\r\n         * Setting this to any value less than `0` disables expiration.\r\n         * @fires expired\r\n         * Triggered when the model/record expires.\r\n         */\r\n        expiration: null,\r\n\r\n        // Holds a setTimeout method for expiration events.\r\n        expirationTimeout: null,\r\n\r\n        created: Date.now(),\r\n        store: null,\r\n\r\n        /**\r\n         * @cfg {boolean} [audit=false]\r\n         * Enable auditing to support #undo/#redo operations. This creates and\r\n         * manages a NGN.DATA.TransactionLog.\r\n         */\r\n        AUDITABLE: false,\r\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\r\n        AUDIT_HANDLER: function (change) {\r\n          if (change.hasOwnProperty('cursor')) {\r\n            me.METADATA.AUDITLOG.commit(me.METADATA.getAuditMap())\r\n          }\r\n        },\r\n\r\n        EVENTS: new Set([\r\n          'field.update',\r\n          'field.create',\r\n          'field.remove',\r\n          'field.invalid',\r\n          'field.valid',\r\n          'field.hidden',\r\n          'field.unhidden',\r\n          'field.rule.add',\r\n          'field.rule.remove',\r\n          'rule.add',\r\n          'rule.remove',\r\n          'relationship.create',\r\n          'relationship.remove',\r\n          'expired',\r\n          'deleted',\r\n          'reset',\r\n          'load'\r\n        ]),\r\n\r\n        /**\r\n         * An internal method used to apply field definitions to the model.\r\n         * @param  {string} fieldname\r\n         * Name of the field (as applied to the model).\r\n         * @param  {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\r\n         * The configuration to apply. See #addField for details.\r\n         * @param  {Boolean} [suppressEvents=false]\r\n         * Optionally suppress the `field.create` event.\r\n         * @private\r\n         */\r\n        applyField: (field, fieldcfg = null, suppressEvents = false) => {\r\n          // Prevent duplicate fields\r\n          if (this.METADATA.knownFieldNames.has(field)) {\r\n            return NGN.WARN(`Duplicate field \"${field}\" detected.`)\r\n          }\r\n\r\n          // Prevent reserved words\r\n          if (this.hasOwnProperty(field) && field.toLowerCase() !== 'id') {\r\n            throw new ReservedWordError(`\"${field}\" cannot be used as a field name (reserved word).`)\r\n          }\r\n\r\n          // If the field config isn't already an NGN.DATA.Field, create it.\r\n          if (!(fieldcfg instanceof NGN.DATA.Field)) {\r\n            if (fieldcfg instanceof NGN.DATA.Store || fieldcfg instanceof NGN.DATA.Model) {\r\n              if (this.METADATA.IdentificationField === field) {\r\n                throw new InvalidConfigurationError(`\"${field}\" cannot be an ID. Relationship fields cannot be an identification field/attribute.`)\r\n              }\r\n\r\n              this.METADATA.fields[field] = new NGN.DATA.Relationship({\r\n                name: field,\r\n                record: fieldcfg,\r\n                model: this\r\n              })\r\n            } else {\r\n              switch (NGN.typeof(fieldcfg)) {\r\n                // Custom config\r\n                case 'object':\r\n                  fieldcfg.model = this\r\n                  fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\r\n                  fieldcfg.name = field\r\n\r\n                  this.METADATA.fields[field] = new NGN.DATA.Field(fieldcfg)\r\n\r\n                  break\r\n\r\n                // Collection of models\r\n                case 'array':\r\n                  return this.METADATA.applyField(field, fieldcfg[0], suppressEvents)\r\n\r\n                // Type-based cfg.\r\n                default:\r\n                  if (NGN.isFn(fieldcfg) || fieldcfg === null) {\r\n                    if (NGN.isFn(fieldcfg) && ['string', 'number', 'boolean', 'number', 'symbol', 'regexp', 'date', 'array', 'object'].indexOf(NGN.typeof(fieldcfg)) < 0) {\r\n                      this.METADATA.fields[field] = new NGN.DATA.VirtualField({\r\n                        name: field,\r\n                        identifier: this.METADATA.IdentificationField === field,\r\n                        model: this,\r\n                        method: fieldcfg\r\n                      })\r\n\r\n                      break\r\n                    }\r\n\r\n                    this.METADATA.fields[field] = new NGN.DATA.Field({\r\n                      name: field,\r\n                      type: fieldcfg,\r\n                      identifier: this.METADATA.IdentificationField === field,\r\n                      model: this\r\n                    })\r\n\r\n                    break\r\n                  }\r\n\r\n                  this.METADATA.fields[field] = new NGN.DATA.Field({\r\n                    name: field,\r\n                    type: NGN.isFn(fieldcfg) ? fieldcfg : String,\r\n                    identifier: NGN.isFn(fieldcfg)\r\n                      ? false\r\n                      : NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field),\r\n                    model: this\r\n                  })\r\n\r\n                  break\r\n              }\r\n            }\r\n          } else if (fieldcfg.model === null) {\r\n            fieldcfg.name = field\r\n            fieldcfg.identifier = fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\r\n\r\n            this.METADATA.fields[field] = fieldcfg\r\n            this.METADATA.fields[field].model = this\r\n          } else if (fieldcfg.model === this) {\r\n            fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\r\n\r\n            this.METADATA.fields[field] = fieldcfg\r\n          } else if (!(fieldcfg instanceof NGN.DATA.Field)) {\r\n            return NGN.WARN(`The \"${fieldcfg.name}\" field cannot be applied because model is already specified.`)\r\n          }\r\n\r\n          // Add a direct reference to the model.\r\n          Object.defineProperty(this, field, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => this.get(field),\r\n            set: (value) => this.set(field, value)\r\n          })\r\n\r\n          // Enable auditing if necessary.\r\n          if (this.METADATA.AUDITABLE) {\r\n            if (this.METADATA.fields[field].fieldType !== 'virtual') {\r\n              this.METADATA.fields[field].auditable = true\r\n              this.METADATA.auditFieldNames.add(field)\r\n            }\r\n          }\r\n\r\n          // Add the field to the list\r\n          this.METADATA.knownFieldNames.add(field)\r\n\r\n          this.METADATA.fields[field].relay('*', this, 'field.')\r\n\r\n          if (!suppressEvents) {\r\n            this.emit('field.create', this.METADATA.fields[field])\r\n          }\r\n\r\n          return this.METADATA.fields[field]\r\n        },\r\n\r\n        /**\r\n         * An internal helper method for applying changes to the model.\r\n         * @param  {String} [type='undo']\r\n         * This can be `undo` or `redo`.\r\n         * @param  {Number} [count=1]\r\n         * The number of cursor indexes to shift\r\n         * @param  {Boolean} [suppressEvents=false]\r\n         * Indicates events should be suppressed.\r\n         * @private\r\n         */\r\n        applyChange: (type = 'undo', count = 1, suppressEvents = false) => {\r\n          if (!this.METADATA.AUDITABLE) {\r\n            NGN.WARN(`The ${type} operation failed on the ${this.name} model because auditing is disabled.`)\r\n            return\r\n          }\r\n\r\n          this.METADATA.AUDITLOG[type === 'undo' ? 'rollback' : 'advance'](count)\r\n\r\n          let data = this.METADATA.AUDITLOG.currentValue\r\n\r\n          if (data) {\r\n            this.METADATA.auditFieldNames.forEach(fieldname => {\r\n              let field = this.METADATA.fields[fieldname]\r\n              let log = field.METADATA.AUDITLOG\r\n\r\n              if (log.cursor !== data[fieldname]) {\r\n                if (typeof data[fieldname] === 'symbol') {\r\n                  log.cursor = data[fieldname]\r\n                } else {\r\n                  log.cursor = null\r\n                }\r\n\r\n                field.METADATA.setValue(NGN.coalesce(log.currentValue, field.default), suppressEvents, true)\r\n              }\r\n            })\r\n          }\r\n        },\r\n\r\n        /**\r\n         * Generates a key/value representation of the model where\r\n         * each key represents an auditable field and each value is the\r\n         * transaction cursor ID.\r\n         * @return {Object}\r\n         * @private\r\n         */\r\n        getAuditMap: () => {\r\n          let map = {}\r\n\r\n          this.METADATA.auditFieldNames.forEach(field => {\r\n            map[field] = this.METADATA.fields[field].METADATA.AUDITLOG.cursor\r\n          })\r\n\r\n          return map\r\n        },\r\n\r\n        /**\r\n         * Restore the model to a specific audit map (i.e. historical state\r\n         * of multiple fields).\r\n         * @param {Object} map\r\n         * The audit map to restore.\r\n         */\r\n        // restore: (map) => {\r\n        //   let keys = Object.keys(map)\r\n        //\r\n        //   for (let i = 0; i < keys.length; i++) {\r\n        //     if (this.METADATA.knownFieldNames.has(keys[i]) && typeof map[keys[i]] === 'symbol') {\r\n        //       console.log('Has', keys[i])\r\n        //\r\n        //     }\r\n        //   }\r\n        // },\r\n\r\n        // Deprecations\r\n        setSilent: NGN.deprecate(this.setSilentFieldValue, 'setSilent has been deprecated. Use setSilentFieldValue instead.'),\r\n\r\n        /**\r\n         * @cfgproperty {object} fieldmap\r\n         * An object mapping model attribute names to data storage field names.\r\n         *\r\n         * _Example_\r\n         * ```\r\n         * {\r\n         *   ModelFieldName: 'inputName',\r\n         *   father: 'dad',\r\n         *   email: 'eml',\r\n         *   image: 'img',\r\n         *   displayName: 'dn',\r\n         *   firstName: 'gn',\r\n         *   lastName: 'sn',\r\n         *   middleName: 'mn',\r\n         *   gender: 'sex',\r\n         *   dob: 'bd'\r\n         * }\r\n         * ```\r\n         */\r\n        DATAMAP: null\r\n      }),\r\n\r\n      MAP: NGN.get(() => {\r\n        return NGN.coalesce(\r\n          this.METADATA.DATAMAP,\r\n          this.METADATA.store instanceof NGN.DATA.Store\r\n            ? this.METADATA.store.map\r\n            : null\r\n        )\r\n      })\r\n    })\r\n\r\n    if (cfg.fieldmap instanceof NGN.DATA.FieldMap) {\r\n      this.METADATA.DATAMAP = cfg.fieldmap\r\n    } else if (NGN.typeof(cfg.fieldmap) === 'object') {\r\n      this.METADATA.DATAMAP = new NGN.DATA.FieldMap(cfg.fieldmap)\r\n    }\r\n\r\n    // Bubble events to the BUS\r\n    // this.relay('*', NGN.BUS, 'record.')\r\n\r\n    // Add data fields.\r\n    let fields = Object.keys(this.METADATA.fields)\r\n    for (let i = 0; i < fields.length; i++) {\r\n      let name = fields[i]\r\n\r\n      if (this.METADATA.knownFieldNames.has(name)) {\r\n        NGN.WARN(`Duplicate field \"${name}\" detected.`)\r\n      } else {\r\n        // Configure a data field for each configuration.\r\n        this.METADATA.applyField(name, this.METADATA.fields[name], true)\r\n      }\r\n    }\r\n\r\n    // Apply automatic ID's when applicable\r\n    if (this.METADATA.autoid) {\r\n      let autoIdValue = null\r\n\r\n      Object.defineProperty(this.METADATA, 'IdentificationValue', NGN.get(() => {\r\n        if (autoIdValue === null) {\r\n          autoIdValue = NGN.DATA.UTILITY.UUID()\r\n        }\r\n\r\n        return autoIdValue\r\n      }))\r\n    }\r\n\r\n    // Apply auditing if configured\r\n    this.auditable = NGN.coalesce(cfg.audit, false)\r\n\r\n    // Clear any cached checksums when the model changes.\r\n    this.on(['field.update', 'field.create', 'field.delete', 'field.hidden', 'field.unhidden'], () => {\r\n      if (this.METADATA.checksum) {\r\n        this.METADATA.checksum = null\r\n      }\r\n    })\r\n\r\n    // Configure TTL/Expiration\r\n    if (cfg.expires) {\r\n      this.expires = cfg.expires\r\n    }\r\n\r\n    // Configure model-level validation rules\r\n    if (this.METADATA.validators !== null) {\r\n      switch (NGN.typeof(this.METADATA.validators)) {\r\n        // Support key/value objects where the key is the name and value is a function.\r\n        case 'object':\r\n          let keys = Object.keys(this.METADATA.validators)\r\n          let rules = []\r\n\r\n          for (let i = 0; i < keys.length; i++) {\r\n            rules.push(new NGN.DATA.Rule(this.METADATA.validators[keys[i]], keys[i], this))\r\n          }\r\n\r\n          break\r\n\r\n        // Support an array of existing data rules.\r\n        case 'array':\r\n          for (let i = 0; i < this.METADATA.validators.length; i++) {\r\n            if (this.METADATA.validators[i].hasOwnProperty('RULE')) {\r\n              this.METADATA.validators[i].RULE.scope = this\r\n            } else {\r\n              throw new Error(`Invalid data rule configuration for ${this.name} model. Rule #${i} is not a valid NGN.DATA.Rule instance.`)\r\n            }\r\n          }\r\n\r\n          break\r\n\r\n        // Diasllow any other kinds of rules.\r\n        default:\r\n          throw new Error(`Invalid data rule configuration for ${this.name} model. Expected an object or array of NGN.DATA.Rule instances. Received \"${NGN.typeof(this.METADATA.validators)}\"`)\r\n      }\r\n    }\r\n  }\r\n\r\n  get name () {\r\n    return this.METADATA.name\r\n  }\r\n\r\n  set auditable (value) {\r\n    value = NGN.forceBoolean(value)\r\n\r\n    if (value !== this.METADATA.AUDITABLE) {\r\n      this.METADATA.AUDITABLE = value\r\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\r\n      this.METADATA.auditFieldNames = value ? new Set() : null\r\n\r\n      // Set each field to an auditable state (or not).\r\n      this.METADATA.knownFieldNames.forEach(fieldname => {\r\n        if (!this.METADATA.fields[fieldname].virtual) {\r\n          this.METADATA.fields[fieldname].auditable = value\r\n\r\n          if (value) {\r\n            this.METADATA.auditFieldNames.add(fieldname)\r\n          }\r\n        }\r\n      })\r\n\r\n      if (value) {\r\n        // Track Changes (if auditing enabled)\r\n        this.on('field.transaction.*', (id) => {\r\n          this.METADATA.AUDIT_HANDLER({ cursor: id })\r\n        })\r\n      } else {\r\n        this.METADATA.auditFieldNames.clear()\r\n\r\n        this.off('field.transaction.*')\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The unique ID assigned to the model.\r\n   * @return {string}\r\n   */\r\n  get id () {\r\n    return this.get(this.METADATA.IdentificationField)\r\n  }\r\n\r\n  set id (value) {\r\n    this.set('id', value)\r\n  }\r\n\r\n  /**\r\n   * @property ID\r\n   * An alias for #id.\r\n   */\r\n  get ID () {\r\n    return this.id\r\n  }\r\n\r\n  set ID (value) {\r\n    this.set('id', value)\r\n  }\r\n\r\n  /**\r\n   * @property {Array} changelog\r\n   * The changelog returns the underlying NGN.DATA.TransactionLog#log if\r\n   * auditing is available. The array will be empty if auditing is disabled.\r\n   */\r\n  get changelog () {\r\n    return this.METADATA.AUDITLOG.log.map(entry => {\r\n      let result = {\r\n        timestamp: entry.timestamp,\r\n        activeCursor: entry.activeCursor,\r\n        value: {}\r\n      }\r\n\r\n      let data = entry.value\r\n      let field = Object.keys(data)\r\n\r\n      for (let i = 0; i < field.length; i++) {\r\n        if (typeof data[field[i]] === 'symbol') {\r\n          result.value[field[i]] = NGN.coalesce(\r\n            this.METADATA.fields[field[i]].METADATA.AUDITLOG.getCommit(data[field[i]]).value,\r\n            this.METADATA.fields[field[i]].default\r\n          )\r\n        } else {\r\n          result.value[field[i]] = NGN.coalesce(this.METADATA.fields[field[i]].default)\r\n        }\r\n      }\r\n\r\n      return result\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @property {Number} createDate\r\n   * The date/time when the model is created.\r\n   */\r\n  get createDate () {\r\n    return this.METADATA.created\r\n  }\r\n\r\n  /**\r\n   * @property {object} data\r\n   * A serialized version of the data represented by the model. This\r\n   * only includes non-virtual fields. See #representation to use\r\n   * a representation of data containing virtual fields.\r\n   */\r\n  get data () {\r\n    if (this.MAP) {\r\n      return this.MAP.applyInverseMap(this.serializeFields())\r\n    }\r\n\r\n    return this.serializeFields()\r\n  }\r\n\r\n  /**\r\n   * @property {object} unmappedData\r\n   * Returns #data _without applying_ the data #map.\r\n   */\r\n  get unmappedData () {\r\n    return this.serializeFields()\r\n  }\r\n\r\n  /**\r\n   * @property {object} representation\r\n   * A serialized version of the data represented by the model. This\r\n   * includes virtual fields. See #data to use just the raw values.\r\n   */\r\n  get representation () {\r\n    if (this.MAP) {\r\n      return this.MAP.applyInverseMap(this.serializeFields(false, false))\r\n    }\r\n\r\n    return this.serializeFields(false, false)\r\n  }\r\n\r\n  /**\r\n   * @property {object} unmappedRepresentation\r\n   * Returns #representation _without applying_ the data #map.\r\n   */\r\n  get unmappedRepresentation () {\r\n    return this.serializeFields(false, false)\r\n  }\r\n\r\n  /**\r\n   * @property {string} checksum\r\n   * The checksum is a unique \"fingerprint\" of the data stored in the model.\r\n   * Please note that generating a checksum for an individual record is\r\n   * usually a quick operation, but generating large quantities of checksums\r\n   * simultaneously/sequentially can be computationally expensive. On average,\r\n   * a checksum takes 3-125ms to generate.\r\n   */\r\n  get checksum () {\r\n    this.METADATA.checksum = NGN.coalesce(this.METADATA.checksum, NGN.DATA.UTILITY.checksum(JSON.stringify(this.data)))\r\n\r\n    return this.METADATA.checksum\r\n  }\r\n\r\n  /**\r\n   * @property {Date} expires\r\n   * The date/time when the record expires. This may be set to\r\n   * a future date, or a numeric value. Numeric values\r\n   * represent the number of milliseconds from the current time\r\n   * before the record expires. For example, set this to `3000`\r\n   * to force the record to expire 3 seconds from now.\r\n   *\r\n   * Set this to `0` to immediately expire the record. Set this to\r\n   * `-1` or `null` to prevent the record from expiring.\r\n   */\r\n  get expires () {\r\n    return this.METADATA.expiration\r\n  }\r\n\r\n  set expires (value) {\r\n    if (value === null) {\r\n      clearTimeout(this.METADATA.expirationTimeout)\r\n      this.METADATA.expiration = null\r\n      return\r\n    }\r\n\r\n    let now = new Date()\r\n\r\n    if (!isNaN(value) && !(value instanceof Date)) {\r\n      // Handle numeric (millisecond) expiration\r\n      if (value < 0) {\r\n        this.METADATA.expiration = null\r\n\r\n        return\r\n      }\r\n\r\n      if (value === 0) {\r\n        this.METADATA.expiration = now\r\n        this.emit('expire')\r\n\r\n        return\r\n      }\r\n\r\n      this.METADATA.expiration = new Date()\r\n      this.METADATA.expiration.setTime(now.getTime() + value)\r\n    } else if (!(value instanceof Date) || value <= now) {\r\n      throw new Error(`${this.name} expiration (TTL) value must be a positive number (milliseconds) or future date.`)\r\n    } else {\r\n      // Handle date-based expiration\r\n      this.METADATA.expiration = value\r\n    }\r\n\r\n    clearTimeout(this.METADATA.expirationTimeout)\r\n\r\n    this.METADATA.expirationTimeout = setTimeout(() => this.emit('expire'), this.METADATA.expiration.getTime() - now.getTime())\r\n  }\r\n\r\n  get expired () {\r\n    if (this.METADATA.expiration === null) {\r\n      return false\r\n    }\r\n\r\n    return this.METADATA.expiration <= (new Date())\r\n  }\r\n\r\n  get fieldDefinitions () {\r\n    return this.METADATA.fields\r\n    // if (this.METADATA.knownFieldNames.size === 0) {\r\n    //   return {}\r\n    // }\r\n    //\r\n    // let fields = this.METADATA.knownFieldNames.keys()\r\n    // let result = {}\r\n    // let fieldname = fields.next()\r\n    //\r\n    // while (!fieldname.done) {\r\n    //   let field = this.METADATA.fields[fieldname.value]\r\n    //\r\n    //   if ((\r\n    //     field.value === undefined ||\r\n    //     (ignoreID && fieldname.value === this.IdentificationField) ||\r\n    //     (!field.virtual || (!ignoreVirtualFields && field.virtual))\r\n    //   )) {\r\n    //     // Do not serialize hidden values or virtuals\r\n    //     if (!field.hidden) {\r\n    //       switch (NGN.typeof(field.value)) {\r\n    //         case 'array':\r\n    //         case 'object':\r\n    //           result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\r\n    //           break\r\n    //\r\n    //         default:\r\n    //           result[fieldname.value] = field.value\r\n    //       }\r\n    //     }\r\n    //   }\r\n    // }\r\n  }\r\n\r\n  serializeFields (ignoreID = false, ignoreVirtualFields = true) {\r\n    if (this.METADATA.knownFieldNames.size === 0) {\r\n      return {}\r\n    }\r\n\r\n    let fields = this.METADATA.knownFieldNames.keys()\r\n    let result = {}\r\n    let fieldname = fields.next()\r\n\r\n    while (!fieldname.done) {\r\n      let field = this.METADATA.fields[fieldname.value]\r\n\r\n      // Ignore unserializable fields\r\n      if ((\r\n        field.value === undefined ||\r\n        (ignoreID && fieldname.value === this.IdentificationField) ||\r\n        (!field.virtual || (!ignoreVirtualFields && field.virtual))\r\n      )) {\r\n        // Do not serialize hidden values or virtuals\r\n        if (!field.hidden) {\r\n          switch (NGN.typeof(field.value)) {\r\n            case 'array':\r\n            case 'object':\r\n              result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\r\n              break\r\n\r\n            default:\r\n              result[fieldname.value] = field.value\r\n          }\r\n        }\r\n      }\r\n\r\n      fieldname = fields.next()\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  serialize () {\r\n    return NGN.deprecate(this.serializeFields, 'serialize is now serializeFields. Use NGN.DATA.UTILITY.serialize for generic object serialization.')\r\n  }\r\n\r\n  /**\r\n   * Determines whether a field exists in the model or not.\r\n   * @param  {string} field\r\n   * Name of the field to check for.\r\n   * @return {boolean}\r\n   */\r\n  fieldExists (field) {\r\n    return this.METADATA.knownFieldNames.has(field)\r\n  }\r\n\r\n  /**\r\n   * Retrieve the value of the specified field.\r\n   * @param  {string} field\r\n   * Name of the field whose value should be returned.\r\n   * @return {any}\r\n   * Returns the value of the field.\r\n   */\r\n  get (field) {\r\n    if (field === 'id' || field === 'ID' || field === this.METADATA.IdentificationField) {\r\n      field = this.METADATA.IdentificationField\r\n\r\n      if (this.METADATA.autoid) {\r\n        if (!this.METADATA.knownFieldNames.has(field)) {\r\n          return this.METADATA.IdentificationValue\r\n        } else {\r\n          return NGN.coalesce(this.METADATA.fields[field].value, this.METADATA.IdentificationValue)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.METADATA.knownFieldNames.has(field)) {\r\n      return this.METADATA.fields[field].value\r\n    } else {\r\n      NGN.WARN(`Cannot get \"${field}\". The field is not part of the model.`)\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set a new value for the specified field.\r\n   * @param {string} field\r\n   * Name of the field whose value will be changed.\r\n   * @param {any} value\r\n   * The new value of the field.\r\n   */\r\n  set (field, value) {\r\n    if (field === 'id' || field === 'ID') {\r\n      field = this.METADATA.IdentificationField\r\n    }\r\n\r\n    if (this.METADATA.knownFieldNames.has(field)) {\r\n      this.METADATA.fields[field].value = value\r\n    } else {\r\n      NGN.WARN(`Cannot set \"${field}\". Unrecognized field name.`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a data field after the initial model definition.\r\n   * @param {string} fieldname\r\n   * The name of the field.\r\n   * @param {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\r\n   * The field configuration (see cfg#fields for syntax).\r\n   * @param {boolean} [suppressEvents=false]\r\n   * Set to `true` to prevent events from firing when the field is added.\r\n   */\r\n  addField (name, fieldConfiguration = null, suppressEvents = false) {\r\n    if (name instanceof NGN.DATA.Field) {\r\n      fieldConfiguration = name\r\n      name = fieldConfiguration.name\r\n    } else if (typeof name !== 'string') {\r\n      throw new Error('Cannot add a non-string based field.')\r\n    }\r\n\r\n    this.METADATA.applyField(name, fieldConfiguration, suppressEvents)\r\n  }\r\n\r\n  /**\r\n   * @method removeField\r\n   * Remove a field from the data model.\r\n   * @param {string} name\r\n   * Name of the field to remove.\r\n   * @param {boolean} [suppressEvents=false]\r\n   * Set to `true` to prevent events from firing when the field is removed.\r\n   */\r\n  removeField (name, suppressEvents = false) {\r\n    if (this.METADATA.knownFieldNames.has(name)) {\r\n      this.METADATA.knownFieldNames.delete(name)\r\n      this.METADATA.invalidFieldNames.delete(name)\r\n\r\n      const field = this.METADATA.fields[name]\r\n\r\n      delete this[name]\r\n      delete this.METADATA.fields[name] // eslint-disable-line no-undef\r\n\r\n      // let change = {\r\n      //   action: 'delete',\r\n      //   field: field.name,\r\n      //   value: field,\r\n      //   join: field instanceof NGN.DATA.Relationship\r\n      // }\r\n\r\n      if (!suppressEvents) {\r\n        this.emit('field.remove', field)\r\n      }\r\n\r\n      if (this.METADATA.store !== null) {\r\n        this.METADATA.store.emit(this.METADATA.store.PRIVATE.EVENT.DELETE_RECORD_FIELD, {\r\n          record: this,\r\n          field\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the NGN.DATA.Field object for the specified field.\r\n   * @param  {string} fieldName\r\n   * Name of the field to retrieve.\r\n   * @return {NGN.DATA.Field}\r\n   * The raw field.\r\n   */\r\n  getField (name) {\r\n    if (name.toLowerCase() === 'id' && !this.METADATA.fields.hasOwnProperty(name) && this.METADATA.fields.hasOwnProperty(this.METADATA.IdentificationField)) {\r\n      return this.METADATA.fields[this.METADATA.IdentificationField]\r\n    }\r\n\r\n    return this.METADATA.fields[name]\r\n  }\r\n\r\n  /**\r\n   * @method setSilent\r\n   * A method to set a field value without triggering an update event.\r\n   * This is designed primarily for use with live update proxies to prevent\r\n   * endless event loops.\r\n   * @param {string} fieldname\r\n   * The name of the #field to update.\r\n   * @param {any} value\r\n   * The new value of the field.\r\n   * @private\r\n   */\r\n  setSilentFieldValue (field, value) {\r\n    this.METADATA.fields[field].silentValue = value\r\n  }\r\n\r\n  /**\r\n   * @method undo\r\n   * A rollback function to undo changes. This operation affects\r\n   * the changelog (transaction log). To \"undo\" an \"undo\", use #redo.\r\n   * @param {number} [OperationCount=1]\r\n   * The number of operations to \"undo\". Defaults to a single operation.\r\n   * @param {boolean} [suppressEvents=false]\r\n   * Set to `true` to quietly update the value (prevents `update` event from\r\n   * firing).\r\n   */\r\n  undo (count = 1, suppressEvents = false) {\r\n    this.METADATA.applyChange('undo', ...arguments)\r\n  }\r\n\r\n  /**\r\n   * @method redo\r\n   * A function to reapply known changes. This operation affects\r\n   * the changelog (transaction log).\r\n   *\r\n   * The redo operation only works after an undo operation, but before a new\r\n   * value is committed to the transaction log. In other words, `undo -> redo`\r\n   * will work, but `undo -> update -> redo` will not. For details, see how\r\n   * the NGN.DATA.TransactionLog cursor system works.\r\n   * @param {number} [OperationCount=1]\r\n   * The number of operations to \"undo\". Defaults to a single operation.\r\n   * @param {boolean} [suppressEvents=false]\r\n   * Set to `true` to quietly update the value (prevents `update` event from\r\n   * firing).\r\n   */\r\n  redo (count = 1, suppressEvents = false) {\r\n    this.METADATA.applyChange('redo', ...arguments)\r\n  }\r\n\r\n  /**\r\n   * @method load\r\n   * Load a data record.\r\n   * @param {object} data\r\n   * The data to apply to the model.\r\n   * @param {boolean} [suppressEvents=false]\r\n   * Do not emit a change event when the data is loaded.\r\n   */\r\n  load (data, suppressEvents = false) {\r\n    if (this.MAP) {\r\n      data = this.MAP.applyMap(data)\r\n    }\r\n\r\n    let keys = Object.keys(data)\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n      if (this.METADATA.knownFieldNames.has(keys[i])) {\r\n        this.METADATA.fields[keys[i]].METADATA.setValue(data[keys[i]], suppressEvents)\r\n      } else {\r\n        NGN.WARN(`Failed to load ${keys[i]} field of ${this.name} model. \"${keys[i]}\" is not a recognized field.`)\r\n      }\r\n    }\r\n\r\n    if (!suppressEvents) {\r\n      this.emit('load')\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * @info This method only works on records within a store. If this method is\r\n   * called on a model that is not part of a store, the model itself will be\r\n   * returned.\r\n   *\r\n   * Retrieve the next record (after this one) from the store.\r\n   * This can be used to iterate through a store by calling `model.next()`.\r\n   * This is operation acts as a linked list iterator.\r\n   * @param  {Number}  [count=1]\r\n   * The number of records to retrieve. For example, `1` retrieves the next record.\r\n   * `2` retrieves the second record after this one. A negative number will\r\n   * automatically use the #previous method to retrieve prior records. Setting this\r\n   * to `0` will return the current record (i.e. no change).\r\n   * @param  {Boolean}  [cycle=false] [description]\r\n   * If this `next` is called on the last record, it will fail. Setting `cycle` to\r\n   * `true` will automatically restart the iteration, returning the first record in\r\n   * the store.\r\n   * @return {NGN.DATA.Model}\r\n   * Returns the next model in the store (after this one.)\r\n   */\r\n  next (count = 1, cycle = false) {\r\n    if (count === 0) {\r\n      return this\r\n    }\r\n\r\n    if (this.METADATA.store) {\r\n      if (typeof count === 'boolean') {\r\n        cycle = count\r\n        count = 1\r\n      }\r\n\r\n      return this.METADATA.store.getRecordSibling(this, count, cycle)\r\n    } else {\r\n      NGN.WARN('Attempted to call next() on a model that does not belong to a store.')\r\n      return this\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve the previous record (before this one) from the store.\r\n   * This can be used to iterate through a store in reverse by calling\r\n   * `model.previous()`. This is operation acts as a doubly linked list iterator.\r\n   *\r\n   * @info This method only works on records within a store. If this method is\r\n   * called on a model that is not part of a store, the model itself will be\r\n   * returned.\r\n   * @param  {Number}  [count=1]\r\n   * The number of records to retrieve. For example, `1` retrieves the prior record.\r\n   * `2` retrieves the second record before this one. A negative number will\r\n   * automatically use the #next method to retrieve forward records. Setting this\r\n   * to `0` will return the current record (i.e. no change).\r\n   * @param  {Boolean}  [cycle=false]\r\n   * If this `next` is called on the first record, it will fail. Setting `cycle` to\r\n   * `true` will automatically restart the iteration, returning the last record in\r\n   * the store.\r\n   * @return {NGN.DATA.Model}\r\n   * Returns the previous model in the store (before this one.)\r\n   */\r\n  previous (count = 1, cycle = false) {\r\n    if (count === 0) {\r\n      return this\r\n    }\r\n\r\n    if (this.METADATA.store) {\r\n      if (typeof count === 'boolean') {\r\n        cycle = count\r\n        count = 1\r\n      }\r\n\r\n      return this.METADATA.store.getRecordSibling(this, 0 - count, cycle)\r\n    } else {\r\n      NGN.WARN('Attempted to call previous() on a model that does not belong to a store.')\r\n      return this\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove this model from the NGN.DATA.Store it is a part of.\r\n   *\r\n   * @info This method only works on records within a store. If this method is\r\n   * called on a model that is not part of a store, nothing will happen.\r\n   */\r\n  destroy () {\r\n    if (this.METADATA.store) {\r\n      this.METADATA.store.remove(this.OID)\r\n    } else {\r\n      NGN.WARN('Attempted to call remove() on a model that does not belong to a store.')\r\n    }\r\n  }\r\n}",
  "tags": {},
  "exceptions": {},
  "events": {
    "field.update": {
      "type": "event",
      "label": "field.update",
      "description": "Fired when a datafield value is changed.",
      "code": "@fires field.update\nFired when a datafield value is changed.",
      "start": {
        "line": 0,
        "column": 0
      },
      "end": {
        "line": 0,
        "column": 0
      },
      "flags": [],
      "authors": [],
      "parameters": {
        "payload": {
          "type": "argument",
          "label": "payload",
          "description": null,
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "authors": [],
          "datatype": "",
          "required": false,
          "enum": null
        }
      },
      "deprecated": false,
      "deprecationReplacement": null
    },
    "field.create": {
      "type": "event",
      "label": "field.create",
      "description": null,
      "code": "this.emit('field.create', this.METADATA.fields[field])",
      "start": {
        "line": 326,
        "column": 12
      },
      "end": {
        "line": 326,
        "column": 66
      },
      "flags": [],
      "authors": [],
      "parameters": {
        "undefined.METADATA.fields.field": {
          "type": "argument",
          "label": "undefined.METADATA.fields.field",
          "description": null,
          "code": "this.METADATA.fields[field]",
          "start": {
            "line": 326,
            "column": 38
          },
          "end": {
            "line": 326,
            "column": 65
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        }
      },
      "deprecated": false,
      "deprecationReplacement": null
    },
    "field.remove": {
      "type": "event",
      "label": "field.remove",
      "description": null,
      "code": "this.emit('field.remove', field)",
      "start": {
        "line": 919,
        "column": 8
      },
      "end": {
        "line": 919,
        "column": 40
      },
      "flags": [],
      "authors": [],
      "parameters": {
        "field": {
          "type": "argument",
          "label": "field",
          "description": null,
          "code": "field",
          "start": {
            "line": 919,
            "column": 34
          },
          "end": {
            "line": 919,
            "column": 39
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        }
      },
      "deprecated": false,
      "deprecationReplacement": null
    },
    "field.invalid": {
      "type": "event",
      "label": "field.invalid",
      "description": "Fired when an invalid value is detected in an data field.",
      "code": "@fires field.invalid\nFired when an invalid value is detected in an data field.",
      "start": {
        "line": 0,
        "column": 0
      },
      "end": {
        "line": 0,
        "column": 0
      },
      "flags": [],
      "authors": [],
      "parameters": {
        "payload": {
          "type": "argument",
          "label": "payload",
          "description": null,
          "code": null,
          "start": {
            "line": 0,
            "column": 0
          },
          "end": {
            "line": 0,
            "column": 0
          },
          "flags": [],
          "authors": [],
          "datatype": "",
          "required": false,
          "enum": null
        }
      },
      "deprecated": false,
      "deprecationReplacement": null
    },
    "load": {
      "type": "event",
      "label": "load",
      "description": null,
      "code": "this.emit('load')",
      "start": {
        "line": 1018,
        "column": 6
      },
      "end": {
        "line": 1018,
        "column": 23
      },
      "flags": [],
      "authors": [],
      "parameters": {},
      "deprecated": false,
      "deprecationReplacement": null
    }
  },
  "start": {
    "line": 16,
    "column": 15
  },
  "end": {
    "line": 1113,
    "column": 1
  },
  "flags": [],
  "authors": [],
  "sourcefile": "data/Model.js",
  "extends": "NGN.EventEmitter",
  "configuration": {},
  "properties": {
    "OID": {
      "type": "property",
      "label": "OID",
      "description": "A unique object ID assigned to the model. This is an\ninternal readon-only reference.",
      "code": "OID: NGN.private(Symbol('model.id'))",
      "start": {
        "line": 42,
        "column": 6
      },
      "end": {
        "line": 42,
        "column": 42
      },
      "flags": [],
      "authors": [],
      "default": null,
      "datatype": "symbol",
      "readable": true,
      "writable": true,
      "configuration": false,
      "private": true
    },
    "METADATA": {
      "type": "property",
      "label": "METADATA",
      "description": null,
      "code": "METADATA: NGN.privateconst({\r\n        /**\r\n         * @cfg {string} [name]\r\n         * A descriptive name for the model. This is typically used for\r\n         * debugging, logging, schema defintions, and (sometimes) data proxies.\r\n         */\r\n        name: NGN.coalesce(cfg.name, 'Untitled Model'),\r\n\r\n        /**\r\n         * @cfg {string} [description]\r\n         * A description of the model. This is typically used for\r\n         * debugging, logging, schema definitions, and (sometimes) data proxies.\r\n         */\r\n        description: NGN.coalesce(cfg.description, cfg.name, 'Generic Data Model'),\r\n\r\n        /**\r\n         * @cfg {object} fields\r\n         * A private object containing the data fields of the model.\r\n         * Each key contains the field name, while each value can be one of\r\n         * the following:\r\n         *\r\n         * - Primitive (String, Number, RegExp, Boolean)\r\n         * - Standard Type (Array, Object, Date)\r\n         * - Custom Class\r\n         * - NGN.DATA.Field\r\n         * - An NGN.DATA.Field configuration\r\n         * - `null` (Defaults to String primitive)\r\n         *\r\n         * ```js\r\n         * fields: {\r\n         *   a: String,\r\n         *   b: Date,\r\n         *   c: MyCustomClass,\r\n         *   d: new NGN.DATA.Field({\r\n         *     required: true,\r\n         *     type: String,\r\n         *     default: 'some default value'\r\n         *   }),\r\n         *   e: {\r\n         *     required: true,\r\n         *     type: String,\r\n         *     default: 'some default value'\r\n         *   },\r\n         *   f: null // Uses default field config (String)\r\n         * }\r\n         * ```\r\n         *\r\n         * Extensions of the NGN.DATA.Field are also supported,\r\n         * such as NGN.DATA.VirtualField and NGN.DATA.Relationship.\r\n         */\r\n        fields: Object.assign({}, NGN.coalesce(cfg.fields, {})),\r\n        knownFieldNames: new Set(),\r\n        invalidFieldNames: new Set(),\r\n        auditFieldNames: NGN.coalesce(cfg.audit, false) ? new Set() : null,\r\n\r\n        /**\r\n         * @property {[NGN.DATA.Rule]|Object}\r\n         * Custom validation rules used to verify the integrity of the entire\r\n         * model. This only applies to the full model. Individual data fields\r\n         * may have their own validators.\r\n         *\r\n         * If an object is specified, it should contain simple key/value pairs,\r\n         * where the key is the descriptive name of the rule and the value is\r\n         * a synchronous callback function that returns a `true`/`false` value.\r\n         * For instance, assume the fields called `price`, `items`, and `tax` exist\r\n         * in the example model below. :\r\n         *\r\n         * ```js\r\n         * {\r\n         *   'Positive Sale': function () {\r\n         *      return (this.price * this.items) > 0\r\n         *   },\r\n         *   'Taxes Applied': function () {\r\n         *      return this.tax > 0\r\n         *   }\r\n         * }\r\n         * ```\r\n         *\r\n         * Alternatively, an array of NGN.DATA.Rule instances may be provided.\r\n         */\r\n        validators: NGN.coalesce(cfg.rules, cfg.rule, cfg.validators),\r\n\r\n        /**\r\n         * @cfgproperty {boolean} [validation=true]\r\n         * Toggle data validation using this.\r\n         */\r\n        validation: NGN.coalesce(cfg.validation, true),\r\n\r\n        /**\r\n         * @cfg {boolean} [autoid=false]\r\n         * If the NGN.DATA.Model#IdentificationField/id is not provided for a record,\r\n         * a unique ID will be automatically generated for it.\r\n         *\r\n         * An NGN.DATA.Store using a model with this set to `true` will never\r\n         * have a duplicate record, since the #id or #IdentificationField will always\r\n         * be unique.\r\n         */\r\n        autoid: NGN.coalesce(cfg.autoid, false),\r\n\r\n        /**\r\n         * @cfg {String} [IdentificationField='id']\r\n         * Setting this allows an attribute of the object to be used as the ID.\r\n         * For example, if an email is the ID of a user, this would be set to\r\n         * `email`.\r\n         */\r\n        IdentificationField: NGN.coalesce(cfg.IdentificationField, cfg.idField, 'id'),\r\n\r\n        /**\r\n         * @cfgproperty {Date|Number} [expires]\r\n         * When this is set to a date/time, the model record will be marked\r\n         * as expired at the specified time/date. If a number is specified\r\n         * (milliseconds), the record will be marked as expired after the\r\n         * specified time period has elapsed. When a record/model is marked as\r\n         * \"expired\", it triggers the `expired` event. By default, expired\r\n         * records/models within an NGN.DATA.Store will be removed from the store.\r\n         *\r\n         * Setting this to any value less than `0` disables expiration.\r\n         * @fires expired\r\n         * Triggered when the model/record expires.\r\n         */\r\n        expiration: null,\r\n\r\n        // Holds a setTimeout method for expiration events.\r\n        expirationTimeout: null,\r\n\r\n        created: Date.now(),\r\n        store: null,\r\n\r\n        /**\r\n         * @cfg {boolean} [audit=false]\r\n         * Enable auditing to support #undo/#redo operations. This creates and\r\n         * manages a NGN.DATA.TransactionLog.\r\n         */\r\n        AUDITABLE: false,\r\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\r\n        AUDIT_HANDLER: function (change) {\r\n          if (change.hasOwnProperty('cursor')) {\r\n            me.METADATA.AUDITLOG.commit(me.METADATA.getAuditMap())\r\n          }\r\n        },\r\n\r\n        EVENTS: new Set([\r\n          'field.update',\r\n          'field.create',\r\n          'field.remove',\r\n          'field.invalid',\r\n          'field.valid',\r\n          'field.hidden',\r\n          'field.unhidden',\r\n          'field.rule.add',\r\n          'field.rule.remove',\r\n          'rule.add',\r\n          'rule.remove',\r\n          'relationship.create',\r\n          'relationship.remove',\r\n          'expired',\r\n          'deleted',\r\n          'reset',\r\n          'load'\r\n        ]),\r\n\r\n        /**\r\n         * An internal method used to apply field definitions to the model.\r\n         * @param  {string} fieldname\r\n         * Name of the field (as applied to the model).\r\n         * @param  {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\r\n         * The configuration to apply. See #addField for details.\r\n         * @param  {Boolean} [suppressEvents=false]\r\n         * Optionally suppress the `field.create` event.\r\n         * @private\r\n         */\r\n        applyField: (field, fieldcfg = null, suppressEvents = false) => {\r\n          // Prevent duplicate fields\r\n          if (this.METADATA.knownFieldNames.has(field)) {\r\n            return NGN.WARN(`Duplicate field \"${field}\" detected.`)\r\n          }\r\n\r\n          // Prevent reserved words\r\n          if (this.hasOwnProperty(field) && field.toLowerCase() !== 'id') {\r\n            throw new ReservedWordError(`\"${field}\" cannot be used as a field name (reserved word).`)\r\n          }\r\n\r\n          // If the field config isn't already an NGN.DATA.Field, create it.\r\n          if (!(fieldcfg instanceof NGN.DATA.Field)) {\r\n            if (fieldcfg instanceof NGN.DATA.Store || fieldcfg instanceof NGN.DATA.Model) {\r\n              if (this.METADATA.IdentificationField === field) {\r\n                throw new InvalidConfigurationError(`\"${field}\" cannot be an ID. Relationship fields cannot be an identification field/attribute.`)\r\n              }\r\n\r\n              this.METADATA.fields[field] = new NGN.DATA.Relationship({\r\n                name: field,\r\n                record: fieldcfg,\r\n                model: this\r\n              })\r\n            } else {\r\n              switch (NGN.typeof(fieldcfg)) {\r\n                // Custom config\r\n                case 'object':\r\n                  fieldcfg.model = this\r\n                  fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\r\n                  fieldcfg.name = field\r\n\r\n                  this.METADATA.fields[field] = new NGN.DATA.Field(fieldcfg)\r\n\r\n                  break\r\n\r\n                // Collection of models\r\n                case 'array':\r\n                  return this.METADATA.applyField(field, fieldcfg[0], suppressEvents)\r\n\r\n                // Type-based cfg.\r\n                default:\r\n                  if (NGN.isFn(fieldcfg) || fieldcfg === null) {\r\n                    if (NGN.isFn(fieldcfg) && ['string', 'number', 'boolean', 'number', 'symbol', 'regexp', 'date', 'array', 'object'].indexOf(NGN.typeof(fieldcfg)) < 0) {\r\n                      this.METADATA.fields[field] = new NGN.DATA.VirtualField({\r\n                        name: field,\r\n                        identifier: this.METADATA.IdentificationField === field,\r\n                        model: this,\r\n                        method: fieldcfg\r\n                      })\r\n\r\n                      break\r\n                    }\r\n\r\n                    this.METADATA.fields[field] = new NGN.DATA.Field({\r\n                      name: field,\r\n                      type: fieldcfg,\r\n                      identifier: this.METADATA.IdentificationField === field,\r\n                      model: this\r\n                    })\r\n\r\n                    break\r\n                  }\r\n\r\n                  this.METADATA.fields[field] = new NGN.DATA.Field({\r\n                    name: field,\r\n                    type: NGN.isFn(fieldcfg) ? fieldcfg : String,\r\n                    identifier: NGN.isFn(fieldcfg)\r\n                      ? false\r\n                      : NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field),\r\n                    model: this\r\n                  })\r\n\r\n                  break\r\n              }\r\n            }\r\n          } else if (fieldcfg.model === null) {\r\n            fieldcfg.name = field\r\n            fieldcfg.identifier = fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\r\n\r\n            this.METADATA.fields[field] = fieldcfg\r\n            this.METADATA.fields[field].model = this\r\n          } else if (fieldcfg.model === this) {\r\n            fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\r\n\r\n            this.METADATA.fields[field] = fieldcfg\r\n          } else if (!(fieldcfg instanceof NGN.DATA.Field)) {\r\n            return NGN.WARN(`The \"${fieldcfg.name}\" field cannot be applied because model is already specified.`)\r\n          }\r\n\r\n          // Add a direct reference to the model.\r\n          Object.defineProperty(this, field, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => this.get(field),\r\n            set: (value) => this.set(field, value)\r\n          })\r\n\r\n          // Enable auditing if necessary.\r\n          if (this.METADATA.AUDITABLE) {\r\n            if (this.METADATA.fields[field].fieldType !== 'virtual') {\r\n              this.METADATA.fields[field].auditable = true\r\n              this.METADATA.auditFieldNames.add(field)\r\n            }\r\n          }\r\n\r\n          // Add the field to the list\r\n          this.METADATA.knownFieldNames.add(field)\r\n\r\n          this.METADATA.fields[field].relay('*', this, 'field.')\r\n\r\n          if (!suppressEvents) {\r\n            this.emit('field.create', this.METADATA.fields[field])\r\n          }\r\n\r\n          return this.METADATA.fields[field]\r\n        },\r\n\r\n        /**\r\n         * An internal helper method for applying changes to the model.\r\n         * @param  {String} [type='undo']\r\n         * This can be `undo` or `redo`.\r\n         * @param  {Number} [count=1]\r\n         * The number of cursor indexes to shift\r\n         * @param  {Boolean} [suppressEvents=false]\r\n         * Indicates events should be suppressed.\r\n         * @private\r\n         */\r\n        applyChange: (type = 'undo', count = 1, suppressEvents = false) => {\r\n          if (!this.METADATA.AUDITABLE) {\r\n            NGN.WARN(`The ${type} operation failed on the ${this.name} model because auditing is disabled.`)\r\n            return\r\n          }\r\n\r\n          this.METADATA.AUDITLOG[type === 'undo' ? 'rollback' : 'advance'](count)\r\n\r\n          let data = this.METADATA.AUDITLOG.currentValue\r\n\r\n          if (data) {\r\n            this.METADATA.auditFieldNames.forEach(fieldname => {\r\n              let field = this.METADATA.fields[fieldname]\r\n              let log = field.METADATA.AUDITLOG\r\n\r\n              if (log.cursor !== data[fieldname]) {\r\n                if (typeof data[fieldname] === 'symbol') {\r\n                  log.cursor = data[fieldname]\r\n                } else {\r\n                  log.cursor = null\r\n                }\r\n\r\n                field.METADATA.setValue(NGN.coalesce(log.currentValue, field.default), suppressEvents, true)\r\n              }\r\n            })\r\n          }\r\n        },\r\n\r\n        /**\r\n         * Generates a key/value representation of the model where\r\n         * each key represents an auditable field and each value is the\r\n         * transaction cursor ID.\r\n         * @return {Object}\r\n         * @private\r\n         */\r\n        getAuditMap: () => {\r\n          let map = {}\r\n\r\n          this.METADATA.auditFieldNames.forEach(field => {\r\n            map[field] = this.METADATA.fields[field].METADATA.AUDITLOG.cursor\r\n          })\r\n\r\n          return map\r\n        },\r\n\r\n        /**\r\n         * Restore the model to a specific audit map (i.e. historical state\r\n         * of multiple fields).\r\n         * @param {Object} map\r\n         * The audit map to restore.\r\n         */\r\n        // restore: (map) => {\r\n        //   let keys = Object.keys(map)\r\n        //\r\n        //   for (let i = 0; i < keys.length; i++) {\r\n        //     if (this.METADATA.knownFieldNames.has(keys[i]) && typeof map[keys[i]] === 'symbol') {\r\n        //       console.log('Has', keys[i])\r\n        //\r\n        //     }\r\n        //   }\r\n        // },\r\n\r\n        // Deprecations\r\n        setSilent: NGN.deprecate(this.setSilentFieldValue, 'setSilent has been deprecated. Use setSilentFieldValue instead.'),\r\n\r\n        /**\r\n         * @cfgproperty {object} fieldmap\r\n         * An object mapping model attribute names to data storage field names.\r\n         *\r\n         * _Example_\r\n         * ```\r\n         * {\r\n         *   ModelFieldName: 'inputName',\r\n         *   father: 'dad',\r\n         *   email: 'eml',\r\n         *   image: 'img',\r\n         *   displayName: 'dn',\r\n         *   firstName: 'gn',\r\n         *   lastName: 'sn',\r\n         *   middleName: 'mn',\r\n         *   gender: 'sex',\r\n         *   dob: 'bd'\r\n         * }\r\n         * ```\r\n         */\r\n        DATAMAP: null\r\n      })",
      "start": {
        "line": 44,
        "column": 6
      },
      "end": {
        "line": 428,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": true
    },
    "MAP": {
      "type": "property",
      "label": "MAP",
      "description": null,
      "code": "MAP: NGN.get(() => {\r\n        return NGN.coalesce(\r\n          this.METADATA.DATAMAP,\r\n          this.METADATA.store instanceof NGN.DATA.Store\r\n            ? this.METADATA.store.map\r\n            : null\r\n        )\r\n      })",
      "start": {
        "line": 430,
        "column": 6
      },
      "end": {
        "line": 437,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "auditable": {
      "type": "property",
      "label": "auditable",
      "description": null,
      "code": "set auditable (value) {\r\n    value = NGN.forceBoolean(value)\r\n\r\n    if (value !== this.METADATA.AUDITABLE) {\r\n      this.METADATA.AUDITABLE = value\r\n      this.METADATA.AUDITLOG = value ? new NGN.DATA.TransactionLog() : null\r\n      this.METADATA.auditFieldNames = value ? new Set() : null\r\n\r\n      // Set each field to an auditable state (or not).\r\n      this.METADATA.knownFieldNames.forEach(fieldname => {\r\n        if (!this.METADATA.fields[fieldname].virtual) {\r\n          this.METADATA.fields[fieldname].auditable = value\r\n\r\n          if (value) {\r\n            this.METADATA.auditFieldNames.add(fieldname)\r\n          }\r\n        }\r\n      })\r\n\r\n      if (value) {\r\n        // Track Changes (if auditing enabled)\r\n        this.on('field.transaction.*', (id) => {\r\n          this.METADATA.AUDIT_HANDLER({ cursor: id })\r\n        })\r\n      } else {\r\n        this.METADATA.auditFieldNames.clear()\r\n\r\n        this.off('field.transaction.*')\r\n      }\r\n    }\r\n  }",
      "start": {
        "line": 527,
        "column": 2
      },
      "end": {
        "line": 557,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": false,
      "writable": true,
      "configuration": false,
      "private": false
    },
    "name": {
      "type": "property",
      "label": "name",
      "description": null,
      "code": "get name () {\r\n    return this.METADATA.name\r\n  }",
      "start": {
        "line": 523,
        "column": 2
      },
      "end": {
        "line": 525,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "id": {
      "type": "property",
      "label": "id",
      "description": null,
      "code": "set id (value) {\r\n    this.set('id', value)\r\n  }",
      "start": {
        "line": 567,
        "column": 2
      },
      "end": {
        "line": 569,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": false,
      "writable": true,
      "configuration": false,
      "private": false
    },
    "ID": {
      "type": "property",
      "label": "ID",
      "description": null,
      "code": "set ID (value) {\r\n    this.set('id', value)\r\n  }",
      "start": {
        "line": 579,
        "column": 2
      },
      "end": {
        "line": 581,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": false,
      "writable": true,
      "configuration": false,
      "private": false
    },
    "changelog": {
      "type": "property",
      "label": "changelog",
      "description": null,
      "code": "get changelog () {\r\n    return this.METADATA.AUDITLOG.log.map(entry => {\r\n      let result = {\r\n        timestamp: entry.timestamp,\r\n        activeCursor: entry.activeCursor,\r\n        value: {}\r\n      }\r\n\r\n      let data = entry.value\r\n      let field = Object.keys(data)\r\n\r\n      for (let i = 0; i < field.length; i++) {\r\n        if (typeof data[field[i]] === 'symbol') {\r\n          result.value[field[i]] = NGN.coalesce(\r\n            this.METADATA.fields[field[i]].METADATA.AUDITLOG.getCommit(data[field[i]]).value,\r\n            this.METADATA.fields[field[i]].default\r\n          )\r\n        } else {\r\n          result.value[field[i]] = NGN.coalesce(this.METADATA.fields[field[i]].default)\r\n        }\r\n      }\r\n\r\n      return result\r\n    })\r\n  }",
      "start": {
        "line": 588,
        "column": 2
      },
      "end": {
        "line": 612,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "createDate": {
      "type": "property",
      "label": "createDate",
      "description": null,
      "code": "get createDate () {\r\n    return this.METADATA.created\r\n  }",
      "start": {
        "line": 618,
        "column": 2
      },
      "end": {
        "line": 620,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "data": {
      "type": "property",
      "label": "data",
      "description": null,
      "code": "get data () {\r\n    if (this.MAP) {\r\n      return this.MAP.applyInverseMap(this.serializeFields())\r\n    }\r\n\r\n    return this.serializeFields()\r\n  }",
      "start": {
        "line": 628,
        "column": 2
      },
      "end": {
        "line": 634,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "unmappedData": {
      "type": "property",
      "label": "unmappedData",
      "description": null,
      "code": "get unmappedData () {\r\n    return this.serializeFields()\r\n  }",
      "start": {
        "line": 640,
        "column": 2
      },
      "end": {
        "line": 642,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "representation": {
      "type": "property",
      "label": "representation",
      "description": null,
      "code": "get representation () {\r\n    if (this.MAP) {\r\n      return this.MAP.applyInverseMap(this.serializeFields(false, false))\r\n    }\r\n\r\n    return this.serializeFields(false, false)\r\n  }",
      "start": {
        "line": 649,
        "column": 2
      },
      "end": {
        "line": 655,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "unmappedRepresentation": {
      "type": "property",
      "label": "unmappedRepresentation",
      "description": null,
      "code": "get unmappedRepresentation () {\r\n    return this.serializeFields(false, false)\r\n  }",
      "start": {
        "line": 661,
        "column": 2
      },
      "end": {
        "line": 663,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "checksum": {
      "type": "property",
      "label": "checksum",
      "description": null,
      "code": "get checksum () {\r\n    this.METADATA.checksum = NGN.coalesce(this.METADATA.checksum, NGN.DATA.UTILITY.checksum(JSON.stringify(this.data)))\r\n\r\n    return this.METADATA.checksum\r\n  }",
      "start": {
        "line": 673,
        "column": 2
      },
      "end": {
        "line": 677,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "expires": {
      "type": "property",
      "label": "expires",
      "description": null,
      "code": "set expires (value) {\r\n    if (value === null) {\r\n      clearTimeout(this.METADATA.expirationTimeout)\r\n      this.METADATA.expiration = null\r\n      return\r\n    }\r\n\r\n    let now = new Date()\r\n\r\n    if (!isNaN(value) && !(value instanceof Date)) {\r\n      // Handle numeric (millisecond) expiration\r\n      if (value < 0) {\r\n        this.METADATA.expiration = null\r\n\r\n        return\r\n      }\r\n\r\n      if (value === 0) {\r\n        this.METADATA.expiration = now\r\n        this.emit('expire')\r\n\r\n        return\r\n      }\r\n\r\n      this.METADATA.expiration = new Date()\r\n      this.METADATA.expiration.setTime(now.getTime() + value)\r\n    } else if (!(value instanceof Date) || value <= now) {\r\n      throw new Error(`${this.name} expiration (TTL) value must be a positive number (milliseconds) or future date.`)\r\n    } else {\r\n      // Handle date-based expiration\r\n      this.METADATA.expiration = value\r\n    }\r\n\r\n    clearTimeout(this.METADATA.expirationTimeout)\r\n\r\n    this.METADATA.expirationTimeout = setTimeout(() => this.emit('expire'), this.METADATA.expiration.getTime() - now.getTime())\r\n  }",
      "start": {
        "line": 694,
        "column": 2
      },
      "end": {
        "line": 730,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": false,
      "writable": true,
      "configuration": false,
      "private": false
    },
    "expired": {
      "type": "property",
      "label": "expired",
      "description": null,
      "code": "get expired () {\r\n    if (this.METADATA.expiration === null) {\r\n      return false\r\n    }\r\n\r\n    return this.METADATA.expiration <= (new Date())\r\n  }",
      "start": {
        "line": 732,
        "column": 2
      },
      "end": {
        "line": 738,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "fieldDefinitions": {
      "type": "property",
      "label": "fieldDefinitions",
      "description": null,
      "code": "get fieldDefinitions () {\r\n    return this.METADATA.fields\r\n    // if (this.METADATA.knownFieldNames.size === 0) {\r\n    //   return {}\r\n    // }\r\n    //\r\n    // let fields = this.METADATA.knownFieldNames.keys()\r\n    // let result = {}\r\n    // let fieldname = fields.next()\r\n    //\r\n    // while (!fieldname.done) {\r\n    //   let field = this.METADATA.fields[fieldname.value]\r\n    //\r\n    //   if ((\r\n    //     field.value === undefined ||\r\n    //     (ignoreID && fieldname.value === this.IdentificationField) ||\r\n    //     (!field.virtual || (!ignoreVirtualFields && field.virtual))\r\n    //   )) {\r\n    //     // Do not serialize hidden values or virtuals\r\n    //     if (!field.hidden) {\r\n    //       switch (NGN.typeof(field.value)) {\r\n    //         case 'array':\r\n    //         case 'object':\r\n    //           result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\r\n    //           break\r\n    //\r\n    //         default:\r\n    //           result[fieldname.value] = field.value\r\n    //       }\r\n    //     }\r\n    //   }\r\n    // }\r\n  }",
      "start": {
        "line": 740,
        "column": 2
      },
      "end": {
        "line": 772,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "datatype": "undefined",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "META": {
      "type": "property",
      "label": "META",
      "description": null,
      "code": "META: NGN.private({\r\n        queued: {},\r\n        collectionQueue: {},\r\n        thresholdQueue: {},\r\n        defaultTTL: -1,\r\n        wildcardEvents: new Set()\r\n      })",
      "start": {
        "line": 33,
        "column": 6
      },
      "end": {
        "line": 39,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": true,
      "configuration": false,
      "private": true
    },
    "setTTL": {
      "type": "property",
      "label": "setTTL",
      "description": "Set a default time-to-live for event handlers (in milliseconds).\r\n      After the TTL period elapses, event handlers are removed.\r\n      By default, there is no TTL (`-1`).\r\n      \r\n      The number of milliseconds before an event handler is automatically\r\n      removed. This value may be `-1` (no TTL/never expires) or a value\r\n      greater than `0`.",
      "code": "setTTL: NGN.const((ttl = -1) => {\r\n        if (ttl === 0) {\r\n          NGN.WARN('NGN.EventEmitter#TTL cannot be 0.')\r\n          return\r\n        }\r\n\r\n        this.META.defaultTTL = ttl\r\n      })",
      "start": {
        "line": 51,
        "column": 6
      },
      "end": {
        "line": 58,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "off": {
      "type": "property",
      "label": "off",
      "description": "Remove an event handler. If no handler is specified, all handlers for\r\n      the specified event will be removed.\r\n      This is a shortcut for #removeListener.\r\n      \r\n      Name of the event to remove.\r\n      \r\n      The handler function to remove from the event handlers.",
      "code": "off: NGN.public((eventName, handlerFn) => {\r\n        if (NGN.typeof(eventName) === 'array') {\r\n          for (let i = 0; i < eventName.length; i++) {\r\n            this.off(eventName[i], handlerFn)\r\n          }\r\n\r\n          return\r\n        }\r\n\r\n        let l = this.listeners(eventName)\r\n\r\n        if (!NGN.isFn(handlerFn)) {\r\n          return this.clear(eventName)\r\n        }\r\n\r\n        let wrappedHandlerFn = this.wrapEventHandlerWithScope(eventName, handlerFn)\r\n\r\n        if (l.indexOf(wrappedHandlerFn) < 0) {\r\n          for (let i = 0; i < l.length; i++) {\r\n            if (l[i].toString() === wrappedHandlerFn.toString()) {\r\n              this.META.wildcardEvents.delete(eventName)\r\n              // this.removeListener(eventName, handlerFn)\r\n              this.removeListener(eventName, l[i], false)\r\n              break\r\n            }\r\n          }\r\n        } else {\r\n          this.META.wildcardEvents.delete(eventName)\r\n          this.removeListener(eventName, handlerFn)\r\n        }\r\n      })",
      "start": {
        "line": 70,
        "column": 6
      },
      "end": {
        "line": 100,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": true,
      "configuration": false,
      "private": false
    },
    "deprecate": {
      "type": "property",
      "label": "deprecate",
      "description": "Provides a deprecation notice for the specified event.\r\n      Automatically emits the appropriate \"replacement\" event\r\n      if a replacement event is configured. If no replacement\r\n      event is configured, the deprecation notice will be written\r\n      to the console but no replacement event will be triggered.\r\n      \r\n      The name of the deprecated event.\r\n      \r\n      The name of the new event.",
      "code": "deprecate: NGN.const((deprecatedEventName, replacementEventName) => {\r\n        const me = this\r\n\r\n        this.on(deprecatedEventName, function () {\r\n          NGN.WARN(`${deprecatedEventName} is deprecated. ` + (!replacementEventName ? '' : `Use ${replacementEventName} instead.`))\r\n\r\n          if (replacementEventName) {\r\n            let args = NGN.slice(arguments)\r\n\r\n            args.shift()\r\n            args.unshift(replacementEventName)\r\n\r\n            me.emit.apply(me, args)\r\n          }\r\n        })\r\n      })",
      "start": {
        "line": 114,
        "column": 6
      },
      "end": {
        "line": 129,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "subscriberObject": {
      "type": "property",
      "label": "subscriberObject",
      "description": "A key:value object where the key is the name of the\nunprefixed event and the key is the handler function.\nA value can be an object, allowing for nesting events. For example:\n\n```js\nNGN.BUS.pool('prefix.', {\ndeep: {\nnested: {\neventName: function  {\nconsole.log('event triggered')\n}\n}\n}\n})\n\nNGN.BUS.emit('prefix.deep.nested.eventName') // <-- Outputs \"event triggered\"\n```",
      "code": "pool: NGN.privateconst(function (prefix, group) {\r\n        if (typeof prefix !== 'string') {\r\n          group = prefix\r\n          prefix = ''\r\n        }\r\n\r\n        let pool = {}\r\n\r\n        for (let eventName in group) {\r\n          let topic = `${NGN.coalesce(prefix, '')}${eventName}`\r\n\r\n          if (NGN.isFn(group[eventName])) {\r\n            this.increaseMaxListeners()\r\n\r\n            pool[eventName] = this.on(topic, group[eventName])\r\n          } else if (typeof group[eventName] === 'object') {\r\n            this.pool(`${topic}.`, group[eventName])\r\n          } else {\r\n            NGN.WARN(`${topic} could not be pooled in the event emitter because it's value is not a function.`)\r\n          }\r\n        }\r\n      })",
      "start": {
        "line": 158,
        "column": 6
      },
      "end": {
        "line": 179,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "default": null,
      "datatype": "object",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": true
    },
    "attach": {
      "type": "property",
      "label": "attach",
      "description": "Attach a function to a topic. This can be used\r\n      to forward events in response to asynchronous functions.\r\n      \n      For example:\r\n      \n      ```js\r\n      myAsyncDataFetch(NGN.BUS.attach('topicName'))\r\n      ```\r\n      \n      This is the same as:\r\n      \n      ```js\r\n      myAsyncCall(function(data){\r\n       NGN.BUS.emit('topicName', data)\r\n      })\r\n      ```\r\n      \r\n      The name of the event to attach a handler method to.\r\n      \r\n      Setting this to `true` will execute a `event.preventDefault()` before\r\n      attaching the handler.\r\n      \r\n      Returns a function that will automatically be associated with an event.",
      "code": "attach: NGN.const(function (eventName, preventDefaultAction) {\r\n        preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\r\n\r\n        return (e) => {\r\n          if (preventDefaultAction && !NGN.nodelike) {\r\n            e.preventDefault()\r\n          }\r\n\r\n          this.emit(eventName, ...arguments)\r\n        }\r\n      })",
      "start": {
        "line": 207,
        "column": 6
      },
      "end": {
        "line": 217,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "increaseMaxListeners": {
      "type": "property",
      "label": "increaseMaxListeners",
      "description": "Increase the number of maximum listeners.\r\n      \r\n      The number of events the max listener account will be increased by.",
      "code": "increaseMaxListeners: NGN.private((count = 1) => {\r\n        this.setMaxListeners(this.getMaxListeners() + count)\r\n      })",
      "start": {
        "line": 226,
        "column": 6
      },
      "end": {
        "line": 228,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": true,
      "configuration": false,
      "private": true
    },
    "decreaseMaxListeners": {
      "type": "property",
      "label": "decreaseMaxListeners",
      "description": "Decrease the number of maximum listeners.\r\n      \r\n      The number of events the max listener account will be decreased by.",
      "code": "decreaseMaxListeners: NGN.private((count = 1) => {\r\n        this.setMaxListeners(this.getMaxListeners() - count)\r\n      })",
      "start": {
        "line": 237,
        "column": 6
      },
      "end": {
        "line": 239,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": true,
      "configuration": false,
      "private": true
    },
    "forward": {
      "type": "property",
      "label": "forward",
      "description": "A special subscriber that fires one or more event in response to\r\n      to an event. This is used to bubble events up/down an event chain.\r\n      \n      For example:\r\n      \n      ```js\r\n      NGN.BUS.forward('sourceEvent', ['someEvent','anotherEvent'], {payload:true})\r\n      ```\r\n      When `sourceEvent` is published, the bind method triggers `someEvent` and\r\n      `anotherEvent`, passing the payload object to `someEvent` and\r\n      `anotherEvent` subscribers simultaneously.\r\n      \n      To forward an event to another EventEmitter, see #relay.\r\n      \r\n      The event to subscribe to.\r\n      \r\n      An event or array of events to fire in response to the sourceEvent.\r\n      \r\n      Optional data to pass to each bound event handler.\r\n      \r\n      Returns an object with a single `remove()` method.",
      "code": "forward: NGN.const(function (eventName, triggers, payload) {\r\n        triggers = NGN.forceArray(triggers)\r\n\r\n        let me = this\r\n        let listener = function () {\r\n          let args = NGN.slice(arguments)\r\n\r\n          if (payload) {\r\n            args.push(payload)\r\n          }\r\n\r\n          me.emit(triggers, ...args)\r\n        }\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(eventName, listener)\r\n\r\n        // Provide handle back for removal of topic\r\n        return {\r\n          remove: () => {\r\n            this.decreaseMaxListeners()\r\n            this.off(eventName, listener)\r\n          }\r\n        }\r\n      })",
      "start": {
        "line": 265,
        "column": 6
      },
      "end": {
        "line": 289,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "relay": {
      "type": "property",
      "label": "relay",
      "description": "This relays an entire event to a different event emitter.\r\n      For example:\r\n      \n      ```js\r\n      let emitterA = new NGN.EventEmitter()\r\n      let emitterB = new NGN.EventEmitter()\r\n      \n      emitterA.relay('my.event', emitterB)\r\n      \n      emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\r\n      \n      emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\r\n      ```\r\n      \r\n      The name of the event to listen for.\r\n      \r\n      The emitter to relay the event to.\r\n      \r\n      An optional prefix to prepend to the eventName.\r\n      \r\n      An optional postfix to append to the eventName.",
      "code": "relay: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\r\n        let eventNameList = NGN.forceArray(eventName)\r\n\r\n        for (let i = 0; i < eventNameList.length; i++) {\r\n          let eventName = eventNameList[i]\r\n\r\n          this.on(eventName, function () {\r\n            if (NGN.typeof(this.event) === 'symbol') {\r\n              if (prefix !== null || postfix !== null) {\r\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\r\n              }\r\n\r\n              targetEmitter.emit(...arguments)\r\n            } else {\r\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\r\n            }\r\n          })\r\n        }\r\n      })",
      "start": {
        "line": 314,
        "column": 6
      },
      "end": {
        "line": 332,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "relayOnce": {
      "type": "property",
      "label": "relayOnce",
      "description": "This relays an entire event to a different event emitter. This is\r\n      the same as #relay, but the event handler is removed after the\r\n      first invocation of the event.\r\n      \n      For example:\r\n      \n      ```js\r\n      let emitterA = new NGN.EventEmitter()\r\n      let emitterB = new NGN.EventEmitter()\r\n      \n      emitterA.relayOnce('my.event', emitterB)\r\n      \n      emitterB.on('my.event', () => { console.log('Emitter B heard the event!') })\r\n      \n      emitterA.emit('my.event') // Outputs \"Emitter B heard the event!\"\r\n      emitterA.emit('my.event') // Does nothing\r\n      ```\r\n      \r\n      The name of the event to listen for.\r\n      \r\n      The emitter to relay the event to.\r\n      \r\n      An optional prefix to prepend to the eventName.\r\n      \r\n      An optional postfix to append to the eventName.",
      "code": "relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\r\n        let eventNameList = NGN.forceArray(eventName)\r\n\r\n        for (let i = 0; i < eventNameList.length; i++) {\r\n          let eventName = eventNameList[i]\r\n\r\n          this.once(eventName, function () {\r\n            if (NGN.typeof(this.event) === 'symbol') {\r\n              if (prefix !== null || postfix !== null) {\r\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\r\n              }\r\n\r\n              targetEmitter.emit(...arguments)\r\n            } else {\r\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\r\n            }\r\n          })\r\n        }\r\n      })",
      "start": {
        "line": 361,
        "column": 6
      },
      "end": {
        "line": 379,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "delayEmit": {
      "type": "property",
      "label": "delayEmit",
      "description": "This method waits for the specified duration, then publishes an\r\n      event once. This will publish the event only once at the end of the\r\n      wait period, even if the event is triggered multiple times. This can\r\n      be useful when working with many events triggered in rapid succession.\r\n      \n      For example, an NGN.DATA.Model representing a person may be used to\r\n      track a user profile. The NGN.DATA.Model fires an event called `field.update`\r\n      every time a data field is modified. In many cases, a user may update\r\n      multiple fields of their profile using a form with a \"Save\" button.\r\n      Instead of generating a new \"save\" (to disk, to memory, to an API, etc)\r\n      operation for each field, the publishOnce event can wait until all\r\n      changes are made before running the save operation.\r\n      \n      ```js\r\n      // Create a data model representing a person.\r\n      var Person = new NGN.DATA.Model({....})\r\n      \n      // Create a new person record for a user.\r\n      var user = new Person()\r\n      \n      // When the user is modified, save the data.\r\n      user.on('field.update', function () {\r\n        // Wait 300 milliseconds to trigger the save event\r\n        NGN.BUS.delayEmit('user.save', 300)\r\n      })\r\n      \n      // Save the user using an API\r\n      NGN.BUS.on('user.save', function () {\r\n        NGN.NET.put({\r\n          url: 'https://my.api.com/user',\r\n          json: user.data\r\n        })\r\n      })\r\n      \n      // Modify the record attributes (which are blank by default)\r\n      user.firstname = 'John'\r\n      user.lastname = 'Doe'\r\n      user.age = 42\r\n      \n      // Make another update 1 second later\r\n      setTimeout(function () {\r\n        user.age = 32\r\n      }, 1000)\r\n      ```\r\n      \n      The code above sets up a model and record. Then it listens to the record\r\n      for field updates. Each time it recognizes an update, it queues the \"save\"\r\n      event. When the queue matures, it fires the `user.save` event.\r\n      \n      The first `field.update` is triggered when `user.firstname = 'John'` runs.\r\n      This initiates a queue for `user.save`, set to mature in 300 millisenconds.\r\n      Next, a `field.update` is triggered when `user.lastname = 'Doe'` runs.\r\n      This time, since the queue for `user.save` is already initiated, notthing\r\n      new happens. Finally, a `field.update` is triggered when `user.age = 42`\r\n      runs. Just like the last one, nothing happens since the `user.save` queue\r\n      is already active.\r\n      \n      The `user.save` queue \"matures\" after 300 milliseconds. This means after\r\n      300 milliseconds have elapsed, the `user.save` event is triggered. In this\r\n      example, it means the `NGN.NET.put()` code will be executed. As a result,\r\n      all 3 change (firstname, lastname, and age) will be complete before the\r\n      API request is executed. The queue is cleared immediately.\r\n      \n      The final update occurs 1 second later (700 milliseconds after the queue\r\n      matures). This triggers a `field.update`, but since the queue is no\r\n      longer active, it is re-initiated. 300 milliseconds later, the `user.save`\r\n      event is fired again, thus executing the API request again (1.3 seconds\r\n      in total).\r\n      \r\n      The event/topic to publish/emit.\r\n      \r\n      The number of milliseconds to wait before firing the event.\r\n      \r\n      An optional payload, such as data to be passed to an event handler.",
      "code": "delayEmit: NGN.const(function (eventName, delay) {\r\n        if (!this.META.queued.hasOwnProperty(eventName)) {\r\n          let args = NGN.slice(arguments)\r\n          args.splice(1, 1)\r\n\r\n          this.META.queued[eventName] = setTimeout(() => {\r\n            delete this.META.queued[eventName]\r\n            this.emit(...args)\r\n          }, delay)\r\n        }\r\n      })",
      "start": {
        "line": 458,
        "column": 6
      },
      "end": {
        "line": 468,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "getInternalCollectionId": {
      "type": "property",
      "label": "getInternalCollectionId",
      "description": "Returns a unique ID for special collections.\r\n      \r\n      The collection to generate an ID for.",
      "code": "getInternalCollectionId: NGN.privateconst(function (collection) {\r\n        return Symbol(collection)\r\n        // let time = (new Date()).getTime().toString()\r\n        // let rand = Math.random().toString()\r\n        // let key = Object.keys(collection).length + 1\r\n        //\r\n        // while (collection.hasOwnProperty(`${key.toString()}${time}${rand}`)) {\r\n        //   key++\r\n        // }\r\n        //\r\n        // return `${key.toString()}${time}${rand}`\r\n      })",
      "start": {
        "line": 477,
        "column": 6
      },
      "end": {
        "line": 488,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": true
    },
    "handleCollectionTrigger": {
      "type": "property",
      "label": "handleCollectionTrigger",
      "description": "A method to manage #chain event handlers.",
      "code": "handleCollectionTrigger: NGN.privateconst(function (eventName, key) {\r\n        let me = this\r\n\r\n        return function () {\r\n          // Use setTimeout to simulate nextTick\r\n          setTimeout(() => {\r\n            let cq = me.META.collectionQueue\r\n\r\n            if (cq[key]) {\r\n              cq[key].remainingqueue.delete(eventName)\r\n\r\n              if (cq[key].remainingqueue.size === 0) {\r\n                cq[key].remainingqueue = cq[key].masterqueue\r\n\r\n                if (NGN.isFn(cq[key].eventName)) {\r\n                  cq[key].eventName(cq[key].payload)\r\n                } else {\r\n                  me.emit(cq[key].eventName, cq[key].payload)\r\n                }\r\n              }\r\n            }\r\n          }, 0)\r\n        }\r\n      })",
      "start": {
        "line": 495,
        "column": 6
      },
      "end": {
        "line": 518,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": true
    },
    "funnel": {
      "type": "property",
      "label": "funnel",
      "description": "Emit an event after a collection of unique events have all fired.\r\n      This can be useful in situations where multiple asynchronous actions\r\n      must complete before another begins. For example, blending 3\r\n      remote data sources from different API's into a single resultset\r\n      can be achieved with this.\r\n      \n      Example\n      ```js\r\n      let collection = NGN.BUS.funnel(['download1done', 'download2done', 'download3done'], 'make.results')\r\n      \n      let allData = []\r\n      \n      // When all of the downloads are done, log them.\r\n      NGN.BUS.on('make.results', () => {\r\n        console.log(allData)\r\n      })\r\n      \n      // Download the first set of data asynchronously\r\n      NGN.NET.json('http:/download1.com/data.json', (data) => {\r\n        allData.push(data)\r\n        NGN.BUS.emit('download1done')\r\n      })\r\n      \n      // Download the second set of data asynchronously\r\n      NGN.NET.json('http:/download2.com/data.json', (data) => {\r\n        allData.push(data)\r\n        NGN.BUS.emit('download2done')\r\n      })\r\n      \n      // Download the third set of data asynchronously\r\n      NGN.NET.json('http:/download3.com/data.json', (data) => {\r\n        allData.push(data)\r\n        NGN.BUS.emit('download3done')\r\n      })\r\n      \n      // The handler can be removed with the special method:\r\n      collection.remove()\r\n      ```\r\n      \r\n      An array of events. Once _all_ of these events have fired,\r\n      the triggerEventName will be fired.\r\n      \r\n      The name of the event triggered after the collection has completed.\r\n      This can also be a callback function. If a callback function is provided,\r\n      it will receive the payload as the only argument when it is triggered.\r\n      \r\n      An optional payload delivered to the #triggerEventName.\r\n      \r\n      Provides the key/value configuration of the collection.\r\n      ```js\r\n      {\r\n        masterqueue: ['event1', 'event2', 'etc'], // The original event array (non-editable)\r\n        remainingqueue: [...], // The events the BUS is still waiting for before firing the trigger event.\r\n        eventName: 'triggeredEventName', // Name of the event triggered after the remaining elements are flushed.\r\n        payload: 'anything', // OPTIONAL\r\n        remove: [Function]\r\n      }\r\n      ```",
      "code": "funnel: NGN.const((eventCollection, triggerEventName, payload = null) => {\r\n        if (NGN.typeof(eventCollection) !== 'array') {\r\n          throw new Error(`NGN.BUS.funnel expected an array of events, but received a(n) ${NGN.typeof(eventCollection)}`)\r\n        }\r\n\r\n        let collection = new Set(eventCollection)\r\n        let key = this.getInternalCollectionId(this.META.collectionQueue)\r\n\r\n        this.META.collectionQueue[key] = {}\r\n\r\n        Object.defineProperties(this.META.collectionQueue[key], {\r\n          masterqueue: NGN.const(new Set(eventCollection)),\r\n          remainingqueue: NGN.private(collection),\r\n          eventName: NGN.const(triggerEventName),\r\n          remove: NGN.const(() => {\r\n            this.META.collectionQueue[key].masterqueue.forEach(event => {\r\n              this.off(event, this.handleCollectionTrigger(event, key))\r\n            })\r\n\r\n            this.decreaseMaxListeners(this.META.collectionQueue[key].masterqueue.size)\r\n\r\n            delete this.META.collectionQueue[key]\r\n          }),\r\n          payload: NGN.const(payload)\r\n        })\r\n\r\n        this.increaseMaxListeners(collection.size)\r\n\r\n        collection.forEach(event => {\r\n          this.on(event, this.handleCollectionTrigger(event, key))\r\n        })\r\n\r\n        return this.META.collectionQueue[key]\r\n      })",
      "start": {
        "line": 581,
        "column": 6
      },
      "end": {
        "line": 614,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "funnelOnce": {
      "type": "property",
      "label": "funnelOnce",
      "description": "This provides the same functionality as #funnel, but\r\n      removes the listener after the resultant event has fired.\r\n      See #funnel for detailed usage.\r\n      \r\n      An array of events. Once _all_ of these events have fired,\r\n      the triggerEventName will be fired.\r\n      \r\n      The name of the event triggered after the collection has completed.\r\n      \r\n      An optional payload delivered to the #triggerEventName.\r\n      \r\n      Provides the key/value configuration of the collection.",
      "code": "funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\r\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\r\n        // let funnelClosureEvent = Symbol(triggerEventName)\r\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\r\n\r\n        this.increaseMaxListeners()\r\n        this.once(funnelClosureEvent, () => {\r\n          collection.remove()\r\n          collection = null\r\n          this.emit(triggerEventName, payload)\r\n        })\r\n      })",
      "start": {
        "line": 631,
        "column": 6
      },
      "end": {
        "line": 642,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "threshold": {
      "type": "property",
      "label": "threshold",
      "description": "After an event is fired a predetermined number of times (the threshold),\r\n      trigger another event or function.\r\n      \n      For example:\r\n      \n      ```js\r\n      NGN.BUS.threshold('push.my.button', 3, 'annoyed')\r\n      \n      NGN.BUS.on('annoyed', function () {\r\n        console.log('We apologize for the slow response, but excessive clicking will not speed up the process.')\r\n      })\r\n      \n      document.getElementById('#myButton').addEventListener('click', NGN.BUS.attach('push.my.button'))\r\n      ```\r\n      \n      Once the threshold is exceeded, the final event will be triggered and\r\n      the threshold will be reset. Using the example above, this means\r\n      clicking 3 times on `#myButton` would trigger the `annoyed` event ONCE,\r\n      6 times triggers `annoyed` TWICE, 9 times triggers `annoyed` THREE times, etc.\r\n      \r\n      The name of the event to count.\r\n      \r\n      The number of occurrances allowed until the final event is triggered.\r\n      The event will be triggered at the threshold. For example, if the limit\r\n      is `3`, the finalEvent will be triggered the 3rd time thresholdEventName is\r\n      fired.\r\n      \r\n      This can be an event or callback function triggered when the threshold is crossed.\r\n      If a callback function is specified, the payload is passed as the only argument.\r\n      \r\n      An optional payload to send to the finalEvent handler(s).\r\n      \r\n      Returns an object that can be used to remove the threshold.",
      "code": "threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\r\n        if (typeof thresholdEventName !== 'string') {\r\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\r\n        }\r\n\r\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\r\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\r\n\r\n        this.META.thresholdQueue[key] = {}\r\n\r\n        Object.defineProperties(this.META.thresholdQueue[key], {\r\n          key: NGN.const(key),\r\n          eventName: NGN.const(thresholdEventName),\r\n          limit: NGN.const(limit),\r\n          count: NGN.private(0),\r\n          finalEventName: NGN.const(finalEventName),\r\n          remove: NGN.const(() => {\r\n            let event = this.META.thresholdQueue[key].eventName\r\n\r\n            delete this.META.thresholdQueue[key]\r\n\r\n            this.decreaseMaxListeners()\r\n            this.off(event, this.handleThresholdTrigger(key))\r\n          }),\r\n          payload: NGN.const(payload)\r\n        })\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\r\n\r\n        return this.META.thresholdQueue[key]\r\n      })",
      "start": {
        "line": 681,
        "column": 6
      },
      "end": {
        "line": 712,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "thresholdOnce": {
      "type": "property",
      "label": "thresholdOnce",
      "description": null,
      "code": "thresholdOnce: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\r\n        let thresholdClosureEvent = `::NGNTHRESHOLD::${(new Date()).getTime()}::${finalEventName}`\r\n        let threshold = this.threshold(thresholdEventName, limit, thresholdClosureEvent, payload)\r\n\r\n        this.once(thresholdClosureEvent, () => {\r\n          threshold.remove()\r\n          threshold = null\r\n          this.emit(finalEventName, payload)\r\n        })\r\n      })",
      "start": {
        "line": 714,
        "column": 6
      },
      "end": {
        "line": 723,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": false
    },
    "handleThresholdTrigger": {
      "type": "property",
      "label": "handleThresholdTrigger",
      "description": "A method to manage #threshold event handlers.",
      "code": "handleThresholdTrigger: NGN.const(function (key) {\r\n        let me = this\r\n        return function () {\r\n          // Use setTimeout to simulate nextTick\r\n          setTimeout(() => {\r\n            if (me.META.thresholdQueue.hasOwnProperty(key)) {\r\n              me.META.thresholdQueue[key].count++\r\n              if (me.META.thresholdQueue[key].count === me.META.thresholdQueue[key].limit) {\r\n                if (NGN.isFn(me.META.thresholdQueue[key].finalEventName)) {\r\n                  me.META.thresholdQueue[key].finalEventName(me.META.thresholdQueue[key].payload)\r\n                } else {\r\n                  me.emit(me.META.thresholdQueue[key].finalEventName, me.META.thresholdQueue[key].payload)\r\n                }\r\n\r\n                // This if statement is required in case the event is removed\r\n                // during the reset process.\r\n                if (me.META.thresholdQueue.hasOwnProperty(key)) {\r\n                  me.META.thresholdQueue[key].count = 0\r\n                }\r\n              }\r\n            }\r\n          }, 0)\r\n        }\r\n      })",
      "start": {
        "line": 730,
        "column": 6
      },
      "end": {
        "line": 753,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": true
    },
    "wrapEventHandlerWithScope": {
      "type": "property",
      "label": "wrapEventHandlerWithScope",
      "description": "An internal method to wrap node-based event handlers\r\n      with the proper scope.\r\n      \r\n      The name of the event being handled.\r\n      \r\n      The handler function.",
      "code": "wrapEventHandlerWithScope: NGN.privateconst((name, fn) => {\r\n        if (!NGN.nodelike) {\r\n          return fn\r\n        }\r\n\r\n        const handlerFn = fn\r\n\r\n        return function () {\r\n          let args = arguments\r\n\r\n          if (typeof args[args.length - 1] === 'symbol') {\r\n            name = args[args.length - 1].toString().replace(/Symbol\\(|\\)/gi, '')\r\n            args = NGN.slice(args)\r\n            args.pop()\r\n          }\r\n\r\n          handlerFn.apply({ event: name }, args)\r\n        }\r\n      })",
      "start": {
        "line": 763,
        "column": 6
      },
      "end": {
        "line": 781,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": true
    },
    "applyScope": {
      "type": "property",
      "label": "applyScope",
      "description": "An internal method to apply scope based on whether the handler\r\n      is a Node-like \"once\" emitter or not.\r\n      \r\n      The name of the event being scoped.\r\n      \r\n      The handler function.",
      "code": "applyScope: NGN.privateconst((args) => {\r\n        if (NGN.nodelike && args.length > 1) {\r\n          if (args[args.length - 1].listener) {\r\n            args[args.length - 1].listener = this.wrapEventHandlerWithScope(\r\n              args[0],\r\n              args[args.length - 1].listener\r\n            )\r\n          } else {\r\n            args[args.length - 1] = this.wrapEventHandlerWithScope(\r\n              args[0],\r\n              args[args.length - 1]\r\n            )\r\n          }\r\n        }\r\n      })",
      "start": {
        "line": 791,
        "column": 6
      },
      "end": {
        "line": 805,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "datatype": "any",
      "readable": true,
      "writable": false,
      "configuration": false,
      "private": true
    }
  },
  "methods": {
    "constructor": {
      "type": "method",
      "label": "constructor",
      "description": null,
      "code": "constructor (cfg) {\r\n    cfg = NGN.coalesce(cfg, {})\r\n\r\n    super()\r\n\r\n    if (cfg.dataMap) {\r\n      cfg.fieldmap = cfg.dataMap\r\n      NGN.WARN('\"dataMap\" is deprecated. Use \"map\" instead.')\r\n    }\r\n\r\n    if (cfg.idAttribute) {\r\n      cfg.IdentificationField = cfg.idAttribute\r\n      NGN.WARN('\"idAttribute\" is deprecated. Use \"IdentificationField\" instead.')\r\n    }\r\n\r\n    const me = this\r\n\r\n    // Create private attributes & data placeholders\r\n    Object.defineProperties(this, {\r\n      /**\r\n       * @property {Symbol} OID\r\n       * A unique object ID assigned to the model. This is an\r\n       * internal readon-only reference.\r\n       * @private\r\n       */\r\n      OID: NGN.private(Symbol('model.id')),\r\n\r\n      METADATA: NGN.privateconst({\r\n        /**\r\n         * @cfg {string} [name]\r\n         * A descriptive name for the model. This is typically used for\r\n         * debugging, logging, schema defintions, and (sometimes) data proxies.\r\n         */\r\n        name: NGN.coalesce(cfg.name, 'Untitled Model'),\r\n\r\n        /**\r\n         * @cfg {string} [description]\r\n         * A description of the model. This is typically used for\r\n         * debugging, logging, schema definitions, and (sometimes) data proxies.\r\n         */\r\n        description: NGN.coalesce(cfg.description, cfg.name, 'Generic Data Model'),\r\n\r\n        /**\r\n         * @cfg {object} fields\r\n         * A private object containing the data fields of the model.\r\n         * Each key contains the field name, while each value can be one of\r\n         * the following:\r\n         *\r\n         * - Primitive (String, Number, RegExp, Boolean)\r\n         * - Standard Type (Array, Object, Date)\r\n         * - Custom Class\r\n         * - NGN.DATA.Field\r\n         * - An NGN.DATA.Field configuration\r\n         * - `null` (Defaults to String primitive)\r\n         *\r\n         * ```js\r\n         * fields: {\r\n         *   a: String,\r\n         *   b: Date,\r\n         *   c: MyCustomClass,\r\n         *   d: new NGN.DATA.Field({\r\n         *     required: true,\r\n         *     type: String,\r\n         *     default: 'some default value'\r\n         *   }),\r\n         *   e: {\r\n         *     required: true,\r\n         *     type: String,\r\n         *     default: 'some default value'\r\n         *   },\r\n         *   f: null // Uses default field config (String)\r\n         * }\r\n         * ```\r\n         *\r\n         * Extensions of the NGN.DATA.Field are also supported,\r\n         * such as NGN.DATA.VirtualField and NGN.DATA.Relationship.\r\n         */\r\n        fields: Object.assign({}, NGN.coalesce(cfg.fields, {})),\r\n        knownFieldNames: new Set(),\r\n        invalidFieldNames: new Set(),\r\n        auditFieldNames: NGN.coalesce(cfg.audit, false) ? new Set() : null,\r\n\r\n        /**\r\n         * @property {[NGN.DATA.Rule]|Object}\r\n         * Custom validation rules used to verify the integrity of the entire\r\n         * model. This only applies to the full model. Individual data fields\r\n         * may have their own validators.\r\n         *\r\n         * If an object is specified, it should contain simple key/value pairs,\r\n         * where the key is the descriptive name of the rule and the value is\r\n         * a synchronous callback function that returns a `true`/`false` value.\r\n         * For instance, assume the fields called `price`, `items`, and `tax` exist\r\n         * in the example model below. :\r\n         *\r\n         * ```js\r\n         * {\r\n         *   'Positive Sale': function () {\r\n         *      return (this.price * this.items) > 0\r\n         *   },\r\n         *   'Taxes Applied': function () {\r\n         *      return this.tax > 0\r\n         *   }\r\n         * }\r\n         * ```\r\n         *\r\n         * Alternatively, an array of NGN.DATA.Rule instances may be provided.\r\n         */\r\n        validators: NGN.coalesce(cfg.rules, cfg.rule, cfg.validators),\r\n\r\n        /**\r\n         * @cfgproperty {boolean} [validation=true]\r\n         * Toggle data validation using this.\r\n         */\r\n        validation: NGN.coalesce(cfg.validation, true),\r\n\r\n        /**\r\n         * @cfg {boolean} [autoid=false]\r\n         * If the NGN.DATA.Model#IdentificationField/id is not provided for a record,\r\n         * a unique ID will be automatically generated for it.\r\n         *\r\n         * An NGN.DATA.Store using a model with this set to `true` will never\r\n         * have a duplicate record, since the #id or #IdentificationField will always\r\n         * be unique.\r\n         */\r\n        autoid: NGN.coalesce(cfg.autoid, false),\r\n\r\n        /**\r\n         * @cfg {String} [IdentificationField='id']\r\n         * Setting this allows an attribute of the object to be used as the ID.\r\n         * For example, if an email is the ID of a user, this would be set to\r\n         * `email`.\r\n         */\r\n        IdentificationField: NGN.coalesce(cfg.IdentificationField, cfg.idField, 'id'),\r\n\r\n        /**\r\n         * @cfgproperty {Date|Number} [expires]\r\n         * When this is set to a date/time, the model record will be marked\r\n         * as expired at the specified time/date. If a number is specified\r\n         * (milliseconds), the record will be marked as expired after the\r\n         * specified time period has elapsed. When a record/model is marked as\r\n         * \"expired\", it triggers the `expired` event. By default, expired\r\n         * records/models within an NGN.DATA.Store will be removed from the store.\r\n         *\r\n         * Setting this to any value less than `0` disables expiration.\r\n         * @fires expired\r\n         * Triggered when the model/record expires.\r\n         */\r\n        expiration: null,\r\n\r\n        // Holds a setTimeout method for expiration events.\r\n        expirationTimeout: null,\r\n\r\n        created: Date.now(),\r\n        store: null,\r\n\r\n        /**\r\n         * @cfg {boolean} [audit=false]\r\n         * Enable auditing to support #undo/#redo operations. This creates and\r\n         * manages a NGN.DATA.TransactionLog.\r\n         */\r\n        AUDITABLE: false,\r\n        AUDITLOG: NGN.coalesce(cfg.audit, false) ? new NGN.DATA.TransactionLog() : null,\r\n        AUDIT_HANDLER: function (change) {\r\n          if (change.hasOwnProperty('cursor')) {\r\n            me.METADATA.AUDITLOG.commit(me.METADATA.getAuditMap())\r\n          }\r\n        },\r\n\r\n        EVENTS: new Set([\r\n          'field.update',\r\n          'field.create',\r\n          'field.remove',\r\n          'field.invalid',\r\n          'field.valid',\r\n          'field.hidden',\r\n          'field.unhidden',\r\n          'field.rule.add',\r\n          'field.rule.remove',\r\n          'rule.add',\r\n          'rule.remove',\r\n          'relationship.create',\r\n          'relationship.remove',\r\n          'expired',\r\n          'deleted',\r\n          'reset',\r\n          'load'\r\n        ]),\r\n\r\n        /**\r\n         * An internal method used to apply field definitions to the model.\r\n         * @param  {string} fieldname\r\n         * Name of the field (as applied to the model).\r\n         * @param  {NGN.DATA.Field|Object|Primitive} [fieldConfiguration=null]\r\n         * The configuration to apply. See #addField for details.\r\n         * @param  {Boolean} [suppressEvents=false]\r\n         * Optionally suppress the `field.create` event.\r\n         * @private\r\n         */\r\n        applyField: (field, fieldcfg = null, suppressEvents = false) => {\r\n          // Prevent duplicate fields\r\n          if (this.METADATA.knownFieldNames.has(field)) {\r\n            return NGN.WARN(`Duplicate field \"${field}\" detected.`)\r\n          }\r\n\r\n          // Prevent reserved words\r\n          if (this.hasOwnProperty(field) && field.toLowerCase() !== 'id') {\r\n            throw new ReservedWordError(`\"${field}\" cannot be used as a field name (reserved word).`)\r\n          }\r\n\r\n          // If the field config isn't already an NGN.DATA.Field, create it.\r\n          if (!(fieldcfg instanceof NGN.DATA.Field)) {\r\n            if (fieldcfg instanceof NGN.DATA.Store || fieldcfg instanceof NGN.DATA.Model) {\r\n              if (this.METADATA.IdentificationField === field) {\r\n                throw new InvalidConfigurationError(`\"${field}\" cannot be an ID. Relationship fields cannot be an identification field/attribute.`)\r\n              }\r\n\r\n              this.METADATA.fields[field] = new NGN.DATA.Relationship({\r\n                name: field,\r\n                record: fieldcfg,\r\n                model: this\r\n              })\r\n            } else {\r\n              switch (NGN.typeof(fieldcfg)) {\r\n                // Custom config\r\n                case 'object':\r\n                  fieldcfg.model = this\r\n                  fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\r\n                  fieldcfg.name = field\r\n\r\n                  this.METADATA.fields[field] = new NGN.DATA.Field(fieldcfg)\r\n\r\n                  break\r\n\r\n                // Collection of models\r\n                case 'array':\r\n                  return this.METADATA.applyField(field, fieldcfg[0], suppressEvents)\r\n\r\n                // Type-based cfg.\r\n                default:\r\n                  if (NGN.isFn(fieldcfg) || fieldcfg === null) {\r\n                    if (NGN.isFn(fieldcfg) && ['string', 'number', 'boolean', 'number', 'symbol', 'regexp', 'date', 'array', 'object'].indexOf(NGN.typeof(fieldcfg)) < 0) {\r\n                      this.METADATA.fields[field] = new NGN.DATA.VirtualField({\r\n                        name: field,\r\n                        identifier: this.METADATA.IdentificationField === field,\r\n                        model: this,\r\n                        method: fieldcfg\r\n                      })\r\n\r\n                      break\r\n                    }\r\n\r\n                    this.METADATA.fields[field] = new NGN.DATA.Field({\r\n                      name: field,\r\n                      type: fieldcfg,\r\n                      identifier: this.METADATA.IdentificationField === field,\r\n                      model: this\r\n                    })\r\n\r\n                    break\r\n                  }\r\n\r\n                  this.METADATA.fields[field] = new NGN.DATA.Field({\r\n                    name: field,\r\n                    type: NGN.isFn(fieldcfg) ? fieldcfg : String,\r\n                    identifier: NGN.isFn(fieldcfg)\r\n                      ? false\r\n                      : NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field),\r\n                    model: this\r\n                  })\r\n\r\n                  break\r\n              }\r\n            }\r\n          } else if (fieldcfg.model === null) {\r\n            fieldcfg.name = field\r\n            fieldcfg.identifier = fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\r\n\r\n            this.METADATA.fields[field] = fieldcfg\r\n            this.METADATA.fields[field].model = this\r\n          } else if (fieldcfg.model === this) {\r\n            fieldcfg.identifier = NGN.coalesce(fieldcfg.identifier, this.METADATA.IdentificationField === field)\r\n\r\n            this.METADATA.fields[field] = fieldcfg\r\n          } else if (!(fieldcfg instanceof NGN.DATA.Field)) {\r\n            return NGN.WARN(`The \"${fieldcfg.name}\" field cannot be applied because model is already specified.`)\r\n          }\r\n\r\n          // Add a direct reference to the model.\r\n          Object.defineProperty(this, field, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => this.get(field),\r\n            set: (value) => this.set(field, value)\r\n          })\r\n\r\n          // Enable auditing if necessary.\r\n          if (this.METADATA.AUDITABLE) {\r\n            if (this.METADATA.fields[field].fieldType !== 'virtual') {\r\n              this.METADATA.fields[field].auditable = true\r\n              this.METADATA.auditFieldNames.add(field)\r\n            }\r\n          }\r\n\r\n          // Add the field to the list\r\n          this.METADATA.knownFieldNames.add(field)\r\n\r\n          this.METADATA.fields[field].relay('*', this, 'field.')\r\n\r\n          if (!suppressEvents) {\r\n            this.emit('field.create', this.METADATA.fields[field])\r\n          }\r\n\r\n          return this.METADATA.fields[field]\r\n        },\r\n\r\n        /**\r\n         * An internal helper method for applying changes to the model.\r\n         * @param  {String} [type='undo']\r\n         * This can be `undo` or `redo`.\r\n         * @param  {Number} [count=1]\r\n         * The number of cursor indexes to shift\r\n         * @param  {Boolean} [suppressEvents=false]\r\n         * Indicates events should be suppressed.\r\n         * @private\r\n         */\r\n        applyChange: (type = 'undo', count = 1, suppressEvents = false) => {\r\n          if (!this.METADATA.AUDITABLE) {\r\n            NGN.WARN(`The ${type} operation failed on the ${this.name} model because auditing is disabled.`)\r\n            return\r\n          }\r\n\r\n          this.METADATA.AUDITLOG[type === 'undo' ? 'rollback' : 'advance'](count)\r\n\r\n          let data = this.METADATA.AUDITLOG.currentValue\r\n\r\n          if (data) {\r\n            this.METADATA.auditFieldNames.forEach(fieldname => {\r\n              let field = this.METADATA.fields[fieldname]\r\n              let log = field.METADATA.AUDITLOG\r\n\r\n              if (log.cursor !== data[fieldname]) {\r\n                if (typeof data[fieldname] === 'symbol') {\r\n                  log.cursor = data[fieldname]\r\n                } else {\r\n                  log.cursor = null\r\n                }\r\n\r\n                field.METADATA.setValue(NGN.coalesce(log.currentValue, field.default), suppressEvents, true)\r\n              }\r\n            })\r\n          }\r\n        },\r\n\r\n        /**\r\n         * Generates a key/value representation of the model where\r\n         * each key represents an auditable field and each value is the\r\n         * transaction cursor ID.\r\n         * @return {Object}\r\n         * @private\r\n         */\r\n        getAuditMap: () => {\r\n          let map = {}\r\n\r\n          this.METADATA.auditFieldNames.forEach(field => {\r\n            map[field] = this.METADATA.fields[field].METADATA.AUDITLOG.cursor\r\n          })\r\n\r\n          return map\r\n        },\r\n\r\n        /**\r\n         * Restore the model to a specific audit map (i.e. historical state\r\n         * of multiple fields).\r\n         * @param {Object} map\r\n         * The audit map to restore.\r\n         */\r\n        // restore: (map) => {\r\n        //   let keys = Object.keys(map)\r\n        //\r\n        //   for (let i = 0; i < keys.length; i++) {\r\n        //     if (this.METADATA.knownFieldNames.has(keys[i]) && typeof map[keys[i]] === 'symbol') {\r\n        //       console.log('Has', keys[i])\r\n        //\r\n        //     }\r\n        //   }\r\n        // },\r\n\r\n        // Deprecations\r\n        setSilent: NGN.deprecate(this.setSilentFieldValue, 'setSilent has been deprecated. Use setSilentFieldValue instead.'),\r\n\r\n        /**\r\n         * @cfgproperty {object} fieldmap\r\n         * An object mapping model attribute names to data storage field names.\r\n         *\r\n         * _Example_\r\n         * ```\r\n         * {\r\n         *   ModelFieldName: 'inputName',\r\n         *   father: 'dad',\r\n         *   email: 'eml',\r\n         *   image: 'img',\r\n         *   displayName: 'dn',\r\n         *   firstName: 'gn',\r\n         *   lastName: 'sn',\r\n         *   middleName: 'mn',\r\n         *   gender: 'sex',\r\n         *   dob: 'bd'\r\n         * }\r\n         * ```\r\n         */\r\n        DATAMAP: null\r\n      }),\r\n\r\n      MAP: NGN.get(() => {\r\n        return NGN.coalesce(\r\n          this.METADATA.DATAMAP,\r\n          this.METADATA.store instanceof NGN.DATA.Store\r\n            ? this.METADATA.store.map\r\n            : null\r\n        )\r\n      })\r\n    })\r\n\r\n    if (cfg.fieldmap instanceof NGN.DATA.FieldMap) {\r\n      this.METADATA.DATAMAP = cfg.fieldmap\r\n    } else if (NGN.typeof(cfg.fieldmap) === 'object') {\r\n      this.METADATA.DATAMAP = new NGN.DATA.FieldMap(cfg.fieldmap)\r\n    }\r\n\r\n    // Bubble events to the BUS\r\n    // this.relay('*', NGN.BUS, 'record.')\r\n\r\n    // Add data fields.\r\n    let fields = Object.keys(this.METADATA.fields)\r\n    for (let i = 0; i < fields.length; i++) {\r\n      let name = fields[i]\r\n\r\n      if (this.METADATA.knownFieldNames.has(name)) {\r\n        NGN.WARN(`Duplicate field \"${name}\" detected.`)\r\n      } else {\r\n        // Configure a data field for each configuration.\r\n        this.METADATA.applyField(name, this.METADATA.fields[name], true)\r\n      }\r\n    }\r\n\r\n    // Apply automatic ID's when applicable\r\n    if (this.METADATA.autoid) {\r\n      let autoIdValue = null\r\n\r\n      Object.defineProperty(this.METADATA, 'IdentificationValue', NGN.get(() => {\r\n        if (autoIdValue === null) {\r\n          autoIdValue = NGN.DATA.UTILITY.UUID()\r\n        }\r\n\r\n        return autoIdValue\r\n      }))\r\n    }\r\n\r\n    // Apply auditing if configured\r\n    this.auditable = NGN.coalesce(cfg.audit, false)\r\n\r\n    // Clear any cached checksums when the model changes.\r\n    this.on(['field.update', 'field.create', 'field.delete', 'field.hidden', 'field.unhidden'], () => {\r\n      if (this.METADATA.checksum) {\r\n        this.METADATA.checksum = null\r\n      }\r\n    })\r\n\r\n    // Configure TTL/Expiration\r\n    if (cfg.expires) {\r\n      this.expires = cfg.expires\r\n    }\r\n\r\n    // Configure model-level validation rules\r\n    if (this.METADATA.validators !== null) {\r\n      switch (NGN.typeof(this.METADATA.validators)) {\r\n        // Support key/value objects where the key is the name and value is a function.\r\n        case 'object':\r\n          let keys = Object.keys(this.METADATA.validators)\r\n          let rules = []\r\n\r\n          for (let i = 0; i < keys.length; i++) {\r\n            rules.push(new NGN.DATA.Rule(this.METADATA.validators[keys[i]], keys[i], this))\r\n          }\r\n\r\n          break\r\n\r\n        // Support an array of existing data rules.\r\n        case 'array':\r\n          for (let i = 0; i < this.METADATA.validators.length; i++) {\r\n            if (this.METADATA.validators[i].hasOwnProperty('RULE')) {\r\n              this.METADATA.validators[i].RULE.scope = this\r\n            } else {\r\n              throw new Error(`Invalid data rule configuration for ${this.name} model. Rule #${i} is not a valid NGN.DATA.Rule instance.`)\r\n            }\r\n          }\r\n\r\n          break\r\n\r\n        // Diasllow any other kinds of rules.\r\n        default:\r\n          throw new Error(`Invalid data rule configuration for ${this.name} model. Expected an object or array of NGN.DATA.Rule instances. Received \"${NGN.typeof(this.METADATA.validators)}\"`)\r\n      }\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 17,
        "column": 2
      },
      "end": {
        "line": 521,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "cfg": {
          "type": "argument",
          "label": "cfg",
          "description": null,
          "code": "cfg",
          "start": {
            "line": 17,
            "column": 15
          },
          "end": {
            "line": 17,
            "column": 18
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "constructor",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "serializeFields": {
      "type": "method",
      "label": "serializeFields",
      "description": null,
      "code": "serializeFields (ignoreID = false, ignoreVirtualFields = true) {\r\n    if (this.METADATA.knownFieldNames.size === 0) {\r\n      return {}\r\n    }\r\n\r\n    let fields = this.METADATA.knownFieldNames.keys()\r\n    let result = {}\r\n    let fieldname = fields.next()\r\n\r\n    while (!fieldname.done) {\r\n      let field = this.METADATA.fields[fieldname.value]\r\n\r\n      // Ignore unserializable fields\r\n      if ((\r\n        field.value === undefined ||\r\n        (ignoreID && fieldname.value === this.IdentificationField) ||\r\n        (!field.virtual || (!ignoreVirtualFields && field.virtual))\r\n      )) {\r\n        // Do not serialize hidden values or virtuals\r\n        if (!field.hidden) {\r\n          switch (NGN.typeof(field.value)) {\r\n            case 'array':\r\n            case 'object':\r\n              result[fieldname.value] = NGN.DATA.UTILITY.serialize(field.value)\r\n              break\r\n\r\n            default:\r\n              result[fieldname.value] = field.value\r\n          }\r\n        }\r\n      }\r\n\r\n      fieldname = fields.next()\r\n    }\r\n\r\n    return result\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 774,
        "column": 2
      },
      "end": {
        "line": 810,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "ignoreID": {
          "type": "argument",
          "label": "ignoreID",
          "description": null,
          "code": "ignoreID = false",
          "start": {
            "line": 774,
            "column": 19
          },
          "end": {
            "line": 774,
            "column": 35
          },
          "flags": [],
          "authors": [],
          "default": false,
          "datatype": "boolean",
          "required": false,
          "enum": null
        },
        "ignoreVirtualFields": {
          "type": "argument",
          "label": "ignoreVirtualFields",
          "description": null,
          "code": "ignoreVirtualFields = true",
          "start": {
            "line": 774,
            "column": 37
          },
          "end": {
            "line": 774,
            "column": 63
          },
          "flags": [],
          "authors": [],
          "default": true,
          "datatype": "boolean",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "serialize": {
      "type": "method",
      "label": "serialize",
      "description": null,
      "code": "serialize () {\r\n    return NGN.deprecate(this.serializeFields, 'serialize is now serializeFields. Use NGN.DATA.UTILITY.serialize for generic object serialization.')\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 812,
        "column": 2
      },
      "end": {
        "line": 814,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {},
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "fieldExists": {
      "type": "method",
      "label": "fieldExists",
      "description": "Determines whether a field exists in the model or not.\r\n  \r\n  Name of the field to check for.",
      "code": "fieldExists (field) {\r\n    return this.METADATA.knownFieldNames.has(field)\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 822,
        "column": 2
      },
      "end": {
        "line": 824,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "field": {
          "type": "argument",
          "label": "field",
          "description": "Name of the field to check for.",
          "code": "field",
          "start": {
            "line": 822,
            "column": 15
          },
          "end": {
            "line": 822,
            "column": 20
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        }
      },
      "returnType": "boolean",
      "returnDescription": "",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "get": {
      "type": "method",
      "label": "get",
      "description": "Retrieve the value of the specified field.\r\n  \r\n  Name of the field whose value should be returned.\r\n  \r\n  Returns the value of the field.",
      "code": "get (field) {\r\n    if (field === 'id' || field === 'ID' || field === this.METADATA.IdentificationField) {\r\n      field = this.METADATA.IdentificationField\r\n\r\n      if (this.METADATA.autoid) {\r\n        if (!this.METADATA.knownFieldNames.has(field)) {\r\n          return this.METADATA.IdentificationValue\r\n        } else {\r\n          return NGN.coalesce(this.METADATA.fields[field].value, this.METADATA.IdentificationValue)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.METADATA.knownFieldNames.has(field)) {\r\n      return this.METADATA.fields[field].value\r\n    } else {\r\n      NGN.WARN(`Cannot get \"${field}\". The field is not part of the model.`)\r\n      return undefined\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 833,
        "column": 2
      },
      "end": {
        "line": 852,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "field": {
          "type": "argument",
          "label": "field",
          "description": "Name of the field whose value should be returned.",
          "code": "field",
          "start": {
            "line": 833,
            "column": 7
          },
          "end": {
            "line": 833,
            "column": 12
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        }
      },
      "returnType": "any",
      "returnDescription": "null Returns the value of the field.",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "set": {
      "type": "method",
      "label": "set",
      "description": "Set a new value for the specified field.\r\n  \r\n  Name of the field whose value will be changed.\r\n  \r\n  The new value of the field.",
      "code": "set (field, value) {\r\n    if (field === 'id' || field === 'ID') {\r\n      field = this.METADATA.IdentificationField\r\n    }\r\n\r\n    if (this.METADATA.knownFieldNames.has(field)) {\r\n      this.METADATA.fields[field].value = value\r\n    } else {\r\n      NGN.WARN(`Cannot set \"${field}\". Unrecognized field name.`)\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 861,
        "column": 2
      },
      "end": {
        "line": 871,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "field": {
          "type": "argument",
          "label": "field",
          "description": "Name of the field whose value will be changed.",
          "code": "field",
          "start": {
            "line": 861,
            "column": 7
          },
          "end": {
            "line": 861,
            "column": 12
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "value": {
          "type": "argument",
          "label": "value",
          "description": "The new value of the field.",
          "code": "value",
          "start": {
            "line": 861,
            "column": 14
          },
          "end": {
            "line": 861,
            "column": 19
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": true,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "addField": {
      "type": "method",
      "label": "addField",
      "description": "Add a data field after the initial model definition.\r\n  \r\n  The name of the field.\r\n  \r\n  The field configuration (see cfg#fields for syntax).\r\n  \r\n  Set to `true` to prevent events from firing when the field is added.",
      "code": "addField (name, fieldConfiguration = null, suppressEvents = false) {\r\n    if (name instanceof NGN.DATA.Field) {\r\n      fieldConfiguration = name\r\n      name = fieldConfiguration.name\r\n    } else if (typeof name !== 'string') {\r\n      throw new Error('Cannot add a non-string based field.')\r\n    }\r\n\r\n    this.METADATA.applyField(name, fieldConfiguration, suppressEvents)\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 882,
        "column": 2
      },
      "end": {
        "line": 891,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "name": {
          "type": "argument",
          "label": "fieldname",
          "description": "The name of the field.",
          "code": "name",
          "start": {
            "line": 882,
            "column": 12
          },
          "end": {
            "line": 882,
            "column": 16
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "fieldConfiguration": {
          "type": "argument",
          "label": "fieldConfiguration",
          "description": "The field configuration .",
          "code": "fieldConfiguration = null",
          "start": {
            "line": 882,
            "column": 18
          },
          "end": {
            "line": 882,
            "column": 43
          },
          "flags": [],
          "authors": [],
          "default": "null",
          "datatype": "ngn.data.field|object|primitive",
          "required": false,
          "enum": [
            "see cfg#fields for syntax"
          ]
        },
        "suppressEvents": {
          "type": "argument",
          "label": "suppressEvents",
          "description": "Set to `true` to prevent events from firing when the field is added.",
          "code": "suppressEvents = false",
          "start": {
            "line": 882,
            "column": 45
          },
          "end": {
            "line": 882,
            "column": 67
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        },
        "fieldname": {
          "type": "argument",
          "label": "fieldname",
          "description": "The name of the field.",
          "code": "name",
          "start": {
            "line": 882,
            "column": 12
          },
          "end": {
            "line": 882,
            "column": 16
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "removeField": {
      "type": "method",
      "label": "removeField",
      "description": "Remove a field from the data model.",
      "code": "removeField (name, suppressEvents = false) {\r\n    if (this.METADATA.knownFieldNames.has(name)) {\r\n      this.METADATA.knownFieldNames.delete(name)\r\n      this.METADATA.invalidFieldNames.delete(name)\r\n\r\n      const field = this.METADATA.fields[name]\r\n\r\n      delete this[name]\r\n      delete this.METADATA.fields[name] // eslint-disable-line no-undef\r\n\r\n      // let change = {\r\n      //   action: 'delete',\r\n      //   field: field.name,\r\n      //   value: field,\r\n      //   join: field instanceof NGN.DATA.Relationship\r\n      // }\r\n\r\n      if (!suppressEvents) {\r\n        this.emit('field.remove', field)\r\n      }\r\n\r\n      if (this.METADATA.store !== null) {\r\n        this.METADATA.store.emit(this.METADATA.store.PRIVATE.EVENT.DELETE_RECORD_FIELD, {\r\n          record: this,\r\n          field\r\n        })\r\n      }\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 901,
        "column": 2
      },
      "end": {
        "line": 929,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "name": {
          "type": "argument",
          "label": "name",
          "description": "Name of the field to remove.",
          "code": "name",
          "start": {
            "line": 901,
            "column": 15
          },
          "end": {
            "line": 901,
            "column": 19
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "suppressEvents": {
          "type": "argument",
          "label": "suppressEvents",
          "description": "Set to `true` to prevent events from firing when the field is removed.",
          "code": "suppressEvents = false",
          "start": {
            "line": 901,
            "column": 21
          },
          "end": {
            "line": 901,
            "column": 43
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "getField": {
      "type": "method",
      "label": "getField",
      "description": "Returns the NGN.DATA.Field object for the specified field.\r\n  \r\n  Name of the field to retrieve.\r\n  \r\n  The raw field.",
      "code": "getField (name) {\r\n    if (name.toLowerCase() === 'id' && !this.METADATA.fields.hasOwnProperty(name) && this.METADATA.fields.hasOwnProperty(this.METADATA.IdentificationField)) {\r\n      return this.METADATA.fields[this.METADATA.IdentificationField]\r\n    }\r\n\r\n    return this.METADATA.fields[name]\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 938,
        "column": 2
      },
      "end": {
        "line": 944,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "name": {
          "type": "argument",
          "label": "fieldName",
          "description": "Name of the field to retrieve.",
          "code": "name",
          "start": {
            "line": 938,
            "column": 12
          },
          "end": {
            "line": 938,
            "column": 16
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "fieldName": {
          "type": "argument",
          "label": "fieldName",
          "description": "Name of the field to retrieve.",
          "code": "name",
          "start": {
            "line": 938,
            "column": 12
          },
          "end": {
            "line": 938,
            "column": 16
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        }
      },
      "returnType": "NGN.DATA.Field",
      "returnDescription": "null The raw field.",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "setSilentFieldValue": {
      "type": "method",
      "label": "setSilentFieldValue",
      "description": "A method to set a field value without triggering an update event.\nThis is designed primarily for use with live update proxies to prevent\nendless event loops.",
      "code": "setSilentFieldValue (field, value) {\r\n    this.METADATA.fields[field].silentValue = value\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 957,
        "column": 2
      },
      "end": {
        "line": 959,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "field": {
          "type": "argument",
          "label": "fieldname",
          "description": "The name of the #field to update.",
          "code": "field",
          "start": {
            "line": 957,
            "column": 23
          },
          "end": {
            "line": 957,
            "column": 28
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "value": {
          "type": "argument",
          "label": "value",
          "description": "The new value of the field.",
          "code": "value",
          "start": {
            "line": 957,
            "column": 30
          },
          "end": {
            "line": 957,
            "column": 35
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": true,
          "enum": null
        },
        "fieldname": {
          "type": "argument",
          "label": "fieldname",
          "description": "The name of the #field to update.",
          "code": "field",
          "start": {
            "line": 957,
            "column": 23
          },
          "end": {
            "line": 957,
            "column": 28
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": true
    },
    "undo": {
      "type": "method",
      "label": "undo",
      "description": "A rollback function to undo changes. This operation affects\nthe changelog . To \"undo\" an \"undo\", use #redo.",
      "code": "undo (count = 1, suppressEvents = false) {\r\n    this.METADATA.applyChange('undo', ...arguments)\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 971,
        "column": 2
      },
      "end": {
        "line": 973,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "count": {
          "type": "argument",
          "label": "OperationCount",
          "description": "The number of operations to \"undo\". Defaults to a single operation.",
          "code": "count = 1",
          "start": {
            "line": 971,
            "column": 8
          },
          "end": {
            "line": 971,
            "column": 17
          },
          "flags": [],
          "authors": [],
          "default": "1",
          "datatype": "number",
          "required": false,
          "enum": null
        },
        "suppressEvents": {
          "type": "argument",
          "label": "suppressEvents",
          "description": "Set to `true` to quietly update the value (prevents `update` event from\nfiring).",
          "code": "suppressEvents = false",
          "start": {
            "line": 971,
            "column": 19
          },
          "end": {
            "line": 971,
            "column": 41
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        },
        "OperationCount": {
          "type": "argument",
          "label": "OperationCount",
          "description": "The number of operations to \"undo\". Defaults to a single operation.",
          "code": "count = 1",
          "start": {
            "line": 971,
            "column": 8
          },
          "end": {
            "line": 971,
            "column": 17
          },
          "flags": [],
          "authors": [],
          "default": "1",
          "datatype": "number",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "redo": {
      "type": "method",
      "label": "redo",
      "description": "A function to reapply known changes. This operation affects\nthe changelog .\n\nThe redo operation only works after an undo operation, but before a new\nvalue is committed to the transaction log. In other words, `undo -> redo`\nwill work, but `undo -> update -> redo` will not. For details, see how\nthe NGN.DATA.TransactionLog cursor system works.",
      "code": "redo (count = 1, suppressEvents = false) {\r\n    this.METADATA.applyChange('redo', ...arguments)\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 990,
        "column": 2
      },
      "end": {
        "line": 992,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "count": {
          "type": "argument",
          "label": "OperationCount",
          "description": "The number of operations to \"undo\". Defaults to a single operation.",
          "code": "count = 1",
          "start": {
            "line": 990,
            "column": 8
          },
          "end": {
            "line": 990,
            "column": 17
          },
          "flags": [],
          "authors": [],
          "default": "1",
          "datatype": "number",
          "required": false,
          "enum": null
        },
        "suppressEvents": {
          "type": "argument",
          "label": "suppressEvents",
          "description": "Set to `true` to quietly update the value (prevents `update` event from\nfiring).",
          "code": "suppressEvents = false",
          "start": {
            "line": 990,
            "column": 19
          },
          "end": {
            "line": 990,
            "column": 41
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        },
        "OperationCount": {
          "type": "argument",
          "label": "OperationCount",
          "description": "The number of operations to \"undo\". Defaults to a single operation.",
          "code": "count = 1",
          "start": {
            "line": 990,
            "column": 8
          },
          "end": {
            "line": 990,
            "column": 17
          },
          "flags": [],
          "authors": [],
          "default": "1",
          "datatype": "number",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "load": {
      "type": "method",
      "label": "load",
      "description": "Load a data record.",
      "code": "load (data, suppressEvents = false) {\r\n    if (this.MAP) {\r\n      data = this.MAP.applyMap(data)\r\n    }\r\n\r\n    let keys = Object.keys(data)\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n      if (this.METADATA.knownFieldNames.has(keys[i])) {\r\n        this.METADATA.fields[keys[i]].METADATA.setValue(data[keys[i]], suppressEvents)\r\n      } else {\r\n        NGN.WARN(`Failed to load ${keys[i]} field of ${this.name} model. \"${keys[i]}\" is not a recognized field.`)\r\n      }\r\n    }\r\n\r\n    if (!suppressEvents) {\r\n      this.emit('load')\r\n    }\r\n\r\n    return this\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 1002,
        "column": 2
      },
      "end": {
        "line": 1022,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "data": {
          "type": "argument",
          "label": "data",
          "description": "The data to apply to the model.",
          "code": "data",
          "start": {
            "line": 1002,
            "column": 8
          },
          "end": {
            "line": 1002,
            "column": 12
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "object",
          "required": true,
          "enum": null
        },
        "suppressEvents": {
          "type": "argument",
          "label": "suppressEvents",
          "description": "Do not emit a change event when the data is loaded.",
          "code": "suppressEvents = false",
          "start": {
            "line": 1002,
            "column": 14
          },
          "end": {
            "line": 1002,
            "column": 36
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "next": {
      "type": "method",
      "label": "next",
      "description": "called on a model that is not part of a store, the model itself will be\r\n  returned.\r\n  \n  Retrieve the next record (after this one) from the store.\r\n  This can be used to iterate through a store by calling `model.next()`.\r\n  This is operation acts as a linked list iterator.\r\n  \r\n  The number of records to retrieve. For example, `1` retrieves the next record.\r\n  `2` retrieves the second record after this one. A negative number will\r\n  automatically use the #previous method to retrieve prior records. Setting this\r\n  to `0` will return the current record (i.e. no change).\r\n  \r\n  If this `next` is called on the last record, it will fail. Setting `cycle` to\r\n  `true` will automatically restart the iteration, returning the first record in\r\n  the store.\r\n  \r\n  Returns the next model in the store (after this one.)",
      "code": "next (count = 1, cycle = false) {\r\n    if (count === 0) {\r\n      return this\r\n    }\r\n\r\n    if (this.METADATA.store) {\r\n      if (typeof count === 'boolean') {\r\n        cycle = count\r\n        count = 1\r\n      }\r\n\r\n      return this.METADATA.store.getRecordSibling(this, count, cycle)\r\n    } else {\r\n      NGN.WARN('Attempted to call next() on a model that does not belong to a store.')\r\n      return this\r\n    }\r\n  }",
      "tags": {
        "info": [
          "This method only works on records within a store. If this method is\ncalled on a model that is not part of a store, the model itself will be\nreturned.\n\nRetrieve the next record (after this one) from the store.\nThis can be used to iterate through a store by calling `model.next()`.\nThis is operation acts as a linked list iterator."
        ]
      },
      "exceptions": {},
      "start": {
        "line": 1044,
        "column": 2
      },
      "end": {
        "line": 1060,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "count": {
          "type": "argument",
          "label": "count",
          "description": "The number of records to retrieve. For example, `1` retrieves the next record.\n`2` retrieves the second record after this one. A negative number will\nautomatically use the #previous method to retrieve prior records. Setting this\nto `0` will return the current record .",
          "code": "count = 1",
          "start": {
            "line": 1044,
            "column": 8
          },
          "end": {
            "line": 1044,
            "column": 17
          },
          "flags": [],
          "authors": [],
          "default": "1",
          "datatype": "number",
          "required": false,
          "enum": [
            "i.e. no change"
          ]
        },
        "cycle": {
          "type": "argument",
          "label": "cycle",
          "description": "[description]\nIf this `next` is called on the last record, it will fail. Setting `cycle` to\n`true` will automatically restart the iteration, returning the first record in\nthe store.",
          "code": "cycle = false",
          "start": {
            "line": 1044,
            "column": 19
          },
          "end": {
            "line": 1044,
            "column": 32
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        }
      },
      "returnType": "NGN.DATA.Model",
      "returnDescription": "null Returns the next model in the store",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "previous": {
      "type": "method",
      "label": "previous",
      "description": "Retrieve the previous record (before this one) from the store.\r\n  This can be used to iterate through a store in reverse by calling\r\n  `model.previous()`. This is operation acts as a doubly linked list iterator.\r\n  \n  \r\n  called on a model that is not part of a store, the model itself will be\r\n  returned.\r\n  \r\n  The number of records to retrieve. For example, `1` retrieves the prior record.\r\n  `2` retrieves the second record before this one. A negative number will\r\n  automatically use the #next method to retrieve forward records. Setting this\r\n  to `0` will return the current record (i.e. no change).\r\n  \r\n  If this `next` is called on the first record, it will fail. Setting `cycle` to\r\n  `true` will automatically restart the iteration, returning the last record in\r\n  the store.\r\n  \r\n  Returns the previous model in the store (before this one.)",
      "code": "previous (count = 1, cycle = false) {\r\n    if (count === 0) {\r\n      return this\r\n    }\r\n\r\n    if (this.METADATA.store) {\r\n      if (typeof count === 'boolean') {\r\n        cycle = count\r\n        count = 1\r\n      }\r\n\r\n      return this.METADATA.store.getRecordSibling(this, 0 - count, cycle)\r\n    } else {\r\n      NGN.WARN('Attempted to call previous() on a model that does not belong to a store.')\r\n      return this\r\n    }\r\n  }",
      "tags": {
        "info": [
          "This method only works on records within a store. If this method is\ncalled on a model that is not part of a store, the model itself will be\nreturned."
        ]
      },
      "exceptions": {},
      "start": {
        "line": 1082,
        "column": 2
      },
      "end": {
        "line": 1098,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "count": {
          "type": "argument",
          "label": "count",
          "description": "The number of records to retrieve. For example, `1` retrieves the prior record.\n`2` retrieves the second record before this one. A negative number will\nautomatically use the #next method to retrieve forward records. Setting this\nto `0` will return the current record .",
          "code": "count = 1",
          "start": {
            "line": 1082,
            "column": 12
          },
          "end": {
            "line": 1082,
            "column": 21
          },
          "flags": [],
          "authors": [],
          "default": "1",
          "datatype": "number",
          "required": false,
          "enum": [
            "i.e. no change"
          ]
        },
        "cycle": {
          "type": "argument",
          "label": "cycle",
          "description": "If this `next` is called on the first record, it will fail. Setting `cycle` to\n`true` will automatically restart the iteration, returning the last record in\nthe store.",
          "code": "cycle = false",
          "start": {
            "line": 1082,
            "column": 23
          },
          "end": {
            "line": 1082,
            "column": 36
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        }
      },
      "returnType": "NGN.DATA.Model",
      "returnDescription": "null Returns the previous model in the store",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "destroy": {
      "type": "method",
      "label": "destroy",
      "description": "Remove this model from the NGN.DATA.Store it is a part of.\r\n  \n  \r\n  called on a model that is not part of a store, nothing will happen.",
      "code": "destroy () {\r\n    if (this.METADATA.store) {\r\n      this.METADATA.store.remove(this.OID)\r\n    } else {\r\n      NGN.WARN('Attempted to call remove() on a model that does not belong to a store.')\r\n    }\r\n  }",
      "tags": {
        "info": [
          "This method only works on records within a store. If this method is\ncalled on a model that is not part of a store, nothing will happen."
        ]
      },
      "exceptions": {},
      "start": {
        "line": 1106,
        "column": 2
      },
      "end": {
        "line": 1112,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {},
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": null,
      "override": false,
      "private": false
    },
    "setTTL": {
      "type": "method",
      "label": "setTTL",
      "description": "Set a default time-to-live for event handlers .\nAfter the TTL period elapses, event handlers are removed.\nBy default, there is no TTL (`-1`).",
      "code": "setTTL: NGN.const((ttl = -1) => {\r\n        if (ttl === 0) {\r\n          NGN.WARN('NGN.EventEmitter#TTL cannot be 0.')\r\n          return\r\n        }\r\n\r\n        this.META.defaultTTL = ttl\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 51,
        "column": 6
      },
      "end": {
        "line": 58,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "ttl": {
          "type": "argument",
          "label": "ttl",
          "description": "The number of milliseconds before an event handler is automatically\nremoved. This value may be `-1`  or a value\ngreater than `0`.",
          "code": "setTTL: NGN.const((ttl = -1) => {\r\n        if (ttl === 0) {\r\n          NGN.WARN('NGN.EventEmitter#TTL cannot be 0.')\r\n          return\r\n        }\r\n\r\n        this.META.defaultTTL = ttl\r\n      })",
          "start": {
            "line": 51,
            "column": 6
          },
          "end": {
            "line": 58,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "number",
          "required": true,
          "enum": [
            "no TTL/never expires"
          ]
        },
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": "Name of the event to remove.",
          "code": "off: NGN.public((eventName, handlerFn) => {\r\n        if (NGN.typeof(eventName) === 'array') {\r\n          for (let i = 0; i < eventName.length; i++) {\r\n            this.off(eventName[i], handlerFn)\r\n          }\r\n\r\n          return\r\n        }\r\n\r\n        let l = this.listeners(eventName)\r\n\r\n        if (!NGN.isFn(handlerFn)) {\r\n          return this.clear(eventName)\r\n        }\r\n\r\n        let wrappedHandlerFn = this.wrapEventHandlerWithScope(eventName, handlerFn)\r\n\r\n        if (l.indexOf(wrappedHandlerFn) < 0) {\r\n          for (let i = 0; i < l.length; i++) {\r\n            if (l[i].toString() === wrappedHandlerFn.toString()) {\r\n              this.META.wildcardEvents.delete(eventName)\r\n              // this.removeListener(eventName, handlerFn)\r\n              this.removeListener(eventName, l[i], false)\r\n              break\r\n            }\r\n          }\r\n        } else {\r\n          this.META.wildcardEvents.delete(eventName)\r\n          this.removeListener(eventName, handlerFn)\r\n        }\r\n      })",
          "start": {
            "line": 70,
            "column": 6
          },
          "end": {
            "line": 100,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "handlerFn": {
          "type": "method",
          "label": "handlerFn",
          "description": "The handler function to remove from the event handlers.",
          "code": "@param {function} [handlerFn]\nThe handler function to remove from the event handlers.",
          "start": {
            "line": 70,
            "column": 6
          },
          "end": {
            "line": 100,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false,
          "super": null,
          "override": false,
          "private": false
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#setTTL",
      "override": false,
      "private": false
    },
    "deprecate": {
      "type": "method",
      "label": "deprecate",
      "description": "Provides a deprecation notice for the specified event.\nAutomatically emits the appropriate \"replacement\" event\nif a replacement event is configured. If no replacement\nevent is configured, the deprecation notice will be written\nto the console but no replacement event will be triggered.",
      "code": "deprecate: NGN.const((deprecatedEventName, replacementEventName) => {\r\n        const me = this\r\n\r\n        this.on(deprecatedEventName, function () {\r\n          NGN.WARN(`${deprecatedEventName} is deprecated. ` + (!replacementEventName ? '' : `Use ${replacementEventName} instead.`))\r\n\r\n          if (replacementEventName) {\r\n            let args = NGN.slice(arguments)\r\n\r\n            args.shift()\r\n            args.unshift(replacementEventName)\r\n\r\n            me.emit.apply(me, args)\r\n          }\r\n        })\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 114,
        "column": 6
      },
      "end": {
        "line": 129,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "deprecatedEventName": {
          "type": "argument",
          "label": "deprecatedEventName",
          "description": "The name of the deprecated event.",
          "code": "deprecate: NGN.const((deprecatedEventName, replacementEventName) => {\r\n        const me = this\r\n\r\n        this.on(deprecatedEventName, function () {\r\n          NGN.WARN(`${deprecatedEventName} is deprecated. ` + (!replacementEventName ? '' : `Use ${replacementEventName} instead.`))\r\n\r\n          if (replacementEventName) {\r\n            let args = NGN.slice(arguments)\r\n\r\n            args.shift()\r\n            args.unshift(replacementEventName)\r\n\r\n            me.emit.apply(me, args)\r\n          }\r\n        })\r\n      })",
          "start": {
            "line": 114,
            "column": 6
          },
          "end": {
            "line": 129,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "replacementEventName": {
          "type": "argument",
          "label": "replacementEventName",
          "description": "The name of the new event.",
          "code": "deprecate: NGN.const((deprecatedEventName, replacementEventName) => {\r\n        const me = this\r\n\r\n        this.on(deprecatedEventName, function () {\r\n          NGN.WARN(`${deprecatedEventName} is deprecated. ` + (!replacementEventName ? '' : `Use ${replacementEventName} instead.`))\r\n\r\n          if (replacementEventName) {\r\n            let args = NGN.slice(arguments)\r\n\r\n            args.shift()\r\n            args.unshift(replacementEventName)\r\n\r\n            me.emit.apply(me, args)\r\n          }\r\n        })\r\n      })",
          "start": {
            "line": 114,
            "column": 6
          },
          "end": {
            "line": 129,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#deprecate",
      "override": false,
      "private": false
    },
    "pool": {
      "type": "method",
      "label": "pool",
      "description": "A helper command to create multiple related subscribers\nall at once. This is a convenience function.",
      "code": "pool: NGN.privateconst(function (prefix, group) {\r\n        if (typeof prefix !== 'string') {\r\n          group = prefix\r\n          prefix = ''\r\n        }\r\n\r\n        let pool = {}\r\n\r\n        for (let eventName in group) {\r\n          let topic = `${NGN.coalesce(prefix, '')}${eventName}`\r\n\r\n          if (NGN.isFn(group[eventName])) {\r\n            this.increaseMaxListeners()\r\n\r\n            pool[eventName] = this.on(topic, group[eventName])\r\n          } else if (typeof group[eventName] === 'object') {\r\n            this.pool(`${topic}.`, group[eventName])\r\n          } else {\r\n            NGN.WARN(`${topic} could not be pooled in the event emitter because it's value is not a function.`)\r\n          }\r\n        }\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 158,
        "column": 6
      },
      "end": {
        "line": 179,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "prefix": {
          "type": "argument",
          "label": "prefix",
          "description": null,
          "code": "prefix",
          "start": {
            "line": 158,
            "column": 39
          },
          "end": {
            "line": 158,
            "column": 45
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        },
        "group": {
          "type": "argument",
          "label": "group",
          "description": null,
          "code": "group",
          "start": {
            "line": 158,
            "column": 47
          },
          "end": {
            "line": 158,
            "column": 52
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#pool",
      "override": false,
      "private": true
    },
    "attach": {
      "type": "method",
      "label": "attach",
      "description": "Attach a function to a topic. This can be used\nto forward events in response to asynchronous functions.\n\nFor example:\n\n```js\nmyAsyncDataFetch\n```\n\nThis is the same as:\n\n```js\nmyAsyncCall(function(data){\nNGN.BUS.emit('topicName', data)\n})\n```",
      "code": "attach: NGN.const(function (eventName, preventDefaultAction) {\r\n        preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\r\n\r\n        return (e) => {\r\n          if (preventDefaultAction && !NGN.nodelike) {\r\n            e.preventDefault()\r\n          }\r\n\r\n          this.emit(eventName, ...arguments)\r\n        }\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 207,
        "column": 6
      },
      "end": {
        "line": 217,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": "The name of the event to attach a handler method to.",
          "code": "attach: NGN.const(function (eventName, preventDefaultAction) {\r\n        preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\r\n\r\n        return (e) => {\r\n          if (preventDefaultAction && !NGN.nodelike) {\r\n            e.preventDefault()\r\n          }\r\n\r\n          this.emit(eventName, ...arguments)\r\n        }\r\n      })",
          "start": {
            "line": 207,
            "column": 6
          },
          "end": {
            "line": 217,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "preventDefaultAction": {
          "type": "argument",
          "label": "preventDefaultAction",
          "description": "Setting this to `true` will execute a `event.preventDefault` before\nattaching the handler.",
          "code": "attach: NGN.const(function (eventName, preventDefaultAction) {\r\n        preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\r\n\r\n        return (e) => {\r\n          if (preventDefaultAction && !NGN.nodelike) {\r\n            e.preventDefault()\r\n          }\r\n\r\n          this.emit(eventName, ...arguments)\r\n        }\r\n      })",
          "start": {
            "line": 207,
            "column": 6
          },
          "end": {
            "line": 217,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": [
            ""
          ]
        }
      },
      "returnType": "function",
      "returnDescription": "null Returns a function that will automatically be associated with an event.",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#attach",
      "override": false,
      "private": false
    },
    "increaseMaxListeners": {
      "type": "method",
      "label": "increaseMaxListeners",
      "description": "Increase the number of maximum listeners.",
      "code": "increaseMaxListeners: NGN.private((count = 1) => {\r\n        this.setMaxListeners(this.getMaxListeners() + count)\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 226,
        "column": 6
      },
      "end": {
        "line": 228,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "count": {
          "type": "argument",
          "label": "value ",
          "description": "The number of events the max listener account will be increased by.",
          "code": "count = 1",
          "start": {
            "line": 226,
            "column": 41
          },
          "end": {
            "line": 226,
            "column": 50
          },
          "flags": [],
          "authors": [],
          "default": " 1",
          "datatype": "number",
          "required": false,
          "enum": null
        },
        "value ": {
          "type": "argument",
          "label": "value ",
          "description": "The number of events the max listener account will be increased by.",
          "code": "increaseMaxListeners: NGN.private((count = 1) => {\r\n        this.setMaxListeners(this.getMaxListeners() + count)\r\n      })",
          "start": {
            "line": 226,
            "column": 6
          },
          "end": {
            "line": 228,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": " 1",
          "datatype": "number",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#increaseMaxListeners",
      "override": false,
      "private": true
    },
    "decreaseMaxListeners": {
      "type": "method",
      "label": "decreaseMaxListeners",
      "description": "Decrease the number of maximum listeners.",
      "code": "decreaseMaxListeners: NGN.private((count = 1) => {\r\n        this.setMaxListeners(this.getMaxListeners() - count)\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 237,
        "column": 6
      },
      "end": {
        "line": 239,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "count": {
          "type": "argument",
          "label": "value ",
          "description": "The number of events the max listener account will be decreased by.",
          "code": "count = 1",
          "start": {
            "line": 237,
            "column": 41
          },
          "end": {
            "line": 237,
            "column": 50
          },
          "flags": [],
          "authors": [],
          "default": " 1",
          "datatype": "number",
          "required": false,
          "enum": null
        },
        "value ": {
          "type": "argument",
          "label": "value ",
          "description": "The number of events the max listener account will be decreased by.",
          "code": "decreaseMaxListeners: NGN.private((count = 1) => {\r\n        this.setMaxListeners(this.getMaxListeners() - count)\r\n      })",
          "start": {
            "line": 237,
            "column": 6
          },
          "end": {
            "line": 239,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": " 1",
          "datatype": "number",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#decreaseMaxListeners",
      "override": false,
      "private": true
    },
    "forward": {
      "type": "method",
      "label": "forward",
      "description": "A special subscriber that fires one or more event in response to\nto an event. This is used to bubble events up/down an event chain.\n\nFor example:\n\n```js\nNGN.BUS.forward\n```\nWhen `sourceEvent` is published, the bind method triggers `someEvent` and\n`anotherEvent`, passing the payload object to `someEvent` and\n`anotherEvent` subscribers simultaneously.\n\nTo forward an event to another EventEmitter, see #relay.",
      "code": "forward: NGN.const(function (eventName, triggers, payload) {\r\n        triggers = NGN.forceArray(triggers)\r\n\r\n        let me = this\r\n        let listener = function () {\r\n          let args = NGN.slice(arguments)\r\n\r\n          if (payload) {\r\n            args.push(payload)\r\n          }\r\n\r\n          me.emit(triggers, ...args)\r\n        }\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(eventName, listener)\r\n\r\n        // Provide handle back for removal of topic\r\n        return {\r\n          remove: () => {\r\n            this.decreaseMaxListeners()\r\n            this.off(eventName, listener)\r\n          }\r\n        }\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 265,
        "column": 6
      },
      "end": {
        "line": 289,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": "The name of the event to listen for.",
          "code": "relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\r\n        let eventNameList = NGN.forceArray(eventName)\r\n\r\n        for (let i = 0; i < eventNameList.length; i++) {\r\n          let eventName = eventNameList[i]\r\n\r\n          this.once(eventName, function () {\r\n            if (NGN.typeof(this.event) === 'symbol') {\r\n              if (prefix !== null || postfix !== null) {\r\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\r\n              }\r\n\r\n              targetEmitter.emit(...arguments)\r\n            } else {\r\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\r\n            }\r\n          })\r\n        }\r\n      })",
          "start": {
            "line": 361,
            "column": 6
          },
          "end": {
            "line": 379,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "triggers": {
          "type": "argument",
          "label": "triggeredEvent",
          "description": "An event or array of events to fire in response to the sourceEvent.",
          "code": "triggers",
          "start": {
            "line": 265,
            "column": 46
          },
          "end": {
            "line": 265,
            "column": 54
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string|array",
          "required": true,
          "enum": null
        },
        "payload": {
          "type": "argument",
          "label": "data",
          "description": "Optional data to pass to each bound event handler.",
          "code": "payload",
          "start": {
            "line": 265,
            "column": 56
          },
          "end": {
            "line": 265,
            "column": 63
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": true,
          "enum": null
        },
        "sourceEvent": {
          "type": "argument",
          "label": "sourceEvent",
          "description": "The event to subscribe to.",
          "code": "forward: NGN.const(function (eventName, triggers, payload) {\r\n        triggers = NGN.forceArray(triggers)\r\n\r\n        let me = this\r\n        let listener = function () {\r\n          let args = NGN.slice(arguments)\r\n\r\n          if (payload) {\r\n            args.push(payload)\r\n          }\r\n\r\n          me.emit(triggers, ...args)\r\n        }\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(eventName, listener)\r\n\r\n        // Provide handle back for removal of topic\r\n        return {\r\n          remove: () => {\r\n            this.decreaseMaxListeners()\r\n            this.off(eventName, listener)\r\n          }\r\n        }\r\n      })",
          "start": {
            "line": 265,
            "column": 6
          },
          "end": {
            "line": 289,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "triggeredEvent": {
          "type": "argument",
          "label": "triggeredEvent",
          "description": "An event or array of events to fire in response to the sourceEvent.",
          "code": "forward: NGN.const(function (eventName, triggers, payload) {\r\n        triggers = NGN.forceArray(triggers)\r\n\r\n        let me = this\r\n        let listener = function () {\r\n          let args = NGN.slice(arguments)\r\n\r\n          if (payload) {\r\n            args.push(payload)\r\n          }\r\n\r\n          me.emit(triggers, ...args)\r\n        }\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(eventName, listener)\r\n\r\n        // Provide handle back for removal of topic\r\n        return {\r\n          remove: () => {\r\n            this.decreaseMaxListeners()\r\n            this.off(eventName, listener)\r\n          }\r\n        }\r\n      })",
          "start": {
            "line": 265,
            "column": 6
          },
          "end": {
            "line": 289,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string|array",
          "required": true,
          "enum": null
        },
        "data": {
          "type": "argument",
          "label": "data",
          "description": "Optional data to pass to each bound event handler.",
          "code": "forward: NGN.const(function (eventName, triggers, payload) {\r\n        triggers = NGN.forceArray(triggers)\r\n\r\n        let me = this\r\n        let listener = function () {\r\n          let args = NGN.slice(arguments)\r\n\r\n          if (payload) {\r\n            args.push(payload)\r\n          }\r\n\r\n          me.emit(triggers, ...args)\r\n        }\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(eventName, listener)\r\n\r\n        // Provide handle back for removal of topic\r\n        return {\r\n          remove: () => {\r\n            this.decreaseMaxListeners()\r\n            this.off(eventName, listener)\r\n          }\r\n        }\r\n      })",
          "start": {
            "line": 265,
            "column": 6
          },
          "end": {
            "line": 289,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": true,
          "enum": null
        },
        "targetEmitter": {
          "type": "argument",
          "label": "targetEmitter",
          "description": "The emitter to relay the event to.",
          "code": "relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\r\n        let eventNameList = NGN.forceArray(eventName)\r\n\r\n        for (let i = 0; i < eventNameList.length; i++) {\r\n          let eventName = eventNameList[i]\r\n\r\n          this.once(eventName, function () {\r\n            if (NGN.typeof(this.event) === 'symbol') {\r\n              if (prefix !== null || postfix !== null) {\r\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\r\n              }\r\n\r\n              targetEmitter.emit(...arguments)\r\n            } else {\r\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\r\n            }\r\n          })\r\n        }\r\n      })",
          "start": {
            "line": 361,
            "column": 6
          },
          "end": {
            "line": 379,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "ngn.eventemitter",
          "required": true,
          "enum": null
        },
        "prefix": {
          "type": "argument",
          "label": "prefix",
          "description": "An optional prefix to prepend to the eventName.",
          "code": "relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\r\n        let eventNameList = NGN.forceArray(eventName)\r\n\r\n        for (let i = 0; i < eventNameList.length; i++) {\r\n          let eventName = eventNameList[i]\r\n\r\n          this.once(eventName, function () {\r\n            if (NGN.typeof(this.event) === 'symbol') {\r\n              if (prefix !== null || postfix !== null) {\r\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\r\n              }\r\n\r\n              targetEmitter.emit(...arguments)\r\n            } else {\r\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\r\n            }\r\n          })\r\n        }\r\n      })",
          "start": {
            "line": 361,
            "column": 6
          },
          "end": {
            "line": 379,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": false,
          "enum": null
        },
        "postfix": {
          "type": "argument",
          "label": "postfix",
          "description": "An optional postfix to append to the eventName.",
          "code": "relayOnce: NGN.const(function (eventName, targetEmitter, prefix = null, postfix = null) {\r\n        let eventNameList = NGN.forceArray(eventName)\r\n\r\n        for (let i = 0; i < eventNameList.length; i++) {\r\n          let eventName = eventNameList[i]\r\n\r\n          this.once(eventName, function () {\r\n            if (NGN.typeof(this.event) === 'symbol') {\r\n              if (prefix !== null || postfix !== null) {\r\n                NGN.INFO('Cannot relay a symbol-based event with a prefix/postfix.')\r\n              }\r\n\r\n              targetEmitter.emit(...arguments)\r\n            } else {\r\n              targetEmitter.emit(`${NGN.coalesce(prefix, '')}${this.event}${NGN.coalesce(postfix, '')}`, ...arguments)\r\n            }\r\n          })\r\n        }\r\n      })",
          "start": {
            "line": 361,
            "column": 6
          },
          "end": {
            "line": 379,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": false,
          "enum": null
        }
      },
      "returnType": "Object",
      "returnDescription": "null Returns an object with a single `remove` method.",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#forward",
      "override": false,
      "private": false
    },
    "delayEmit": {
      "type": "method",
      "label": "delayEmit",
      "description": "This method waits for the specified duration, then publishes an\nevent once. This will publish the event only once at the end of the\nwait period, even if the event is triggered multiple times. This can\nbe useful when working with many events triggered in rapid succession.\n\nFor example, an NGN.DATA.Model representing a person may be used to\ntrack a user profile. The NGN.DATA.Model fires an event called `field.update`\nevery time a data field is modified. In many cases, a user may update\nmultiple fields of their profile using a form with a \"Save\" button.\nInstead of generating a new \"save\" \noperation for each field, the publishOnce event can wait until all\nchanges are made before running the save operation.\n\n```js\n// Create a data model representing a person.\nvar Person = new NGN.DATA.Model({....})\n\n// Create a new person record for a user.\nvar user = new Person()\n\n// When the user is modified, save the data.\nuser.on('field.update', function () {\n// Wait 300 milliseconds to trigger the save event\nNGN.BUS.delayEmit('user.save', 300)\n})\n\n// Save the user using an API\nNGN.BUS.on('user.save', function () {\nNGN.NET.put({\nurl: 'https://my.api.com/user',\njson: user.data\n})\n})\n\n// Modify the record attributes (which are blank by default)\nuser.firstname = 'John'\nuser.lastname = 'Doe'\nuser.age = 42\n\n// Make another update 1 second later\nsetTimeout(function () {\nuser.age = 32\n}, 1000)\n```\n\nThe code above sets up a model and record. Then it listens to the record\nfor field updates. Each time it recognizes an update, it queues the \"save\"\nevent. When the queue matures, it fires the `user.save` event.\n\nThe first `field.update` is triggered when `user.firstname = 'John'` runs.\nThis initiates a queue for `user.save`, set to mature in 300 millisenconds.\nNext, a `field.update` is triggered when `user.lastname = 'Doe'` runs.\nThis time, since the queue for `user.save` is already initiated, notthing\nnew happens. Finally, a `field.update` is triggered when `user.age = 42`\nruns. Just like the last one, nothing happens since the `user.save` queue\nis already active.\n\nThe `user.save` queue \"matures\" after 300 milliseconds. This means after\n300 milliseconds have elapsed, the `user.save` event is triggered. In this\nexample, it means the `NGN.NET.put()` code will be executed. As a result,\nall 3 change (firstname, lastname, and age) will be complete before the\nAPI request is executed. The queue is cleared immediately.\n\nThe final update occurs 1 second later (700 milliseconds after the queue\nmatures). This triggers a `field.update`, but since the queue is no\nlonger active, it is re-initiated. 300 milliseconds later, the `user.save`\nevent is fired again, thus executing the API request again (1.3 seconds\nin total).",
      "code": "delayEmit: NGN.const(function (eventName, delay) {\r\n        if (!this.META.queued.hasOwnProperty(eventName)) {\r\n          let args = NGN.slice(arguments)\r\n          args.splice(1, 1)\r\n\r\n          this.META.queued[eventName] = setTimeout(() => {\r\n            delete this.META.queued[eventName]\r\n            this.emit(...args)\r\n          }, delay)\r\n        }\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 458,
        "column": 6
      },
      "end": {
        "line": 468,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": "The event/topic to publish/emit.",
          "code": "delayEmit: NGN.const(function (eventName, delay) {\r\n        if (!this.META.queued.hasOwnProperty(eventName)) {\r\n          let args = NGN.slice(arguments)\r\n          args.splice(1, 1)\r\n\r\n          this.META.queued[eventName] = setTimeout(() => {\r\n            delete this.META.queued[eventName]\r\n            this.emit(...args)\r\n          }, delay)\r\n        }\r\n      })",
          "start": {
            "line": 458,
            "column": 6
          },
          "end": {
            "line": 468,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "delay": {
          "type": "argument",
          "label": "delay",
          "description": "The number of milliseconds to wait before firing the event.",
          "code": "delayEmit: NGN.const(function (eventName, delay) {\r\n        if (!this.META.queued.hasOwnProperty(eventName)) {\r\n          let args = NGN.slice(arguments)\r\n          args.splice(1, 1)\r\n\r\n          this.META.queued[eventName] = setTimeout(() => {\r\n            delete this.META.queued[eventName]\r\n            this.emit(...args)\r\n          }, delay)\r\n        }\r\n      })",
          "start": {
            "line": 458,
            "column": 6
          },
          "end": {
            "line": 468,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": "300",
          "datatype": "number",
          "required": false,
          "enum": null
        },
        "payload": {
          "type": "argument",
          "label": "payload",
          "description": "An optional payload, such as data to be passed to an event handler.",
          "code": "delayEmit: NGN.const(function (eventName, delay) {\r\n        if (!this.META.queued.hasOwnProperty(eventName)) {\r\n          let args = NGN.slice(arguments)\r\n          args.splice(1, 1)\r\n\r\n          this.META.queued[eventName] = setTimeout(() => {\r\n            delete this.META.queued[eventName]\r\n            this.emit(...args)\r\n          }, delay)\r\n        }\r\n      })",
          "start": {
            "line": 458,
            "column": 6
          },
          "end": {
            "line": 468,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#delayEmit",
      "override": false,
      "private": false
    },
    "getInternalCollectionId": {
      "type": "method",
      "label": "getInternalCollectionId",
      "description": "Returns a unique ID for special collections.",
      "code": "getInternalCollectionId: NGN.privateconst(function (collection) {\r\n        return Symbol(collection)\r\n        // let time = (new Date()).getTime().toString()\r\n        // let rand = Math.random().toString()\r\n        // let key = Object.keys(collection).length + 1\r\n        //\r\n        // while (collection.hasOwnProperty(`${key.toString()}${time}${rand}`)) {\r\n        //   key++\r\n        // }\r\n        //\r\n        // return `${key.toString()}${time}${rand}`\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 477,
        "column": 6
      },
      "end": {
        "line": 488,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "collection": {
          "type": "argument",
          "label": "collection",
          "description": "The collection to generate an ID for.",
          "code": "getInternalCollectionId: NGN.privateconst(function (collection) {\r\n        return Symbol(collection)\r\n        // let time = (new Date()).getTime().toString()\r\n        // let rand = Math.random().toString()\r\n        // let key = Object.keys(collection).length + 1\r\n        //\r\n        // while (collection.hasOwnProperty(`${key.toString()}${time}${rand}`)) {\r\n        //   key++\r\n        // }\r\n        //\r\n        // return `${key.toString()}${time}${rand}`\r\n      })",
          "start": {
            "line": 477,
            "column": 6
          },
          "end": {
            "line": 488,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "object",
          "required": true,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#getInternalCollectionId",
      "override": false,
      "private": true
    },
    "handleCollectionTrigger": {
      "type": "method",
      "label": "handleCollectionTrigger",
      "description": "A method to manage #chain event handlers.",
      "code": "handleCollectionTrigger: NGN.privateconst(function (eventName, key) {\r\n        let me = this\r\n\r\n        return function () {\r\n          // Use setTimeout to simulate nextTick\r\n          setTimeout(() => {\r\n            let cq = me.META.collectionQueue\r\n\r\n            if (cq[key]) {\r\n              cq[key].remainingqueue.delete(eventName)\r\n\r\n              if (cq[key].remainingqueue.size === 0) {\r\n                cq[key].remainingqueue = cq[key].masterqueue\r\n\r\n                if (NGN.isFn(cq[key].eventName)) {\r\n                  cq[key].eventName(cq[key].payload)\r\n                } else {\r\n                  me.emit(cq[key].eventName, cq[key].payload)\r\n                }\r\n              }\r\n            }\r\n          }, 0)\r\n        }\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 495,
        "column": 6
      },
      "end": {
        "line": 518,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": null,
          "code": "eventName",
          "start": {
            "line": 495,
            "column": 58
          },
          "end": {
            "line": 495,
            "column": 67
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        },
        "key": {
          "type": "argument",
          "label": "key",
          "description": null,
          "code": "key",
          "start": {
            "line": 495,
            "column": 69
          },
          "end": {
            "line": 495,
            "column": 72
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#handleCollectionTrigger",
      "override": false,
      "private": true
    },
    "funnel": {
      "type": "method",
      "label": "funnel",
      "description": "Emit an event after a collection of unique events have all fired.\nThis can be useful in situations where multiple asynchronous actions\nmust complete before another begins. For example, blending 3\nremote data sources from different API's into a single resultset\ncan be achieved with this.\n\n**Example**\n```js\nlet collection = NGN.BUS.funnel\n\nlet allData = []\n\n// When all of the downloads are done, log them.\nNGN.BUS.on('make.results', () => {\nconsole.log(allData)\n})\n\n// Download the first set of data asynchronously\nNGN.NET.json('http:/download1.com/data.json', (data) => {\nallData.push(data)\nNGN.BUS.emit('download1done')\n})\n\n// Download the second set of data asynchronously\nNGN.NET.json('http:/download2.com/data.json', (data) => {\nallData.push(data)\nNGN.BUS.emit('download2done')\n})\n\n// Download the third set of data asynchronously\nNGN.NET.json('http:/download3.com/data.json', (data) => {\nallData.push(data)\nNGN.BUS.emit('download3done')\n})\n\n// The handler can be removed with the special method:\ncollection.remove()\n```",
      "code": "funnel: NGN.const((eventCollection, triggerEventName, payload = null) => {\r\n        if (NGN.typeof(eventCollection) !== 'array') {\r\n          throw new Error(`NGN.BUS.funnel expected an array of events, but received a(n) ${NGN.typeof(eventCollection)}`)\r\n        }\r\n\r\n        let collection = new Set(eventCollection)\r\n        let key = this.getInternalCollectionId(this.META.collectionQueue)\r\n\r\n        this.META.collectionQueue[key] = {}\r\n\r\n        Object.defineProperties(this.META.collectionQueue[key], {\r\n          masterqueue: NGN.const(new Set(eventCollection)),\r\n          remainingqueue: NGN.private(collection),\r\n          eventName: NGN.const(triggerEventName),\r\n          remove: NGN.const(() => {\r\n            this.META.collectionQueue[key].masterqueue.forEach(event => {\r\n              this.off(event, this.handleCollectionTrigger(event, key))\r\n            })\r\n\r\n            this.decreaseMaxListeners(this.META.collectionQueue[key].masterqueue.size)\r\n\r\n            delete this.META.collectionQueue[key]\r\n          }),\r\n          payload: NGN.const(payload)\r\n        })\r\n\r\n        this.increaseMaxListeners(collection.size)\r\n\r\n        collection.forEach(event => {\r\n          this.on(event, this.handleCollectionTrigger(event, key))\r\n        })\r\n\r\n        return this.META.collectionQueue[key]\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 581,
        "column": 6
      },
      "end": {
        "line": 614,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "triggerEventName": {
          "type": "argument",
          "label": "payload",
          "description": "An optional payload delivered to the #triggerEventName.",
          "code": "triggerEventName",
          "start": {
            "line": 581,
            "column": 25
          },
          "end": {
            "line": 581,
            "column": 40
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": false,
          "enum": null
        },
        "payload": {
          "type": "argument",
          "label": "payload",
          "description": "An optional payload delivered to the #triggerEventName.",
          "code": "funnel: NGN.const((eventCollection, triggerEventName, payload = null) => {\r\n        if (NGN.typeof(eventCollection) !== 'array') {\r\n          throw new Error(`NGN.BUS.funnel expected an array of events, but received a(n) ${NGN.typeof(eventCollection)}`)\r\n        }\r\n\r\n        let collection = new Set(eventCollection)\r\n        let key = this.getInternalCollectionId(this.META.collectionQueue)\r\n\r\n        this.META.collectionQueue[key] = {}\r\n\r\n        Object.defineProperties(this.META.collectionQueue[key], {\r\n          masterqueue: NGN.const(new Set(eventCollection)),\r\n          remainingqueue: NGN.private(collection),\r\n          eventName: NGN.const(triggerEventName),\r\n          remove: NGN.const(() => {\r\n            this.META.collectionQueue[key].masterqueue.forEach(event => {\r\n              this.off(event, this.handleCollectionTrigger(event, key))\r\n            })\r\n\r\n            this.decreaseMaxListeners(this.META.collectionQueue[key].masterqueue.size)\r\n\r\n            delete this.META.collectionQueue[key]\r\n          }),\r\n          payload: NGN.const(payload)\r\n        })\r\n\r\n        this.increaseMaxListeners(collection.size)\r\n\r\n        collection.forEach(event => {\r\n          this.on(event, this.handleCollectionTrigger(event, key))\r\n        })\r\n\r\n        return this.META.collectionQueue[key]\r\n      })",
          "start": {
            "line": 581,
            "column": 6
          },
          "end": {
            "line": 614,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": false,
          "enum": null
        },
        "eventCollection": {
          "type": "argument",
          "label": "eventCollection",
          "description": "An array of events. Once _all_ of these events have fired,\nthe triggerEventName will be fired.",
          "code": "funnel: NGN.const((eventCollection, triggerEventName, payload = null) => {\r\n        if (NGN.typeof(eventCollection) !== 'array') {\r\n          throw new Error(`NGN.BUS.funnel expected an array of events, but received a(n) ${NGN.typeof(eventCollection)}`)\r\n        }\r\n\r\n        let collection = new Set(eventCollection)\r\n        let key = this.getInternalCollectionId(this.META.collectionQueue)\r\n\r\n        this.META.collectionQueue[key] = {}\r\n\r\n        Object.defineProperties(this.META.collectionQueue[key], {\r\n          masterqueue: NGN.const(new Set(eventCollection)),\r\n          remainingqueue: NGN.private(collection),\r\n          eventName: NGN.const(triggerEventName),\r\n          remove: NGN.const(() => {\r\n            this.META.collectionQueue[key].masterqueue.forEach(event => {\r\n              this.off(event, this.handleCollectionTrigger(event, key))\r\n            })\r\n\r\n            this.decreaseMaxListeners(this.META.collectionQueue[key].masterqueue.size)\r\n\r\n            delete this.META.collectionQueue[key]\r\n          }),\r\n          payload: NGN.const(payload)\r\n        })\r\n\r\n        this.increaseMaxListeners(collection.size)\r\n\r\n        collection.forEach(event => {\r\n          this.on(event, this.handleCollectionTrigger(event, key))\r\n        })\r\n\r\n        return this.META.collectionQueue[key]\r\n      })",
          "start": {
            "line": 581,
            "column": 6
          },
          "end": {
            "line": 614,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "array",
          "required": true,
          "enum": null
        }
      },
      "returnType": "object",
      "returnDescription": "collection Provides the key/value configuration of the collection.\n```js\n{\nmasterqueue: ['event1', 'event2', 'etc'], // The original event array \nremainingqueue: [...], // The events the BUS is still waiting for before firing the trigger event.\neventName: 'triggeredEventName', // Name of the event triggered after the remaining elements are flushed.\npayload: 'anything', // OPTIONAL\nremove: [Function]\n}\n```",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#funnel",
      "override": false,
      "private": false
    },
    "funnelOnce": {
      "type": "method",
      "label": "funnelOnce",
      "description": "This provides the same functionality as #funnel, but\nremoves the listener after the resultant event has fired.\nSee #funnel for detailed usage.",
      "code": "funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\r\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\r\n        // let funnelClosureEvent = Symbol(triggerEventName)\r\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\r\n\r\n        this.increaseMaxListeners()\r\n        this.once(funnelClosureEvent, () => {\r\n          collection.remove()\r\n          collection = null\r\n          this.emit(triggerEventName, payload)\r\n        })\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 631,
        "column": 6
      },
      "end": {
        "line": 642,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "eventCollection": {
          "type": "argument",
          "label": "eventCollection",
          "description": "An array of events. Once _all_ of these events have fired,\nthe triggerEventName will be fired.",
          "code": "funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\r\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\r\n        // let funnelClosureEvent = Symbol(triggerEventName)\r\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\r\n\r\n        this.increaseMaxListeners()\r\n        this.once(funnelClosureEvent, () => {\r\n          collection.remove()\r\n          collection = null\r\n          this.emit(triggerEventName, payload)\r\n        })\r\n      })",
          "start": {
            "line": 631,
            "column": 6
          },
          "end": {
            "line": 642,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "array",
          "required": true,
          "enum": null
        },
        "triggerEventName": {
          "type": "argument",
          "label": "triggerEventName",
          "description": "The name of the event triggered after the collection has completed.",
          "code": "funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\r\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\r\n        // let funnelClosureEvent = Symbol(triggerEventName)\r\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\r\n\r\n        this.increaseMaxListeners()\r\n        this.once(funnelClosureEvent, () => {\r\n          collection.remove()\r\n          collection = null\r\n          this.emit(triggerEventName, payload)\r\n        })\r\n      })",
          "start": {
            "line": 631,
            "column": 6
          },
          "end": {
            "line": 642,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "payload": {
          "type": "argument",
          "label": "payload",
          "description": "An optional payload delivered to the #triggerEventName.",
          "code": "funnelOnce: NGN.const((eventCollection, triggerEventName, payload = null) => {\r\n        let funnelClosureEvent = `::NGNFUNNEL::${(new Date()).getTime()}::${triggerEventName}`\r\n        // let funnelClosureEvent = Symbol(triggerEventName)\r\n        let collection = this.funnel(eventCollection, funnelClosureEvent, payload)\r\n\r\n        this.increaseMaxListeners()\r\n        this.once(funnelClosureEvent, () => {\r\n          collection.remove()\r\n          collection = null\r\n          this.emit(triggerEventName, payload)\r\n        })\r\n      })",
          "start": {
            "line": 631,
            "column": 6
          },
          "end": {
            "line": 642,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": false,
          "enum": null
        }
      },
      "returnType": "object",
      "returnDescription": "collection Provides the key/value configuration of the collection.",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#funnelOnce",
      "override": false,
      "private": false
    },
    "threshold": {
      "type": "method",
      "label": "threshold",
      "description": "After an event is fired a predetermined number of times ,\ntrigger another event or function.\n\nFor example:\n\n```js\nNGN.BUS.threshold('push.my.button', 3, 'annoyed')\n\nNGN.BUS.on('annoyed', function () {\nconsole.log('We apologize for the slow response, but excessive clicking will not speed up the process.')\n})\n\ndocument.getElementById('#myButton').addEventListener('click', NGN.BUS.attach('push.my.button'))\n```\n\nOnce the threshold is exceeded, the final event will be triggered and\nthe threshold will be reset. Using the example above, this means\nclicking 3 times on `#myButton` would trigger the `annoyed` event ONCE,\n6 times triggers `annoyed` TWICE, 9 times triggers `annoyed` THREE times, etc.",
      "code": "threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\r\n        if (typeof thresholdEventName !== 'string') {\r\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\r\n        }\r\n\r\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\r\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\r\n\r\n        this.META.thresholdQueue[key] = {}\r\n\r\n        Object.defineProperties(this.META.thresholdQueue[key], {\r\n          key: NGN.const(key),\r\n          eventName: NGN.const(thresholdEventName),\r\n          limit: NGN.const(limit),\r\n          count: NGN.private(0),\r\n          finalEventName: NGN.const(finalEventName),\r\n          remove: NGN.const(() => {\r\n            let event = this.META.thresholdQueue[key].eventName\r\n\r\n            delete this.META.thresholdQueue[key]\r\n\r\n            this.decreaseMaxListeners()\r\n            this.off(event, this.handleThresholdTrigger(key))\r\n          }),\r\n          payload: NGN.const(payload)\r\n        })\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\r\n\r\n        return this.META.thresholdQueue[key]\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 681,
        "column": 6
      },
      "end": {
        "line": 712,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "thresholdEventName": {
          "type": "argument",
          "label": "thresholdEventName",
          "description": "The name of the event to count.",
          "code": "threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\r\n        if (typeof thresholdEventName !== 'string') {\r\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\r\n        }\r\n\r\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\r\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\r\n\r\n        this.META.thresholdQueue[key] = {}\r\n\r\n        Object.defineProperties(this.META.thresholdQueue[key], {\r\n          key: NGN.const(key),\r\n          eventName: NGN.const(thresholdEventName),\r\n          limit: NGN.const(limit),\r\n          count: NGN.private(0),\r\n          finalEventName: NGN.const(finalEventName),\r\n          remove: NGN.const(() => {\r\n            let event = this.META.thresholdQueue[key].eventName\r\n\r\n            delete this.META.thresholdQueue[key]\r\n\r\n            this.decreaseMaxListeners()\r\n            this.off(event, this.handleThresholdTrigger(key))\r\n          }),\r\n          payload: NGN.const(payload)\r\n        })\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\r\n\r\n        return this.META.thresholdQueue[key]\r\n      })",
          "start": {
            "line": 681,
            "column": 6
          },
          "end": {
            "line": 712,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "finalEventName": {
          "type": "argument",
          "label": "payload",
          "description": "An optional payload to send to the finalEvent handler.",
          "code": "finalEventName",
          "start": {
            "line": 681,
            "column": 57
          },
          "end": {
            "line": 681,
            "column": 62
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": false,
          "enum": [
            "s"
          ]
        },
        "payload": {
          "type": "argument",
          "label": "payload",
          "description": "An optional payload to send to the finalEvent handler.",
          "code": "threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\r\n        if (typeof thresholdEventName !== 'string') {\r\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\r\n        }\r\n\r\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\r\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\r\n\r\n        this.META.thresholdQueue[key] = {}\r\n\r\n        Object.defineProperties(this.META.thresholdQueue[key], {\r\n          key: NGN.const(key),\r\n          eventName: NGN.const(thresholdEventName),\r\n          limit: NGN.const(limit),\r\n          count: NGN.private(0),\r\n          finalEventName: NGN.const(finalEventName),\r\n          remove: NGN.const(() => {\r\n            let event = this.META.thresholdQueue[key].eventName\r\n\r\n            delete this.META.thresholdQueue[key]\r\n\r\n            this.decreaseMaxListeners()\r\n            this.off(event, this.handleThresholdTrigger(key))\r\n          }),\r\n          payload: NGN.const(payload)\r\n        })\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\r\n\r\n        return this.META.thresholdQueue[key]\r\n      })",
          "start": {
            "line": 681,
            "column": 6
          },
          "end": {
            "line": 712,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": false,
          "enum": [
            "s"
          ]
        },
        "limit": {
          "type": "argument",
          "label": "limit",
          "description": "The number of occurrances allowed until the final event is triggered.\nThe event will be triggered at the threshold. For example, if the limit\nis `3`, the finalEvent will be triggered the 3rd time thresholdEventName is\nfired.",
          "code": "threshold: NGN.const(function (thresholdEventName, limit, finalEventName, payload = null) {\r\n        if (typeof thresholdEventName !== 'string') {\r\n          throw new Error('The threshold event name must be a string (received ' + (typeof thresholdEventName) + ')')\r\n        }\r\n\r\n        // let key = `${this.getInternalCollectionId(this.META.thresholdQueue)}${limit.toString()}`\r\n        let key = this.getInternalCollectionId(this.META.thresholdQueue)\r\n\r\n        this.META.thresholdQueue[key] = {}\r\n\r\n        Object.defineProperties(this.META.thresholdQueue[key], {\r\n          key: NGN.const(key),\r\n          eventName: NGN.const(thresholdEventName),\r\n          limit: NGN.const(limit),\r\n          count: NGN.private(0),\r\n          finalEventName: NGN.const(finalEventName),\r\n          remove: NGN.const(() => {\r\n            let event = this.META.thresholdQueue[key].eventName\r\n\r\n            delete this.META.thresholdQueue[key]\r\n\r\n            this.decreaseMaxListeners()\r\n            this.off(event, this.handleThresholdTrigger(key))\r\n          }),\r\n          payload: NGN.const(payload)\r\n        })\r\n\r\n        this.increaseMaxListeners()\r\n        this.on(thresholdEventName, this.handleThresholdTrigger(key))\r\n\r\n        return this.META.thresholdQueue[key]\r\n      })",
          "start": {
            "line": 681,
            "column": 6
          },
          "end": {
            "line": 712,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "number",
          "required": true,
          "enum": null
        }
      },
      "returnType": "object",
      "returnDescription": "null Returns an object that can be used to remove the threshold.",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#threshold",
      "override": false,
      "private": false
    },
    "handleThresholdTrigger": {
      "type": "method",
      "label": "handleThresholdTrigger",
      "description": "A method to manage #threshold event handlers.",
      "code": "handleThresholdTrigger: NGN.const(function (key) {\r\n        let me = this\r\n        return function () {\r\n          // Use setTimeout to simulate nextTick\r\n          setTimeout(() => {\r\n            if (me.META.thresholdQueue.hasOwnProperty(key)) {\r\n              me.META.thresholdQueue[key].count++\r\n              if (me.META.thresholdQueue[key].count === me.META.thresholdQueue[key].limit) {\r\n                if (NGN.isFn(me.META.thresholdQueue[key].finalEventName)) {\r\n                  me.META.thresholdQueue[key].finalEventName(me.META.thresholdQueue[key].payload)\r\n                } else {\r\n                  me.emit(me.META.thresholdQueue[key].finalEventName, me.META.thresholdQueue[key].payload)\r\n                }\r\n\r\n                // This if statement is required in case the event is removed\r\n                // during the reset process.\r\n                if (me.META.thresholdQueue.hasOwnProperty(key)) {\r\n                  me.META.thresholdQueue[key].count = 0\r\n                }\r\n              }\r\n            }\r\n          }, 0)\r\n        }\r\n      })",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 730,
        "column": 6
      },
      "end": {
        "line": 753,
        "column": 8
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "key": {
          "type": "argument",
          "label": "key",
          "description": null,
          "code": "key",
          "start": {
            "line": 730,
            "column": 50
          },
          "end": {
            "line": 730,
            "column": 53
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        },
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": "The name of the event being scoped.",
          "code": "applyScope: NGN.privateconst((args) => {\r\n        if (NGN.nodelike && args.length > 1) {\r\n          if (args[args.length - 1].listener) {\r\n            args[args.length - 1].listener = this.wrapEventHandlerWithScope(\r\n              args[0],\r\n              args[args.length - 1].listener\r\n            )\r\n          } else {\r\n            args[args.length - 1] = this.wrapEventHandlerWithScope(\r\n              args[0],\r\n              args[args.length - 1]\r\n            )\r\n          }\r\n        }\r\n      })",
          "start": {
            "line": 791,
            "column": 6
          },
          "end": {
            "line": 805,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "handlerFn": {
          "type": "method",
          "label": "handlerFn",
          "description": "The handler function.",
          "code": "@param {function} handlerFn\nThe handler function.",
          "start": {
            "line": 763,
            "column": 6
          },
          "end": {
            "line": 781,
            "column": 8
          },
          "flags": [],
          "authors": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false,
          "super": null,
          "override": false,
          "private": false
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "init",
      "computed": false,
      "super": "NGN.EventEmitter#handleThresholdTrigger",
      "override": false,
      "private": false
    },
    "clear": {
      "type": "method",
      "label": "clear",
      "description": "Remove all event handlers from the EventEmitter (both regular and adhoc).\r\n  This is a shortcut for #removeAllListeners.",
      "code": "clear () {\r\n    let events = NGN.slice(arguments)\r\n\r\n    if (events.length === 0) {\r\n      this.META.wildcardEvents.clear()\r\n\r\n      let symbolEvents = []\r\n\r\n      if (NGN.nodelike) {\r\n        symbolEvents = Object.getOwnPropertySymbols(this._events)\r\n      } else {\r\n        symbolEvents = Object.getOwnPropertySymbols(this.adhoc)\r\n        symbolEvents = symbolEvents.concat(Object.getOwnPropertySymbols(this.handlers))\r\n      }\r\n\r\n      for (let i = 0; i < symbolEvents.length; i++) {\r\n        this.removeAllListeners(symbolEvents[i])\r\n      }\r\n\r\n      return this.removeAllListeners()\r\n    }\r\n\r\n    for (let i = 0; i < events.length; i++) {\r\n      this.META.wildcardEvents.delete(events[i])\r\n      this.removeAllListeners(events[i])\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 813,
        "column": 2
      },
      "end": {
        "line": 839,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {},
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": "NGN.EventEmitter#clear",
      "override": false,
      "private": false
    },
    "eventHandler": {
      "type": "method",
      "label": "eventHandler",
      "description": "Internal method used to handle TTL and wildcard management.",
      "code": "eventHandler (eventName, callback, ttl, prepend = false) {\r\n    if (NGN.typeof(ttl) === 'boolean') {\r\n      prepend = ttl\r\n      ttl = this.META.defaultTTL\r\n    }\r\n\r\n    if (ttl === undefined) {\r\n      ttl = this.META.defaultTTL\r\n    }\r\n\r\n    if (ttl > 0) {\r\n      setTimeout(() => this.off(eventName, callback), ttl)\r\n    }\r\n\r\n    if (typeof eventName === 'string' && eventName.indexOf('*') >= 0) {\r\n      this.META.wildcardEvents.add(eventName)\r\n    }\r\n\r\n    return prepend\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 845,
        "column": 2
      },
      "end": {
        "line": 864,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": null,
          "code": "eventName",
          "start": {
            "line": 845,
            "column": 16
          },
          "end": {
            "line": 845,
            "column": 25
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        },
        "callback": {
          "type": "argument",
          "label": "callback",
          "description": null,
          "code": "callback",
          "start": {
            "line": 845,
            "column": 27
          },
          "end": {
            "line": 845,
            "column": 35
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        },
        "ttl": {
          "type": "argument",
          "label": "ttl",
          "description": null,
          "code": "ttl",
          "start": {
            "line": 845,
            "column": 37
          },
          "end": {
            "line": 845,
            "column": 40
          },
          "flags": [],
          "authors": [],
          "datatype": "any",
          "required": true,
          "enum": null
        },
        "prepend": {
          "type": "argument",
          "label": "prepend",
          "description": null,
          "code": "prepend = false",
          "start": {
            "line": 845,
            "column": 42
          },
          "end": {
            "line": 845,
            "column": 57
          },
          "flags": [],
          "authors": [],
          "default": false,
          "datatype": "boolean",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": "NGN.EventEmitter#eventHandler",
      "override": false,
      "private": true
    },
    "on": {
      "type": "method",
      "label": "on",
      "description": "Create a new event handler for the specified event.",
      "code": "on (eventName, callback, ttl, prepend = false) {\r\n    if (NGN.typeof(eventName) === 'array') {\r\n      for (let i = 0; i < eventName.length; i++) {\r\n        this.on(eventName[i], callback, ttl, prepend)\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    if (this.eventHandler(...arguments)) {\r\n      this.prependListener(eventName, callback)\r\n    } else {\r\n      this.addListener(eventName, callback)\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 884,
        "column": 2
      },
      "end": {
        "line": 898,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": "Name of the event to listen for.\nIf an object is passed, this method will automatically setup a #pool.",
          "code": "eventName",
          "start": {
            "line": 884,
            "column": 6
          },
          "end": {
            "line": 884,
            "column": 15
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string|string[]|object",
          "required": true,
          "enum": null
        },
        "handler": {
          "type": "method",
          "label": "handler",
          "description": "The method responsible for responding to the event.\nThis is ignored if eventName is an object.",
          "code": "@param {function} handler\nThe method responsible for responding to the event.\nThis is ignored if eventName is an object.",
          "start": {
            "line": 884,
            "column": 2
          },
          "end": {
            "line": 898,
            "column": 3
          },
          "flags": [],
          "authors": [],
          "arguments": {},
          "returnType": "void",
          "returnDescription": "void",
          "kind": null,
          "generator": false,
          "static": false,
          "computed": false,
          "async": false,
          "super": null,
          "override": false,
          "private": false
        },
        "ttl": {
          "type": "argument",
          "label": "TTL",
          "description": "Time-To-Live is the number of milliseconds before the event handler\nis automatically removed. This is useful for automatically cleaning\nup limited-life event handlers.",
          "code": "ttl",
          "start": {
            "line": 884,
            "column": 27
          },
          "end": {
            "line": 884,
            "column": 30
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "number",
          "required": false,
          "enum": null
        },
        "prepend": {
          "type": "argument",
          "label": "prepend",
          "description": "When set to `true`, the event is added to the beginning of\nthe processing list instead of the end.\nThis is ignored if eventName is an object.",
          "code": "prepend = false",
          "start": {
            "line": 884,
            "column": 32
          },
          "end": {
            "line": 884,
            "column": 47
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        },
        "TTL": {
          "type": "argument",
          "label": "TTL",
          "description": "Time-To-Live is the number of milliseconds before the event handler\nis automatically removed. This is useful for automatically cleaning\nup limited-life event handlers.",
          "code": "ttl",
          "start": {
            "line": 884,
            "column": 27
          },
          "end": {
            "line": 884,
            "column": 30
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "number",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": "NGN.EventEmitter#on",
      "override": false,
      "private": false
    },
    "once": {
      "type": "method",
      "label": "once",
      "description": "Create a new event handler for the specified event. The\nhandler will be removed immediately after it is executed. This\neffectively listens for an event to happen once and only once\nbefore the handler is destroyed.",
      "code": "once (eventName, callback, ttl, prepend = false) {\r\n    if (NGN.typeof(eventName) === 'array') {\r\n      for (let i = 0; i < eventName.length; i++) {\r\n        this.once(eventName[i], callback, ttl, prepend)\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    if (this.eventHandler(...arguments)) {\r\n      this.prependOnceListener(eventName, callback)\r\n    } else {\r\n      super.once(eventName, this.wrapEventHandlerWithScope(eventName, callback))\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 914,
        "column": 2
      },
      "end": {
        "line": 928,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": "Name of the event to listen for.",
          "code": "eventName",
          "start": {
            "line": 914,
            "column": 8
          },
          "end": {
            "line": 914,
            "column": 17
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string",
          "required": true,
          "enum": null
        },
        "callback": {
          "type": "argument",
          "label": "handler",
          "description": "The method responsible for responding to the event.",
          "code": "callback",
          "start": {
            "line": 914,
            "column": 19
          },
          "end": {
            "line": 914,
            "column": 27
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "function",
          "required": true,
          "enum": null
        },
        "ttl": {
          "type": "argument",
          "label": "prepend",
          "description": "When set to `true`, the event is added to the beginning of\nthe processing list instead of the end.",
          "code": "ttl",
          "start": {
            "line": 914,
            "column": 29
          },
          "end": {
            "line": 914,
            "column": 32
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        },
        "prepend": {
          "type": "argument",
          "label": "prepend",
          "description": "When set to `true`, the event is added to the beginning of\nthe processing list instead of the end.",
          "code": "ttl",
          "start": {
            "line": 914,
            "column": 29
          },
          "end": {
            "line": 914,
            "column": 32
          },
          "flags": [],
          "authors": [],
          "default": "false",
          "datatype": "boolean",
          "required": false,
          "enum": null
        },
        "handler": {
          "type": "argument",
          "label": "handler",
          "description": "The method responsible for responding to the event.",
          "code": "callback",
          "start": {
            "line": 914,
            "column": 19
          },
          "end": {
            "line": 914,
            "column": 27
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "function",
          "required": true,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": "NGN.EventEmitter#once",
      "override": false,
      "private": false
    },
    "prependListener": {
      "type": "method",
      "label": "prependListener",
      "description": null,
      "code": "prependListener () {\r\n    this.applyScope(arguments)\r\n    super.prependListener(...arguments)\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 931,
        "column": 2
      },
      "end": {
        "line": 934,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {},
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": "NGN.EventEmitter#prependListener",
      "override": false,
      "private": false
    },
    "prependOnceListener": {
      "type": "method",
      "label": "prependOnceListener",
      "description": null,
      "code": "prependOnceListener () {\r\n    this.applyScope(arguments)\r\n    super.prependOnceListener(...arguments)\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 936,
        "column": 2
      },
      "end": {
        "line": 939,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {},
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": "NGN.EventEmitter#prependOnceListener",
      "override": false,
      "private": false
    },
    "addListener": {
      "type": "method",
      "label": "addListener",
      "description": null,
      "code": "addListener () {\r\n    this.applyScope(arguments)\r\n    super.addListener(...arguments)\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 941,
        "column": 2
      },
      "end": {
        "line": 944,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {},
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": "NGN.EventEmitter#addListener",
      "override": false,
      "private": false
    },
    "removeListener": {
      "type": "method",
      "label": "removeListener",
      "description": null,
      "code": "removeListener () {\r\n    if (arguments[arguments.length - 1] !== true) {\r\n      this.applyScope(arguments)\r\n    }\r\n\r\n    super.removeListener(...arguments)\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 946,
        "column": 2
      },
      "end": {
        "line": 952,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {},
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": "NGN.EventEmitter#removeListener",
      "override": false,
      "private": false
    },
    "emit": {
      "type": "method",
      "label": "emit",
      "description": "Emits an event.",
      "code": "emit () {\r\n    if (NGN.typeof(arguments[0]) === 'array') {\r\n      let args = NGN.slice(arguments)\r\n      let eventNames = args.shift()\r\n\r\n      for (let i = 0; i < eventNames.length; i++) {\r\n        this.emit(eventNames[i], ...args)\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    // This catches non-string event names. NGN internally uses Symbols\r\n    // for the NGN.WARN/INFO/ERROR event names to prevent name collisions.\r\n    // This check provides support for these special events. These types\r\n    // of events will never have wildcards.\r\n    if (!NGN.nodelike || !arguments[0] || this.META.wildcardEvents.size === 0) {\r\n      super.emit(...arguments)\r\n      return\r\n    }\r\n\r\n    if (NGN.nodelike && typeof arguments[0] === 'symbol') {\r\n      super.emit(...arguments)\r\n      return\r\n    }\r\n\r\n    /**\r\n     * The NGN browser-based event emitter supports wildcards natively, but\r\n     * Node.js does not. This adds simple wildcard support for Node. The\r\n     * only wildcard character supported at this time is `*`. This feature\r\n     * will check the event name for the existance of a wildcard. If a\r\n     * wilcard character is present, the internally-maintained list of\r\n     * wildcard events is checked to see if it's a known event. If none\r\n     * of these checks pass, the standard event emitter is used, otherwise\r\n     * special wildcard handling is used.\r\n     */\r\n    let iterator = this.META.wildcardEvents.values()\r\n    let currentEvent = null\r\n    let args = NGN.slice(arguments)\r\n\r\n    args.shift()\r\n\r\n    while (currentEvent === null || !currentEvent.done) {\r\n      if (currentEvent !== null && currentEvent.value !== arguments[0]) {\r\n        let pattern = new RegExp(currentEvent.value.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\r\n\r\n        if (pattern.test(arguments[0])) {\r\n          super.emit(currentEvent.value, ...args, typeof arguments[0] !== 'symbol' ? Symbol(arguments[0]) : arguments[0])\r\n          break\r\n        }\r\n      }\r\n\r\n      currentEvent = iterator.next()\r\n    }\r\n  }",
      "tags": {},
      "exceptions": {},
      "start": {
        "line": 964,
        "column": 2
      },
      "end": {
        "line": 1018,
        "column": 3
      },
      "flags": [],
      "authors": [],
      "arguments": {
        "eventName": {
          "type": "argument",
          "label": "eventName",
          "description": "The event name can be a string or an array of strings. If an array\nof strings is specified, an event will be fired for each event name\nwithin the array.",
          "code": "emit () {\r\n    if (NGN.typeof(arguments[0]) === 'array') {\r\n      let args = NGN.slice(arguments)\r\n      let eventNames = args.shift()\r\n\r\n      for (let i = 0; i < eventNames.length; i++) {\r\n        this.emit(eventNames[i], ...args)\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    // This catches non-string event names. NGN internally uses Symbols\r\n    // for the NGN.WARN/INFO/ERROR event names to prevent name collisions.\r\n    // This check provides support for these special events. These types\r\n    // of events will never have wildcards.\r\n    if (!NGN.nodelike || !arguments[0] || this.META.wildcardEvents.size === 0) {\r\n      super.emit(...arguments)\r\n      return\r\n    }\r\n\r\n    if (NGN.nodelike && typeof arguments[0] === 'symbol') {\r\n      super.emit(...arguments)\r\n      return\r\n    }\r\n\r\n    /**\r\n     * The NGN browser-based event emitter supports wildcards natively, but\r\n     * Node.js does not. This adds simple wildcard support for Node. The\r\n     * only wildcard character supported at this time is `*`. This feature\r\n     * will check the event name for the existance of a wildcard. If a\r\n     * wilcard character is present, the internally-maintained list of\r\n     * wildcard events is checked to see if it's a known event. If none\r\n     * of these checks pass, the standard event emitter is used, otherwise\r\n     * special wildcard handling is used.\r\n     */\r\n    let iterator = this.META.wildcardEvents.values()\r\n    let currentEvent = null\r\n    let args = NGN.slice(arguments)\r\n\r\n    args.shift()\r\n\r\n    while (currentEvent === null || !currentEvent.done) {\r\n      if (currentEvent !== null && currentEvent.value !== arguments[0]) {\r\n        let pattern = new RegExp(currentEvent.value.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\r\n\r\n        if (pattern.test(arguments[0])) {\r\n          super.emit(currentEvent.value, ...args, typeof arguments[0] !== 'symbol' ? Symbol(arguments[0]) : arguments[0])\r\n          break\r\n        }\r\n      }\r\n\r\n      currentEvent = iterator.next()\r\n    }\r\n  }",
          "start": {
            "line": 964,
            "column": 2
          },
          "end": {
            "line": 1018,
            "column": 3
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "string[]",
          "required": true,
          "enum": null
        },
        "payload": {
          "type": "argument",
          "label": "payload",
          "description": "An optional payload. This can be any number of additional arguments.",
          "code": "emit () {\r\n    if (NGN.typeof(arguments[0]) === 'array') {\r\n      let args = NGN.slice(arguments)\r\n      let eventNames = args.shift()\r\n\r\n      for (let i = 0; i < eventNames.length; i++) {\r\n        this.emit(eventNames[i], ...args)\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    // This catches non-string event names. NGN internally uses Symbols\r\n    // for the NGN.WARN/INFO/ERROR event names to prevent name collisions.\r\n    // This check provides support for these special events. These types\r\n    // of events will never have wildcards.\r\n    if (!NGN.nodelike || !arguments[0] || this.META.wildcardEvents.size === 0) {\r\n      super.emit(...arguments)\r\n      return\r\n    }\r\n\r\n    if (NGN.nodelike && typeof arguments[0] === 'symbol') {\r\n      super.emit(...arguments)\r\n      return\r\n    }\r\n\r\n    /**\r\n     * The NGN browser-based event emitter supports wildcards natively, but\r\n     * Node.js does not. This adds simple wildcard support for Node. The\r\n     * only wildcard character supported at this time is `*`. This feature\r\n     * will check the event name for the existance of a wildcard. If a\r\n     * wilcard character is present, the internally-maintained list of\r\n     * wildcard events is checked to see if it's a known event. If none\r\n     * of these checks pass, the standard event emitter is used, otherwise\r\n     * special wildcard handling is used.\r\n     */\r\n    let iterator = this.META.wildcardEvents.values()\r\n    let currentEvent = null\r\n    let args = NGN.slice(arguments)\r\n\r\n    args.shift()\r\n\r\n    while (currentEvent === null || !currentEvent.done) {\r\n      if (currentEvent !== null && currentEvent.value !== arguments[0]) {\r\n        let pattern = new RegExp(currentEvent.value.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'), 'g')\r\n\r\n        if (pattern.test(arguments[0])) {\r\n          super.emit(currentEvent.value, ...args, typeof arguments[0] !== 'symbol' ? Symbol(arguments[0]) : arguments[0])\r\n          break\r\n        }\r\n      }\r\n\r\n      currentEvent = iterator.next()\r\n    }\r\n  }",
          "start": {
            "line": 964,
            "column": 2
          },
          "end": {
            "line": 1018,
            "column": 3
          },
          "flags": [],
          "authors": [],
          "default": null,
          "datatype": "any",
          "required": false,
          "enum": null
        }
      },
      "returnType": "void",
      "returnDescription": "void",
      "kind": "method",
      "generator": false,
      "static": false,
      "computed": false,
      "async": false,
      "super": "NGN.EventEmitter#emit",
      "override": false,
      "private": false
    }
  }
}